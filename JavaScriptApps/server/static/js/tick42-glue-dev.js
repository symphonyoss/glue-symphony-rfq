(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = function(configuration) {
    'use strict';
    var cuid = require('cuid');
    var objectAssign = require('object-assign');
    var hc;

    if (typeof window !== 'undefined') {
        hc = window.htmlContainer
    }

    function getDefaultConfiguration() {
        var uid = cuid();
        return {
            appConfigFacadeConfig: hc ? hc.appConfigFacade.config : { identity: {} },
            application: getApplicationName(uid),
            metrics: getMetricsDefaults(uid),
            agm: { presenceInterval: 3000 },
            gateway: getGatewayDefaults()
        };
    }

    function getMetricsDefaults(uid) {
        var documentTitle = typeof document !== 'undefined' ? document.title : 'nknown';
        // check for empty titles
        documentTitle = documentTitle || 'none';
        return {
            system: hc ? 'HtmlContainer.' + hc.containerName : 'Browser',
            service: hc ? 'JS.' + hc.browserWindowName : documentTitle,
            instance: hc ? '~' + hc.machineName : '~' + uid
        }
    }

    function getGatewayDefaults() {
        var gatewayURL = 'localhost:22037';
        var isSSL = isSecureConnection();

        return {
            ws: isSSL ? 'wss://' + gatewayURL : 'ws://' + gatewayURL,
            http: isSSL ? 'https:' + gatewayURL : 'http://' + gatewayURL,
            protocolVersion : 1
        }
    }

    function isSecureConnection() {
        if (typeof window !== 'undefined' && window.location) {
            return window.location.protocol !== 'http:';
        }
        // Defaults to secure for node env.
        return true;
    }

    function getApplicationName(uid) {
        if (hc) {
            return hc.containerName + '.' + hc.browserWindowName
        }

        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            return (window.agm_application || document.title) + uid;
        } else {
            return 'NodeJS' + uid;
        }
    }

    function appConfig(settings) {
        var identity = {};

        Object.keys(settings.identity).forEach(function (key) {
            identity[key] = supplant(settings.identity[key])
        });

        return objectAssign({}, settings, { identity: identity })
    }

    function supplant(template, pattern) {
        var p = pattern || /\{([^{}]*)\}/g;
        return template.replace(p, function (match, key) {
            var value = this;
            key.split('.').forEach(function (part) {
                if (value) {
                    value = value[part];
                }
            });
            return typeof value === 'string' || typeof value === 'number' ? value : match;
        });
    }

    var defaults = getDefaultConfiguration();
    var options = objectAssign({}, defaults, configuration);
    options.gateway.ws = options.gateway.ws || defaults.gateway.ws;
    options.gateway.http = options.gateway.ws || defaults.gateway.http;

    var gatewayConnection = {};
    if (hc !== undefined) {
        gatewayConnection = undefined;
    } else if (require('detect-node') || ('WebSocket' in window && window.WebSocket.CLOSING === 2)) {
        gatewayConnection = { ws: options.gateway.ws, protocolVersion: options.gateway.protocolVersion };
    } else {
        gatewayConnection = { http: options.gateway.http, protocolVersion: options.gateway.protocolVersion  };
    }

    if (gatewayConnection) {
        gatewayConnection.application = options.application;
        gatewayConnection.gwTokenProvider = options.gwTokenProvider;
    }

    return {
        connection: gatewayConnection,
        appConfig: appConfig(defaults.appConfigFacadeConfig), // Not configurable currently
        logger: {
            identity: {
                system: options.metrics.system,
                service: options.metrics.service,
                instance: options.metrics.instance
            }
        },
        metrics: {
            identity: {
                system: options.metrics.system,
                service: options.metrics.service,
                instance: options.metrics.instance
            }
        },
        agm: {
            instance: { application: options.application },
            server: {
                hearbeat_interval: defaults.agm.heartbeatInterval, // Not configurable currently
                presence_interval: options.agm.presenceInterval
            }
        }
    }
};

},{"cuid":7,"detect-node":8,"object-assign":12}],2:[function(require,module,exports){
module.exports = function(options) {
    'use strict';

    var metrics = require('tick42-metrics');
    var agm = require('tick42-agm');
    var gatewayConnection = require('tick42-gateway-connection');
    var logger = require('tick42-logger');
    var appconfig = require('tick42-appconfig');
    var windows = require('tick42-windows');
    var appManager = require('tick42-app-manager');
    var activity = require('tick42-activity');
    var contexts = require('tick42-contexts');
    var Promise = require('es6-promise').Promise;
    var pjson = require('../package.json');
    var getConfig = require('./config.js');

    // Init the GLUE namespace
    var hc = typeof window !== 'undefined' && window.htmlContainer;

    return new Promise(function (resolve, reject) {
        // gwProtocolVersion 2 requires auth (TODO - we should change 3 to be the same)
        if (!options.auth && options.gateway.protocolVersion > 1) {
            reject('You need to provide auth information')
        }

        var glueConfig = getConfig(options);
        var _connection = gatewayConnection(glueConfig.connection);

        glueConfig.agm.connection = _connection;
        glueConfig.logger.connection = _connection;
        glueConfig.metrics.connection = _connection;

        if (options.auth) {
            var authRequest;
            if (typeof options.auth === 'string' || options.auth instanceof String || typeof options.auth === 'number' || options.auth instanceof Number) {
                authRequest = { token: options.auth };
            } else if (Object.prototype.toString.call(options.auth) === '[object Object]') {
                authRequest = options.auth;
            } else {
                throw new Error('Invalid auth object - ' + JSON.stringify(authRequest));
            }

            _connection.login(authRequest)
                .then(function (client) {
                    if (client) {
                        glueConfig.agm.instance.machine = client.ipAddress;
                        glueConfig.agm.instance.user = client.username;
                    }

                    _configure(glueConfig)
                        .then(function(glue) {
                            resolve(glue);
                        })['catch'](function(err) {
                            reject(err);
                        })
                })['catch'](function (err) {
                    reject(err);
                });
        } else {
            resolve(_configure(glueConfig));
        }

        function _configure(configuration) {
            return new Promise(function (resolve, reject) {
                var _agm, _windows, _appManager, _appConfig, _activities, _logger, _rootMetrics, _metrics, _info, _feedback, _contexts;

                // Logger
                _logger = logger(configuration.logger);

                // Metrics
                configuration.metrics.logger = _logger.subLogger('metrics');
                _rootMetrics = metrics(configuration.metrics);
                _metrics = _rootMetrics.subSystem('App');
                _logger.metricsLevel('warn', _metrics.parent.subSystem('LogEvents'));

                // AGM
                configuration.agm.metrics = _rootMetrics.subSystem('AGM');
                configuration.agm.logger = _logger.subLogger('agm');
                configuration.agm.logger.consoleLevel('debug');

                agm(configuration.agm)
                    .then(function (agm) {
                        _agm = agm;

                        // Windows
                        _windows = windows(_agm);

                        // AppManager
                        _appManager = appManager(_agm, _windows);

                        if (hc) {
                            // AppConfig
                            if (hc.appConfigFacade && hc.appConfigFacade.config) {
                                _appConfig = appconfig().init(glueConfig.appConfig);
                            }

                            // Activities
                            if (hc.activityFacade) {
                                var activityLogger = _logger.subLogger('activity');
                                activityLogger.publishLevel('debug');
                                activityLogger.consoleLevel('info');
                                activityLogger.metricsLevel('off');

                                _activities = activity({
                                    agm: _agm,
                                    logger: activityLogger
                                });
                            }
                        }

                        _contexts = contexts();

                        _info = {
                            glueVersion: pjson.version,
                            activities: _activities ? _activities.version : 'unknown',
                            metrics: _metrics.repo.version,
                            agm: _agm.version,
                            windows: _windows.version,
                            logger: _logger.version,
                            appManager: _appManager.version,
                            connection: _connection.version,
                            contexts: _contexts.version
                        };

                        _feedback = function () {
                            if (!_agm) {
                                return;
                            }
                            _agm.invoke('T42.ACS.Feedback', {}, 'best');
                        };

                        resolve({
                            activities: _activities,
                            agm: _agm,
                            appConfig: _appConfig,
                            appManager: _appManager,
                            connection: _connection,
                            contexts: _contexts,
                            feedback: _feedback,
                            info: _info,
                            logger: _logger,
                            metrics: _metrics,
                            version: pjson.version,
                            windows: _windows
                        });
                    })['catch'](function (err) {
                        reject(err)
                    });
            });
        }
    })
};

},{"../package.json":111,"./config.js":1,"es6-promise":11,"tick42-activity":18,"tick42-agm":44,"tick42-app-manager":61,"tick42-appconfig":67,"tick42-contexts":75,"tick42-gateway-connection":78,"tick42-logger":87,"tick42-metrics":103,"tick42-windows":106}],3:[function(require,module,exports){
(function (global){
(function() {
    'use strict';

    // Do not do anything if there is no support of ECMAScript 5
    if (typeof [].forEach !== 'function') {
        require('es5-shim');
        require('es5-shim/es5-sham');
    }

    /**
     * Init logic that we follow:
     * v1 supports autoInit
     * v2, v3 does not support auto-init -this means that you should use Glue factory method to init glue
     */
    var createGlue = require('./glue');
    var config = global.glueConfig || {};

    config.gateway = config.gateway || {};
    config.gateway.protocolVersion = config.gateway.protocolVersion || 3;
    var autoInit = config.autoInit || config.gateway.protocolVersion === 1;

    if (autoInit && config.gateway.protocolVersion > 1) {
        throw new Error('glue auto init is only supported for gateway protocol version 1 - switch to 1 or turn off auto init');
    }

    // if in node switch to v2
    if (require('detect-node')) {
        autoInit = false;
        config.gateway.protocolVersion = 2;
    }

    if (autoInit) {
        createGlue(config)
            .then(function (glue) {
                global.glue = glue;
            })['catch'](function (error) {
                console.error('error auto initialing glue', error);
            });
    }

    var factory = function (options) {
        if (!(options.gateway && options.gateway.protocolVersion)) {
            options.gateway.protocolVersion = config.gateway.protocolVersion;
        }
        return createGlue(options);
    };

    if (typeof window !== 'undefined') {
        window.Glue = factory;
    }

    module.exports = factory
}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./glue":2,"detect-node":8,"es5-shim":10,"es5-shim/es5-sham":9}],4:[function(require,module,exports){
/**
 * (c) 2013 Beau Sorensen
 * MIT Licensed
 * For all details and documentation:
 * https://github.com/sorensen/ascii-table
 */

;(function() {
'use strict';

/*!
 * Module dependencies
 */

var slice = Array.prototype.slice
  , toString = Object.prototype.toString

/**
 * AsciiTable constructor
 *
 * @param {String|Object} title or JSON table
 * @param {Object} table options
 *  - `prefix` - string prefix added to each line on render
 * @constructor
 * @api public
 */

function AsciiTable(name, options) {
  this.options = options || {}
  this.reset(name)
}

/*!
 * Current library version, should match `package.json`
 */

AsciiTable.VERSION = '0.0.8'

/*!
 * Alignment constants
 */

AsciiTable.LEFT = 0
AsciiTable.CENTER = 1
AsciiTable.RIGHT = 2

/*!
 * Static methods
 */

/**
 * Create a new table instance
 *
 * @param {String|Object} title or JSON table
 * @param {Object} table options
 * @api public
 */

AsciiTable.factory = function(name, options) {
  return new AsciiTable(name, options)
}

/**
 * Align the a string at the given length
 *
 * @param {Number} direction
 * @param {String} string input
 * @param {Number} string length
 * @param {Number} padding character
 * @api public
 */

AsciiTable.align = function(dir, str, len, pad) {
  if (dir === AsciiTable.LEFT) return AsciiTable.alignLeft(str, len, pad)
  if (dir === AsciiTable.RIGHT) return AsciiTable.alignRight(str, len, pad)
  if (dir === AsciiTable.CENTER) return AsciiTable.alignCenter(str, len, pad)
  return AsciiTable.alignAuto(str, len, pad)
}

/**
 * Left align a string by padding it at a given length
 *
 * @param {String} str
 * @param {Number} string length
 * @param {String} padding character (optional, default '')
 * @api public
 */

AsciiTable.alignLeft = function(str, len, pad) {
  if (!len || len < 0) return ''
  if (str === undefined || str === null) str = ''
  if (typeof pad === 'undefined') pad = ' '
  if (typeof str !== 'string') str = str.toString()
  var alen = len + 1 - str.length
  if (alen <= 0) return str
  return str + Array(len + 1 - str.length).join(pad)
}

/**
 * Center align a string by padding it at a given length
 *
 * @param {String} str
 * @param {Number} string length
 * @param {String} padding character (optional, default '')
 * @api public
 */

AsciiTable.alignCenter = function(str, len, pad) {
  if (!len || len < 0) return ''
  if (str === undefined || str === null) str = ''
  if (typeof pad === 'undefined') pad = ' '
  if (typeof str !== 'string') str = str.toString()
  var nLen = str.length
    , half = Math.floor(len / 2 - nLen / 2)
    , odds = Math.abs((nLen % 2) - (len % 2))
    , len = str.length

  return AsciiTable.alignRight('', half, pad) 
    + str
    + AsciiTable.alignLeft('', half + odds, pad)
}

/**
 * Right align a string by padding it at a given length
 *
 * @param {String} str
 * @param {Number} string length
 * @param {String} padding character (optional, default '')
 * @api public
 */

AsciiTable.alignRight = function(str, len, pad) {
  if (!len || len < 0) return ''
  if (str === undefined || str === null) str = ''
  if (typeof pad === 'undefined') pad = ' '
  if (typeof str !== 'string') str = str.toString()
  var alen = len + 1 - str.length
  if (alen <= 0) return str
  return Array(len + 1 - str.length).join(pad) + str
}

/**
 * Auto align string value based on object type
 *
 * @param {Any} object to string
 * @param {Number} string length
 * @param {String} padding character (optional, default '')
 * @api public
 */

AsciiTable.alignAuto = function(str, len, pad) {
  if (str === undefined || str === null) str = ''
  var type = toString.call(str)
  pad || (pad = ' ')
  len = +len
  if (type !== '[object String]') {
    str = str.toString()
  }
  if (str.length < len) {
    switch(type) {
      case '[object Number]': return AsciiTable.alignRight(str, len, pad)
      default: return AsciiTable.alignLeft(str, len, pad)
    }
  }
  return str
}

/**
 * Fill an array at a given size with the given value
 *
 * @param {Number} array size
 * @param {Any} fill value
 * @return {Array} filled array
 * @api public
 */

AsciiTable.arrayFill = function(len, fill) {
  var arr = new Array(len)
  for (var i = 0; i !== len; i++) {
    arr[i] = fill;
  }
  return arr
}

/*!
 * Instance methods
 */

/**
 * Reset the table state back to defaults
 *
 * @param {String|Object} title or JSON table
 * @api public
 */

AsciiTable.prototype.reset = 
AsciiTable.prototype.clear = function(name) {
  this.__name = ''
  this.__nameAlign = AsciiTable.CENTER
  this.__rows = []
  this.__maxCells = 0
  this.__aligns = []
  this.__colMaxes = []
  this.__spacing = 1
  this.__heading = null
  this.__headingAlign = AsciiTable.CENTER
  this.setBorder()

  if (toString.call(name) === '[object String]') {
    this.__name = name
  } else if (toString.call(name) === '[object Object]') {
    this.fromJSON(name)
  }
  return this
}

/**
 * Set the table border
 *
 * @param {String} horizontal edges (optional, default `|`)
 * @param {String} vertical edges (optional, default `-`)
 * @param {String} top corners (optional, default `.`)
 * @param {String} bottom corners (optional, default `'`)
 * @api public
 */

AsciiTable.prototype.setBorder = function(edge, fill, top, bottom) {
  this.__border = true
  if (arguments.length === 1) {
    fill = top = bottom = edge
  }
  this.__edge = edge || '|'
  this.__fill = fill || '-'
  this.__top = top || '.'
  this.__bottom = bottom || "'"
  return this
}

/**
 * Remove all table borders
 *
 * @api public
 */

AsciiTable.prototype.removeBorder = function() {
  this.__border = false
  this.__edge = ' '
  this.__fill = ' '
  return this
}

/**
 * Set the column alignment at a given index
 *
 * @param {Number} column index
 * @param {Number} alignment direction
 * @api public
 */

AsciiTable.prototype.setAlign = function(idx, dir) {
  this.__aligns[idx] = dir
  return this
}

/**
 * Set the title of the table
 *
 * @param {String} title
 * @api public
 */

AsciiTable.prototype.setTitle = function(name) {
  this.__name = name
  return this
}

/**
 * Get the title of the table
 *
 * @return {String} title
 * @api public
 */

AsciiTable.prototype.getTitle = function() {
  return this.__name
}

/**
 * Set table title alignment
 *
 * @param {Number} direction
 * @api public
 */

AsciiTable.prototype.setTitleAlign = function(dir) {
  this.__nameAlign = dir
  return this
}

/**
 * AsciiTable sorting shortcut to sort rows
 *
 * @param {Function} sorting method
 * @api public
 */

AsciiTable.prototype.sort = function(method) {
  this.__rows.sort(method)
  return this
}

/**
 * Sort rows based on sort method for given column
 *
 * @param {Number} column index
 * @param {Function} sorting method
 * @api public
 */

AsciiTable.prototype.sortColumn = function(idx, method) {
  this.__rows.sort(function(a, b) {
    return method(a[idx], b[idx])
  })
  return this
}

/**
 * Set table heading for columns
 *
 * @api public
 */

AsciiTable.prototype.setHeading = function(row) {
  if (arguments.length > 1 || toString.call(row) !== '[object Array]') {
    row = slice.call(arguments)
  }
  this.__heading = row
  return this
}

/**
 * Get table heading for columns
 *
 * @return {Array} copy of headings
 * @api public
 */

AsciiTable.prototype.getHeading = function() {
  return this.__heading.slice()
}

/**
 * Set heading alignment
 *
 * @param {Number} direction
 * @api public
 */

AsciiTable.prototype.setHeadingAlign = function(dir) {
  this.__headingAlign = dir
  return this
}

/**
 * Add a row of information to the table
 * 
 * @param {...|Array} argument values in order of columns
 * @api public
 */

AsciiTable.prototype.addRow = function(row) {
  if (arguments.length > 1 || toString.call(row) !== '[object Array]') {
    row = slice.call(arguments)
  }
  this.__maxCells = Math.max(this.__maxCells, row.length)
  this.__rows.push(row)
  return this
}

/**
 * Get a copy of all rows of the table
 *
 * @return {Array} copy of rows
 * @api public
 */

AsciiTable.prototype.getRows = function() {
  return this.__rows.slice().map(function(row) {
    return row.slice()
  })
}

/**
 * Add rows in the format of a row matrix
 *
 * @param {Array} row matrix
 * @api public
 */

AsciiTable.prototype.addRowMatrix = function(rows) {
  for (var i = 0; i < rows.length; i++) {
    this.addRow(rows[i])
  }
  return this
}

/**
 * Add rows from the given data array, processed by the callback function rowCallback.
 *
 * @param {Array} data
 * @param (Function) rowCallback
 * @param (Boolean) asMatrix - controls if the row created by rowCallback should be assigned as row matrix
 * @api public
 */

AsciiTable.prototype.addData = function(data, rowCallback, asMatrix) {
  if (toString.call(data) !== '[object Array]') {
    return this;
  }
  for (var index = 0, limit = data.length; index < limit; index++) {
    var row = rowCallback(data[index]);
    if(asMatrix) {
      this.addRowMatrix(row);
    } else {
      this.addRow(row);
    }
  }
  return this
}

  /**
 * Reset the current row state
 *
 * @api public
 */

AsciiTable.prototype.clearRows = function() {
  this.__rows = []
  this.__maxCells = 0
  this.__colMaxes = []
  return this
}

/**
 * Apply an even spaced column justification
 *
 * @param {Boolean} on / off
 * @api public
 */

AsciiTable.prototype.setJustify = function(val) {
  arguments.length === 0 && (val = true)
  this.__justify = !!val
  return this
}

/**
 * Convert the current instance to a JSON structure
 *
 * @return {Object} json representation
 * @api public
 */

AsciiTable.prototype.toJSON = function() {
  return {
    title: this.getTitle()
  , heading: this.getHeading()
  , rows: this.getRows()
  }
}

/**
 * Populate the table from a JSON object
 *
 * @param {Object} json representation
 * @api public
 */

AsciiTable.prototype.parse = 
AsciiTable.prototype.fromJSON = function(obj) {
  return this
    .clear()
    .setTitle(obj.title)
    .setHeading(obj.heading)
    .addRowMatrix(obj.rows)
}

/**
 * Render the table with the current information
 *
 * @return {String} formatted table
 * @api public
 */

AsciiTable.prototype.render =
AsciiTable.prototype.valueOf =
AsciiTable.prototype.toString = function() {
  var self = this
    , body = []
    , mLen = this.__maxCells
    , max = AsciiTable.arrayFill(mLen, 0)
    , total = mLen * 3
    , rows = this.__rows
    , justify
    , border = this.__border
    , all = this.__heading 
        ? [this.__heading].concat(rows)
        : rows

  // Calculate max table cell lengths across all rows
  for (var i = 0; i < all.length; i++) {
    var row = all[i]
    for (var k = 0; k < mLen; k++) {
      var cell = row[k]
      max[k] = Math.max(max[k], cell ? cell.toString().length : 0)
    }
  }
  this.__colMaxes = max
  justify = this.__justify ? Math.max.apply(null, max) : 0

  // Get 
  max.forEach(function(x) {
    total += justify ? justify : x + self.__spacing
  })
  justify && (total += max.length)
  total -= this.__spacing

  // Heading
  border && body.push(this._seperator(total - mLen + 1, this.__top))
  if (this.__name) {
    body.push(this._renderTitle(total - mLen + 1))
    border && body.push(this._seperator(total - mLen + 1))
  }
  if (this.__heading) {
    body.push(this._renderRow(this.__heading, ' ', this.__headingAlign))
    body.push(this._rowSeperator(mLen, this.__fill))
  }
  for (var i = 0; i < this.__rows.length; i++) {
    body.push(this._renderRow(this.__rows[i], ' '))
  }
  border && body.push(this._seperator(total - mLen + 1, this.__bottom))

  var prefix = this.options.prefix || ''
  return prefix + body.join('\n' + prefix)
}

/**
 * Create a line seperator
 *
 * @param {Number} string size
 * @param {String} side values (default '|')
 * @api private
 */

AsciiTable.prototype._seperator = function(len, sep) {
  sep || (sep = this.__edge)
  return sep + AsciiTable.alignRight(sep, len, this.__fill)
}

/**
 * Create a row seperator
 *
 * @return {String} seperator
 * @api private
 */

AsciiTable.prototype._rowSeperator = function() {
  var blanks = AsciiTable.arrayFill(this.__maxCells, this.__fill)
  return this._renderRow(blanks, this.__fill)
}

/**
 * Render the table title in a centered box
 *
 * @param {Number} string size
 * @return {String} formatted title
 * @api private
 */

AsciiTable.prototype._renderTitle = function(len) {
  var name = ' ' + this.__name + ' '
    , str = AsciiTable.align(this.__nameAlign, name, len - 1, ' ')
  return this.__edge + str + this.__edge
}

/**
 * Render an invdividual row
 *
 * @param {Array} row
 * @param {String} column seperator
 * @param {Number} total row alignment (optional, default `auto`)
 * @return {String} formatted row
 * @api private
 */

AsciiTable.prototype._renderRow = function(row, str, align) {
  var tmp = ['']
    , max = this.__colMaxes

  for (var k = 0; k < this.__maxCells; k++) {
    var cell = row[k]
      , just = this.__justify ? Math.max.apply(null, max) : max[k]
      // , pad = k === this.__maxCells - 1 ? just : just + this.__spacing
      , pad = just
      , cAlign = this.__aligns[k]
      , use = align
      , method = 'alignAuto'
  
    if (typeof align === 'undefined') use = cAlign

    if (use === AsciiTable.LEFT) method = 'alignLeft'
    if (use === AsciiTable.CENTER) method = 'alignCenter'
    if (use === AsciiTable.RIGHT) method = 'alignRight'

    tmp.push(AsciiTable[method](cell, pad, str))
  }
  var front = tmp.join(str + this.__edge + str)
  front = front.substr(1, front.length)
  return front + str + this.__edge
}

/*!
 * Aliases
 */

// Create method shortcuts to all alignment methods for each direction
;['Left', 'Right', 'Center'].forEach(function(dir) {
  var constant = AsciiTable[dir.toUpperCase()]

  ;['setAlign', 'setTitleAlign', 'setHeadingAlign'].forEach(function(method) {
    // Call the base method with the direction constant as the last argument
    AsciiTable.prototype[method + dir] = function() {
      var args = slice.call(arguments).concat(constant)
      return this[method].apply(this, args)
    }
  })
})

/*!
 * Module exports.
 */

if (typeof exports !== 'undefined') {
  module.exports = AsciiTable
} else {
  this.AsciiTable = AsciiTable
}

}).call(this);

},{}],5:[function(require,module,exports){
module.exports = require('./ascii-table')
},{"./ascii-table":4}],6:[function(require,module,exports){
module.exports = function () {
	"use strict";

	var callbacks = {};

	function add(key, callback) {
		var callbacksForKey = callbacks[key];

		if (!callbacksForKey) {
			callbacksForKey = [];
			callbacks[key] = callbacksForKey;
		}

		var newLen = callbacksForKey.push(callback);
		var itemIndex = newLen - 1;

		// callback id is formed as <item-index>_<key>, we use that id to remove the callback 
		return itemIndex + '_' + key;
	}

	function remove(callbackId) {
		var parts = callbackId.split('_');
		if (parts.length !== 2) {
			return false;
		}

		var index = parts[0];
		var key = parts[1];
		
		var callbackArray = callbacks[key];
		if (!callbackArray || callbackArray.length === 0) {
			return false;
		}

		delete callbackArray[index];
		return true;
	}

	function execute(key, argumentsArr) {
		var callbacksForKey = callbacks[key];
		if (!callbacksForKey || callbacksForKey.length === 0){
			return;
		}

		var args = [].splice.call(arguments, 1);

		callbacksForKey.forEach(function (callback) {
			callback.apply(undefined, args);
		});
	}

	return {
		add: add,
		remove: remove,
		execute: execute
	};
};

},{}],7:[function(require,module,exports){
/**
 * cuid.js
 * Collision-resistant UID generator for browsers and node.
 * Sequential for fast db lookups and recency sorting.
 * Safe for element IDs and server-side lookups.
 *
 * Extracted from CLCTR
 *
 * Copyright (c) Eric Elliott 2012
 * MIT License
 */

/*global window, navigator, document, require, process, module */
(function (app) {
  'use strict';
  var namespace = 'cuid',
    c = 0,
    blockSize = 4,
    base = 36,
    discreteValues = Math.pow(base, blockSize),

    pad = function pad(num, size) {
      var s = "000000000" + num;
      return s.substr(s.length-size);
    },

    randomBlock = function randomBlock() {
      return pad((Math.random() *
            discreteValues << 0)
            .toString(base), blockSize);
    },

    safeCounter = function () {
      c = (c < discreteValues) ? c : 0;
      c++; // this is not subliminal
      return c - 1;
    },

    api = function cuid() {
      // Starting with a lowercase letter makes
      // it HTML element ID friendly.
      var letter = 'c', // hard-coded allows for sequential access

        // timestamp
        // warning: this exposes the exact date and time
        // that the uid was created.
        timestamp = (new Date().getTime()).toString(base),

        // Prevent same-machine collisions.
        counter,

        // A few chars to generate distinct ids for different
        // clients (so different computers are far less
        // likely to generate the same id)
        fingerprint = api.fingerprint(),

        // Grab some more chars from Math.random()
        random = randomBlock() + randomBlock();

        counter = pad(safeCounter().toString(base), blockSize);

      return  (letter + timestamp + counter + fingerprint + random);
    };

  api.slug = function slug() {
    var date = new Date().getTime().toString(36),
      counter,
      print = api.fingerprint().slice(0,1) +
        api.fingerprint().slice(-1),
      random = randomBlock().slice(-2);

      counter = safeCounter().toString(36).slice(-4);

    return date.slice(-2) +
      counter + print + random;
  };

  api.globalCount = function globalCount() {
    // We want to cache the results of this
    var cache = (function calc() {
        var i,
          count = 0;

        for (i in window) {
          count++;
        }

        return count;
      }());

    api.globalCount = function () { return cache; };
    return cache;
  };

  api.fingerprint = function browserPrint() {
    return pad((navigator.mimeTypes.length +
      navigator.userAgent.length).toString(36) +
      api.globalCount().toString(36), 4);
  };

  // don't change anything from here down.
  if (app.register) {
    app.register(namespace, api);
  } else if (typeof module !== 'undefined') {
    module.exports = api;
  } else {
    app[namespace] = api;
  }

}(this.applitude || this));

},{}],8:[function(require,module,exports){
(function (global){
module.exports = false;

// Only Node.JS has a process variable that is of [[Class]] process
try {
 module.exports = Object.prototype.toString.call(global.process) === '[object process]' 
} catch(e) {}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],9:[function(require,module,exports){
/*!
 * https://github.com/es-shims/es5-shim
 * @license es5-shim Copyright 2009-2015 by contributors, MIT License
 * see https://github.com/es-shims/es5-shim/blob/master/LICENSE
 */

// vim: ts=4 sts=4 sw=4 expandtab

// Add semicolon to prevent IIFE from being passed as argument to concatenated code.
;

// UMD (Universal Module Definition)
// see https://github.com/umdjs/umd/blob/master/templates/returnExports.js
(function (root, factory) {
    'use strict';

    /* global define, exports, module */
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.returnExports = factory();
    }
}(this, function () {

    var call = Function.call;
    var prototypeOfObject = Object.prototype;
    var owns = call.bind(prototypeOfObject.hasOwnProperty);
    var isEnumerable = call.bind(prototypeOfObject.propertyIsEnumerable);
    var toStr = call.bind(prototypeOfObject.toString);

    // If JS engine supports accessors creating shortcuts.
    var defineGetter;
    var defineSetter;
    var lookupGetter;
    var lookupSetter;
    var supportsAccessors = owns(prototypeOfObject, '__defineGetter__');
    if (supportsAccessors) {
        /* eslint-disable no-underscore-dangle */
        defineGetter = call.bind(prototypeOfObject.__defineGetter__);
        defineSetter = call.bind(prototypeOfObject.__defineSetter__);
        lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
        lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
        /* eslint-enable no-underscore-dangle */
    }

    var isPrimitive = function isPrimitive(o) {
        return o == null || (typeof o !== 'object' && typeof o !== 'function');
    };

    // ES5 15.2.3.2
    // http://es5.github.com/#x15.2.3.2
    if (!Object.getPrototypeOf) {
        // https://github.com/es-shims/es5-shim/issues#issue/2
        // http://ejohn.org/blog/objectgetprototypeof/
        // recommended by fschaefer on github
        //
        // sure, and webreflection says ^_^
        // ... this will nerever possibly return null
        // ... Opera Mini breaks here with infinite loops
        Object.getPrototypeOf = function getPrototypeOf(object) {
            /* eslint-disable no-proto */
            var proto = object.__proto__;
            /* eslint-enable no-proto */
            if (proto || proto === null) {
                return proto;
            } else if (toStr(object.constructor) === '[object Function]') {
                return object.constructor.prototype;
            } else if (object instanceof Object) {
                return prototypeOfObject;
            } else {
                // Correctly return null for Objects created with `Object.create(null)`
                // (shammed or native) or `{ __proto__: null}`.  Also returns null for
                // cross-realm objects on browsers that lack `__proto__` support (like
                // IE <11), but that's the best we can do.
                return null;
            }
        };
    }

    // ES5 15.2.3.3
    // http://es5.github.com/#x15.2.3.3

    var doesGetOwnPropertyDescriptorWork = function doesGetOwnPropertyDescriptorWork(object) {
        try {
            object.sentinel = 0;
            return Object.getOwnPropertyDescriptor(object, 'sentinel').value === 0;
        } catch (exception) {
            return false;
        }
    };

    // check whether getOwnPropertyDescriptor works if it's given. Otherwise, shim partially.
    if (Object.defineProperty) {
        var getOwnPropertyDescriptorWorksOnObject = doesGetOwnPropertyDescriptorWork({});
        var getOwnPropertyDescriptorWorksOnDom = typeof document === 'undefined' ||
        doesGetOwnPropertyDescriptorWork(document.createElement('div'));
        if (!getOwnPropertyDescriptorWorksOnDom || !getOwnPropertyDescriptorWorksOnObject) {
            var getOwnPropertyDescriptorFallback = Object.getOwnPropertyDescriptor;
        }
    }

    if (!Object.getOwnPropertyDescriptor || getOwnPropertyDescriptorFallback) {
        var ERR_NON_OBJECT = 'Object.getOwnPropertyDescriptor called on a non-object: ';

        /* eslint-disable no-proto */
        Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
            if (isPrimitive(object)) {
                throw new TypeError(ERR_NON_OBJECT + object);
            }

            // make a valiant attempt to use the real getOwnPropertyDescriptor
            // for I8's DOM elements.
            if (getOwnPropertyDescriptorFallback) {
                try {
                    return getOwnPropertyDescriptorFallback.call(Object, object, property);
                } catch (exception) {
                    // try the shim if the real one doesn't work
                }
            }

            var descriptor;

            // If object does not owns property return undefined immediately.
            if (!owns(object, property)) {
                return descriptor;
            }

            // If object has a property then it's for sure `configurable`, and
            // probably `enumerable`. Detect enumerability though.
            descriptor = {
                enumerable: isEnumerable(object, property),
                configurable: true
            };

            // If JS engine supports accessor properties then property may be a
            // getter or setter.
            if (supportsAccessors) {
                // Unfortunately `__lookupGetter__` will return a getter even
                // if object has own non getter property along with a same named
                // inherited getter. To avoid misbehavior we temporary remove
                // `__proto__` so that `__lookupGetter__` will return getter only
                // if it's owned by an object.
                var prototype = object.__proto__;
                var notPrototypeOfObject = object !== prototypeOfObject;
                // avoid recursion problem, breaking in Opera Mini when
                // Object.getOwnPropertyDescriptor(Object.prototype, 'toString')
                // or any other Object.prototype accessor
                if (notPrototypeOfObject) {
                    object.__proto__ = prototypeOfObject;
                }

                var getter = lookupGetter(object, property);
                var setter = lookupSetter(object, property);

                if (notPrototypeOfObject) {
                    // Once we have getter and setter we can put values back.
                    object.__proto__ = prototype;
                }

                if (getter || setter) {
                    if (getter) {
                        descriptor.get = getter;
                    }
                    if (setter) {
                        descriptor.set = setter;
                    }
                    // If it was accessor property we're done and return here
                    // in order to avoid adding `value` to the descriptor.
                    return descriptor;
                }
            }

            // If we got this far we know that object has an own property that is
            // not an accessor so we set it as a value and return descriptor.
            descriptor.value = object[property];
            descriptor.writable = true;
            return descriptor;
        };
        /* eslint-enable no-proto */
    }

    // ES5 15.2.3.4
    // http://es5.github.com/#x15.2.3.4
    if (!Object.getOwnPropertyNames) {
        Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
            return Object.keys(object);
        };
    }

    // ES5 15.2.3.5
    // http://es5.github.com/#x15.2.3.5
    if (!Object.create) {

        // Contributed by Brandon Benvie, October, 2012
        var createEmpty;
        var supportsProto = !({ __proto__: null } instanceof Object);
                            // the following produces false positives
                            // in Opera Mini => not a reliable check
                            // Object.prototype.__proto__ === null

        // Check for document.domain and active x support
        // No need to use active x approach when document.domain is not set
        // see https://github.com/es-shims/es5-shim/issues/150
        // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
        /* global ActiveXObject */
        var shouldUseActiveX = function shouldUseActiveX() {
            // return early if document.domain not set
            if (!document.domain) {
                return false;
            }

            try {
                return !!new ActiveXObject('htmlfile');
            } catch (exception) {
                return false;
            }
        };

        // This supports IE8 when document.domain is used
        // see https://github.com/es-shims/es5-shim/issues/150
        // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
        var getEmptyViaActiveX = function getEmptyViaActiveX() {
            var empty;
            var xDoc;

            xDoc = new ActiveXObject('htmlfile');

            var script = 'script';
            xDoc.write('<' + script + '></' + script + '>');
            xDoc.close();

            empty = xDoc.parentWindow.Object.prototype;
            xDoc = null;

            return empty;
        };

        // The original implementation using an iframe
        // before the activex approach was added
        // see https://github.com/es-shims/es5-shim/issues/150
        var getEmptyViaIFrame = function getEmptyViaIFrame() {
            var iframe = document.createElement('iframe');
            var parent = document.body || document.documentElement;
            var empty;

            iframe.style.display = 'none';
            parent.appendChild(iframe);
            /* eslint-disable no-script-url */
            iframe.src = 'javascript:';
            /* eslint-enable no-script-url */

            empty = iframe.contentWindow.Object.prototype;
            parent.removeChild(iframe);
            iframe = null;

            return empty;
        };

        /* global document */
        if (supportsProto || typeof document === 'undefined') {
            createEmpty = function () {
                return { __proto__: null };
            };
        } else {
            // In old IE __proto__ can't be used to manually set `null`, nor does
            // any other method exist to make an object that inherits from nothing,
            // aside from Object.prototype itself. Instead, create a new global
            // object and *steal* its Object.prototype and strip it bare. This is
            // used as the prototype to create nullary objects.
            createEmpty = function () {
                // Determine which approach to use
                // see https://github.com/es-shims/es5-shim/issues/150
                var empty = shouldUseActiveX() ? getEmptyViaActiveX() : getEmptyViaIFrame();

                delete empty.constructor;
                delete empty.hasOwnProperty;
                delete empty.propertyIsEnumerable;
                delete empty.isPrototypeOf;
                delete empty.toLocaleString;
                delete empty.toString;
                delete empty.valueOf;

                var Empty = function Empty() {};
                Empty.prototype = empty;
                // short-circuit future calls
                createEmpty = function () {
                    return new Empty();
                };
                return new Empty();
            };
        }

        Object.create = function create(prototype, properties) {

            var object;
            var Type = function Type() {}; // An empty constructor.

            if (prototype === null) {
                object = createEmpty();
            } else {
                if (prototype !== null && isPrimitive(prototype)) {
                    // In the native implementation `parent` can be `null`
                    // OR *any* `instanceof Object`  (Object|Function|Array|RegExp|etc)
                    // Use `typeof` tho, b/c in old IE, DOM elements are not `instanceof Object`
                    // like they are in modern browsers. Using `Object.create` on DOM elements
                    // is...err...probably inappropriate, but the native version allows for it.
                    throw new TypeError('Object prototype may only be an Object or null'); // same msg as Chrome
                }
                Type.prototype = prototype;
                object = new Type();
                // IE has no built-in implementation of `Object.getPrototypeOf`
                // neither `__proto__`, but this manually setting `__proto__` will
                // guarantee that `Object.getPrototypeOf` will work as expected with
                // objects created using `Object.create`
                /* eslint-disable no-proto */
                object.__proto__ = prototype;
                /* eslint-enable no-proto */
            }

            if (properties !== void 0) {
                Object.defineProperties(object, properties);
            }

            return object;
        };
    }

    // ES5 15.2.3.6
    // http://es5.github.com/#x15.2.3.6

    // Patch for WebKit and IE8 standard mode
    // Designed by hax <hax.github.com>
    // related issue: https://github.com/es-shims/es5-shim/issues#issue/5
    // IE8 Reference:
    //     http://msdn.microsoft.com/en-us/library/dd282900.aspx
    //     http://msdn.microsoft.com/en-us/library/dd229916.aspx
    // WebKit Bugs:
    //     https://bugs.webkit.org/show_bug.cgi?id=36423

    var doesDefinePropertyWork = function doesDefinePropertyWork(object) {
        try {
            Object.defineProperty(object, 'sentinel', {});
            return 'sentinel' in object;
        } catch (exception) {
            return false;
        }
    };

    // check whether defineProperty works if it's given. Otherwise,
    // shim partially.
    if (Object.defineProperty) {
        var definePropertyWorksOnObject = doesDefinePropertyWork({});
        var definePropertyWorksOnDom = typeof document === 'undefined' ||
            doesDefinePropertyWork(document.createElement('div'));
        if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
            var definePropertyFallback = Object.defineProperty,
                definePropertiesFallback = Object.defineProperties;
        }
    }

    if (!Object.defineProperty || definePropertyFallback) {
        var ERR_NON_OBJECT_DESCRIPTOR = 'Property description must be an object: ';
        var ERR_NON_OBJECT_TARGET = 'Object.defineProperty called on non-object: ';
        var ERR_ACCESSORS_NOT_SUPPORTED = 'getters & setters can not be defined on this javascript engine';

        Object.defineProperty = function defineProperty(object, property, descriptor) {
            if (isPrimitive(object)) {
                throw new TypeError(ERR_NON_OBJECT_TARGET + object);
            }
            if (isPrimitive(descriptor)) {
                throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
            }
            // make a valiant attempt to use the real defineProperty
            // for I8's DOM elements.
            if (definePropertyFallback) {
                try {
                    return definePropertyFallback.call(Object, object, property, descriptor);
                } catch (exception) {
                    // try the shim if the real one doesn't work
                }
            }

            // If it's a data property.
            if ('value' in descriptor) {
                // fail silently if 'writable', 'enumerable', or 'configurable'
                // are requested but not supported
                /*
                // alternate approach:
                if ( // can't implement these features; allow false but not true
                    ('writable' in descriptor && !descriptor.writable) ||
                    ('enumerable' in descriptor && !descriptor.enumerable) ||
                    ('configurable' in descriptor && !descriptor.configurable)
                ))
                    throw new RangeError(
                        'This implementation of Object.defineProperty does not support configurable, enumerable, or writable.'
                    );
                */

                if (supportsAccessors && (lookupGetter(object, property) || lookupSetter(object, property))) {
                    // As accessors are supported only on engines implementing
                    // `__proto__` we can safely override `__proto__` while defining
                    // a property to make sure that we don't hit an inherited
                    // accessor.
                    /* eslint-disable no-proto */
                    var prototype = object.__proto__;
                    object.__proto__ = prototypeOfObject;
                    // Deleting a property anyway since getter / setter may be
                    // defined on object itself.
                    delete object[property];
                    object[property] = descriptor.value;
                    // Setting original `__proto__` back now.
                    object.__proto__ = prototype;
                    /* eslint-enable no-proto */
                } else {
                    object[property] = descriptor.value;
                }
            } else {
                var hasGetter = 'get' in descriptor;
                var hasSetter = 'set' in descriptor;
                if (!supportsAccessors && (hasGetter || hasSetter)) {
                     return;
                }
                // If we got that far then getters and setters can be defined !!
                if (hasGetter) {
                    defineGetter(object, property, descriptor.get);
                }
                if (hasSetter) {
                    defineSetter(object, property, descriptor.set);
                }
            }
            return object;
        };
    }

    // ES5 15.2.3.7
    // http://es5.github.com/#x15.2.3.7
    if (!Object.defineProperties || definePropertiesFallback) {
        Object.defineProperties = function defineProperties(object, properties) {
            // make a valiant attempt to use the real defineProperties
            if (definePropertiesFallback) {
                try {
                    return definePropertiesFallback.call(Object, object, properties);
                } catch (exception) {
                    // try the shim if the real one doesn't work
                }
            }

            Object.keys(properties).forEach(function (property) {
                if (property !== '__proto__') {
                    Object.defineProperty(object, property, properties[property]);
                }
            });
            return object;
        };
    }

    // ES5 15.2.3.8
    // http://es5.github.com/#x15.2.3.8
    if (!Object.seal) {
        Object.seal = function seal(object) {
            if (Object(object) !== object) {
                throw new TypeError('Object.seal can only be called on Objects.');
            }
            // this is misleading and breaks feature-detection, but
            // allows "securable" code to "gracefully" degrade to working
            // but insecure code.
            return object;
        };
    }

    // ES5 15.2.3.9
    // http://es5.github.com/#x15.2.3.9
    if (!Object.freeze) {
        Object.freeze = function freeze(object) {
            if (Object(object) !== object) {
                throw new TypeError('Object.freeze can only be called on Objects.');
            }
            // this is misleading and breaks feature-detection, but
            // allows "securable" code to "gracefully" degrade to working
            // but insecure code.
            return object;
        };
    }

    // detect a Rhino bug and patch it
    try {
        Object.freeze(function () {});
    } catch (exception) {
        Object.freeze = (function (freezeObject) {
            return function freeze(object) {
                if (typeof object === 'function') {
                    return object;
                } else {
                    return freezeObject(object);
                }
            };
        }(Object.freeze));
    }

    // ES5 15.2.3.10
    // http://es5.github.com/#x15.2.3.10
    if (!Object.preventExtensions) {
        Object.preventExtensions = function preventExtensions(object) {
            if (Object(object) !== object) {
                throw new TypeError('Object.preventExtensions can only be called on Objects.');
            }
            // this is misleading and breaks feature-detection, but
            // allows "securable" code to "gracefully" degrade to working
            // but insecure code.
            return object;
        };
    }

    // ES5 15.2.3.11
    // http://es5.github.com/#x15.2.3.11
    if (!Object.isSealed) {
        Object.isSealed = function isSealed(object) {
            if (Object(object) !== object) {
                throw new TypeError('Object.isSealed can only be called on Objects.');
            }
            return false;
        };
    }

    // ES5 15.2.3.12
    // http://es5.github.com/#x15.2.3.12
    if (!Object.isFrozen) {
        Object.isFrozen = function isFrozen(object) {
            if (Object(object) !== object) {
                throw new TypeError('Object.isFrozen can only be called on Objects.');
            }
            return false;
        };
    }

    // ES5 15.2.3.13
    // http://es5.github.com/#x15.2.3.13
    if (!Object.isExtensible) {
        Object.isExtensible = function isExtensible(object) {
            // 1. If Type(O) is not Object throw a TypeError exception.
            if (Object(object) !== object) {
                throw new TypeError('Object.isExtensible can only be called on Objects.');
            }
            // 2. Return the Boolean value of the [[Extensible]] internal property of O.
            var name = '';
            while (owns(object, name)) {
                name += '?';
            }
            object[name] = true;
            var returnValue = owns(object, name);
            delete object[name];
            return returnValue;
        };
    }

}));

},{}],10:[function(require,module,exports){
/*!
 * https://github.com/es-shims/es5-shim
 * @license es5-shim Copyright 2009-2015 by contributors, MIT License
 * see https://github.com/es-shims/es5-shim/blob/master/LICENSE
 */

// vim: ts=4 sts=4 sw=4 expandtab

// Add semicolon to prevent IIFE from being passed as argument to concatenated code.
;

// UMD (Universal Module Definition)
// see https://github.com/umdjs/umd/blob/master/templates/returnExports.js
(function (root, factory) {
    'use strict';

    /* global define, exports, module */
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.returnExports = factory();
    }
}(this, function () {
    /**
     * Brings an environment as close to ECMAScript 5 compliance
     * as is possible with the facilities of erstwhile engines.
     *
     * Annotated ES5: http://es5.github.com/ (specific links below)
     * ES5 Spec: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
     * Required reading: http://javascriptweblog.wordpress.com/2011/12/05/extending-javascript-natives/
     */

    // Shortcut to an often accessed properties, in order to avoid multiple
    // dereference that costs universally. This also holds a reference to known-good
    // functions.
    var $Array = Array;
    var ArrayPrototype = $Array.prototype;
    var $Object = Object;
    var ObjectPrototype = $Object.prototype;
    var $Function = Function;
    var FunctionPrototype = $Function.prototype;
    var $String = String;
    var StringPrototype = $String.prototype;
    var $Number = Number;
    var NumberPrototype = $Number.prototype;
    var array_slice = ArrayPrototype.slice;
    var array_splice = ArrayPrototype.splice;
    var array_push = ArrayPrototype.push;
    var array_unshift = ArrayPrototype.unshift;
    var array_concat = ArrayPrototype.concat;
    var array_join = ArrayPrototype.join;
    var call = FunctionPrototype.call;
    var apply = FunctionPrototype.apply;
    var max = Math.max;
    var min = Math.min;

    // Having a toString local variable name breaks in Opera so use to_string.
    var to_string = ObjectPrototype.toString;

    /* global Symbol */
    /* eslint-disable one-var-declaration-per-line, no-redeclare, max-statements-per-line */
    var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
    var isCallable; /* inlined from https://npmjs.com/is-callable */ var fnToStr = Function.prototype.toString, constructorRegex = /^\s*class /, isES6ClassFn = function isES6ClassFn(value) { try { var fnStr = fnToStr.call(value); var singleStripped = fnStr.replace(/\/\/.*\n/g, ''); var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, ''); var spaceStripped = multiStripped.replace(/\n/mg, ' ').replace(/ {2}/g, ' '); return constructorRegex.test(spaceStripped); } catch (e) { return false; /* not a function */ } }, tryFunctionObject = function tryFunctionObject(value) { try { if (isES6ClassFn(value)) { return false; } fnToStr.call(value); return true; } catch (e) { return false; } }, fnClass = '[object Function]', genClass = '[object GeneratorFunction]', isCallable = function isCallable(value) { if (!value) { return false; } if (typeof value !== 'function' && typeof value !== 'object') { return false; } if (hasToStringTag) { return tryFunctionObject(value); } if (isES6ClassFn(value)) { return false; } var strClass = to_string.call(value); return strClass === fnClass || strClass === genClass; };

    var isRegex; /* inlined from https://npmjs.com/is-regex */ var regexExec = RegExp.prototype.exec, tryRegexExec = function tryRegexExec(value) { try { regexExec.call(value); return true; } catch (e) { return false; } }, regexClass = '[object RegExp]'; isRegex = function isRegex(value) { if (typeof value !== 'object') { return false; } return hasToStringTag ? tryRegexExec(value) : to_string.call(value) === regexClass; };
    var isString; /* inlined from https://npmjs.com/is-string */ var strValue = String.prototype.valueOf, tryStringObject = function tryStringObject(value) { try { strValue.call(value); return true; } catch (e) { return false; } }, stringClass = '[object String]'; isString = function isString(value) { if (typeof value === 'string') { return true; } if (typeof value !== 'object') { return false; } return hasToStringTag ? tryStringObject(value) : to_string.call(value) === stringClass; };
    /* eslint-enable one-var-declaration-per-line, no-redeclare, max-statements-per-line */

    /* inlined from http://npmjs.com/define-properties */
    var supportsDescriptors = $Object.defineProperty && (function () {
        try {
            var obj = {};
            $Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
            for (var _ in obj) { // jscs:ignore disallowUnusedVariables
                return false;
            }
            return obj.x === obj;
        } catch (e) { /* this is ES3 */
            return false;
        }
    }());
    var defineProperties = (function (has) {
        // Define configurable, writable, and non-enumerable props
        // if they don't exist.
        var defineProperty;
        if (supportsDescriptors) {
            defineProperty = function (object, name, method, forceAssign) {
                if (!forceAssign && (name in object)) {
                    return;
                }
                $Object.defineProperty(object, name, {
                    configurable: true,
                    enumerable: false,
                    writable: true,
                    value: method
                });
            };
        } else {
            defineProperty = function (object, name, method, forceAssign) {
                if (!forceAssign && (name in object)) {
                    return;
                }
                object[name] = method;
            };
        }
        return function defineProperties(object, map, forceAssign) {
            for (var name in map) {
                if (has.call(map, name)) {
                    defineProperty(object, name, map[name], forceAssign);
                }
            }
        };
    }(ObjectPrototype.hasOwnProperty));

    //
    // Util
    // ======
    //

    /* replaceable with https://npmjs.com/package/es-abstract /helpers/isPrimitive */
    var isPrimitive = function isPrimitive(input) {
        var type = typeof input;
        return input === null || (type !== 'object' && type !== 'function');
    };

    var isActualNaN = $Number.isNaN || function isActualNaN(x) {
        return x !== x;
    };

    var ES = {
        // ES5 9.4
        // http://es5.github.com/#x9.4
        // http://jsperf.com/to-integer
        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToInteger */
        ToInteger: function ToInteger(num) {
            var n = +num;
            if (isActualNaN(n)) {
                n = 0;
            } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
                n = (n > 0 || -1) * Math.floor(Math.abs(n));
            }
            return n;
        },

        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToPrimitive */
        ToPrimitive: function ToPrimitive(input) {
            var val, valueOf, toStr;
            if (isPrimitive(input)) {
                return input;
            }
            valueOf = input.valueOf;
            if (isCallable(valueOf)) {
                val = valueOf.call(input);
                if (isPrimitive(val)) {
                    return val;
                }
            }
            toStr = input.toString;
            if (isCallable(toStr)) {
                val = toStr.call(input);
                if (isPrimitive(val)) {
                    return val;
                }
            }
            throw new TypeError();
        },

        // ES5 9.9
        // http://es5.github.com/#x9.9
        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToObject */
        ToObject: function (o) {
            if (o == null) { // this matches both null and undefined
                throw new TypeError("can't convert " + o + ' to object');
            }
            return $Object(o);
        },

        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToUint32 */
        ToUint32: function ToUint32(x) {
            return x >>> 0;
        }
    };

    //
    // Function
    // ========
    //

    // ES-5 15.3.4.5
    // http://es5.github.com/#x15.3.4.5

    var Empty = function Empty() {};

    defineProperties(FunctionPrototype, {
        bind: function bind(that) { // .length is 1
            // 1. Let Target be the this value.
            var target = this;
            // 2. If IsCallable(Target) is false, throw a TypeError exception.
            if (!isCallable(target)) {
                throw new TypeError('Function.prototype.bind called on incompatible ' + target);
            }
            // 3. Let A be a new (possibly empty) internal list of all of the
            //   argument values provided after thisArg (arg1, arg2 etc), in order.
            // XXX slicedArgs will stand in for "A" if used
            var args = array_slice.call(arguments, 1); // for normal call
            // 4. Let F be a new native ECMAScript object.
            // 11. Set the [[Prototype]] internal property of F to the standard
            //   built-in Function prototype object as specified in 15.3.3.1.
            // 12. Set the [[Call]] internal property of F as described in
            //   15.3.4.5.1.
            // 13. Set the [[Construct]] internal property of F as described in
            //   15.3.4.5.2.
            // 14. Set the [[HasInstance]] internal property of F as described in
            //   15.3.4.5.3.
            var bound;
            var binder = function () {

                if (this instanceof bound) {
                    // 15.3.4.5.2 [[Construct]]
                    // When the [[Construct]] internal method of a function object,
                    // F that was created using the bind function is called with a
                    // list of arguments ExtraArgs, the following steps are taken:
                    // 1. Let target be the value of F's [[TargetFunction]]
                    //   internal property.
                    // 2. If target has no [[Construct]] internal method, a
                    //   TypeError exception is thrown.
                    // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                    //   property.
                    // 4. Let args be a new list containing the same values as the
                    //   list boundArgs in the same order followed by the same
                    //   values as the list ExtraArgs in the same order.
                    // 5. Return the result of calling the [[Construct]] internal
                    //   method of target providing args as the arguments.

                    var result = apply.call(
                        target,
                        this,
                        array_concat.call(args, array_slice.call(arguments))
                    );
                    if ($Object(result) === result) {
                        return result;
                    }
                    return this;

                } else {
                    // 15.3.4.5.1 [[Call]]
                    // When the [[Call]] internal method of a function object, F,
                    // which was created using the bind function is called with a
                    // this value and a list of arguments ExtraArgs, the following
                    // steps are taken:
                    // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                    //   property.
                    // 2. Let boundThis be the value of F's [[BoundThis]] internal
                    //   property.
                    // 3. Let target be the value of F's [[TargetFunction]] internal
                    //   property.
                    // 4. Let args be a new list containing the same values as the
                    //   list boundArgs in the same order followed by the same
                    //   values as the list ExtraArgs in the same order.
                    // 5. Return the result of calling the [[Call]] internal method
                    //   of target providing boundThis as the this value and
                    //   providing args as the arguments.

                    // equiv: target.call(this, ...boundArgs, ...args)
                    return apply.call(
                        target,
                        that,
                        array_concat.call(args, array_slice.call(arguments))
                    );

                }

            };

            // 15. If the [[Class]] internal property of Target is "Function", then
            //     a. Let L be the length property of Target minus the length of A.
            //     b. Set the length own property of F to either 0 or L, whichever is
            //       larger.
            // 16. Else set the length own property of F to 0.

            var boundLength = max(0, target.length - args.length);

            // 17. Set the attributes of the length own property of F to the values
            //   specified in 15.3.5.1.
            var boundArgs = [];
            for (var i = 0; i < boundLength; i++) {
                array_push.call(boundArgs, '$' + i);
            }

            // XXX Build a dynamic function with desired amount of arguments is the only
            // way to set the length property of a function.
            // In environments where Content Security Policies enabled (Chrome extensions,
            // for ex.) all use of eval or Function costructor throws an exception.
            // However in all of these environments Function.prototype.bind exists
            // and so this code will never be executed.
            bound = $Function('binder', 'return function (' + array_join.call(boundArgs, ',') + '){ return binder.apply(this, arguments); }')(binder);

            if (target.prototype) {
                Empty.prototype = target.prototype;
                bound.prototype = new Empty();
                // Clean up dangling references.
                Empty.prototype = null;
            }

            // TODO
            // 18. Set the [[Extensible]] internal property of F to true.

            // TODO
            // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
            // 20. Call the [[DefineOwnProperty]] internal method of F with
            //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
            //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
            //   false.
            // 21. Call the [[DefineOwnProperty]] internal method of F with
            //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
            //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
            //   and false.

            // TODO
            // NOTE Function objects created using Function.prototype.bind do not
            // have a prototype property or the [[Code]], [[FormalParameters]], and
            // [[Scope]] internal properties.
            // XXX can't delete prototype in pure-js.

            // 22. Return F.
            return bound;
        }
    });

    // _Please note: Shortcuts are defined after `Function.prototype.bind` as we
    // use it in defining shortcuts.
    var owns = call.bind(ObjectPrototype.hasOwnProperty);
    var toStr = call.bind(ObjectPrototype.toString);
    var arraySlice = call.bind(array_slice);
    var arraySliceApply = apply.bind(array_slice);
    var strSlice = call.bind(StringPrototype.slice);
    var strSplit = call.bind(StringPrototype.split);
    var strIndexOf = call.bind(StringPrototype.indexOf);
    var pushCall = call.bind(array_push);
    var isEnum = call.bind(ObjectPrototype.propertyIsEnumerable);
    var arraySort = call.bind(ArrayPrototype.sort);

    //
    // Array
    // =====
    //

    var isArray = $Array.isArray || function isArray(obj) {
        return toStr(obj) === '[object Array]';
    };

    // ES5 15.4.4.12
    // http://es5.github.com/#x15.4.4.13
    // Return len+argCount.
    // [bugfix, ielt8]
    // IE < 8 bug: [].unshift(0) === undefined but should be "1"
    var hasUnshiftReturnValueBug = [].unshift(0) !== 1;
    defineProperties(ArrayPrototype, {
        unshift: function () {
            array_unshift.apply(this, arguments);
            return this.length;
        }
    }, hasUnshiftReturnValueBug);

    // ES5 15.4.3.2
    // http://es5.github.com/#x15.4.3.2
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
    defineProperties($Array, { isArray: isArray });

    // The IsCallable() check in the Array functions
    // has been replaced with a strict check on the
    // internal class of the object to trap cases where
    // the provided function was actually a regular
    // expression literal, which in V8 and
    // JavaScriptCore is a typeof "function".  Only in
    // V8 are regular expression literals permitted as
    // reduce parameters, so it is desirable in the
    // general case for the shim to match the more
    // strict and common behavior of rejecting regular
    // expressions.

    // ES5 15.4.4.18
    // http://es5.github.com/#x15.4.4.18
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/forEach

    // Check failure of by-index access of string characters (IE < 9)
    // and failure of `0 in boxedString` (Rhino)
    var boxedString = $Object('a');
    var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

    var properlyBoxesContext = function properlyBoxed(method) {
        // Check node 0.6.21 bug where third parameter is not boxed
        var properlyBoxesNonStrict = true;
        var properlyBoxesStrict = true;
        var threwException = false;
        if (method) {
            try {
                method.call('foo', function (_, __, context) {
                    if (typeof context !== 'object') {
                        properlyBoxesNonStrict = false;
                    }
                });

                method.call([1], function () {
                    'use strict';

                    properlyBoxesStrict = typeof this === 'string';
                }, 'x');
            } catch (e) {
                threwException = true;
            }
        }
        return !!method && !threwException && properlyBoxesNonStrict && properlyBoxesStrict;
    };

    defineProperties(ArrayPrototype, {
        forEach: function forEach(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var i = -1;
            var length = ES.ToUint32(self.length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.forEach callback must be a function');
            }

            while (++i < length) {
                if (i in self) {
                    // Invoke the callback function with call, passing arguments:
                    // context, property value, property key, thisArg object
                    if (typeof T === 'undefined') {
                        callbackfn(self[i], i, object);
                    } else {
                        callbackfn.call(T, self[i], i, object);
                    }
                }
            }
        }
    }, !properlyBoxesContext(ArrayPrototype.forEach));

    // ES5 15.4.4.19
    // http://es5.github.com/#x15.4.4.19
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
    defineProperties(ArrayPrototype, {
        map: function map(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var result = $Array(length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.map callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self) {
                    if (typeof T === 'undefined') {
                        result[i] = callbackfn(self[i], i, object);
                    } else {
                        result[i] = callbackfn.call(T, self[i], i, object);
                    }
                }
            }
            return result;
        }
    }, !properlyBoxesContext(ArrayPrototype.map));

    // ES5 15.4.4.20
    // http://es5.github.com/#x15.4.4.20
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
    defineProperties(ArrayPrototype, {
        filter: function filter(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var result = [];
            var value;
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.filter callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self) {
                    value = self[i];
                    if (typeof T === 'undefined' ? callbackfn(value, i, object) : callbackfn.call(T, value, i, object)) {
                        pushCall(result, value);
                    }
                }
            }
            return result;
        }
    }, !properlyBoxesContext(ArrayPrototype.filter));

    // ES5 15.4.4.16
    // http://es5.github.com/#x15.4.4.16
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every
    defineProperties(ArrayPrototype, {
        every: function every(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.every callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self && !(typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
                    return false;
                }
            }
            return true;
        }
    }, !properlyBoxesContext(ArrayPrototype.every));

    // ES5 15.4.4.17
    // http://es5.github.com/#x15.4.4.17
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
    defineProperties(ArrayPrototype, {
        some: function some(callbackfn/*, thisArg */) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.some callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self && (typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
                    return true;
                }
            }
            return false;
        }
    }, !properlyBoxesContext(ArrayPrototype.some));

    // ES5 15.4.4.21
    // http://es5.github.com/#x15.4.4.21
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
    var reduceCoercesToObject = false;
    if (ArrayPrototype.reduce) {
        reduceCoercesToObject = typeof ArrayPrototype.reduce.call('es5', function (_, __, ___, list) {
            return list;
        }) === 'object';
    }
    defineProperties(ArrayPrototype, {
        reduce: function reduce(callbackfn/*, initialValue*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.reduce callback must be a function');
            }

            // no value to return if no initial value and an empty array
            if (length === 0 && arguments.length === 1) {
                throw new TypeError('reduce of empty array with no initial value');
            }

            var i = 0;
            var result;
            if (arguments.length >= 2) {
                result = arguments[1];
            } else {
                do {
                    if (i in self) {
                        result = self[i++];
                        break;
                    }

                    // if array contains no values, no initial value to return
                    if (++i >= length) {
                        throw new TypeError('reduce of empty array with no initial value');
                    }
                } while (true);
            }

            for (; i < length; i++) {
                if (i in self) {
                    result = callbackfn(result, self[i], i, object);
                }
            }

            return result;
        }
    }, !reduceCoercesToObject);

    // ES5 15.4.4.22
    // http://es5.github.com/#x15.4.4.22
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduceRight
    var reduceRightCoercesToObject = false;
    if (ArrayPrototype.reduceRight) {
        reduceRightCoercesToObject = typeof ArrayPrototype.reduceRight.call('es5', function (_, __, ___, list) {
            return list;
        }) === 'object';
    }
    defineProperties(ArrayPrototype, {
        reduceRight: function reduceRight(callbackfn/*, initial*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.reduceRight callback must be a function');
            }

            // no value to return if no initial value, empty array
            if (length === 0 && arguments.length === 1) {
                throw new TypeError('reduceRight of empty array with no initial value');
            }

            var result;
            var i = length - 1;
            if (arguments.length >= 2) {
                result = arguments[1];
            } else {
                do {
                    if (i in self) {
                        result = self[i--];
                        break;
                    }

                    // if array contains no values, no initial value to return
                    if (--i < 0) {
                        throw new TypeError('reduceRight of empty array with no initial value');
                    }
                } while (true);
            }

            if (i < 0) {
                return result;
            }

            do {
                if (i in self) {
                    result = callbackfn(result, self[i], i, object);
                }
            } while (i--);

            return result;
        }
    }, !reduceRightCoercesToObject);

    // ES5 15.4.4.14
    // http://es5.github.com/#x15.4.4.14
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
    var hasFirefox2IndexOfBug = ArrayPrototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
    defineProperties(ArrayPrototype, {
        indexOf: function indexOf(searchElement/*, fromIndex */) {
            var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
            var length = ES.ToUint32(self.length);

            if (length === 0) {
                return -1;
            }

            var i = 0;
            if (arguments.length > 1) {
                i = ES.ToInteger(arguments[1]);
            }

            // handle negative indices
            i = i >= 0 ? i : max(0, length + i);
            for (; i < length; i++) {
                if (i in self && self[i] === searchElement) {
                    return i;
                }
            }
            return -1;
        }
    }, hasFirefox2IndexOfBug);

    // ES5 15.4.4.15
    // http://es5.github.com/#x15.4.4.15
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf
    var hasFirefox2LastIndexOfBug = ArrayPrototype.lastIndexOf && [0, 1].lastIndexOf(0, -3) !== -1;
    defineProperties(ArrayPrototype, {
        lastIndexOf: function lastIndexOf(searchElement/*, fromIndex */) {
            var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
            var length = ES.ToUint32(self.length);

            if (length === 0) {
                return -1;
            }
            var i = length - 1;
            if (arguments.length > 1) {
                i = min(i, ES.ToInteger(arguments[1]));
            }
            // handle negative indices
            i = i >= 0 ? i : length - Math.abs(i);
            for (; i >= 0; i--) {
                if (i in self && searchElement === self[i]) {
                    return i;
                }
            }
            return -1;
        }
    }, hasFirefox2LastIndexOfBug);

    // ES5 15.4.4.12
    // http://es5.github.com/#x15.4.4.12
    var spliceNoopReturnsEmptyArray = (function () {
        var a = [1, 2];
        var result = a.splice();
        return a.length === 2 && isArray(result) && result.length === 0;
    }());
    defineProperties(ArrayPrototype, {
        // Safari 5.0 bug where .splice() returns undefined
        splice: function splice(start, deleteCount) {
            if (arguments.length === 0) {
                return [];
            } else {
                return array_splice.apply(this, arguments);
            }
        }
    }, !spliceNoopReturnsEmptyArray);

    var spliceWorksWithEmptyObject = (function () {
        var obj = {};
        ArrayPrototype.splice.call(obj, 0, 0, 1);
        return obj.length === 1;
    }());
    defineProperties(ArrayPrototype, {
        splice: function splice(start, deleteCount) {
            if (arguments.length === 0) {
                return [];
            }
            var args = arguments;
            this.length = max(ES.ToInteger(this.length), 0);
            if (arguments.length > 0 && typeof deleteCount !== 'number') {
                args = arraySlice(arguments);
                if (args.length < 2) {
                    pushCall(args, this.length - start);
                } else {
                    args[1] = ES.ToInteger(deleteCount);
                }
            }
            return array_splice.apply(this, args);
        }
    }, !spliceWorksWithEmptyObject);
    var spliceWorksWithLargeSparseArrays = (function () {
        // Per https://github.com/es-shims/es5-shim/issues/295
        // Safari 7/8 breaks with sparse arrays of size 1e5 or greater
        var arr = new $Array(1e5);
        // note: the index MUST be 8 or larger or the test will false pass
        arr[8] = 'x';
        arr.splice(1, 1);
        // note: this test must be defined *after* the indexOf shim
        // per https://github.com/es-shims/es5-shim/issues/313
        return arr.indexOf('x') === 7;
    }());
    var spliceWorksWithSmallSparseArrays = (function () {
        // Per https://github.com/es-shims/es5-shim/issues/295
        // Opera 12.15 breaks on this, no idea why.
        var n = 256;
        var arr = [];
        arr[n] = 'a';
        arr.splice(n + 1, 0, 'b');
        return arr[n] === 'a';
    }());
    defineProperties(ArrayPrototype, {
        splice: function splice(start, deleteCount) {
            var O = ES.ToObject(this);
            var A = [];
            var len = ES.ToUint32(O.length);
            var relativeStart = ES.ToInteger(start);
            var actualStart = relativeStart < 0 ? max((len + relativeStart), 0) : min(relativeStart, len);
            var actualDeleteCount = min(max(ES.ToInteger(deleteCount), 0), len - actualStart);

            var k = 0;
            var from;
            while (k < actualDeleteCount) {
                from = $String(actualStart + k);
                if (owns(O, from)) {
                    A[k] = O[from];
                }
                k += 1;
            }

            var items = arraySlice(arguments, 2);
            var itemCount = items.length;
            var to;
            if (itemCount < actualDeleteCount) {
                k = actualStart;
                var maxK = len - actualDeleteCount;
                while (k < maxK) {
                    from = $String(k + actualDeleteCount);
                    to = $String(k + itemCount);
                    if (owns(O, from)) {
                        O[to] = O[from];
                    } else {
                        delete O[to];
                    }
                    k += 1;
                }
                k = len;
                var minK = len - actualDeleteCount + itemCount;
                while (k > minK) {
                    delete O[k - 1];
                    k -= 1;
                }
            } else if (itemCount > actualDeleteCount) {
                k = len - actualDeleteCount;
                while (k > actualStart) {
                    from = $String(k + actualDeleteCount - 1);
                    to = $String(k + itemCount - 1);
                    if (owns(O, from)) {
                        O[to] = O[from];
                    } else {
                        delete O[to];
                    }
                    k -= 1;
                }
            }
            k = actualStart;
            for (var i = 0; i < items.length; ++i) {
                O[k] = items[i];
                k += 1;
            }
            O.length = len - actualDeleteCount + itemCount;

            return A;
        }
    }, !spliceWorksWithLargeSparseArrays || !spliceWorksWithSmallSparseArrays);

    var originalJoin = ArrayPrototype.join;
    var hasStringJoinBug;
    try {
        hasStringJoinBug = Array.prototype.join.call('123', ',') !== '1,2,3';
    } catch (e) {
        hasStringJoinBug = true;
    }
    if (hasStringJoinBug) {
        defineProperties(ArrayPrototype, {
            join: function join(separator) {
                var sep = typeof separator === 'undefined' ? ',' : separator;
                return originalJoin.call(isString(this) ? strSplit(this, '') : this, sep);
            }
        }, hasStringJoinBug);
    }

    var hasJoinUndefinedBug = [1, 2].join(undefined) !== '1,2';
    if (hasJoinUndefinedBug) {
        defineProperties(ArrayPrototype, {
            join: function join(separator) {
                var sep = typeof separator === 'undefined' ? ',' : separator;
                return originalJoin.call(this, sep);
            }
        }, hasJoinUndefinedBug);
    }

    var pushShim = function push(item) {
        var O = ES.ToObject(this);
        var n = ES.ToUint32(O.length);
        var i = 0;
        while (i < arguments.length) {
            O[n + i] = arguments[i];
            i += 1;
        }
        O.length = n + i;
        return n + i;
    };

    var pushIsNotGeneric = (function () {
        var obj = {};
        var result = Array.prototype.push.call(obj, undefined);
        return result !== 1 || obj.length !== 1 || typeof obj[0] !== 'undefined' || !owns(obj, 0);
    }());
    defineProperties(ArrayPrototype, {
        push: function push(item) {
            if (isArray(this)) {
                return array_push.apply(this, arguments);
            }
            return pushShim.apply(this, arguments);
        }
    }, pushIsNotGeneric);

    // This fixes a very weird bug in Opera 10.6 when pushing `undefined
    var pushUndefinedIsWeird = (function () {
        var arr = [];
        var result = arr.push(undefined);
        return result !== 1 || arr.length !== 1 || typeof arr[0] !== 'undefined' || !owns(arr, 0);
    }());
    defineProperties(ArrayPrototype, { push: pushShim }, pushUndefinedIsWeird);

    // ES5 15.2.3.14
    // http://es5.github.io/#x15.4.4.10
    // Fix boxed string bug
    defineProperties(ArrayPrototype, {
        slice: function (start, end) {
            var arr = isString(this) ? strSplit(this, '') : this;
            return arraySliceApply(arr, arguments);
        }
    }, splitString);

    var sortIgnoresNonFunctions = (function () {
        try {
            [1, 2].sort(null);
            [1, 2].sort({});
            return true;
        } catch (e) {}
        return false;
    }());
    var sortThrowsOnRegex = (function () {
        // this is a problem in Firefox 4, in which `typeof /a/ === 'function'`
        try {
            [1, 2].sort(/a/);
            return false;
        } catch (e) {}
        return true;
    }());
    var sortIgnoresUndefined = (function () {
        // applies in IE 8, for one.
        try {
            [1, 2].sort(undefined);
            return true;
        } catch (e) {}
        return false;
    }());
    defineProperties(ArrayPrototype, {
        sort: function sort(compareFn) {
            if (typeof compareFn === 'undefined') {
                return arraySort(this);
            }
            if (!isCallable(compareFn)) {
                throw new TypeError('Array.prototype.sort callback must be a function');
            }
            return arraySort(this, compareFn);
        }
    }, sortIgnoresNonFunctions || !sortIgnoresUndefined || !sortThrowsOnRegex);

    //
    // Object
    // ======
    //

    // ES5 15.2.3.14
    // http://es5.github.com/#x15.2.3.14

    // http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
    var hasDontEnumBug = !isEnum({ 'toString': null }, 'toString');
    var hasProtoEnumBug = isEnum(function () {}, 'prototype');
    var hasStringEnumBug = !owns('x', '0');
    var equalsConstructorPrototype = function (o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
    };
    var blacklistedKeys = {
        $window: true,
        $console: true,
        $parent: true,
        $self: true,
        $frame: true,
        $frames: true,
        $frameElement: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $external: true
    };
    var hasAutomationEqualityBug = (function () {
        /* globals window */
        if (typeof window === 'undefined') {
            return false;
        }
        for (var k in window) {
            try {
                if (!blacklistedKeys['$' + k] && owns(window, k) && window[k] !== null && typeof window[k] === 'object') {
                    equalsConstructorPrototype(window[k]);
                }
            } catch (e) {
                return true;
            }
        }
        return false;
    }());
    var equalsConstructorPrototypeIfNotBuggy = function (object) {
        if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
            return equalsConstructorPrototype(object);
        }
        try {
            return equalsConstructorPrototype(object);
        } catch (e) {
            return false;
        }
    };
    var dontEnums = [
        'toString',
        'toLocaleString',
        'valueOf',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'constructor'
    ];
    var dontEnumsLength = dontEnums.length;

    // taken directly from https://github.com/ljharb/is-arguments/blob/master/index.js
    // can be replaced with require('is-arguments') if we ever use a build process instead
    var isStandardArguments = function isArguments(value) {
        return toStr(value) === '[object Arguments]';
    };
    var isLegacyArguments = function isArguments(value) {
        return value !== null &&
            typeof value === 'object' &&
            typeof value.length === 'number' &&
            value.length >= 0 &&
            !isArray(value) &&
            isCallable(value.callee);
    };
    var isArguments = isStandardArguments(arguments) ? isStandardArguments : isLegacyArguments;

    defineProperties($Object, {
        keys: function keys(object) {
            var isFn = isCallable(object);
            var isArgs = isArguments(object);
            var isObject = object !== null && typeof object === 'object';
            var isStr = isObject && isString(object);

            if (!isObject && !isFn && !isArgs) {
                throw new TypeError('Object.keys called on a non-object');
            }

            var theKeys = [];
            var skipProto = hasProtoEnumBug && isFn;
            if ((isStr && hasStringEnumBug) || isArgs) {
                for (var i = 0; i < object.length; ++i) {
                    pushCall(theKeys, $String(i));
                }
            }

            if (!isArgs) {
                for (var name in object) {
                    if (!(skipProto && name === 'prototype') && owns(object, name)) {
                        pushCall(theKeys, $String(name));
                    }
                }
            }

            if (hasDontEnumBug) {
                var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
                for (var j = 0; j < dontEnumsLength; j++) {
                    var dontEnum = dontEnums[j];
                    if (!(skipConstructor && dontEnum === 'constructor') && owns(object, dontEnum)) {
                        pushCall(theKeys, dontEnum);
                    }
                }
            }
            return theKeys;
        }
    });

    var keysWorksWithArguments = $Object.keys && (function () {
        // Safari 5.0 bug
        return $Object.keys(arguments).length === 2;
    }(1, 2));
    var keysHasArgumentsLengthBug = $Object.keys && (function () {
        var argKeys = $Object.keys(arguments);
        return arguments.length !== 1 || argKeys.length !== 1 || argKeys[0] !== 1;
    }(1));
    var originalKeys = $Object.keys;
    defineProperties($Object, {
        keys: function keys(object) {
            if (isArguments(object)) {
                return originalKeys(arraySlice(object));
            } else {
                return originalKeys(object);
            }
        }
    }, !keysWorksWithArguments || keysHasArgumentsLengthBug);

    //
    // Date
    // ====
    //

    var hasNegativeMonthYearBug = new Date(-3509827329600292).getUTCMonth() !== 0;
    var aNegativeTestDate = new Date(-1509842289600292);
    var aPositiveTestDate = new Date(1449662400000);
    var hasToUTCStringFormatBug = aNegativeTestDate.toUTCString() !== 'Mon, 01 Jan -45875 11:59:59 GMT';
    var hasToDateStringFormatBug;
    var hasToStringFormatBug;
    var timeZoneOffset = aNegativeTestDate.getTimezoneOffset();
    if (timeZoneOffset < -720) {
        hasToDateStringFormatBug = aNegativeTestDate.toDateString() !== 'Tue Jan 02 -45875';
        hasToStringFormatBug = !(/^Thu Dec 10 2015 \d\d:\d\d:\d\d GMT[-\+]\d\d\d\d(?: |$)/).test(aPositiveTestDate.toString());
    } else {
        hasToDateStringFormatBug = aNegativeTestDate.toDateString() !== 'Mon Jan 01 -45875';
        hasToStringFormatBug = !(/^Wed Dec 09 2015 \d\d:\d\d:\d\d GMT[-\+]\d\d\d\d(?: |$)/).test(aPositiveTestDate.toString());
    }

    var originalGetFullYear = call.bind(Date.prototype.getFullYear);
    var originalGetMonth = call.bind(Date.prototype.getMonth);
    var originalGetDate = call.bind(Date.prototype.getDate);
    var originalGetUTCFullYear = call.bind(Date.prototype.getUTCFullYear);
    var originalGetUTCMonth = call.bind(Date.prototype.getUTCMonth);
    var originalGetUTCDate = call.bind(Date.prototype.getUTCDate);
    var originalGetUTCDay = call.bind(Date.prototype.getUTCDay);
    var originalGetUTCHours = call.bind(Date.prototype.getUTCHours);
    var originalGetUTCMinutes = call.bind(Date.prototype.getUTCMinutes);
    var originalGetUTCSeconds = call.bind(Date.prototype.getUTCSeconds);
    var originalGetUTCMilliseconds = call.bind(Date.prototype.getUTCMilliseconds);
    var dayName = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    var monthName = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    var daysInMonth = function daysInMonth(month, year) {
        return originalGetDate(new Date(year, month, 0));
    };

    defineProperties(Date.prototype, {
        getFullYear: function getFullYear() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetFullYear(this);
            if (year < 0 && originalGetMonth(this) > 11) {
                return year + 1;
            }
            return year;
        },
        getMonth: function getMonth() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetFullYear(this);
            var month = originalGetMonth(this);
            if (year < 0 && month > 11) {
                return 0;
            }
            return month;
        },
        getDate: function getDate() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetFullYear(this);
            var month = originalGetMonth(this);
            var date = originalGetDate(this);
            if (year < 0 && month > 11) {
                if (month === 12) {
                    return date;
                }
                var days = daysInMonth(0, year + 1);
                return (days - date) + 1;
            }
            return date;
        },
        getUTCFullYear: function getUTCFullYear() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetUTCFullYear(this);
            if (year < 0 && originalGetUTCMonth(this) > 11) {
                return year + 1;
            }
            return year;
        },
        getUTCMonth: function getUTCMonth() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetUTCFullYear(this);
            var month = originalGetUTCMonth(this);
            if (year < 0 && month > 11) {
                return 0;
            }
            return month;
        },
        getUTCDate: function getUTCDate() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetUTCFullYear(this);
            var month = originalGetUTCMonth(this);
            var date = originalGetUTCDate(this);
            if (year < 0 && month > 11) {
                if (month === 12) {
                    return date;
                }
                var days = daysInMonth(0, year + 1);
                return (days - date) + 1;
            }
            return date;
        }
    }, hasNegativeMonthYearBug);

    defineProperties(Date.prototype, {
        toUTCString: function toUTCString() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var day = originalGetUTCDay(this);
            var date = originalGetUTCDate(this);
            var month = originalGetUTCMonth(this);
            var year = originalGetUTCFullYear(this);
            var hour = originalGetUTCHours(this);
            var minute = originalGetUTCMinutes(this);
            var second = originalGetUTCSeconds(this);
            return dayName[day] + ', ' +
                (date < 10 ? '0' + date : date) + ' ' +
                monthName[month] + ' ' +
                year + ' ' +
                (hour < 10 ? '0' + hour : hour) + ':' +
                (minute < 10 ? '0' + minute : minute) + ':' +
                (second < 10 ? '0' + second : second) + ' GMT';
        }
    }, hasNegativeMonthYearBug || hasToUTCStringFormatBug);

    // Opera 12 has `,`
    defineProperties(Date.prototype, {
        toDateString: function toDateString() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var day = this.getDay();
            var date = this.getDate();
            var month = this.getMonth();
            var year = this.getFullYear();
            return dayName[day] + ' ' +
                monthName[month] + ' ' +
                (date < 10 ? '0' + date : date) + ' ' +
                year;
        }
    }, hasNegativeMonthYearBug || hasToDateStringFormatBug);

    // can't use defineProperties here because of toString enumeration issue in IE <= 8
    if (hasNegativeMonthYearBug || hasToStringFormatBug) {
        Date.prototype.toString = function toString() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var day = this.getDay();
            var date = this.getDate();
            var month = this.getMonth();
            var year = this.getFullYear();
            var hour = this.getHours();
            var minute = this.getMinutes();
            var second = this.getSeconds();
            var timezoneOffset = this.getTimezoneOffset();
            var hoursOffset = Math.floor(Math.abs(timezoneOffset) / 60);
            var minutesOffset = Math.floor(Math.abs(timezoneOffset) % 60);
            return dayName[day] + ' ' +
                monthName[month] + ' ' +
                (date < 10 ? '0' + date : date) + ' ' +
                year + ' ' +
                (hour < 10 ? '0' + hour : hour) + ':' +
                (minute < 10 ? '0' + minute : minute) + ':' +
                (second < 10 ? '0' + second : second) + ' GMT' +
                (timezoneOffset > 0 ? '-' : '+') +
                (hoursOffset < 10 ? '0' + hoursOffset : hoursOffset) +
                (minutesOffset < 10 ? '0' + minutesOffset : minutesOffset);
        };
        if (supportsDescriptors) {
            $Object.defineProperty(Date.prototype, 'toString', {
                configurable: true,
                enumerable: false,
                writable: true
            });
        }
    }

    // ES5 15.9.5.43
    // http://es5.github.com/#x15.9.5.43
    // This function returns a String value represent the instance in time
    // represented by this Date object. The format of the String is the Date Time
    // string format defined in 15.9.1.15. All fields are present in the String.
    // The time zone is always UTC, denoted by the suffix Z. If the time value of
    // this object is not a finite Number a RangeError exception is thrown.
    var negativeDate = -62198755200000;
    var negativeYearString = '-000001';
    var hasNegativeDateBug = Date.prototype.toISOString && new Date(negativeDate).toISOString().indexOf(negativeYearString) === -1;
    var hasSafari51DateBug = Date.prototype.toISOString && new Date(-1).toISOString() !== '1969-12-31T23:59:59.999Z';

    var getTime = call.bind(Date.prototype.getTime);

    defineProperties(Date.prototype, {
        toISOString: function toISOString() {
            if (!isFinite(this) || !isFinite(getTime(this))) {
                // Adope Photoshop requires the second check.
                throw new RangeError('Date.prototype.toISOString called on non-finite value.');
            }

            var year = originalGetUTCFullYear(this);

            var month = originalGetUTCMonth(this);
            // see https://github.com/es-shims/es5-shim/issues/111
            year += Math.floor(month / 12);
            month = (month % 12 + 12) % 12;

            // the date time string format is specified in 15.9.1.15.
            var result = [month + 1, originalGetUTCDate(this), originalGetUTCHours(this), originalGetUTCMinutes(this), originalGetUTCSeconds(this)];
            year = (
                (year < 0 ? '-' : (year > 9999 ? '+' : '')) +
                strSlice('00000' + Math.abs(year), (0 <= year && year <= 9999) ? -4 : -6)
            );

            for (var i = 0; i < result.length; ++i) {
                // pad months, days, hours, minutes, and seconds to have two digits.
                result[i] = strSlice('00' + result[i], -2);
            }
            // pad milliseconds to have three digits.
            return (
                year + '-' + arraySlice(result, 0, 2).join('-') +
                'T' + arraySlice(result, 2).join(':') + '.' +
                strSlice('000' + originalGetUTCMilliseconds(this), -3) + 'Z'
            );
        }
    }, hasNegativeDateBug || hasSafari51DateBug);

    // ES5 15.9.5.44
    // http://es5.github.com/#x15.9.5.44
    // This function provides a String representation of a Date object for use by
    // JSON.stringify (15.12.3).
    var dateToJSONIsSupported = (function () {
        try {
            return Date.prototype.toJSON &&
                new Date(NaN).toJSON() === null &&
                new Date(negativeDate).toJSON().indexOf(negativeYearString) !== -1 &&
                Date.prototype.toJSON.call({ // generic
                    toISOString: function () { return true; }
                });
        } catch (e) {
            return false;
        }
    }());
    if (!dateToJSONIsSupported) {
        Date.prototype.toJSON = function toJSON(key) {
            // When the toJSON method is called with argument key, the following
            // steps are taken:

            // 1.  Let O be the result of calling ToObject, giving it the this
            // value as its argument.
            // 2. Let tv be ES.ToPrimitive(O, hint Number).
            var O = $Object(this);
            var tv = ES.ToPrimitive(O);
            // 3. If tv is a Number and is not finite, return null.
            if (typeof tv === 'number' && !isFinite(tv)) {
                return null;
            }
            // 4. Let toISO be the result of calling the [[Get]] internal method of
            // O with argument "toISOString".
            var toISO = O.toISOString;
            // 5. If IsCallable(toISO) is false, throw a TypeError exception.
            if (!isCallable(toISO)) {
                throw new TypeError('toISOString property is not callable');
            }
            // 6. Return the result of calling the [[Call]] internal method of
            //  toISO with O as the this value and an empty argument list.
            return toISO.call(O);

            // NOTE 1 The argument is ignored.

            // NOTE 2 The toJSON function is intentionally generic; it does not
            // require that its this value be a Date object. Therefore, it can be
            // transferred to other kinds of objects for use as a method. However,
            // it does require that any such object have a toISOString method. An
            // object is free to use the argument key to filter its
            // stringification.
        };
    }

    // ES5 15.9.4.2
    // http://es5.github.com/#x15.9.4.2
    // based on work shared by Daniel Friesen (dantman)
    // http://gist.github.com/303249
    var supportsExtendedYears = Date.parse('+033658-09-27T01:46:40.000Z') === 1e15;
    var acceptsInvalidDates = !isNaN(Date.parse('2012-04-04T24:00:00.500Z')) || !isNaN(Date.parse('2012-11-31T23:59:59.000Z')) || !isNaN(Date.parse('2012-12-31T23:59:60.000Z'));
    var doesNotParseY2KNewYear = isNaN(Date.parse('2000-01-01T00:00:00.000Z'));
    if (doesNotParseY2KNewYear || acceptsInvalidDates || !supportsExtendedYears) {
        // XXX global assignment won't work in embeddings that use
        // an alternate object for the context.
        /* global Date: true */
        /* eslint-disable no-undef */
        var maxSafeUnsigned32Bit = Math.pow(2, 31) - 1;
        var hasSafariSignedIntBug = isActualNaN(new Date(1970, 0, 1, 0, 0, 0, maxSafeUnsigned32Bit + 1).getTime());
        /* eslint-disable no-implicit-globals */
        Date = (function (NativeDate) {
        /* eslint-enable no-implicit-globals */
        /* eslint-enable no-undef */
            // Date.length === 7
            var DateShim = function Date(Y, M, D, h, m, s, ms) {
                var length = arguments.length;
                var date;
                if (this instanceof NativeDate) {
                    var seconds = s;
                    var millis = ms;
                    if (hasSafariSignedIntBug && length >= 7 && ms > maxSafeUnsigned32Bit) {
                        // work around a Safari 8/9 bug where it treats the seconds as signed
                        var msToShift = Math.floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
                        var sToShift = Math.floor(msToShift / 1e3);
                        seconds += sToShift;
                        millis -= sToShift * 1e3;
                    }
                    date = length === 1 && $String(Y) === Y ? // isString(Y)
                        // We explicitly pass it through parse:
                        new NativeDate(DateShim.parse(Y)) :
                        // We have to manually make calls depending on argument
                        // length here
                        length >= 7 ? new NativeDate(Y, M, D, h, m, seconds, millis) :
                        length >= 6 ? new NativeDate(Y, M, D, h, m, seconds) :
                        length >= 5 ? new NativeDate(Y, M, D, h, m) :
                        length >= 4 ? new NativeDate(Y, M, D, h) :
                        length >= 3 ? new NativeDate(Y, M, D) :
                        length >= 2 ? new NativeDate(Y, M) :
                        length >= 1 ? new NativeDate(Y instanceof NativeDate ? +Y : Y) :
                                      new NativeDate();
                } else {
                    date = NativeDate.apply(this, arguments);
                }
                if (!isPrimitive(date)) {
                    // Prevent mixups with unfixed Date object
                    defineProperties(date, { constructor: DateShim }, true);
                }
                return date;
            };

            // 15.9.1.15 Date Time String Format.
            var isoDateExpression = new RegExp('^' +
                '(\\d{4}|[+-]\\d{6})' + // four-digit year capture or sign +
                                          // 6-digit extended year
                '(?:-(\\d{2})' + // optional month capture
                '(?:-(\\d{2})' + // optional day capture
                '(?:' + // capture hours:minutes:seconds.milliseconds
                    'T(\\d{2})' + // hours capture
                    ':(\\d{2})' + // minutes capture
                    '(?:' + // optional :seconds.milliseconds
                        ':(\\d{2})' + // seconds capture
                        '(?:(\\.\\d{1,}))?' + // milliseconds capture
                    ')?' +
                '(' + // capture UTC offset component
                    'Z|' + // UTC capture
                    '(?:' + // offset specifier +/-hours:minutes
                        '([-+])' + // sign capture
                        '(\\d{2})' + // hours offset capture
                        ':(\\d{2})' + // minutes offset capture
                    ')' +
                ')?)?)?)?' +
            '$');

            var months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];

            var dayFromMonth = function dayFromMonth(year, month) {
                var t = month > 1 ? 1 : 0;
                return (
                    months[month] +
                    Math.floor((year - 1969 + t) / 4) -
                    Math.floor((year - 1901 + t) / 100) +
                    Math.floor((year - 1601 + t) / 400) +
                    365 * (year - 1970)
                );
            };

            var toUTC = function toUTC(t) {
                var s = 0;
                var ms = t;
                if (hasSafariSignedIntBug && ms > maxSafeUnsigned32Bit) {
                    // work around a Safari 8/9 bug where it treats the seconds as signed
                    var msToShift = Math.floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
                    var sToShift = Math.floor(msToShift / 1e3);
                    s += sToShift;
                    ms -= sToShift * 1e3;
                }
                return $Number(new NativeDate(1970, 0, 1, 0, 0, s, ms));
            };

            // Copy any custom methods a 3rd party library may have added
            for (var key in NativeDate) {
                if (owns(NativeDate, key)) {
                    DateShim[key] = NativeDate[key];
                }
            }

            // Copy "native" methods explicitly; they may be non-enumerable
            defineProperties(DateShim, {
                now: NativeDate.now,
                UTC: NativeDate.UTC
            }, true);
            DateShim.prototype = NativeDate.prototype;
            defineProperties(DateShim.prototype, {
                constructor: DateShim
            }, true);

            // Upgrade Date.parse to handle simplified ISO 8601 strings
            var parseShim = function parse(string) {
                var match = isoDateExpression.exec(string);
                if (match) {
                    // parse months, days, hours, minutes, seconds, and milliseconds
                    // provide default values if necessary
                    // parse the UTC offset component
                    var year = $Number(match[1]),
                        month = $Number(match[2] || 1) - 1,
                        day = $Number(match[3] || 1) - 1,
                        hour = $Number(match[4] || 0),
                        minute = $Number(match[5] || 0),
                        second = $Number(match[6] || 0),
                        millisecond = Math.floor($Number(match[7] || 0) * 1000),
                        // When time zone is missed, local offset should be used
                        // (ES 5.1 bug)
                        // see https://bugs.ecmascript.org/show_bug.cgi?id=112
                        isLocalTime = Boolean(match[4] && !match[8]),
                        signOffset = match[9] === '-' ? 1 : -1,
                        hourOffset = $Number(match[10] || 0),
                        minuteOffset = $Number(match[11] || 0),
                        result;
                    var hasMinutesOrSecondsOrMilliseconds = minute > 0 || second > 0 || millisecond > 0;
                    if (
                        hour < (hasMinutesOrSecondsOrMilliseconds ? 24 : 25) &&
                        minute < 60 && second < 60 && millisecond < 1000 &&
                        month > -1 && month < 12 && hourOffset < 24 &&
                        minuteOffset < 60 && // detect invalid offsets
                        day > -1 &&
                        day < (dayFromMonth(year, month + 1) - dayFromMonth(year, month))
                    ) {
                        result = (
                            (dayFromMonth(year, month) + day) * 24 +
                            hour +
                            hourOffset * signOffset
                        ) * 60;
                        result = (
                            (result + minute + minuteOffset * signOffset) * 60 +
                            second
                        ) * 1000 + millisecond;
                        if (isLocalTime) {
                            result = toUTC(result);
                        }
                        if (-8.64e15 <= result && result <= 8.64e15) {
                            return result;
                        }
                    }
                    return NaN;
                }
                return NativeDate.parse.apply(this, arguments);
            };
            defineProperties(DateShim, { parse: parseShim });

            return DateShim;
        }(Date));
        /* global Date: false */
    }

    // ES5 15.9.4.4
    // http://es5.github.com/#x15.9.4.4
    if (!Date.now) {
        Date.now = function now() {
            return new Date().getTime();
        };
    }

    //
    // Number
    // ======
    //

    // ES5.1 15.7.4.5
    // http://es5.github.com/#x15.7.4.5
    var hasToFixedBugs = NumberPrototype.toFixed && (
      (0.00008).toFixed(3) !== '0.000' ||
      (0.9).toFixed(0) !== '1' ||
      (1.255).toFixed(2) !== '1.25' ||
      (1000000000000000128).toFixed(0) !== '1000000000000000128'
    );

    var toFixedHelpers = {
        base: 1e7,
        size: 6,
        data: [0, 0, 0, 0, 0, 0],
        multiply: function multiply(n, c) {
            var i = -1;
            var c2 = c;
            while (++i < toFixedHelpers.size) {
                c2 += n * toFixedHelpers.data[i];
                toFixedHelpers.data[i] = c2 % toFixedHelpers.base;
                c2 = Math.floor(c2 / toFixedHelpers.base);
            }
        },
        divide: function divide(n) {
            var i = toFixedHelpers.size;
            var c = 0;
            while (--i >= 0) {
                c += toFixedHelpers.data[i];
                toFixedHelpers.data[i] = Math.floor(c / n);
                c = (c % n) * toFixedHelpers.base;
            }
        },
        numToString: function numToString() {
            var i = toFixedHelpers.size;
            var s = '';
            while (--i >= 0) {
                if (s !== '' || i === 0 || toFixedHelpers.data[i] !== 0) {
                    var t = $String(toFixedHelpers.data[i]);
                    if (s === '') {
                        s = t;
                    } else {
                        s += strSlice('0000000', 0, 7 - t.length) + t;
                    }
                }
            }
            return s;
        },
        pow: function pow(x, n, acc) {
            return (n === 0 ? acc : (n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc)));
        },
        log: function log(x) {
            var n = 0;
            var x2 = x;
            while (x2 >= 4096) {
                n += 12;
                x2 /= 4096;
            }
            while (x2 >= 2) {
                n += 1;
                x2 /= 2;
            }
            return n;
        }
    };

    var toFixedShim = function toFixed(fractionDigits) {
        var f, x, s, m, e, z, j, k;

        // Test for NaN and round fractionDigits down
        f = $Number(fractionDigits);
        f = isActualNaN(f) ? 0 : Math.floor(f);

        if (f < 0 || f > 20) {
            throw new RangeError('Number.toFixed called with invalid number of decimals');
        }

        x = $Number(this);

        if (isActualNaN(x)) {
            return 'NaN';
        }

        // If it is too big or small, return the string value of the number
        if (x <= -1e21 || x >= 1e21) {
            return $String(x);
        }

        s = '';

        if (x < 0) {
            s = '-';
            x = -x;
        }

        m = '0';

        if (x > 1e-21) {
            // 1e-21 < x < 1e21
            // -70 < log2(x) < 70
            e = toFixedHelpers.log(x * toFixedHelpers.pow(2, 69, 1)) - 69;
            z = (e < 0 ? x * toFixedHelpers.pow(2, -e, 1) : x / toFixedHelpers.pow(2, e, 1));
            z *= 0x10000000000000; // Math.pow(2, 52);
            e = 52 - e;

            // -18 < e < 122
            // x = z / 2 ^ e
            if (e > 0) {
                toFixedHelpers.multiply(0, z);
                j = f;

                while (j >= 7) {
                    toFixedHelpers.multiply(1e7, 0);
                    j -= 7;
                }

                toFixedHelpers.multiply(toFixedHelpers.pow(10, j, 1), 0);
                j = e - 1;

                while (j >= 23) {
                    toFixedHelpers.divide(1 << 23);
                    j -= 23;
                }

                toFixedHelpers.divide(1 << j);
                toFixedHelpers.multiply(1, 1);
                toFixedHelpers.divide(2);
                m = toFixedHelpers.numToString();
            } else {
                toFixedHelpers.multiply(0, z);
                toFixedHelpers.multiply(1 << (-e), 0);
                m = toFixedHelpers.numToString() + strSlice('0.00000000000000000000', 2, 2 + f);
            }
        }

        if (f > 0) {
            k = m.length;

            if (k <= f) {
                m = s + strSlice('0.0000000000000000000', 0, f - k + 2) + m;
            } else {
                m = s + strSlice(m, 0, k - f) + '.' + strSlice(m, k - f);
            }
        } else {
            m = s + m;
        }

        return m;
    };
    defineProperties(NumberPrototype, { toFixed: toFixedShim }, hasToFixedBugs);

    var hasToPrecisionUndefinedBug = (function () {
        try {
            return 1.0.toPrecision(undefined) === '1';
        } catch (e) {
            return true;
        }
    }());
    var originalToPrecision = NumberPrototype.toPrecision;
    defineProperties(NumberPrototype, {
        toPrecision: function toPrecision(precision) {
            return typeof precision === 'undefined' ? originalToPrecision.call(this) : originalToPrecision.call(this, precision);
        }
    }, hasToPrecisionUndefinedBug);

    //
    // String
    // ======
    //

    // ES5 15.5.4.14
    // http://es5.github.com/#x15.5.4.14

    // [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
    // Many browsers do not split properly with regular expressions or they
    // do not perform the split correctly under obscure conditions.
    // See http://blog.stevenlevithan.com/archives/cross-browser-split
    // I've tested in many browsers and this seems to cover the deviant ones:
    //    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
    //    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
    //    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
    //       [undefined, "t", undefined, "e", ...]
    //    ''.split(/.?/) should be [], not [""]
    //    '.'.split(/()()/) should be ["."], not ["", "", "."]

    if (
        'ab'.split(/(?:ab)*/).length !== 2 ||
        '.'.split(/(.?)(.?)/).length !== 4 ||
        'tesst'.split(/(s)*/)[1] === 't' ||
        'test'.split(/(?:)/, -1).length !== 4 ||
        ''.split(/.?/).length ||
        '.'.split(/()()/).length > 1
    ) {
        (function () {
            var compliantExecNpcg = typeof (/()??/).exec('')[1] === 'undefined'; // NPCG: nonparticipating capturing group
            var maxSafe32BitInt = Math.pow(2, 32) - 1;

            StringPrototype.split = function (separator, limit) {
                var string = String(this);
                if (typeof separator === 'undefined' && limit === 0) {
                    return [];
                }

                // If `separator` is not a regex, use native split
                if (!isRegex(separator)) {
                    return strSplit(this, separator, limit);
                }

                var output = [];
                var flags = (separator.ignoreCase ? 'i' : '') +
                            (separator.multiline ? 'm' : '') +
                            (separator.unicode ? 'u' : '') + // in ES6
                            (separator.sticky ? 'y' : ''), // Firefox 3+ and ES6
                    lastLastIndex = 0,
                    // Make `global` and avoid `lastIndex` issues by working with a copy
                    separator2, match, lastIndex, lastLength;
                var separatorCopy = new RegExp(separator.source, flags + 'g');
                if (!compliantExecNpcg) {
                    // Doesn't need flags gy, but they don't hurt
                    separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
                }
                /* Values for `limit`, per the spec:
                 * If undefined: 4294967295 // maxSafe32BitInt
                 * If 0, Infinity, or NaN: 0
                 * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
                 * If negative number: 4294967296 - Math.floor(Math.abs(limit))
                 * If other: Type-convert, then use the above rules
                 */
                var splitLimit = typeof limit === 'undefined' ? maxSafe32BitInt : ES.ToUint32(limit);
                match = separatorCopy.exec(string);
                while (match) {
                    // `separatorCopy.lastIndex` is not reliable cross-browser
                    lastIndex = match.index + match[0].length;
                    if (lastIndex > lastLastIndex) {
                        pushCall(output, strSlice(string, lastLastIndex, match.index));
                        // Fix browsers whose `exec` methods don't consistently return `undefined` for
                        // nonparticipating capturing groups
                        if (!compliantExecNpcg && match.length > 1) {
                            /* eslint-disable no-loop-func */
                            match[0].replace(separator2, function () {
                                for (var i = 1; i < arguments.length - 2; i++) {
                                    if (typeof arguments[i] === 'undefined') {
                                        match[i] = void 0;
                                    }
                                }
                            });
                            /* eslint-enable no-loop-func */
                        }
                        if (match.length > 1 && match.index < string.length) {
                            array_push.apply(output, arraySlice(match, 1));
                        }
                        lastLength = match[0].length;
                        lastLastIndex = lastIndex;
                        if (output.length >= splitLimit) {
                            break;
                        }
                    }
                    if (separatorCopy.lastIndex === match.index) {
                        separatorCopy.lastIndex++; // Avoid an infinite loop
                    }
                    match = separatorCopy.exec(string);
                }
                if (lastLastIndex === string.length) {
                    if (lastLength || !separatorCopy.test('')) {
                        pushCall(output, '');
                    }
                } else {
                    pushCall(output, strSlice(string, lastLastIndex));
                }
                return output.length > splitLimit ? arraySlice(output, 0, splitLimit) : output;
            };
        }());

    // [bugfix, chrome]
    // If separator is undefined, then the result array contains just one String,
    // which is the this value (converted to a String). If limit is not undefined,
    // then the output array is truncated so that it contains no more than limit
    // elements.
    // "0".split(undefined, 0) -> []
    } else if ('0'.split(void 0, 0).length) {
        StringPrototype.split = function split(separator, limit) {
            if (typeof separator === 'undefined' && limit === 0) {
                return [];
            }
            return strSplit(this, separator, limit);
        };
    }

    var str_replace = StringPrototype.replace;
    var replaceReportsGroupsCorrectly = (function () {
        var groups = [];
        'x'.replace(/x(.)?/g, function (match, group) {
            pushCall(groups, group);
        });
        return groups.length === 1 && typeof groups[0] === 'undefined';
    }());

    if (!replaceReportsGroupsCorrectly) {
        StringPrototype.replace = function replace(searchValue, replaceValue) {
            var isFn = isCallable(replaceValue);
            var hasCapturingGroups = isRegex(searchValue) && (/\)[*?]/).test(searchValue.source);
            if (!isFn || !hasCapturingGroups) {
                return str_replace.call(this, searchValue, replaceValue);
            } else {
                var wrappedReplaceValue = function (match) {
                    var length = arguments.length;
                    var originalLastIndex = searchValue.lastIndex;
                    searchValue.lastIndex = 0;
                    var args = searchValue.exec(match) || [];
                    searchValue.lastIndex = originalLastIndex;
                    pushCall(args, arguments[length - 2], arguments[length - 1]);
                    return replaceValue.apply(this, args);
                };
                return str_replace.call(this, searchValue, wrappedReplaceValue);
            }
        };
    }

    // ECMA-262, 3rd B.2.3
    // Not an ECMAScript standard, although ECMAScript 3rd Edition has a
    // non-normative section suggesting uniform semantics and it should be
    // normalized across all browsers
    // [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
    var string_substr = StringPrototype.substr;
    var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
    defineProperties(StringPrototype, {
        substr: function substr(start, length) {
            var normalizedStart = start;
            if (start < 0) {
                normalizedStart = max(this.length + start, 0);
            }
            return string_substr.call(this, normalizedStart, length);
        }
    }, hasNegativeSubstrBug);

    // ES5 15.5.4.20
    // whitespace from: http://es5.github.io/#x15.5.4.20
    var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
        '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' +
        '\u2029\uFEFF';
    var zeroWidth = '\u200b';
    var wsRegexChars = '[' + ws + ']';
    var trimBeginRegexp = new RegExp('^' + wsRegexChars + wsRegexChars + '*');
    var trimEndRegexp = new RegExp(wsRegexChars + wsRegexChars + '*$');
    var hasTrimWhitespaceBug = StringPrototype.trim && (ws.trim() || !zeroWidth.trim());
    defineProperties(StringPrototype, {
        // http://blog.stevenlevithan.com/archives/faster-trim-javascript
        // http://perfectionkills.com/whitespace-deviations/
        trim: function trim() {
            if (typeof this === 'undefined' || this === null) {
                throw new TypeError("can't convert " + this + ' to object');
            }
            return $String(this).replace(trimBeginRegexp, '').replace(trimEndRegexp, '');
        }
    }, hasTrimWhitespaceBug);
    var trim = call.bind(String.prototype.trim);

    var hasLastIndexBug = StringPrototype.lastIndexOf && 'abc'.lastIndexOf('', 2) !== -1;
    defineProperties(StringPrototype, {
        lastIndexOf: function lastIndexOf(searchString) {
            if (typeof this === 'undefined' || this === null) {
                throw new TypeError("can't convert " + this + ' to object');
            }
            var S = $String(this);
            var searchStr = $String(searchString);
            var numPos = arguments.length > 1 ? $Number(arguments[1]) : NaN;
            var pos = isActualNaN(numPos) ? Infinity : ES.ToInteger(numPos);
            var start = min(max(pos, 0), S.length);
            var searchLen = searchStr.length;
            var k = start + searchLen;
            while (k > 0) {
                k = max(0, k - searchLen);
                var index = strIndexOf(strSlice(S, k, start + searchLen), searchStr);
                if (index !== -1) {
                    return k + index;
                }
            }
            return -1;
        }
    }, hasLastIndexBug);

    var originalLastIndexOf = StringPrototype.lastIndexOf;
    defineProperties(StringPrototype, {
        lastIndexOf: function lastIndexOf(searchString) {
            return originalLastIndexOf.apply(this, arguments);
        }
    }, StringPrototype.lastIndexOf.length !== 1);

    // ES-5 15.1.2.2
    /* eslint-disable radix */
    if (parseInt(ws + '08') !== 8 || parseInt(ws + '0x16') !== 22) {
    /* eslint-enable radix */
        /* global parseInt: true */
        parseInt = (function (origParseInt) {
            var hexRegex = /^[\-+]?0[xX]/;
            return function parseInt(str, radix) {
                var string = trim(String(str));
                var defaultedRadix = $Number(radix) || (hexRegex.test(string) ? 16 : 10);
                return origParseInt(string, defaultedRadix);
            };
        }(parseInt));
    }

    // https://es5.github.io/#x15.1.2.3
    if (1 / parseFloat('-0') !== -Infinity) {
        /* global parseFloat: true */
        parseFloat = (function (origParseFloat) {
            return function parseFloat(string) {
                var inputString = trim(String(string));
                var result = origParseFloat(inputString);
                return result === 0 && strSlice(inputString, 0, 1) === '-' ? -0 : result;
            };
        }(parseFloat));
    }

    if (String(new RangeError('test')) !== 'RangeError: test') {
        var errorToStringShim = function toString() {
            if (typeof this === 'undefined' || this === null) {
                throw new TypeError("can't convert " + this + ' to object');
            }
            var name = this.name;
            if (typeof name === 'undefined') {
                name = 'Error';
            } else if (typeof name !== 'string') {
                name = $String(name);
            }
            var msg = this.message;
            if (typeof msg === 'undefined') {
                msg = '';
            } else if (typeof msg !== 'string') {
                msg = $String(msg);
            }
            if (!name) {
                return msg;
            }
            if (!msg) {
                return name;
            }
            return name + ': ' + msg;
        };
        // can't use defineProperties here because of toString enumeration issue in IE <= 8
        Error.prototype.toString = errorToStringShim;
    }

    if (supportsDescriptors) {
        var ensureNonEnumerable = function (obj, prop) {
            if (isEnum(obj, prop)) {
                var desc = Object.getOwnPropertyDescriptor(obj, prop);
                if (desc.configurable) {
                    desc.enumerable = false;
                    Object.defineProperty(obj, prop, desc);
                }
            }
        };
        ensureNonEnumerable(Error.prototype, 'message');
        if (Error.prototype.message !== '') {
            Error.prototype.message = '';
        }
        ensureNonEnumerable(Error.prototype, 'name');
    }

    if (String(/a/mig) !== '/a/gim') {
        var regexToString = function toString() {
            var str = '/' + this.source + '/';
            if (this.global) {
                str += 'g';
            }
            if (this.ignoreCase) {
                str += 'i';
            }
            if (this.multiline) {
                str += 'm';
            }
            return str;
        };
        // can't use defineProperties here because of toString enumeration issue in IE <= 8
        RegExp.prototype.toString = regexToString;
    }
}));

},{}],11:[function(require,module,exports){
(function (process,global){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   3.3.1
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.ES6Promise = factory());
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  return typeof x === 'function' || typeof x === 'object' && x !== null;
}

function isFunction(x) {
  return typeof x === 'function';
}

var _isArray = undefined;
if (!Array.isArray) {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
} else {
  _isArray = Array.isArray;
}

var isArray = _isArray;

var len = 0;
var vertxNext = undefined;
var customSchedulerFn = undefined;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  return function () {
    vertxNext(flush);
  };
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var r = require;
    var vertx = r('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = undefined;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && typeof require === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var _arguments = arguments;

  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;

  if (_state) {
    (function () {
      var callback = _arguments[_state - 1];
      asap(function () {
        return invokeCallback(_state, child, callback, parent._result);
      });
    })();
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  _resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(16);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

var GET_THEN_ERROR = new ErrorObject();

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function getThen(promise) {
  try {
    return promise.then;
  } catch (error) {
    GET_THEN_ERROR.error = error;
    return GET_THEN_ERROR;
  }
}

function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
  try {
    then.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        _resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      _reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      _reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    _reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return _resolve(promise, value);
    }, function (reason) {
      return _reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$) {
  if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$ === GET_THEN_ERROR) {
      _reject(promise, GET_THEN_ERROR.error);
    } else if (then$$ === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$)) {
      handleForeignThenable(promise, maybeThenable, then$$);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function _resolve(promise, value) {
  if (promise === value) {
    _reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    handleMaybeThenable(promise, value, getThen(value));
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function _reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;

  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = undefined,
      callback = undefined,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function ErrorObject() {
  this.error = null;
}

var TRY_CATCH_ERROR = new ErrorObject();

function tryCatch(callback, detail) {
  try {
    return callback(detail);
  } catch (e) {
    TRY_CATCH_ERROR.error = e;
    return TRY_CATCH_ERROR;
  }
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = undefined,
      error = undefined,
      succeeded = undefined,
      failed = undefined;

  if (hasCallback) {
    value = tryCatch(callback, detail);

    if (value === TRY_CATCH_ERROR) {
      failed = true;
      error = value.error;
      value = null;
    } else {
      succeeded = true;
    }

    if (promise === value) {
      _reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
    succeeded = true;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
      _resolve(promise, value);
    } else if (failed) {
      _reject(promise, error);
    } else if (settled === FULFILLED) {
      fulfill(promise, value);
    } else if (settled === REJECTED) {
      _reject(promise, value);
    }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      _resolve(promise, value);
    }, function rejectPromise(reason) {
      _reject(promise, reason);
    });
  } catch (e) {
    _reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function Enumerator(Constructor, input) {
  this._instanceConstructor = Constructor;
  this.promise = new Constructor(noop);

  if (!this.promise[PROMISE_ID]) {
    makePromise(this.promise);
  }

  if (isArray(input)) {
    this._input = input;
    this.length = input.length;
    this._remaining = input.length;

    this._result = new Array(this.length);

    if (this.length === 0) {
      fulfill(this.promise, this._result);
    } else {
      this.length = this.length || 0;
      this._enumerate();
      if (this._remaining === 0) {
        fulfill(this.promise, this._result);
      }
    }
  } else {
    _reject(this.promise, validationError());
  }
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
};

Enumerator.prototype._enumerate = function () {
  var length = this.length;
  var _input = this._input;

  for (var i = 0; this._state === PENDING && i < length; i++) {
    this._eachEntry(_input[i], i);
  }
};

Enumerator.prototype._eachEntry = function (entry, i) {
  var c = this._instanceConstructor;
  var resolve$$ = c.resolve;

  if (resolve$$ === resolve) {
    var _then = getThen(entry);

    if (_then === then && entry._state !== PENDING) {
      this._settledAt(entry._state, i, entry._result);
    } else if (typeof _then !== 'function') {
      this._remaining--;
      this._result[i] = entry;
    } else if (c === Promise) {
      var promise = new c(noop);
      handleMaybeThenable(promise, entry, _then);
      this._willSettleAt(promise, i);
    } else {
      this._willSettleAt(new c(function (resolve$$) {
        return resolve$$(entry);
      }), i);
    }
  } else {
    this._willSettleAt(resolve$$(entry), i);
  }
};

Enumerator.prototype._settledAt = function (state, i, value) {
  var promise = this.promise;

  if (promise._state === PENDING) {
    this._remaining--;

    if (state === REJECTED) {
      _reject(promise, value);
    } else {
      this._result[i] = value;
    }
  }

  if (this._remaining === 0) {
    fulfill(promise, this._result);
  }
};

Enumerator.prototype._willSettleAt = function (promise, i) {
  var enumerator = this;

  subscribe(promise, undefined, function (value) {
    return enumerator._settledAt(FULFILLED, i, value);
  }, function (reason) {
    return enumerator._settledAt(REJECTED, i, reason);
  });
};

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  _reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {function} resolver
  Useful for tooling.
  @constructor
*/
function Promise(resolver) {
  this[PROMISE_ID] = nextId();
  this._result = this._state = undefined;
  this._subscribers = [];

  if (noop !== resolver) {
    typeof resolver !== 'function' && needsResolver();
    this instanceof Promise ? initializePromise(this, resolver) : needsNew();
  }
}

Promise.all = all;
Promise.race = race;
Promise.resolve = resolve;
Promise.reject = reject;
Promise._setScheduler = setScheduler;
Promise._setAsap = setAsap;
Promise._asap = asap;

Promise.prototype = {
  constructor: Promise,

  /**
    The primary way of interacting with a promise is through its `then` method,
    which registers callbacks to receive either a promise's eventual value or the
    reason why the promise cannot be fulfilled.
  
    ```js
    findUser().then(function(user){
      // user is available
    }, function(reason){
      // user is unavailable, and you are given the reason why
    });
    ```
  
    Chaining
    --------
  
    The return value of `then` is itself a promise.  This second, 'downstream'
    promise is resolved with the return value of the first promise's fulfillment
    or rejection handler, or rejected if the handler throws an exception.
  
    ```js
    findUser().then(function (user) {
      return user.name;
    }, function (reason) {
      return 'default name';
    }).then(function (userName) {
      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
      // will be `'default name'`
    });
  
    findUser().then(function (user) {
      throw new Error('Found user, but still unhappy');
    }, function (reason) {
      throw new Error('`findUser` rejected and we're unhappy');
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
    });
    ```
    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
  
    ```js
    findUser().then(function (user) {
      throw new PedagogicalException('Upstream error');
    }).then(function (value) {
      // never reached
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // The `PedgagocialException` is propagated all the way down to here
    });
    ```
  
    Assimilation
    ------------
  
    Sometimes the value you want to propagate to a downstream promise can only be
    retrieved asynchronously. This can be achieved by returning a promise in the
    fulfillment or rejection handler. The downstream promise will then be pending
    until the returned promise is settled. This is called *assimilation*.
  
    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // The user's comments are now available
    });
    ```
  
    If the assimliated promise rejects, then the downstream promise will also reject.
  
    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // If `findCommentsByAuthor` fulfills, we'll have the value here
    }, function (reason) {
      // If `findCommentsByAuthor` rejects, we'll have the reason here
    });
    ```
  
    Simple Example
    --------------
  
    Synchronous Example
  
    ```javascript
    let result;
  
    try {
      result = findResult();
      // success
    } catch(reason) {
      // failure
    }
    ```
  
    Errback Example
  
    ```js
    findResult(function(result, err){
      if (err) {
        // failure
      } else {
        // success
      }
    });
    ```
  
    Promise Example;
  
    ```javascript
    findResult().then(function(result){
      // success
    }, function(reason){
      // failure
    });
    ```
  
    Advanced Example
    --------------
  
    Synchronous Example
  
    ```javascript
    let author, books;
  
    try {
      author = findAuthor();
      books  = findBooksByAuthor(author);
      // success
    } catch(reason) {
      // failure
    }
    ```
  
    Errback Example
  
    ```js
  
    function foundBooks(books) {
  
    }
  
    function failure(reason) {
  
    }
  
    findAuthor(function(author, err){
      if (err) {
        failure(err);
        // failure
      } else {
        try {
          findBoooksByAuthor(author, function(books, err) {
            if (err) {
              failure(err);
            } else {
              try {
                foundBooks(books);
              } catch(reason) {
                failure(reason);
              }
            }
          });
        } catch(error) {
          failure(err);
        }
        // success
      }
    });
    ```
  
    Promise Example;
  
    ```javascript
    findAuthor().
      then(findBooksByAuthor).
      then(function(books){
        // found books
    })['catch'](function(reason){
      // something went wrong
    });
    ```
  
    @method then
    @param {Function} onFulfilled
    @param {Function} onRejected
    Useful for tooling.
    @return {Promise}
  */
  then: then,

  /**
    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
    as the catch block of a try/catch statement.
  
    ```js
    function findAuthor(){
      throw new Error('couldn't find that author');
    }
  
    // synchronous
    try {
      findAuthor();
    } catch(reason) {
      // something went wrong
    }
  
    // async with promises
    findAuthor()['catch'](function(reason){
      // something went wrong
    });
    ```
  
    @method catch
    @param {Function} onRejection
    Useful for tooling.
    @return {Promise}
  */
  'catch': function _catch(onRejection) {
    return this.then(null, onRejection);
  }
};

function polyfill() {
    var local = undefined;

    if (typeof global !== 'undefined') {
        local = global;
    } else if (typeof self !== 'undefined') {
        local = self;
    } else {
        try {
            local = Function('return this')();
        } catch (e) {
            throw new Error('polyfill failed because global object is unavailable in this environment');
        }
    }

    var P = local.Promise;

    if (P) {
        var promiseToString = null;
        try {
            promiseToString = Object.prototype.toString.call(P.resolve());
        } catch (e) {
            // silently ignored
        }

        if (promiseToString === '[object Promise]' && !P.cast) {
            return;
        }
    }

    local.Promise = Promise;
}

polyfill();
// Strange compat..
Promise.polyfill = polyfill;
Promise.Promise = Promise;

return Promise;

})));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":13}],12:[function(require,module,exports){
'use strict';
/* eslint-disable no-unused-vars */
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (e) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],13:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],14:[function(require,module,exports){
"use strict";
var promiseExtensions_1 = require("./../helpers/promiseExtensions");
var activityManagementAPI_1 = require("./activityManagementAPI");
var activityAGM_1 = require("../core/activityAGM");
var ActivityAPI = (function () {
    function ActivityAPI(manager, my) {
        this.version = "2.4.1";
        this.__mgr = manager;
        this._my = my;
        this.all = new activityManagementAPI_1.ActivityManagementAPI(manager, my);
    }
    ActivityAPI.prototype.ready = function (callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            _this.__mgr.ready()
                .then(function () {
                resolve(_this);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    Object.defineProperty(ActivityAPI.prototype, "my", {
        get: function () {
            return this._my;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityAPI.prototype, "aware", {
        get: function () {
            return this._my.window !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityAPI.prototype, "inActivity", {
        get: function () {
            return this.aware && this._my.activity !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityAPI.prototype, "agm", {
        get: function () {
            if (!this.aware) {
                return undefined;
            }
            if (!this.inActivity) {
                return new activityAGM_1.ActivityAGM(null);
            }
            return this._my.activity.agm;
        },
        enumerable: true,
        configurable: true
    });
    return ActivityAPI;
}());
exports.ActivityAPI = ActivityAPI;

},{"../core/activityAGM":22,"./../helpers/promiseExtensions":33,"./activityManagementAPI":15}],15:[function(require,module,exports){
"use strict";
var util = require("./../helpers/util");
var ActivityManagementAPI = (function () {
    function ActivityManagementAPI(manager, my) {
        this._m = manager;
        this._my = my;
        this.activityTypes = {
            get: this._getActivityTypesWrapper.bind(this),
            register: this._m.registerActivityType.bind(this._m),
            unregister: this._m.unregisterActivityType.bind(this._m),
            subscribe: this._m.subscribeActivityTypeEvents.bind(this._m),
            unsubscribe: undefined,
            initiate: this._m.initiate.bind(this._m)
        };
        this.windowTypes = {
            get: this._getWindowTypesWrapper.bind(this),
            registerFactory: this._m.registerWindowFactory.bind(this._m),
            unregisterFactory: this._m.unregisterWindowFactory.bind(this._m),
            subscribe: this._m.subscribeWindowTypeEvents.bind(this._m),
            unsubscribe: undefined
        };
        this.windows = {
            get: this._m.getWindows.bind(this._m),
            subscribe: this._m.subscribeWindowEvents.bind(this._m),
            announce: this._m.announceWindow.bind(this._m),
            unsubscribe: undefined,
            create: this._m.createWindow.bind(this._m)
        };
        this.instances = {
            get: this._m.getActivities.bind(this._m),
            subscribe: this._m.subscribeActivityEvents.bind(this._m),
            unsubscribe: undefined
        };
    }
    ActivityManagementAPI.prototype._getActivityTypesWrapper = function (name) {
        if (util.isUndefined(name)) {
            return this._m.getActivityTypes();
        }
        return this._m.getActivityType(name);
    };
    ActivityManagementAPI.prototype._getWindowTypesWrapper = function (name) {
        if (util.isUndefined(name)) {
            return this._m.getWindowTypes();
        }
        return this._m.getWindowType(name);
    };
    return ActivityManagementAPI;
}());
exports.ActivityManagementAPI = ActivityManagementAPI;

},{"./../helpers/util":35}],16:[function(require,module,exports){
"use strict";
var logger_1 = require("./../helpers/logger");
var util = require("./../helpers/util");
var ActivityMy = (function () {
    function ActivityMy(manager) {
        var _this = this;
        this._myActivityJoinedCallbacks = [];
        this._myActivityRemovedCallbacks = [];
        this._myContextUpdateCallbacks = [];
        this._logger = logger_1.Logger.Get(this);
        this._m = manager;
        manager.ready()
            .then(function (am) {
            am.subscribeActivityContextChanged(_this._subscribeMyContextChanged.bind(_this));
            am.subscribeWindowEvents(_this._subscribeMyWindowEvent.bind(_this));
        });
    }
    Object.defineProperty(ActivityMy.prototype, "window", {
        get: function () {
            if (util.isUndefinedOrNull(this._w)) {
                var announcedWindows = this._m.announcedWindows;
                if (announcedWindows.length > 0) {
                    this._w = announcedWindows[0];
                }
            }
            return this._w;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityMy.prototype, "activity", {
        get: function () {
            var myWin = this.window;
            if (util.isUndefinedOrNull(myWin)) {
                return undefined;
            }
            return myWin.activity;
        },
        enumerable: true,
        configurable: true
    });
    ActivityMy.prototype.createWindow = function (windowType) {
        return this._m.createWindow(this.activity, windowType);
    };
    ActivityMy.prototype.createStackedWindows = function (windowTypes, timeout) {
        return this._m.createStackedWindows(this.activity, windowTypes, timeout);
    };
    Object.defineProperty(ActivityMy.prototype, "context", {
        get: function () {
            var activity = this.activity;
            if (util.isUndefined(activity)) {
                return {};
            }
            return activity.context;
        },
        enumerable: true,
        configurable: true
    });
    ActivityMy.prototype.onActivityJoined = function (callback) {
        this._myActivityJoinedCallbacks.push(callback);
        var myWin = this.window;
        if (!util.isUndefinedOrNull(myWin) && !util.isUndefinedOrNull(myWin.activity)) {
            callback(myWin.activity);
        }
    };
    ActivityMy.prototype.onActivityLeft = function (callback) {
        this._myActivityRemovedCallbacks.push(callback);
    };
    ActivityMy.prototype.onContextChanged = function (callback) {
        this._myContextUpdateCallbacks.push(callback);
        var myWin = this.window;
        if (util.isUndefinedOrNull(myWin)) {
            return;
        }
        var activity = myWin.activity;
        if (util.isUndefinedOrNull(activity)) {
            return;
        }
        callback(activity.context, activity.context, [], activity);
    };
    ActivityMy.prototype._subscribeMyContextChanged = function (activity, context, delta, removed) {
        var myWin = this.window;
        if (util.isUndefinedOrNull(myWin)) {
            return;
        }
        var myActivity = myWin.activity;
        if (util.isUndefinedOrNull(myActivity)) {
            return;
        }
        if (activity.id !== myActivity.id) {
            return;
        }
        this._notifyMyContextChanged(activity, context, delta, removed);
    };
    ActivityMy.prototype._subscribeMyWindowEvent = function (activity, window, event) {
        if (util.isUndefinedOrNull(this.window)) {
            return;
        }
        if (this.window.id !== window.id) {
            return;
        }
        if (event === "joined") {
            this._notifyOnJoined(activity);
        }
        else {
            this._notifyMyWindowEvent(activity, this._myActivityRemovedCallbacks);
        }
    };
    ActivityMy.prototype._notifyMyWindowEvent = function (activity, callbackStore) {
        for (var index = 0; index < callbackStore.length; index++) {
            var element = callbackStore[index];
            try {
                element(activity, event);
            }
            catch (e) {
                this._logger.warn('error in user callback ' + e);
            }
        }
    };
    ActivityMy.prototype._notifyMyContextChanged = function (activity, context, delta, removed) {
        delta = delta || {};
        removed = removed || [];
        for (var index = 0; index < this._myContextUpdateCallbacks.length; index++) {
            var element = this._myContextUpdateCallbacks[index];
            try {
                element(context, delta, removed, activity);
            }
            catch (e) {
                this._logger.warn('error in user callback ' + e);
            }
        }
    };
    ActivityMy.prototype._notifyOnJoined = function (activity) {
        this._notifyMyWindowEvent(activity, this._myActivityJoinedCallbacks);
        this._notifyMyContextChanged(activity, activity.context);
    };
    return ActivityMy;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= ActivityMy;

},{"./../helpers/logger":32,"./../helpers/util":35}],17:[function(require,module,exports){
"use strict";
var ActivityConfig = (function () {
    function ActivityConfig() {
    }
    return ActivityConfig;
}());
exports.ActivityConfig = ActivityConfig;

},{}],18:[function(require,module,exports){
"use strict";
require("es6-promise");
var hcBridge_1 = require("./bridges/hcBridge");
var activityManager_1 = require("./core/activityManager");
var activityMyAPI_1 = require("./API/activityMyAPI");
var logger_1 = require("./helpers/logger");
var util = require("./helpers/util");
var activityConfig_1 = require("./activityConfig");
var activityAPI_1 = require("./API/activityAPI");
var activityAGM_1 = require("./core/activityAGM");
var activity = function (config) {
    config = config || new activityConfig_1.ActivityConfig;
    if (!util.isUndefined(config.logLevel)) {
        logger_1.Logger.Level = config.logLevel;
    }
    if (!util.isUndefinedOrNull(config.logger)) {
        logger_1.Logger.GlueLogger = config.logger;
    }
    var bridge;
    if (!util.isUndefined(window.htmlContainer)) {
        bridge = new hcBridge_1['default']();
    }
    else {
        throw new Error("Activity not supported in in browser");
    }
    if (!bridge) {
        throw new Error("A bridge to native activity is needed to create activity lib.");
    }
    activityAGM_1.ActivityAGM.AGM = config.agm;
    var activityManager = new activityManager_1['default'](bridge, !config.disableAutoAnnounce);
    var my = new activityMyAPI_1['default'](activityManager);
    return new activityAPI_1.ActivityAPI(activityManager, my);
};
module.exports = activity;

},{"./API/activityAPI":14,"./API/activityMyAPI":16,"./activityConfig":17,"./bridges/hcBridge":19,"./core/activityAGM":22,"./core/activityManager":23,"./helpers/logger":32,"./helpers/util":35,"es6-promise":11}],19:[function(require,module,exports){
"use strict";
var entityEvent_1 = require("../contracts/entityEvent");
var activityStatus_1 = require("../contracts/activityStatus");
var activityType_1 = require("../entities/activityType");
var windowType_1 = require("../entities/windowType");
var activity_1 = require("../entities/activity");
var activityWindow_1 = require("../entities/activityWindow");
var proxyWindowFactory_1 = require("../core/proxyWindowFactory");
var logger_1 = require("../helpers/logger");
var entityEvent_2 = require("../contracts/entityEvent");
var readyMarker_1 = require("../helpers/readyMarker");
var util = require("../helpers/util");
var entityEvent_3 = require("../contracts/entityEvent");
var HCBridge = (function () {
    function HCBridge(agm) {
        this._activityTypeEntityName = "activityType";
        this._windowTypeEntityName = "windowType";
        this._activityEntityName = "activity";
        this._windowEntityName = "activityWindow";
        this._logger = logger_1.Logger.Get(this);
        this._lastSeq = 0;
        this._eventQueue = [];
        this._activityTypeCallbacks = [];
        this._windowTypeCallbacks = [];
        this._activityCallbacks = [];
        this._windowCallbacks = [];
        this._agm = agm;
    }
    HCBridge.prototype.init = function () {
        var _this = this;
        this._readyMarker = new readyMarker_1.ReadyMarker("HC Bridge", 1);
        this._htmlContainer = window.htmlContainer.activityFacade;
        this._htmlContainer.init(this._agm ? this._agm.instance : undefined, this._hcEventHandler.bind(this), function () {
            _this._readyMarker.signal("Init done from HC");
        }, function (error) {
            _this._readyMarker.error(error);
        });
    };
    HCBridge.prototype.ready = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._readyMarker.setCallback(function (err) {
                if (!err) {
                    resolve(_this);
                }
                else {
                    _this._logger.error("Error initializing HC bridge - " + err);
                    reject(_this._readyMarker.getError());
                }
            });
        });
    };
    HCBridge.prototype._hcEventHandler = function (eventJson) {
        this._logger.trace(eventJson);
        var event = JSON.parse(eventJson);
        this._processEventBySeq(event);
    };
    HCBridge.prototype._processEventBySeq = function (event) {
        var seq = event.sequence;
        if (seq === this._lastSeq + 1) {
            this._processEvent(event);
            this._lastSeq++;
            var nextEvent = this._eventQueue[seq + 1];
            if (!util.isUndefined(nextEvent)) {
                this._logger.debug("replaying message number " + seq);
                this._processEventBySeq(nextEvent);
                delete this._eventQueue[seq + 1];
            }
        }
        else {
            this._eventQueue[seq] = event;
            this._logger.debug("Got out of order event with number " + seq + ". Will wait for previous event(s) before replaying.");
        }
    };
    HCBridge.prototype._processEvent = function (event) {
        var entityType = event.entityType;
        var eventContext = this._convertContext(event.context);
        var entity;
        switch (entityType) {
            case this._activityTypeEntityName:
                entity = HCBridge._hcToJsActivityType(event.entity);
                this._publishActivityTypeStatusChange(entity, eventContext);
                break;
            case this._windowTypeEntityName:
                entity = this._hcToJsWindowType(event.entity);
                this._publishWindowTypeStatusChange(entity, eventContext);
                break;
            case this._activityEntityName:
                entity = this._hcToJsActivity(event.entity);
                this._publishActivityStatusChange(entity, eventContext);
                break;
            case this._windowEntityName:
                entity = HCBridge._hcToJsWindow(event.entity);
                this._publishActivityWindowEvent(entity, eventContext);
                break;
        }
    };
    HCBridge.prototype._convertContext = function (hcContext) {
        if (hcContext.type === entityEvent_1.EntityEventType.StatusChange) {
            var oldStatus = new activityStatus_1.ActivityStatus(hcContext.oldStatus.state, hcContext.oldStatus.statusMessage, hcContext.oldStatus.statusTime);
            var newStatus = new activityStatus_1.ActivityStatus(hcContext.newStatus.state, hcContext.newStatus.statusMessage, hcContext.newStatus.statusTime);
            return new entityEvent_1.EntityStatusChangeEventContext(newStatus, oldStatus);
        }
        else if (hcContext.type === entityEvent_1.EntityEventType.ActivityWindowEvent) {
            var act = this._hcToJsActivity(hcContext.activity);
            return new entityEvent_1.EntityActivityWindowEventContext(act, hcContext.event);
        }
        else if (hcContext.type === entityEvent_1.EntityEventType.ActivityContextChange) {
            return new entityEvent_3.ActivityContextChangedContext(hcContext.newContext, hcContext.updated, hcContext.removed);
        }
        return new entityEvent_1.EntityEventContext(hcContext.type);
    };
    HCBridge._hcToJsWindow = function (hcWindow) {
        return new activityWindow_1['default'](hcWindow.id, hcWindow.name, hcWindow.type, hcWindow.activityId, hcWindow.instance, hcWindow.isIndependent);
    };
    HCBridge.prototype._hcToJsActivity = function (hcAct) {
        var window = hcAct.owner ? HCBridge._hcToJsWindow(hcAct.owner) : null;
        var windowId = window ? window.id : null;
        var status = new activityStatus_1.ActivityStatus(hcAct.status.state, hcAct.status.statusMessage, hcAct.status.statusTime);
        var context = JSON.parse(hcAct.context);
        return new activity_1['default'](hcAct.id, hcAct.type.name, status, context, windowId);
    };
    HCBridge._hcToJsActivityType = function (hcActType) {
        return new activityType_1['default'](hcActType.name, hcActType.ownerWindowType, hcActType.helperWindowTypes, hcActType.description);
    };
    HCBridge.prototype._hcToJsWindowType = function (hcWinType) {
        if (util.isUndefined(hcWinType.factories)) {
            hcWinType.factories = [];
        }
        var factories = hcWinType.factories.map(function (f) {
            return HCBridge._hcToJsWindowTypeFactory(f);
        });
        return new windowType_1['default'](hcWinType.name, factories);
    };
    HCBridge._hcToJsWindowTypeFactory = function (hcWinTypeFactory) {
        return new proxyWindowFactory_1.ProxyWindowFactory(hcWinTypeFactory.description);
    };
    HCBridge._getURLParameter = function (name) {
        return decodeURIComponent((new RegExp('[?|&]' + name + '=' + '([^&;]+?)(&|#|;|$)').exec(location.search) || [, ""])[1].replace(/\+/g, '%20')) || null;
    };
    HCBridge.prototype.getActivityTypes = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.getActivityTypes(function (infos) {
                var result = [];
                for (var index = 0; index < infos.length; index++) {
                    var info = infos[index];
                    var newActivityType = HCBridge._hcToJsActivityType(info);
                    result.push(newActivityType);
                }
                resolve(result);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.registerActivityType = function (activityTypeName, ownerWindow, helperWindows, layoutConfig, description) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (helperWindows === undefined) {
                helperWindows = [];
            }
            var config = {
                name: activityTypeName,
                ownerWindowType: ownerWindow,
                helperWindowTypes: helperWindows,
                description: description,
                layoutConfig: JSON.stringify(layoutConfig)
            };
            _this._htmlContainer.registerActivityType(JSON.stringify(config), function (info) {
                var newActivityType = HCBridge._hcToJsActivityType(info);
                resolve(newActivityType);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.unregisterActivityType = function (activityTypeName) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.unregisterActivityType(activityTypeName, function (info) {
                resolve(true);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.getWindowTypes = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.getWindowTypes(function (infos) {
                var result = [];
                for (var index = 0; index < infos.length; index++) {
                    var info = infos[index];
                    var newWindowType = _this._hcToJsWindowType(info);
                    result.push(newWindowType);
                }
                resolve(result);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.registerWindowFactory = function (windowTypeName, factory) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(windowTypeName)) {
                reject("windowTypeName should be provided");
                return;
            }
            _this._htmlContainer.registerWindowFactory(windowTypeName, factory.create.bind(factory), function (info) {
                resolve(true);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.initiateActivity = function (activityType, context, callback) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(activityType)) {
                reject("windowTypeName should be provided");
                return;
            }
            if (util.isUndefinedOrNull(context)) {
                context = {};
            }
            _this._htmlContainer.initiate(activityType, JSON.stringify(context), function (activityId) {
                resolve(activityId);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.getAnnouncementInfo = function () {
        var hc = window.htmlContainer;
        var context = hc.getContext();
        var result = { activityWindowId: "", activityWindowType: "", activityWindowIndependent: false, activityWindowName: "" };
        result.activityWindowType = context.activityWindowType;
        if (util.isUndefined(result.activityWindowType)) {
            result.activityWindowType = HCBridge._getURLParameter("activityWindowType");
        }
        result.activityWindowId = context.activityWindowId;
        if (util.isUndefined(result.activityWindowId)) {
            result.activityWindowId = HCBridge._getURLParameter("activityWindowId");
        }
        result.activityWindowIndependent = context.activityWindowIndependent;
        if (util.isUndefined(result.activityWindowIndependent)) {
        }
        result.activityWindowName = context.activityWindowName;
        if (util.isUndefined(result.activityWindowName)) {
            result.activityWindowName = HCBridge._getURLParameter("activityWindowName");
        }
        return result;
    };
    HCBridge.prototype.announceWindow = function (windowType, activityWindowId) {
        var _this = this;
        if (util.isUndefined(windowType)) {
            throw new Error("can not determine window type");
        }
        if (util.isUndefined(windowType)) {
            throw new Error("can not determine window activityWindowId");
        }
        this._htmlContainer.announceWindow(windowType, activityWindowId, function (error) {
            _this._logger.error("Error announcing activity window with id '" + activityWindowId + "'. " + error);
        });
    };
    HCBridge.prototype.getActivities = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._logger.trace("Executing getActivities()");
            _this._htmlContainer.getActivities(function (activitiesStr) {
                _this._logger.trace("Got getActivities() :" + activitiesStr);
                var activities = JSON.parse(activitiesStr);
                var result = activities.map(function (act) { return _this._hcToJsActivity(act); });
                resolve(result);
            }, function (error) {
                _this._logger.trace("Error in getActivities() :" + error);
                reject(error);
            });
        });
    };
    HCBridge.prototype.updateActivityContext = function (activity, context, fullReplace, removedKeys) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (util.isUndefined(removedKeys)) {
                removedKeys = [];
            }
            var options = {
                fullReplace: fullReplace,
                removedKeys: removedKeys
            };
            _this._htmlContainer.setActivityContext(activity.id, JSON.stringify(context), JSON.stringify(options), function (newContextString) {
                var newContext = JSON.parse(newContextString);
                resolve(newContext);
            }, function (error) { return reject(error); });
        });
    };
    HCBridge.prototype.getActivityWindows = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.getWindows(function (windows) {
                var result = windows.map(function (wind) { return HCBridge._hcToJsWindow(wind); });
                resolve(result);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.stopActivity = function (activity) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.stopActivity(activity.id, function (result) {
                resolve(result);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.unregisterWindowFactory = function (windowTypeName) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.registerWindowFactory(windowTypeName, function (info) {
                resolve(true);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.createWindow = function (id, windowDefinition) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.createWindow(id, JSON.stringify(windowDefinition), function (id) {
                resolve(id);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.createStackedWindows = function (id, windowDefinitions, timeout) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.createStackedWindows(id, JSON.stringify(windowDefinitions), timeout, function (id) {
                resolve(id);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.onActivityTypeStatusChange = function (callback) {
        this._activityTypeCallbacks.push(callback);
    };
    HCBridge.prototype.onWindowTypeStatusChange = function (callback) {
        this._windowTypeCallbacks.push(callback);
    };
    HCBridge.prototype.onActivityStatusChange = function (callback) {
        this._activityCallbacks.push(callback);
    };
    HCBridge.prototype.onActivityWindowChange = function (callback) {
        this._windowCallbacks.push(callback);
    };
    HCBridge.prototype.getWindowBounds = function (id) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.getWindowBounds(id, function (bounds) {
                resolve(bounds);
            }, function (err) {
                reject(err);
            });
        });
    };
    HCBridge.prototype.setWindowBounds = function (id, bounds) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.setWindowBounds(id, JSON.stringify(bounds), function () {
                resolve();
            }, function (err) {
                reject(err);
            });
        });
    };
    HCBridge.prototype.registerWindow = function (type, name, independent) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.registerWindow(type, name, independent, function (id) {
                resolve(id);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.closeWindow = function (id) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.closeWindow(id, function () {
                resolve();
            }, function (err) {
                reject(err);
            });
        });
    };
    HCBridge.prototype.activateWindow = function (id, focus) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.activateWindow(id, focus, function () {
                resolve();
            }, function (err) {
                reject(err);
            });
        });
    };
    HCBridge.prototype._publishStatusChange = function (entity, context, callbacks) {
        var entityEvent = new entityEvent_2.EntityEvent(entity, context);
        callbacks.forEach(function (callback) {
            callback(entityEvent);
        });
    };
    HCBridge.prototype._publishActivityTypeStatusChange = function (at, context) {
        this._publishStatusChange(at, context, this._activityTypeCallbacks);
    };
    HCBridge.prototype._publishWindowTypeStatusChange = function (wt, context) {
        this._publishStatusChange(wt, context, this._windowTypeCallbacks);
    };
    HCBridge.prototype._publishActivityStatusChange = function (act, context) {
        this._publishStatusChange(act, context, this._activityCallbacks);
    };
    HCBridge.prototype._publishActivityWindowEvent = function (w, context) {
        this._publishStatusChange(w, context, this._windowCallbacks);
    };
    return HCBridge;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= HCBridge;

},{"../contracts/activityStatus":20,"../contracts/entityEvent":21,"../core/proxyWindowFactory":25,"../entities/activity":26,"../entities/activityType":28,"../entities/activityWindow":29,"../entities/windowType":30,"../helpers/logger":32,"../helpers/readyMarker":34,"../helpers/util":35}],20:[function(require,module,exports){
"use strict";
var ActivityStatus = (function () {
    function ActivityStatus(state, message, time) {
        this.state = state;
        this.message = message;
        this.time = time;
    }
    ActivityStatus.prototype.getState = function () {
        return this.state;
    };
    ActivityStatus.prototype.getMessage = function () {
        return this.message;
    };
    ActivityStatus.prototype.getTime = function () {
        return this.time;
    };
    return ActivityStatus;
}());
exports.ActivityStatus = ActivityStatus;

},{}],21:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var EntityEvent = (function () {
    function EntityEvent(entitiy, context) {
        this.entity = entitiy;
        this.context = context;
    }
    return EntityEvent;
}());
exports.EntityEvent = EntityEvent;
var EntityEventContext = (function () {
    function EntityEventContext(eventType) {
        this.type = eventType;
    }
    return EntityEventContext;
}());
exports.EntityEventContext = EntityEventContext;
var EntityStatusChangeEventContext = (function (_super) {
    __extends(EntityStatusChangeEventContext, _super);
    function EntityStatusChangeEventContext(newStatus, oldStatus) {
        _super.call(this, EntityEventType.StatusChange);
        this.newStatus = newStatus;
        this.oldStatus = oldStatus;
    }
    return EntityStatusChangeEventContext;
}(EntityEventContext));
exports.EntityStatusChangeEventContext = EntityStatusChangeEventContext;
var EntityActivityWindowEventContext = (function (_super) {
    __extends(EntityActivityWindowEventContext, _super);
    function EntityActivityWindowEventContext(activity, event) {
        _super.call(this, EntityEventType.ActivityWindowEvent);
        this.activity = activity;
        this.event = event;
    }
    return EntityActivityWindowEventContext;
}(EntityEventContext));
exports.EntityActivityWindowEventContext = EntityActivityWindowEventContext;
var ActivityContextChangedContext = (function (_super) {
    __extends(ActivityContextChangedContext, _super);
    function ActivityContextChangedContext(context, updated, removed) {
        _super.call(this, EntityEventType.ActivityContextChange);
        this.updated = updated;
        this.removed = removed;
        this.context = JSON.parse(context);
    }
    return ActivityContextChangedContext;
}(EntityEventContext));
exports.ActivityContextChangedContext = ActivityContextChangedContext;
var EntityEventType = (function () {
    function EntityEventType() {
    }
    EntityEventType.Added = "added";
    EntityEventType.Removed = "removed";
    EntityEventType.Updated = "updated";
    EntityEventType.FactoryRegistered = "factoryRegistered";
    EntityEventType.FactoryUnregistered = "factoryUnregistered";
    EntityEventType.StatusChange = "statusChange";
    EntityEventType.ActivityContextChange = "activityContextUpdate";
    EntityEventType.ActivityWindowEvent = "activityWindowEvent";
    return EntityEventType;
}());
exports.EntityEventType = EntityEventType;

},{}],22:[function(require,module,exports){
"use strict";
var util = require("../helpers/util");
var ActivityAGM = (function () {
    function ActivityAGM(activity) {
        this._activity = activity;
    }
    ActivityAGM.prototype.register = function (definition, handler) {
        this._ensureHasAgm();
        ActivityAGM.AGM.register(definition, handler);
    };
    ActivityAGM.prototype.servers = function () {
        this._ensureHasAgm();
        if (util.isUndefinedOrNull(this._activity)) {
            return [];
        }
        return this._activity.windows.map(function (w) {
            return w.instance;
        });
    };
    ActivityAGM.prototype.methods = function () {
        this._ensureHasAgm();
        if (util.isUndefinedOrNull(this._activity)) {
            return [];
        }
        var windows = this._activity.windows;
        var methodNames = [];
        var methods = [];
        for (var index = 0; index < windows.length; index++) {
            var window_1 = windows[index];
            var windowMethods = this.methodsForWindow(window_1);
            for (var methodIndex = 0; methodIndex < windowMethods.length; methodIndex++) {
                var currentWindowMethod = windowMethods[methodIndex];
                if (methodNames.indexOf(currentWindowMethod.name) === -1) {
                    methodNames.push(currentWindowMethod.name);
                    methods.push(currentWindowMethod);
                }
            }
        }
        return methods;
    };
    ActivityAGM.prototype.methodsForWindow = function (window) {
        this._ensureHasAgm();
        if (!window.instance) {
            return [];
        }
        return ActivityAGM.AGM.methodsForInstance(window.instance);
    };
    ActivityAGM.prototype.invoke = function (methodName, arg, target, options, success, error) {
        this._ensureHasAgm();
        var activityServers = this.servers();
        var serversToInvokeAgainst = [];
        if (util.isUndefinedOrNull(target)) {
            target = "activity.all";
        }
        if (util.isString(target)) {
            if (target === "activity.all") {
                serversToInvokeAgainst = activityServers;
            }
            else if (target === "activity.best") {
                var potentialTargets = activityServers.filter(function (server) {
                    var methods = ActivityAGM.AGM.methodsForInstance(server);
                    return methods.filter(function (m) {
                        return m.name === methodName;
                    }).length > 0;
                });
                if (potentialTargets.length > 0) {
                    serversToInvokeAgainst = [potentialTargets[0]];
                }
            }
            else if (target === "all" || target === "best") {
                return ActivityAGM.AGM.invoke(methodName, arg, target, options, success, error);
            }
            else {
                throw new Error("Invalid invoke target " + target);
            }
        }
        else if (util.isArray(target)) {
            if (target.length >= 0) {
                var firstElem = target[0];
                if (this._isAgmInstance(firstElem)) {
                    serversToInvokeAgainst = target.map(function (instance) { return instance; });
                }
                else if (this._isActivityWindow(firstElem)) {
                    serversToInvokeAgainst = target.map(function (win) { return win.instance; });
                }
                else {
                    throw new Error("Unknown target object");
                }
            }
        }
        else {
            if (this._isAgmInstance(target)) {
                serversToInvokeAgainst = [target];
            }
            else if (this._isActivityWindow(target)) {
                serversToInvokeAgainst = [target.instance];
            }
            else {
                throw new Error("Unknown target object");
            }
        }
        return ActivityAGM.AGM.invoke(methodName, arg, serversToInvokeAgainst, options, success, error);
    };
    ActivityAGM.prototype.unregister = function (definition) {
        this._ensureHasAgm();
        return ActivityAGM.AGM.unregister(definition);
    };
    ActivityAGM.prototype.createStream = function (methodDefinition, subscriberAddedHandler, subscriberRemovedFunction) {
        this._ensureHasAgm();
        ActivityAGM.AGM.createStream(methodDefinition, subscriberAddedHandler, subscriberRemovedFunction);
    };
    ActivityAGM.prototype.subscribe = function (methodDefinition, parameters, target) {
        this._ensureHasAgm();
        var servers = this.servers();
        return ActivityAGM.AGM.subscribe(methodDefinition, parameters, servers);
    };
    ActivityAGM.prototype._ensureHasAgm = function () {
        if (util.isUndefinedOrNull(ActivityAGM.AGM)) {
            throw new Error("Agm should be configured to be used in activity");
        }
    };
    ActivityAGM.prototype._isAgmInstance = function (obj) {
        return obj.application != undefined;
    };
    ActivityAGM.prototype._isActivityWindow = function (obj) {
        return obj.instance !== undefined;
    };
    return ActivityAGM;
}());
exports.ActivityAGM = ActivityAGM;

},{"../helpers/util":35}],23:[function(require,module,exports){
"use strict";
var entityEvent_1 = require("../contracts/entityEvent");
var activityType_1 = require("../entities/activityType");
var promiseExtensions_1 = require("../helpers/promiseExtensions");
var readyMarker_1 = require("../helpers/readyMarker");
var entityObservableCollection_1 = require("../helpers/entityObservableCollection");
var logger_1 = require("../helpers/logger");
var util = require("../helpers/util");
var localWindowFactory_1 = require("./localWindowFactory");
var ActivityManager = (function () {
    function ActivityManager(bridge, autoAnnounce) {
        var _this = this;
        this._logger = logger_1.Logger.Get(this);
        this._announcedWindows = [];
        this._bridge = bridge;
        this._activityTypes = new entityObservableCollection_1.EntityObservableCollection(function (e) { return _this._grabEntity(e); });
        this._windowTypes = new entityObservableCollection_1.EntityObservableCollection(function (e) { return _this._grabEntity(e); });
        this._activities = new entityObservableCollection_1.EntityObservableCollection(function (e) { return _this._grabEntity(e); });
        this._windows = new entityObservableCollection_1.EntityObservableCollection(function (e) { return _this._grabEntity(e); });
        this._dataReadyMarker = new readyMarker_1.ReadyMarker("Activity Manager Data", ["GetActivityTypes", "GetWindowTypes", "GetActivities", "GetWindows"].length);
        if (autoAnnounce) {
            var announceMaker = new readyMarker_1.ReadyMarker("Activity Manager Announce", ["Announcement"].length);
            this._readyMarker = announceMaker;
            this._dataReadyMarker.setCallback(function (err) {
                if (err) {
                    _this._readyMarker.error(err);
                }
                _this._logger.debug("Auto announcing window");
                _this.announceWindow()
                    .then(function (w) {
                    _this._announcedWindows.push(w);
                    _this._readyMarker.signal("Successfully announced window with id '" + w.id + "'");
                })['catch'](function (err) {
                    _this._logger.debug("Will not announce window - " + err);
                    _this._readyMarker.signal();
                });
            });
        }
        else {
            this._readyMarker = this._dataReadyMarker;
        }
        this._bridge.init();
        this._bridge
            .ready()
            .then(function (aw) {
            _this._subscribeForData();
        })['catch'](function (error) {
            console.log(error);
        });
    }
    Object.defineProperty(ActivityManager.prototype, "announcedWindows", {
        get: function () {
            return this._announcedWindows;
        },
        set: function (v) {
            throw new Error("not allowed");
        },
        enumerable: true,
        configurable: true
    });
    ActivityManager.prototype.ready = function (callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            _this._readyMarker.setCallback(function (err) {
                if (!err) {
                    resolve(_this);
                }
                else {
                    reject(_this._readyMarker.getError());
                }
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.getActivityTypes = function () {
        return this._activityTypes.get();
    };
    ActivityManager.prototype.getActivityType = function (name) {
        return this._activityTypes.getByName(name);
    };
    ActivityManager.prototype.registerActivityType = function (activityTypeName, ownerWindowType, helperWindowTypes, layoutConfig, description, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(activityTypeName)) {
                reject("activityTypeName argument can not be undefined");
            }
            if (!util.isString(activityTypeName)) {
                reject("activityTypeName should be string");
            }
            var actType = _this.getActivityType(activityTypeName);
            if (!util.isUndefinedOrNull(actType)) {
                reject("Activity type '" + activityTypeName + "' already exists");
            }
            var ownerDefinition;
            if (util.isUndefined(ownerWindowType)) {
                reject("Owner window type can not be undefined");
            }
            if (util.isString(ownerWindowType)) {
                ownerDefinition = { type: ownerWindowType, name: "", isIndependent: false, arguments: {} };
            }
            else {
                ownerDefinition = ownerWindowType;
            }
            var helperDefinitions = [];
            if (!util.isUndefined(helperWindowTypes) && util.isArray(helperWindowTypes)) {
                for (var index in helperWindowTypes) {
                    var item = helperWindowTypes[index];
                    if (util.isString(item)) {
                        var definition = {
                            type: item,
                            name: "",
                            isIndependent: false,
                            arguments: {},
                            relativeTo: "",
                            relativeDirection: "",
                            windowStyleAttributes: {}
                        };
                        helperDefinitions.push(definition);
                    }
                    else {
                        helperDefinitions.push(item);
                    }
                }
            }
            _this._bridge
                .registerActivityType(activityTypeName, ownerDefinition, helperDefinitions, layoutConfig, description)
                .then(function (activityType) {
                _this._grabEntity(activityType);
                resolve(activityType);
            })['catch'](function (error) {
                reject(error);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.unregisterActivityType = function (type, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            var actType = _this.getActivityType(type);
            if (util.isUndefined(actType)) {
                reject("Activity type '" + type + "' does not exists");
            }
            return _this._bridge.unregisterActivityType(type);
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.initiate = function (activityType, context, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            var actType = _this.getActivityType(activityType);
            if (util.isUndefined(actType)) {
                reject("Activity type '" + activityType + "' does not exists");
            }
            _this._bridge
                .initiateActivity(activityType, context)
                .then(function (actId) {
                _this._activities
                    .getOrWait(actId)
                    .then(function (act) {
                    resolve(act);
                })['catch'](function (err) { return reject(err); });
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.subscribeActivityTypeEvents = function (handler) {
        this._activityTypes.subscribe(function (at, context) {
            handler(at, context.type);
        });
    };
    ActivityManager.prototype.getWindowTypes = function () {
        return this._windowTypes.get();
    };
    ActivityManager.prototype.getWindowType = function (name) {
        return this._windowTypes.getByName(name);
    };
    ActivityManager.prototype.registerWindowFactory = function (windowType, factoryMethod, description, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(windowType)) {
                reject("no windowType specified");
                return;
            }
            if (util.isObject(windowType)) {
                windowType = windowType.getName();
            }
            else if (!util.isString(windowType)) {
                reject("windowType should be string or object that has getName method");
                return;
            }
            var factory = new localWindowFactory_1.LocalWindowFactory(factoryMethod, description);
            _this._bridge
                .registerWindowFactory(windowType, factory)
                .then(function (v) {
                resolve(v);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.unregisterWindowFactory = function (windowType, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(windowType)) {
                reject("no windowType specified");
                return;
            }
            if (!util.isString(windowType)) {
                reject("windowType should be a string");
                return;
            }
            _this._bridge
                .unregisterWindowFactory(windowType)
                .then(function (v) {
                resolve(v);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.getActivities = function (activityType) {
        var act = this._activities.get();
        if (!activityType) {
            return act;
        }
        var types = activityType;
        if (util.isString(activityType)) {
            types = [activityType];
        }
        else if (activityType instanceof activityType_1['default']) {
            types = [activityType.name];
        }
        else if (activityType instanceof Array) {
        }
        else {
            throw new Error("Invalid input argument 'activityType' = " + activityType);
        }
        return act.filter(function (act) {
            var type = act.type;
            return util.some(types, function (t) {
                return type.id == t.id;
            });
        });
    };
    ActivityManager.prototype.getActivityById = function (id) {
        return this._activities.getByName(id);
    };
    ActivityManager.prototype.announceWindow = function (activityWindowId, windowType) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            var announcementInfo = _this._bridge.getAnnouncementInfo();
            if (util.isUndefined(activityWindowId)) {
                activityWindowId = announcementInfo.activityWindowId;
            }
            if (util.isUndefined(windowType)) {
                windowType = announcementInfo.activityWindowType;
            }
            if (util.isUndefinedOrNull(windowType)) {
                throw new Error("Can not announce - unknown windowType");
            }
            if (util.isUndefinedOrNull(activityWindowId)) {
                _this._logger.debug("Registering window with type:'" + windowType + "', name:'" + announcementInfo.activityWindowName + "', ind.:'" + announcementInfo.activityWindowIndependent + "'");
                _this._bridge.registerWindow(windowType, announcementInfo.activityWindowName, announcementInfo.activityWindowIndependent)
                    .then(_this._windows.getOrWait.bind(_this._windows))
                    .then(function (w) {
                    resolve(w);
                })['catch'](function (err) {
                    _this._logger.error(err);
                });
            }
            else {
                _this._logger.debug("Announcing window with id '" + activityWindowId + "' and type '" + windowType + "'");
                var currentWindow = _this._windows.getByName(activityWindowId);
                if (!util.isUndefinedOrNull(currentWindow)) {
                    _this._logger.debug("Window with id '" + activityWindowId + "' already announced - reusing the window");
                    resolve(currentWindow);
                    return;
                }
                var windowEventHandler = function (a, w, e) {
                    if (activityWindowId === w.id) {
                        if (e === "joined") {
                            var activity = w.activity;
                            if (util.isUndefined(activity)) {
                                reject("UNDEFINED ACTIVITY");
                            }
                            _this._logger.trace("Got joined event for id '" + activityWindowId + "'");
                            resolve(w);
                            _this.unsubscribeWindowEvents(windowEventHandler);
                        }
                    }
                };
                _this.subscribeWindowEvents(windowEventHandler);
                _this._logger.trace("Waiting for joined event for id '" + activityWindowId + "'");
                _this._bridge.announceWindow(windowType, activityWindowId);
            }
        });
        return promise;
    };
    ActivityManager.prototype.subscribeWindowTypeEvents = function (handler) {
        this._windowTypes.subscribe(function (wt, context) {
            handler(wt, context.type);
        });
    };
    ActivityManager.prototype.subscribeActivityEvents = function (handler) {
        this._activities.subscribe(function (act, context) {
            if (context.type === entityEvent_1.EntityEventType.StatusChange) {
                var p = context;
                handler(act, p.newStatus, p.oldStatus);
            }
        });
    };
    ActivityManager.prototype.subscribeWindowEvents = function (handler) {
        this._windows.subscribe(function (window, context) {
            if (context.type === entityEvent_1.EntityEventType.ActivityWindowEvent) {
                var p = context;
                handler(window.activity, window, p.event);
            }
            else if (context.type === 'removed') {
                handler(window.activity, window, context.type);
            }
        });
    };
    ActivityManager.prototype.unsubscribeWindowEvents = function (handler) {
    };
    ActivityManager.prototype.createWindow = function (activity, windowType, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(activity)) {
                reject("activity is undefined");
            }
            if (util.isUndefinedOrNull(windowType)) {
                reject("windowType is undefined");
            }
            var windowDefinition;
            if (util.isString(windowType)) {
                windowDefinition = { type: windowType, name: "", isIndependent: false, arguments: {} };
            }
            else {
                windowDefinition = windowType;
            }
            var relativeToWindow;
            if (!util.isUndefinedOrNull(windowDefinition.relativeTo)) {
                relativeToWindow = windowDefinition.relativeTo;
                if (util.isString(relativeToWindow)) {
                    var windows = _this.getWindows({ type: relativeToWindow });
                    if (!util.isUndefinedOrNull(windows) && windows.length > 0) {
                        windowDefinition.relativeTo = windows[0].id;
                    }
                }
                else if (!util.isUndefinedOrNull(relativeToWindow.type)) {
                    var windows = _this.getWindows({ type: relativeToWindow.type });
                    if (!util.isUndefinedOrNull(windows) && windows.length > 0) {
                        windowDefinition.relativeTo = windows[0].id;
                    }
                }
                else if (!util.isUndefinedOrNull(relativeToWindow.windowId)) {
                    windowDefinition.relativeTo = relativeToWindow.windowId;
                }
            }
            _this._bridge.createWindow(activity.id, windowDefinition)
                .then(function (wid) {
                _this._logger.debug("Window created, waiting for window entity with id " + wid);
                var handler = function (window, context) {
                    if (window.id === wid && window.activity) {
                        this._logger.debug("Got entity window with id " + wid);
                        resolve(window);
                        this._windows.unsubscribe(handler);
                    }
                }.bind(_this);
                _this._windows.subscribe(handler);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.createStackedWindows = function (activity, relativeWindowTypes, timeout, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(activity)) {
                reject("activity is undefined");
            }
            if (util.isUndefinedOrNull(relativeWindowTypes)) {
                reject("relativeWindowTypes is undefined");
            }
            if (!Array.isArray(relativeWindowTypes)) {
                reject("relativeWindowTypes has to be array");
            }
            if (util.isUndefinedOrNull(timeout)) {
                timeout = 20000;
            }
            var relativeWindows = [];
            relativeWindowTypes.forEach(function (element) {
                var windowDefinition;
                if (util.isString(element)) {
                    windowDefinition = { type: element, name: "", isIndependent: false, arguments: {} };
                }
                else {
                    windowDefinition = element;
                }
                var relativeToWindow;
                if (!util.isUndefinedOrNull(windowDefinition.relativeTo)) {
                    relativeToWindow = windowDefinition.relativeTo;
                    if (!util.isUndefinedOrNull(relativeToWindow.type)) {
                        windowDefinition.relativeTo = relativeToWindow.type;
                    }
                    else if (!util.isUndefinedOrNull(relativeToWindow.windowId)) {
                        var windows = _this.getWindows({ id: relativeToWindow.windowId });
                        if (!util.isUndefinedOrNull(windows) && windows.length > 0) {
                            windowDefinition.relativeTo = windows[0].type.name;
                            windowDefinition.useExisting = true;
                        }
                    }
                }
                relativeWindows.push(windowDefinition);
            });
            _this._bridge.createStackedWindows(activity.id, relativeWindows, timeout)
                .then(function (wid) {
                var activityWindows = [];
                var alreadyCreated = [];
                var handler = function (window, context) {
                    if (wid.indexOf(window.id) >= 0 && alreadyCreated.indexOf(window.id) < 0 && window.activity) {
                        this._logger.debug("Got entity window with id " + wid);
                        activityWindows.push(window);
                        alreadyCreated.push(window.id);
                        if (activityWindows.length == wid.length) {
                            resolve(activityWindows);
                            this._windows.unsubscribe(handler);
                        }
                    }
                }.bind(_this);
                _this._windows.subscribe(handler);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.joinWindowToActivity = function (activity, window, callback) {
        return undefined;
    };
    ActivityManager.prototype.leaveWindowFromActivity = function (activity, window, callback) {
        return undefined;
    };
    ActivityManager.prototype.setActivityContext = function (activity, context, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(activity)) {
                reject("activity can not be null");
            }
            _this._bridge
                .updateActivityContext(activity, context, true)
                .then(function (obj) {
                resolve(obj);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.updateActivityContext = function (activity, context, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(activity)) {
                reject("activity can not be null");
            }
            var removedKeys = [];
            for (var key in context) {
                if (context.hasOwnProperty(key) && context[key] === null) {
                    removedKeys.push(key);
                }
            }
            _this._bridge
                .updateActivityContext(activity, context, false, removedKeys)
                .then(function (obj) {
                resolve(obj);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.subscribeActivityContextChanged = function (handler) {
        this._activities.subscribe(function (act, context) {
            if (context.type === entityEvent_1.EntityEventType.ActivityContextChange) {
                var updateContext = context;
                handler(act, updateContext.context, updateContext.updated, updateContext.removed);
            }
        });
    };
    ActivityManager.prototype.stopActivity = function (activity, callback) {
        var promise = this._bridge.stopActivity(activity);
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.getWindows = function (filter) {
        if (util.isUndefined(filter)) {
            return this._windows.get();
        }
        if (!util.isUndefined(filter.id)) {
            return [this._windows.getByName(filter.id)];
        }
        var allWindows = this._windows.get();
        return allWindows.filter(function (w) {
            if (!util.isUndefined(filter.type) && w.type.id !== filter.type) {
                return false;
            }
            if (!util.isUndefined(filter.name) && w.name !== filter.name) {
                return false;
            }
            if (!util.isUndefined(filter.activityId)) {
                if (util.isUndefinedOrNull(w.activity)) {
                    return false;
                }
                if (w.activity.id !== filter.activityId) {
                    return false;
                }
            }
            return true;
        });
    };
    ActivityManager.prototype._grabEntity = function (entity) {
        entity.manager = this;
    };
    ActivityManager.prototype._subscribeForData = function () {
        var _this = this;
        this._logger.debug("Start getting initial data...");
        this._bridge.onActivityTypeStatusChange(function (event) {
            _this._activityTypes.process(event);
        });
        this._bridge.getActivityTypes()
            .then(function (at) {
            _this._activityTypes.add(at);
            _this._dataReadyMarker.signal("Got act types");
        })['catch'](function (error) {
            _this._logger.error(error);
            _this._dataReadyMarker.error("Can not initialize ActivityManager - error getting activity types -" + error);
        });
        this._bridge.onWindowTypeStatusChange(function (event) {
            _this._windowTypes.process(event);
        });
        this._bridge.getWindowTypes()
            .then(function (wt) {
            _this._windowTypes.add(wt);
            _this._dataReadyMarker.signal("Got window types");
        })['catch'](function (error) {
            _this._logger.error(error);
            _this._dataReadyMarker.error("Can not initialize ActivityManager - error getting window types  " + error);
        });
        this._bridge.onActivityStatusChange(function (event) {
            _this._activities.process(event);
        });
        this._bridge.getActivities()
            .then(function (ac) {
            _this._activities.add(ac);
            _this._dataReadyMarker.signal("Got activities");
        })['catch'](function (error) {
            _this._logger.error(error);
            _this._dataReadyMarker.error("Can not initialize ActivityManager - error getting activity instances -" + error);
        });
        this._bridge.onActivityWindowChange(function (event) {
            _this._windows.process(event);
        });
        this._bridge.getActivityWindows()
            .then(function (aw) {
            _this._windows.add(aw);
            _this._dataReadyMarker.signal("Got windows");
        })['catch'](function (error) {
            _this._logger.error(error);
            _this._dataReadyMarker.error("Can not initialize ActivityManager - error getting activity windows -" + error);
        });
    };
    ActivityManager.prototype.getWindowBounds = function (id) {
        return this._bridge.getWindowBounds(id);
    };
    ActivityManager.prototype.setWindowBounds = function (id, bounds, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            _this._bridge.setWindowBounds(id, bounds)
                .then(function () { return resolve(); })['catch'](function (err) { return reject(err); });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.closeWindow = function (id) {
        return this._bridge.closeWindow(id);
    };
    ActivityManager.prototype.activateWindow = function (id, focus) {
        return this._bridge.activateWindow(id, focus);
    };
    return ActivityManager;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= ActivityManager;

},{"../contracts/entityEvent":21,"../entities/activityType":28,"../helpers/entityObservableCollection":31,"../helpers/logger":32,"../helpers/promiseExtensions":33,"../helpers/readyMarker":34,"../helpers/util":35,"./localWindowFactory":24}],24:[function(require,module,exports){
"use strict";
var LocalWindowFactory = (function () {
    function LocalWindowFactory(createFunction, description) {
        this._createFunction = createFunction;
        this._description = description;
    }
    LocalWindowFactory.prototype.create = function (activityWindowId, context, layout) {
        return this._createFunction(activityWindowId, context, layout);
    };
    LocalWindowFactory.prototype.description = function () {
        return this._description;
    };
    return LocalWindowFactory;
}());
exports.LocalWindowFactory = LocalWindowFactory;

},{}],25:[function(require,module,exports){
"use strict";
var ProxyWindowFactory = (function () {
    function ProxyWindowFactory(description) {
        this._description = description;
    }
    ProxyWindowFactory.prototype.create = function (activityWindowId, context) {
        return undefined;
    };
    ProxyWindowFactory.prototype.description = function () {
        return this._description;
    };
    return ProxyWindowFactory;
}());
exports.ProxyWindowFactory = ProxyWindowFactory;

},{}],26:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var activityEntity_1 = require("./activityEntity");
var activityAGM_1 = require("../core/activityAGM");
var Activity = (function (_super) {
    __extends(Activity, _super);
    function Activity(id, actType, status, context, ownerId) {
        _super.call(this, id);
        this._id = id;
        this._actType = actType;
        this._status = status;
        this._context = context;
        this._ownerId = ownerId;
        this._agm = new activityAGM_1.ActivityAGM(this);
    }
    Object.defineProperty(Activity.prototype, "type", {
        get: function () {
            if (this.manager) {
                return this.manager.getActivityType(this._actType);
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Activity.prototype, "context", {
        get: function () {
            return this._context;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Activity.prototype, "status", {
        get: function () {
            return this._status;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Activity.prototype, "owner", {
        get: function () {
            if (!this._ownerId) {
                return null;
            }
            return this.manager.getWindows({ id: this._ownerId })[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Activity.prototype, "windows", {
        get: function () {
            return this.manager.getWindows({ activityId: this._id });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Activity.prototype, "agm", {
        get: function () {
            return this._agm;
        },
        enumerable: true,
        configurable: true
    });
    Activity.prototype.join = function (window, callback) {
        return this.manager.joinWindowToActivity(this, window, callback);
    };
    Activity.prototype.createWindow = function (windowType, callback) {
        return this.manager.createWindow(this, windowType, callback);
    };
    Activity.prototype.createStackedWindows = function (windowTypes, timeout, callback) {
        return this.manager.createStackedWindows(this, windowTypes, timeout, callback);
    };
    Activity.prototype.leave = function (window, callback) {
        return this.manager.leaveWindowFromActivity(this, window, callback);
    };
    Activity.prototype.getWindowsByType = function (windowType) {
        var filter = { activityId: this._id, type: windowType };
        return this.manager.getWindows(filter);
    };
    Activity.prototype.setContext = function (context, callback) {
        return this.manager.setActivityContext(this, context, callback);
    };
    Activity.prototype.updateContext = function (context, callback) {
        return this.manager.updateActivityContext(this, context, callback);
    };
    Activity.prototype.onStatusChange = function (handler) {
        var _this = this;
        this.manager.subscribeActivityEvents(function (a, ns, os) {
            if (a.id === _this.id) {
                handler(a, ns, os);
            }
        });
    };
    Activity.prototype.onWindowEvent = function (handler) {
        var _this = this;
        this.manager.subscribeWindowEvents(function (a, w, e) {
            if (a.id === _this.id) {
                handler(a, w, e);
            }
        });
    };
    Activity.prototype.onContextChanged = function (handler) {
        var _this = this;
        this.manager.subscribeActivityContextChanged(function (act, context, delta, removed) {
            if (act.id === _this.id) {
                handler(context, delta, removed, act);
            }
        });
        try {
            handler(this.context, this.context, [], this);
        }
        catch (e) { }
    };
    Activity.prototype.stop = function () {
        this.manager.stopActivity(this);
    };
    Activity.prototype.updateCore = function (activity) {
        _super.prototype.updateCore.call(this, activity);
        this._actType = activity._actType;
        this._context = activity._context;
        this._status = activity._status;
        this._ownerId = activity._ownerId;
    };
    return Activity;
}(activityEntity_1['default']));
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= Activity;

},{"../core/activityAGM":22,"./activityEntity":27}],27:[function(require,module,exports){
"use strict";
var ActivityEntity = (function () {
    function ActivityEntity(id) {
        this.listeners = [];
        this._id = id;
    }
    Object.defineProperty(ActivityEntity.prototype, "id", {
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    ActivityEntity.prototype.onUpdated = function (handler) {
        this.listeners.push(handler);
    };
    ActivityEntity.prototype.update = function (other) {
        if (other._id != this._id) {
            throw Error("Can not update from entity with different id.");
        }
        this.updateCore(other);
        this.notify();
    };
    ActivityEntity.prototype.updateCore = function (other) {
    };
    ActivityEntity.prototype.notify = function () {
        for (var index = 0; index < this.listeners.length; index++) {
            var listener = this.listeners[index];
            listener(this);
        }
    };
    return ActivityEntity;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= ActivityEntity;

},{}],28:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var activityEntity_1 = require("./activityEntity");
var ActivityType = (function (_super) {
    __extends(ActivityType, _super);
    function ActivityType(name, ownerWindow, helperWindows, description) {
        _super.call(this, name);
        this._name = name;
        this._description = description;
        this._ownerWindow = ownerWindow;
        this._helperWindows = helperWindows || [];
    }
    Object.defineProperty(ActivityType.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityType.prototype, "description", {
        get: function () {
            return this._description;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityType.prototype, "helperWindows", {
        get: function () {
            return this._helperWindows;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityType.prototype, "ownerWindow", {
        get: function () {
            return this._ownerWindow;
        },
        enumerable: true,
        configurable: true
    });
    ActivityType.prototype.subscribeActivityStatusChange = function (handler) {
        return undefined;
    };
    ActivityType.prototype.initiate = function (context, callback) {
        return this.manager.initiate(this._name, context, callback);
    };
    ActivityType.prototype.updateCore = function (type) {
        _super.prototype.updateCore.call(this, type);
        this._description = type._description;
        this._ownerWindow = type._ownerWindow;
        this._helperWindows = type._helperWindows;
    };
    return ActivityType;
}(activityEntity_1['default']));
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= ActivityType;

},{"./activityEntity":27}],29:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var activityEntity_1 = require("./activityEntity");
var logger_1 = require("../helpers/logger");
var util = require("../helpers/util");
var ActivityWindow = (function (_super) {
    __extends(ActivityWindow, _super);
    function ActivityWindow(id, name, type, activityId, instance, isIndependent) {
        _super.call(this, id);
        this._logger = logger_1.Logger.Get(this);
        this._type = type;
        this._activityId = activityId;
        this._name = name;
        this._instance = instance;
        this._isIndependent = isIndependent;
    }
    ActivityWindow.prototype.getBounds = function () {
        return this.manager.getWindowBounds(this.id);
    };
    Object.defineProperty(ActivityWindow.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityWindow.prototype, "isIndependent", {
        get: function () {
            return this._isIndependent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityWindow.prototype, "type", {
        get: function () {
            if (this.manager) {
                return this.manager.getWindowType(this._type);
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityWindow.prototype, "activity", {
        get: function () {
            if (util.isUndefined(this._activityId)) {
                return undefined;
            }
            return this.manager.getActivityById(this._activityId);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityWindow.prototype, "isOwner", {
        get: function () {
            var act = this.activity;
            if (util.isUndefined(act)) {
                return false;
            }
            return act.owner.id === this.id;
        },
        enumerable: true,
        configurable: true
    });
    ActivityWindow.prototype.setVisible = function (isVisible, callback) {
        return undefined;
    };
    ActivityWindow.prototype.activate = function (focus) {
        return this.manager.activateWindow(this.id, focus);
    };
    ActivityWindow.prototype.setTitle = function (title, callback) {
        return undefined;
    };
    ActivityWindow.prototype.setBounds = function (bounds, callback) {
        return this.manager.setWindowBounds(this.id, bounds, callback);
    };
    ActivityWindow.prototype.setState = function (state, callback) {
        return undefined;
    };
    ActivityWindow.prototype.close = function () {
        return this.manager.closeWindow(this.id);
    };
    Object.defineProperty(ActivityWindow.prototype, "instance", {
        get: function () {
            return this._instance;
        },
        enumerable: true,
        configurable: true
    });
    ActivityWindow.prototype.onActivityJoined = function (callback) {
        this._subscribeForActivityWindowEvent("joined", callback);
    };
    ActivityWindow.prototype.onActivityRemoved = function (callback) {
        this._subscribeForActivityWindowEvent("removed", callback);
    };
    ActivityWindow.prototype.updateCore = function (other) {
        this._activityId = other._activityId;
        this._isIndependent = other._isIndependent;
        if (!util.isUndefinedOrNull(other._instance)) {
            this._instance = other._instance;
        }
    };
    ActivityWindow.prototype._subscribeForActivityWindowEvent = function (eventName, callback) {
        var _this = this;
        this.manager.subscribeWindowEvents(function (activity, window, event) {
            if (window.id !== _this.id) {
                return;
            }
            if (event === eventName) {
                callback(activity);
            }
        });
    };
    return ActivityWindow;
}(activityEntity_1['default']));
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= ActivityWindow;

},{"../helpers/logger":32,"../helpers/util":35,"./activityEntity":27}],30:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var activityEntity_1 = require("./activityEntity");
var WindowType = (function (_super) {
    __extends(WindowType, _super);
    function WindowType(name, factories) {
        _super.call(this, name);
        this._name = name;
        this._factories = factories;
    }
    Object.defineProperty(WindowType.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WindowType.prototype, "factories", {
        get: function () {
            return this._factories;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WindowType.prototype, "windows", {
        get: function () {
            return this.manager.getWindows({ type: this._name });
        },
        enumerable: true,
        configurable: true
    });
    WindowType.prototype.registerFactory = function (factory, factoryMethod, description, callback) {
        return this.manager.registerWindowFactory(this, factoryMethod, description);
    };
    return WindowType;
}(activityEntity_1['default']));
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= WindowType;

},{"./activityEntity":27}],31:[function(require,module,exports){
"use strict";
var entityEvent_1 = require("../contracts/entityEvent");
var EntityObservableCollection = (function () {
    function EntityObservableCollection(processNew) {
        this._items = {};
        this._listeners = [];
        this._processNew = processNew;
    }
    EntityObservableCollection.prototype.addOne = function (item) {
        this.add([item]);
    };
    EntityObservableCollection.prototype.add = function (items) {
        for (var index = 0; index < items.length; index++) {
            var element = items[index];
            this.process(new entityEvent_1.EntityEvent(element, new entityEvent_1.EntityEventContext(entityEvent_1.EntityEventType.Added)));
        }
    };
    EntityObservableCollection.prototype.process = function (event) {
        var context = event.context;
        var type = context.type;
        var entity = event.entity;
        var internalEntity = this._updateInternalCollections(entity, type);
        this._notifyListeners(internalEntity, context);
    };
    EntityObservableCollection.prototype.get = function () {
        var result = [];
        for (var key in this._items) {
            if (this._items.hasOwnProperty(key)) {
                var element = this._items[key];
                result.push(element);
            }
        }
        return result;
    };
    EntityObservableCollection.prototype.getByName = function (name) {
        for (var key in this._items) {
            if (key === name) {
                return this._items[key];
            }
        }
        return undefined;
    };
    EntityObservableCollection.prototype.getOrWait = function (name) {
        var _this = this;
        return new Promise(function (resolve) {
            var entityAddedHandler = function (entity) {
                if (entity.id !== name) {
                    return;
                }
                resolve(entity);
                _this.unsubscribe(entityAddedHandler);
            };
            _this.subscribe(entityAddedHandler);
            var window = _this.getByName(name);
            if (window) {
                resolve(window);
                return;
            }
        });
    };
    EntityObservableCollection.prototype.subscribe = function (handler) {
        this._listeners.push(handler);
        for (var key in this._items) {
            var element = this._items[key];
            handler(element, new entityEvent_1.EntityEventContext(entityEvent_1.EntityEventType.Added.toString()));
        }
    };
    EntityObservableCollection.prototype.unsubscribe = function (handler) {
        var index = this._listeners.indexOf(handler);
        if (index != -1) {
            this._listeners.splice(index, 1);
        }
    };
    EntityObservableCollection.prototype._notifyListeners = function (entity, context) {
        for (var index = 0; index < this._listeners.length; index++) {
            var listener = this._listeners[index];
            try {
                listener(entity, context);
            }
            catch (e) { }
        }
    };
    EntityObservableCollection.prototype._updateInternalCollections = function (entity, type) {
        if (type === entityEvent_1.EntityEventType.Removed) {
            delete this._items[entity.id];
            this._processNew(entity);
            return entity;
        }
        else {
            var key = entity.id;
            if (!this._items.hasOwnProperty(key)) {
                this._processNew(entity);
                this._items[entity.id] = entity;
            }
            else {
                this._items[entity.id].update(entity);
            }
        }
        return this._items[entity.id];
    };
    return EntityObservableCollection;
}());
exports.EntityObservableCollection = EntityObservableCollection;

},{"../contracts/entityEvent":21}],32:[function(require,module,exports){
"use strict";
var util = require("./util");
var LogLevel = (function () {
    function LogLevel() {
    }
    LogLevel.Trace = "trace";
    LogLevel.Debug = "debug";
    LogLevel.Info = "info";
    LogLevel.Warn = "warn";
    LogLevel.Error = "error";
    return LogLevel;
}());
exports.LogLevel = LogLevel;
var Logger = (function () {
    function Logger(name) {
        this._name = name;
        if (!util.isUndefinedOrNull(Logger.GlueLogger)) {
            this._glueLogger = Logger.GlueLogger.subLogger(name);
        }
    }
    Logger.GetNamed = function (name) {
        return new Logger(name);
    };
    Logger.Get = function (owner) {
        return new Logger(Logger.GetTypeName(owner));
    };
    Logger.prototype.trace = function (message) {
        if (!util.isUndefinedOrNull(this._glueLogger)) {
            this._glueLogger.trace(message);
        }
        else {
            if (Logger.Level === LogLevel.Trace) {
                console.info(this._getMessage(message, LogLevel.Trace));
            }
        }
    };
    Logger.prototype.debug = function (message) {
        if (!util.isUndefinedOrNull(this._glueLogger)) {
            this._glueLogger.debug(message);
        }
        else {
            if (Logger.Level === LogLevel.Debug ||
                Logger.Level === LogLevel.Trace) {
                console.info(this._getMessage(message, LogLevel.Debug));
            }
        }
    };
    Logger.prototype.info = function (message) {
        if (!util.isUndefinedOrNull(this._glueLogger)) {
            this._glueLogger.info(message);
        }
        else {
            if (Logger.Level === LogLevel.Debug ||
                Logger.Level === LogLevel.Trace ||
                Logger.Level === LogLevel.Info) {
                console.info(this._getMessage(message, LogLevel.Info));
            }
        }
    };
    Logger.prototype.warn = function (message) {
        if (!util.isUndefinedOrNull(this._glueLogger)) {
            this._glueLogger.warn(message);
        }
        else {
            if (Logger.Level === LogLevel.Debug ||
                Logger.Level === LogLevel.Trace ||
                Logger.Level === LogLevel.Info ||
                Logger.Level === LogLevel.Warn) {
                console.info(this._getMessage(message, LogLevel.Info));
            }
        }
    };
    Logger.prototype.error = function (message) {
        if (!util.isUndefinedOrNull(this._glueLogger)) {
            this._glueLogger.error(message);
        }
        else {
            console.error(this._getMessage(message, LogLevel.Error));
            console.trace();
        }
    };
    Logger.prototype._getMessage = function (message, level) {
        return "[" + level + "] " + this._name + " - " + message;
    };
    Logger.GetTypeName = function (object) {
        var funcNameRegex = /function (.{1,})\(/;
        var results = (funcNameRegex).exec(object.constructor.toString());
        return (results && results.length > 1) ? results[1] : "";
    };
    Logger.Level = LogLevel.Info;
    return Logger;
}());
exports.Logger = Logger;

},{"./util":35}],33:[function(require,module,exports){
"use strict";
var util = require("../helpers/util");
var nextTick = function (cb) { setTimeout(cb, 0); };
function nodeify(promise, callback) {
    if (!util.isFunction(callback)) {
        return promise;
    }
    promise.then(function (resp) {
        nextTick(function () {
            callback(null, resp);
        });
    }, function (err) {
        nextTick(function () {
            callback(err, null);
        });
    });
}
exports.nodeify = nodeify;
;

},{"../helpers/util":35}],34:[function(require,module,exports){
"use strict";
var logger_1 = require("./logger");
var util = require("../helpers/util");
var ReadyMarker = (function () {
    function ReadyMarker(name, signalsToWait) {
        this._logger = logger_1.Logger.GetNamed("ReadyMarker [" + name + "]");
        this._logger.debug("Initializing ready marker for '" + name + "' with " + signalsToWait + " signals to wait");
        if (signalsToWait <= 0) {
            throw new Error("Invalid signal number. Should be > 0");
        }
        this._signals = signalsToWait;
        this._callbacks = [];
        this._name = name;
    }
    ReadyMarker.prototype.setCallback = function (callback) {
        if (this.isSet()) {
            callback(undefined);
            return;
        }
        else if (this.isError()) {
            callback(this._error);
            return;
        }
        this._callbacks.push(callback);
    };
    ReadyMarker.prototype.signal = function (message) {
        this._logger.debug("Signaled - " + message + " - signals left " + (this._signals - 1));
        this._signals--;
        if (this._signals < 0) {
            throw new Error("Error in ready marker '" + this._name + " - signals are " + this._signals);
        }
        if (this.isSet()) {
            this._callbacks.forEach(function (callback) {
                callback(undefined);
            });
        }
    };
    ReadyMarker.prototype.error = function (error) {
        this._error = error;
        this._callbacks.forEach(function (errorCallback) {
            errorCallback(error);
        });
    };
    ReadyMarker.prototype.isSet = function () {
        if (this.isError()) {
            return false;
        }
        return this._signals === 0;
    };
    ReadyMarker.prototype.isError = function () {
        return !util.isUndefined(this._error);
    };
    ReadyMarker.prototype.getError = function () {
        return this._error;
    };
    return ReadyMarker;
}());
exports.ReadyMarker = ReadyMarker;

},{"../helpers/util":35,"./logger":32}],35:[function(require,module,exports){
"use strict";
function isNumber(arg) {
    return typeof arg === 'number';
}
exports.isNumber = isNumber;
function isString(arg) {
    return typeof arg === 'string';
}
exports.isString = isString;
function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;
function isArray(arg) {
    if (Array.isArray) {
        return Array.isArray(arg);
    }
    return toString.call(arg) === '[object Array]';
}
exports.isArray = isArray;
function isUndefined(arg) {
    return typeof arg === 'undefined';
}
exports.isUndefined = isUndefined;
function isUndefinedOrNull(arg) {
    return !arg || typeof arg === 'undefined';
}
exports.isUndefinedOrNull = isUndefinedOrNull;
function isEmpty(arg) {
    for (var prop in arg) {
        if (arg.hasOwnProperty(prop))
            return false;
    }
    return true;
}
exports.isEmpty = isEmpty;
function isFunction(arg) {
    return !!(arg && arg.constructor && arg.call && arg.apply);
}
exports.isFunction = isFunction;
;
function some(array, predicate) {
    for (var index = 0; index < array.length; index++) {
        if (predicate(array[index], index)) {
            return true;
        }
    }
    return false;
}
exports.some = some;
function first(array, predicate) {
    for (var index = 0; index < array.length; index++) {
        if (predicate(array[index], index)) {
            return array[index];
        }
    }
    return undefined;
}
exports.first = first;

},{}],36:[function(require,module,exports){
/**
 * This module handles AGM method invocations - validating inputs and delegating to protocol
 */
var random = require('./helpers/random');

module.exports = function (protocol) {
    'use strict';

    /** Store pending callback **/
    var pendingCallbacks = {};

    /**
     * Invokes an AGM method to a single AGM server, given valid input.
     * @param method
     * @param argumentsObj
     * @param target
     * @param stuff
     * @param success
     * @param error
     */
    function invoke(method, argumentsObj, target, stuff, success, error) {
        // Generate a unique invocation ID, for this invocation
        var invocationId = random();

        // Register the user's callbacks
        registerInvocation(invocationId, {
            method: method,
            calledWith: argumentsObj
        }, success, error, stuff.method_response_timeout);

        protocol.invoke(invocationId, method, argumentsObj, target, stuff);
    }

    /**
     * Register invocation so we can find it later when invocation result is received
     * @param invocationId
     * @param response
     * @param success
     * @param error
     * @param timeout
     */
    function registerInvocation(invocationId, response, success, error, timeout) {
        // Adds the callbacks
        pendingCallbacks[invocationId] = { response: response, success: success, error: error };
        // Schedules to throw a timeout if nobody answers
        setTimeout(function () {
            if (pendingCallbacks[invocationId] === undefined) {
                return;
            }
            error({
                method: response.method,
                called_with: response.calledWith,
                message: 'Timeout reached'
            });
            delete pendingCallbacks[invocationId];
        }, timeout);
    }

    /**
     * Process invocation result received from protocl
     * @param invocationId
     * @param executedBy
     * @param status
     * @param result
     * @param resultMessage
     */
    function processInvocationResult(invocationId, executedBy, status, result, resultMessage) {
        // Finds the appropriate callback
        var callback = pendingCallbacks[invocationId];
        if (callback === undefined) {
            return;
        }
        // If the server returned success, execute the success callback
        if (status === 0 && typeof callback.success === 'function') {

            // Execute the success callback
            callback.success({
                method: callback.response.method.info,
                called_with: callback.response.calledWith,
                executed_by: executedBy,
                returned: result,
                message: resultMessage
                // log_details: message.ResultLogDetails
            });
            // Else, return an error
        } else if (typeof callback.error === 'function') {

            callback.error({
                method: callback.response.method.info,
                called_with: callback.response.calledWith,
                executed_by: executedBy,
                message: resultMessage,
                // log_details: message.ResultLogDetails,
                status: status
            });
        }
        // Finally, remove the callbacks
        delete pendingCallbacks[invocationId];
    }

    // subscribe for invocation results
    protocol.onInvocationResult(processInvocationResult);

    return { invoke: invoke };
};

},{"./helpers/random":46}],37:[function(require,module,exports){
(function (global){
/*
 The AGM Client analyses server presences, collects information about their methods and allows users to invoke these methods.
 */

var Promise = require('es6-promise').Promise;
var ClientInvocationsState = require('./agm-client-invoke');
var promisify = require('./helpers/promisify');

module.exports = function (protocol, repo, instance, configuration) {
    'use strict';

    // Instantiate the module that handles method execution and responses
    var clientInvocations = new ClientInvocationsState(protocol);

    /**
     * Returns all methods that match the given filter. If no filter specified returns all methods.
     * @param    methodFilter Optional object - partial method definition
     * @return An array of {server:{}, methods:[]} objects - methods for each server that match the filter
     * */
    function getMethods(methodFilter) {
        if (methodFilter === undefined) {
            return repo.getMethods();
        }
        if (typeof methodFilter === 'string') {
            methodFilter = { name: methodFilter };
        }
        return repo.getMethods().filter(function (method) {
            return methodMatch(methodFilter, method.info);
        });
    }

    /**
     * Retrieves all servers that support any of several methods, listed as an array
     */
    function getMethodsForInstance(instanceFilter) {
        var allServers = repo.getServers();

        var matchingServers = allServers.filter(function (server) {
            return instanceMatch(instanceFilter, server.info);
        });

        if (matchingServers.length === 0) {
            return [];
        }

        var resultMethodsObject = {};

        if (matchingServers.length === 1) {
            resultMethodsObject = matchingServers[0].methods;
        } else {
            // we have more than one server matching, join all methods
            matchingServers.forEach(function (server) {
                Object.keys(server.methods).forEach(function (methodKey) {
                    var method = server.methods[methodKey];
                    resultMethodsObject[method.id] = method.getInfoForUser();
                })
            });
        }

        // transform the object to array
        return Object.keys(resultMethodsObject)
            .map(function (key) {
                return resultMethodsObject[key]
            });
    }

    /**
     * Retrieves all getServers that support a given method
     */
    function getServers(methodFilter) {
        var servers = repo.getServers();

        // No method - get all getServers
        if (methodFilter === undefined) {
            return servers.map(function (server) {
                return { server: server };
            });
        }
        // Non-existing method - return an empty array
        var methods = getMethods(methodFilter);
        if (methods === undefined) {
            return [];
        }

        return servers.reduce(function (prev, current) {

            var methods = repo.getServerMethodsById(current.id);

            var matchingMethods = methods.filter(function (method) {
                return methodMatch(methodFilter, method.info);
            });

            if (matchingMethods.length > 0) {
                prev.push({ server: current, methods: matchingMethods });
            }

            return prev;
        }, []);
    }

    /**
     * Returns an array of server-methods pairs for all servers that match the target and have at lease one method mathing the method filter
     * @param methodFilter
     * @param target
     * @returns {*}
     */
    function getServerMethodsByFilterAndTarget(methodFilter, target) {
        // get all servers that have method(s) matching the filter
        var serversMethodMap = getServers(methodFilter);
        // filter the server-method map by target
        return filterByTarget(target, serversMethodMap);
    }

    /**
     * Invokes an AGM method
     * @param methodFilter
     * @param argumentObj
     * @param target
     * @param additionalOptions
     * @param success
     * @param error
     * @returns {*}
     **/
    function invoke(methodFilter, argumentObj, target, additionalOptions, success, error) {
        var promise = new Promise(function (resolve, reject) {
            var successProxy, errorProxy;

            successProxy = function (args) {
                // var parsed = JSON.parse(args);
                resolve(args);
            };
            errorProxy = function (args) {
                // var parsed = JSON.parse(args);
                reject(args);
            };
            // Add default params
            if (!argumentObj) {
                argumentObj = {};
            }
            if (!target) {
                target = 'best';
            }
            if (typeof target === 'string' && target !== 'all' && target !== 'best') {
                reject({ message: '"' + target + '" is not a valid target. Valid targets are "all" and "best".' });
            }
            if (!additionalOptions) {
                additionalOptions = {};
            }

            if (additionalOptions.method_response_timeout === undefined) {
                additionalOptions.method_response_timeout = configuration.method_response_timeout;
            }
            if (additionalOptions.wait_for_method_timeout === undefined) {
                additionalOptions.wait_for_method_timeout = configuration.wait_for_method_timeout;
            }

            // Check if the arguments are an object
            if (typeof argumentObj !== 'object') {
                reject({ message: 'The method arguments must be an object.' });
            }

            if (typeof methodFilter === 'string') {
                methodFilter = { name: methodFilter };
            }

            var serversMethodMap = getServerMethodsByFilterAndTarget(methodFilter, target);

            if (serversMethodMap.length === 0) {

                invokeUnexisting(methodFilter, argumentObj, target, additionalOptions, successProxy, errorProxy);

            } else if (serversMethodMap.length === 1) {

                var serverMethodPair = serversMethodMap[0];
                clientInvocations.invoke(serverMethodPair.methods[0], argumentObj, serverMethodPair.server, additionalOptions, successProxy, errorProxy);

            } else {

                invokeOnAll(serversMethodMap, argumentObj, additionalOptions, successProxy, errorProxy);

            }
        });

        return promisify(promise, success, error);
    }

    /**
     * Called when the user tries to invoke a method which does not exist
     * @param methodFilter
     * @param argumentObj
     * @param target
     * @param additionalOptions
     * @param success
     * @param error
     */
    function invokeUnexisting(methodFilter, argumentObj, target, additionalOptions, success, error) {

        if (additionalOptions.wait_for_method_timeout === 0) {
            callError();
        } else {
            setTimeout(function () {
                // get all servers that have method(s) matching the filter
                var serversMethodMap = getServerMethodsByFilterAndTarget(methodFilter, target);
                if (serversMethodMap.length > 0) {
                    invoke(methodFilter, argumentObj, target, additionalOptions, success, error);
                } else {
                    callError();
                }
            }, additionalOptions.wait_for_method_timeout);
        }

        function callError() {
            error({
                method: methodFilter,
                called_with: argumentObj,
                message: 'Can not find a method matching "' + JSON.stringify(methodFilter) + '" with server filter "' + JSON.stringify(target) + '"'
            });
        }
    }

    /**
     * Calls a method for all servers and unifies the results they return into one:
     * @param serverMethodsMap
     * @param argumentObj
     * @param additionalOptions
     * @param success
     * @param error
     */
    function invokeOnAll(serverMethodsMap, argumentObj, additionalOptions, success, error) {
        // Here we will store the results that the getServers return
        var successes = [];
        var errors = [];
        // These are the callbacks
        var successCallback = function (result) {
            successes.push(result);
            sendResponse(successes, errors);
        };
        var errorCallback = function (result) {
            errors.push(result);
            sendResponse(successes, errors);
        };
        // Call the method for all targets
        serverMethodsMap.forEach(function (serverMethodsPair) {
            clientInvocations.invoke(serverMethodsPair.methods[0],
                argumentObj,
                serverMethodsPair.server,
                additionalOptions,
                successCallback,
                errorCallback);
        });

        // Calls the main success and error callbacks with the aggregated results
        function sendResponse() {
            // wait till everybody is finished
            if (successes.length + errors.length < serverMethodsMap.length) {
                return;
            }
            // Execute the "success" callback
            if (successes.length !== 0) {
                var result = successes.reduce(function (obj, success) {
                    obj.method = success.method;
                    obj.called_with = success.called_with;
                    obj.returned = success.returned;
                    obj.all_return_values.push({
                        executed_by: success.executed_by,
                        returned: success.returned
                    });
                    obj.executed_by = success.executed_by;
                    return obj;
                }, { all_return_values: [] });

                // If we get errors from one of the getServers add them to the success object that will be resolved.
                if (errors.length !== 0) {
                    result.all_errors = [];
                    errors.forEach(function (obj) {
                        result.all_errors.push({
                            // executed_by : obj.executed_by, // we don't get executed_by object from the error clientInvocations
                            name: obj.method.name,
                            message: obj.message
                        });
                    });
                }

                success(result);

            } else if (errors.length !== 0) { // Execute the "error" callback
                error(errors.reduce(function (obj, error) {
                    obj.method = error.method;
                    obj.called_with = error.called_with;
                    obj.message = error.message;
                    obj.all_errors.push({
                        executed_by: error.executed_by,
                        message: error.message
                    });
                    // obj.executed_by = success.executed_by;
                    return obj;
                }, { all_errors: [] }));
            }
        }
    }

    /**
     * Filters an array of servers and returns the ones which match the target criteria
     * @param target
     * @param serverMethodMap
     * @returns {*}
     * */
    function filterByTarget(target, serverMethodMap) {
        // If the user specified target as string:
        if (typeof target === 'string') {
            if (target === 'all') {
                target = serverMethodMap;
            } else if (target === 'best') {
                target = serverMethodMap[0] !== undefined ? [serverMethodMap[0]] : [];  // If the user specified the target as server filter
            }
        } else {
            if (!Array.isArray(target)) {
                target = [target];
            }
            // Retrieve all getServers that match the filters
            target = target.reduce(function (matches, filter) {
                // Add matches for each filter
                var myMatches = serverMethodMap.filter(function (serverMethodPair) {
                    return instanceMatch(filter, serverMethodPair.server.info);
                });
                return matches.concat(myMatches);
            }, []);
        }
        return target;
    }

    /**
     * Matches a server definition against a server filter
     * @param instanceFilter
     * @param instanceDefinition
     */
    function instanceMatch(instanceFilter, instanceDefinition) {
        return containsProps(instanceFilter, instanceDefinition);
    }

    /**
     * Matches a method definition against a method filter
     * @param methodFilter
     * @param methodDefinition
     */
    function methodMatch(methodFilter, methodDefinition) {
        return containsProps(methodFilter, methodDefinition);
    }

    /**
     * Checks if all properties of filter match properties in object
     * @param filter
     * @param object
     * @returns {*}
     */
    function containsProps(filter, object) {
        return Object.keys(filter).reduce(function (match, prop) {
            // ignore undefined properties
            if (!filter[prop]) {
                return match;
            }

            if (filter[prop].constructor === RegExp) {
                if (!filter[prop].test(object[prop])) {
                    return false;
                } else {
                    return match;
                }
            } else {
                if (String(filter[prop]).toLowerCase() !== String(object[prop]).toLowerCase()) {
                    return false;
                } else {
                    return match;
                }
            }
        }, true);
    }

    /**
     * Subscribes to an AGM streaming method
     * @param name
     * @param options
     * @param successCallback
     * @param errorCallback
     * @returns {*}
     */
    function subscribe(name, options, successCallback, errorCallback) {
        // options can have arguments:{}, target: 'best'/'all'/{server_instance}, waitTimeoutMs:3000

        function callProtocolSubscribe(targetServers, stream, options, successProxy, errorProxy) {
            if (global.console !== undefined && configuration.debug === true) {
                console.log('>>> Subscribing to "' + name + '" on ' + targetServers.length + ' servers');
            }

            protocol.subscribe(
                stream,
                options.arguments,
                targetServers,
                { method_response_timeout: options.waitTimeoutMs },
                successProxy,
                errorProxy
            );
        }

        var promise = new Promise(function (resolve, reject) {

            var successProxy = function (args) {
                resolve(args);
            };
            var errorProxy = function (args) {
                reject(args);
            };

            if (options === undefined) {
                options = {};
            }
            var target = options.target;
            if (target === undefined) {
                target = 'best';
            }
            if (typeof target === 'string' && target !== 'all' && target !== 'best') {
                reject({ message: '"' + target + '" is not a valid target. Valid targets are "all", "best", or an instance.' });
            }
            if (typeof options.waitTimeoutMs !== 'number' || options.waitTimeoutMs !== options.waitTimeoutMs /* NaN */) {
                options.waitTimeoutMs = configuration.wait_for_method_timeout;
            }

            // don't check if the method is streaming or not, subscribing to non-streaming method has to invoke it
            var currentServers = getServerMethodsByFilterAndTarget({ name: name }, target);

            if (currentServers.length === 0) {

                // console.log('...no servers')//test

                setTimeout(function () {
                    var lateServers = getServerMethodsByFilterAndTarget({ name: name }, target);
                    // TODO: change to use the methodAdded handler
                    // TODO: set agm.methodAdded and if(waitTimeout>=0){setTimeout}

                    var streamInfo = lateServers.length > 0 ? lateServers[0].methods[0] : { name: name };
                    callProtocolSubscribe(lateServers, streamInfo, options, successProxy, errorProxy)

                }, options.waitTimeoutMs)

            } else {
                callProtocolSubscribe(currentServers, currentServers[0].methods[0], options, successProxy, errorProxy)
            }
        });

        return promisify(promise, successCallback, errorCallback);
    }

    return {
        subscribe: subscribe,
        invoke: invoke,
        servers: function (methodFilter) {
            return getServers(methodFilter).map(function (serverMethodMap) {
                return serverMethodMap.server.getInfoForUser();
            })
        },
        methods: function (methodFilter) {
            return getMethods(methodFilter).map(function (m) {
                return m.getInfoForUser()
            })
        },
        methodsForInstance: function (instance) {
            return getMethodsForInstance(instance).map(function (m) {
                return m.getInfoForUser()
            })
        },
        methodAdded: function (callback) {
            repo.onMethodAdded(function (method) {
                callback(method.getInfoForUser())
            })
        },
        methodRemoved: function (callback) {
            repo.onMethodRemoved(function (method) {
                callback(method.getInfoForUser())
            })
        },
        serverAdded: function (callback) {
            repo.onServerAdded(function (server) {
                callback(server.getInfoForUser())
            })
        },
        serverRemoved: function (callback) {
            repo.onServerRemoved(function (server, reason) {
                callback(server.getInfoForUser(), reason)
            })
        },
        serverMethodAdded: function (callback) {
            repo.onServerMethodAdded(function (server, method) {
                callback({ server: server.getInfoForUser(), method: method.getInfoForUser() })
            })
        },
        serverMethodRemoved: function (callback) {
            repo.onServerMethodRemoved(function (server, method) {
                callback({ server: server.getInfoForUser(), method: method.getInfoForUser() })
            })
        }
    };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./agm-client-invoke":36,"./helpers/promisify":45,"es6-promise":11}],38:[function(require,module,exports){
(function (global){
/*
 The AGM instance collects information about the machine we are in,
 and interacts with the .NET gateway in other ways,
 to deliver full AGM compatibility to AGM.JS.

 To do so, it relies on the default AGM client.
 */

var document = global.document || global.process;
var random = require('./helpers/random');

module.exports = function (userSubmittedProperties) {
    'use strict';

    var instance = {};
    // Generate default instance properties
    instance.ApplicationName = document.title + random();
    instance.ProcessId = Math.floor(Math.random() * 10000000000); // PID should be integer for protocolVersion 1
    instance.ProcessStartTime = new Date().getTime();

    // Apply user-submitted instance properties
    if (typeof userSubmittedProperties === 'object') {
        if (userSubmittedProperties.application !== undefined) {
            instance.ApplicationName = userSubmittedProperties.application;
        }
        instance.MachineName = userSubmittedProperties.machine;
        instance.UserName = userSubmittedProperties.user;
        instance.Environment = userSubmittedProperties.environment;
        instance.Region = userSubmittedProperties.region;
        instance.State = 1;
    }
    var identityUpdated = false;

    function updateIdentity(newInstance) {
        if (identityUpdated) {
            return;
        }
        if (instance.MachineName === undefined) {
            instance.MachineName = newInstance.MachineName;
        }
        if (instance.UserName === undefined) {
            instance.UserName = newInstance.UserName;
        }
        if (instance.Environment === undefined) {
            instance.Environment = newInstance.Environment;
        }
        if (instance.Region === undefined) {
            instance.Region = newInstance.Region;
        }
        if (instance.State === undefined) {
            instance.State = newInstance.State;
        }
        if (global.console !== undefined && global.console.table !== undefined && agm.debug === true) {
            console.log('Received instance with info from Gateway.');
        }
        identityUpdated = true;
    }

    // Create a method for accessing a property
    function createGetter(property) {
        return instance[property];
    }

    // Returns all instance properties
    function info() {
        return instance;
    }

    return {
        _updateIdentity: updateIdentity,
        info: info,
        get application() {
            return createGetter('ApplicationName');
        },
        get pid() {
            return createGetter('ProcessId');
        },
        get user() {
            return createGetter('UserName');
        },
        get machine() {
            return createGetter('MachineName');
        }
    };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./helpers/random":46}],39:[function(require,module,exports){
(function (global){
var Promise = require('es6-promise').Promise;
var promisify = require('./helpers/promisify');
var pjson = require('../package.json');

module.exports = function (configuration) {
    'use strict';

    // date parsing
    var facade = global.htmlContainer.jsAgmFacade;
    var dateTimeIdentifier = facade.jsonValueDatePrefix;
    var lenOfIdentifier = dateTimeIdentifier.length;

    function stringToObject(param, stringPropName) {
        if (typeof param === 'string') {
            var obj = {};
            obj[stringPropName] = param;
            return obj;
        }

        return param;
    }

    // helper function for parsing dates properly
    function agmParse(str) {
        return JSON.parse(str, function (k, v) {
            if (typeof v !== 'string') {
                return v;
            }

            // pre-seed - this should be a bit faster than indexOf
            if (v[0] !== dateTimeIdentifier[0]) {
                return v;
            }

            if (v.indexOf(dateTimeIdentifier) !== 0) {
                return v;
            }

            var unixTimestampMs = v.substr(lenOfIdentifier);
            return new Date(parseFloat(unixTimestampMs));
        });
    }

    /**
     * Converts a target argument to object ready to be passed to Agm facade
     * @param target
     */
    function targetArgToObject(target) {

        target = target || 'best';

        if (typeof target === 'string') {
            if (target !== 'all' && target !== 'best') {
                throw new Error('"' + target + '" is not a valid target. Valid targets are "all" and "best".');
            }
            return { target: target };
        } else {
            if (!Array.isArray(target)) {
                target = [target];
            }

            target = target.map(function (e) {
                return convertInstanceToRegex(e);
            });

            return { serverFilter: target };
        }
    }

    function convertInstanceToRegex(instance) {
        var instanceConverted = {};

        Object.keys(instance).forEach(function (key) {
            var propValue = instance[key];
            instanceConverted[key] = propValue;

            if (typeof propValue === 'undefined' || propValue === null) {
                return;
            }

            if (typeof propValue === 'string') {
                // do exact matching if user passed a string
                instanceConverted[key] = '^' + instance[key] + '$';
            } else if (instance[key].constructor === RegExp) {
                instanceConverted[key] = instance[key].source;
            } else {
                instanceConverted[key] = instance[key];
            }
        });
        return instanceConverted;
    }

    return new Promise(function (resolve) {
        var result = {

            version: pjson.version,

            // Registers a JavaScript function as an AGM method, thus making it available other AGM instances on the same transport.
            register: function (methodInfo, callback) {

                var pv = this.agmFacade.protocolVersion;

                if (pv && pv >= 3) {
                    // for newer HC use the version where we don't pass arguments as JSON (because of different issues)
                    this.agmFacade.register(JSON.stringify(stringToObject(methodInfo, 'name')),
                        callback,
                        true); // return as objects
                } else {
                    this.agmFacade.register(JSON.stringify(stringToObject(methodInfo, 'name')),
                        function (arg) {
                            var result = callback(JSON.parse(arg), arguments[1]);
                            return JSON.stringify(result);
                        });
                }
            },

            registerAsync: function (methodInfo, callback) {
                if (!this.agmFacade.registerAsync) {
                    throw new Error('not supported in that version of HtmlContainer');
                }

                this.agmFacade.registerAsync(stringToObject(methodInfo, 'name'),
                    function (args, instance, tracker) {
                        // execute the user callback
                        callback(args,
                            instance,
                            function (successArgs) {
                                tracker.success(successArgs);
                            },
                            function (error) {
                                tracker.error(error)
                            });
                    });
            },

            unregister: function (methodFilter) {
                this.agmFacade.unregister(JSON.stringify(stringToObject(methodFilter, 'name')));
            },

            // Invokes an AGM method asynchronously.
            invoke: function (methodFilter, args, target, options, successCallback, errorCallback) {

                var promise = new Promise(function (resolve, reject) {

                    if (args === undefined) {
                        args = {};
                    }

                    if (typeof args !== 'object') {
                        reject({ message: 'The method arguments must be an object.' });
                    }

                    if (options === undefined) {
                        options = {};
                    }

                    target = targetArgToObject(target);

                    if (this.agmFacade.invoke2) {
                        // invoke ver2 - do not stringify arguments and result values
                        this.agmFacade.invoke2(
                            JSON.stringify(stringToObject(methodFilter, 'name')),
                            args,
                            JSON.stringify(target),
                            JSON.stringify(options),
                            function (args) {
                                resolve(args)
                            },
                            function (err) {
                                reject(err)
                            }
                        );
                    } else {
                        var successProxy, errorProxy;

                        successProxy = function (args) {
                            var parsed = JSON.parse(args);
                            resolve(parsed);
                        };
                        errorProxy = function (args) {
                            var parsed = JSON.parse(args);
                            reject(parsed);
                        };
                        this.agmFacade.invoke(
                            JSON.stringify(stringToObject(methodFilter, 'name')),
                            JSON.stringify(args),
                            JSON.stringify(target),
                            JSON.stringify(options),
                            successProxy,
                            errorProxy
                        );
                    }

                }.bind(this));

                return promisify(promise, successCallback, errorCallback);
            },

            // Registers a handler which notifies you when a new AGM method is available.
            methodAdded: function (callback) {
                this.agmFacade.methodAdded(callback);
            },

            // Registers a handler which notifies you when an AGM method stops being available.
            methodRemoved: function (callback) {
                this.agmFacade.methodRemoved(callback);
            },

            serverAdded: function (callback) {
                this.agmFacade.serverAdded(callback);
            },

            serverRemoved: function (callback) {
                this.agmFacade.serverRemoved(callback);
            },

            serverMethodAdded: function (callback) {
                this.agmFacade.serverMethodAdded(callback);
            },

            serverMethodRemoved: function (callback) {
                this.agmFacade.serverMethodRemoved(callback);
            },

            // Retrieves a list of AGM servers (instances) optionally filtered by method.
            servers: function (methodFilter) {
                var jsonResult = this.agmFacade.servers(JSON.stringify(methodFilter));
                return agmParse(jsonResult);
            },

            // Retrieves a list of methods that matches a given filter. You can use this to check if a given method exists.
            methods: function (methodFilter) {
                var jsonResult = this.agmFacade.methods(JSON.stringify(methodFilter));
                return agmParse(jsonResult);
            },

            methodsForInstance: function (instanceFilter) {
                var jsonResult = this.agmFacade.methodsForInstance(JSON.stringify(instanceFilter));
                return agmParse(jsonResult);
            },

            // streaming support
            subscribe: function (name, options, successCallback, errorCallback) {
                var promise = new Promise(function (resolve, reject) {
                    if (options === undefined) {
                        options = {};
                    }
                    options.args = JSON.stringify(options.arguments || {});
                    options.target = targetArgToObject(options.target);

                    this.agmFacade.subscribe2(name,
                        JSON.stringify(options),
                        function (stream) {
                            resolve(stream);
                        },
                        function (error) {
                            reject(error);
                        }
                    );
                }.bind(this));

                return promisify(promise, successCallback, errorCallback);
            },

            createStream: function (streamDef, callbacks, successCallback, errorCallback) {
                var promise = new Promise(function (resolve, reject) {
                    if (typeof streamDef === 'string') {
                        streamDef = { name: streamDef };
                    }

                    if (!callbacks) {
                        callbacks = {};
                    }

                    this.agmFacade.createStream2(
                        JSON.stringify(streamDef),
                        // TODO - wrap to transform params
                        callbacks.subscriptionRequestHandler,
                        // TODO - wrap to transform params
                        callbacks.subscriptionAddedHandler,
                        // TODO - wrap to transform params
                        callbacks.subscriptionRemovedHandler,
                        // success handler
                        function (stream) {
                            resolve(stream);
                        },
                        // error handler
                        function (error) {
                            reject(error);
                        }
                    );
                }.bind(this));

                return promisify(promise, successCallback, errorCallback);
            }
        };

        // add metrics
        if (configuration !== undefined && configuration.metrics !== undefined) {
            configuration.metrics.metricsIdentity = configuration.metrics.identity;


            // quick and dirty - we need to stringify the configuration so we need to replace the metrics object (which has circular references)
            // with an object that holds only the properties needed
            var metricsConfig = {
                metricsIdentity: configuration.metrics.metricsIdentity,
                path: configuration.metrics.path
            };
            configuration.metrics = metricsConfig;
        }
        // remove the logger - we don't need it in HC and has circular references
        delete configuration.logger;

        // create new AGM faade for this instance
        result.instance = facade.init(JSON.stringify(configuration));
        result.agmFacade = facade;

        // deprecated API
        result.create_stream = result.createStream;
        result.methods_for_instance = result.methodsForInstance;
        result.method_added = result.methodAdded;
        result.method_removed = result.methodRemoved;
        result.server_added = result.serverAdded;
        result.server_removed = result.serverRemoved;
        result.server_method_added = result.serverMethodAdded;
        result.server_method_removed = result.serverMethodRemoved;

        resolve(result);
    });
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../package.json":60,"./helpers/promisify":45,"es6-promise":11}],40:[function(require,module,exports){
/*
 * Repository holding servers and methods visible by this peer including those created by the peer itself.
 */

var Callbacks = require('callback-registry');

module.exports = function () {
    'use strict';

    // each server has format {id:'', info:{}, methods:{}}
    // where methods has format {id:'', info:{}}
    var servers = {};

    // object keyed by method id - value is number of servers that offer that method
    var methodsCount = {};

    // store for callbacks
    var callbacks = new Callbacks();

    // add a new server to internal collection
    function addServer(info, serverId) {
        var current = servers[serverId];
        if (current) {
            return current.id;
        }

        var serverEntry = { id: serverId, info: info, methods: {} };
        serverEntry.getInfoForUser = function () {
            return createUserServerInfo(serverEntry.info);
        };

        servers[serverId] = serverEntry;
        callbacks.execute('onServerAdded', serverEntry);
        return serverId;
    }

    function removeServerById(id, reason) {
        var server = servers[id];

        Object.keys(server.methods).forEach(function (methodId) {
            removeServerMethod(id, methodId);
        });

        delete servers[id];
        callbacks.execute('onServerRemoved', server, reason);
    }

    function addServerMethod(serverId, method) {
        var server = servers[serverId];
        if (!server) {
            throw new Error('server does not exists');
        }

        var methodId = createMethodId(method);

        // server already has that method
        if (server.methods[methodId]) {
            return;
        }

        var methodEntity = { id: methodId, info: method };
        methodEntity.getInfoForUser = function () {
            return createUserMethodInfo(methodEntity.info);
        };
        server.methods[methodId] = methodEntity;

        // increase the ref and notify listeners
        if (!methodsCount[methodId]) {
            methodsCount[methodId] = 0;
            callbacks.execute('onMethodAdded', methodEntity);
        }
        methodsCount[methodId] = methodsCount[methodId] + 1;
        callbacks.execute('onServerMethodAdded', server, methodEntity);
    }

    function createMethodId(methodInfo) {
        // Setting properties to defaults:
        var accepts = methodInfo.accepts !== undefined ? methodInfo.accepts : '';
        var returns = methodInfo.returns !== undefined ? methodInfo.returns : '';
        var version = methodInfo.version !== undefined ? methodInfo.version : 0;
        return (methodInfo.name + accepts + returns + version).toLowerCase();
    }

    function removeServerMethod(serverId, methodId) {
        var server = servers[serverId];
        if (!server) {
            throw new Error('server does not exists');
        }

        var method = server.methods[methodId];
        delete server.methods[methodId];

        // update ref counting
        methodsCount[methodId] = methodsCount[methodId] - 1;
        if (methodsCount[methodId] === 0) {
            callbacks.execute('onMethodRemoved', method);
        }

        callbacks.execute('onServerMethodRemoved', server, method);
    }

    function getMethods() {

        var allMethods = {};
        Object.keys(servers).forEach(function (serverId) {
            var server = servers[serverId];
            Object.keys(server.methods).forEach(function (methodId) {
                var method = server.methods[methodId];
                allMethods[method.id] = method;
            })
        });

        var methodsAsArray = Object.keys(allMethods).map(function (id) {
            return allMethods[id];
        });

        return methodsAsArray;
    }

    function getServers() {
        var allServers = [];
        Object.keys(servers).forEach(function (serverId) {
            var server = servers[serverId];
            allServers.push(server)
        });

        return allServers;
    }

    function getServerMethodById(serverId) {
        var server = servers[serverId];

        return Object.keys(server.methods).map(function (id) {
            return server.methods[id];
        });
    }

    function onServerAdded(callback) {
        callbacks.add('onServerAdded', callback);

        // replay all servers
        getServers().forEach(function (server) {
            callback(server);
        });
    }

    function onMethodAdded(callback) {
        callbacks.add('onMethodAdded', callback);

        // reply all existing methods
        getMethods().forEach(function (method) {
            callback(method);
        })
    }

    function onServerMethodAdded(callback) {
        callbacks.add('onServerMethodAdded', callback);
        // TODO - the old version does not do this - confirm what is correct
    }

    function getServerById(id) {
        return servers[id];
    }

    /**
     * Transforms internal server object to user object
     * @param server
     * @returns {{machine: *, pid: *, started: *, user: *, application: *, environment: *, region: *, service_name: *, state: *}}
     */
    function createUserServerInfo(serverInfo) {
        return {
            machine: serverInfo.machine,
            pid: serverInfo.pid,
            user: serverInfo.user,
            application: serverInfo.application,
            environment: serverInfo.environment,
            region: serverInfo.region,
            instance: serverInfo.instance
        };
    }

    /**
     * Transforms internal method object to user object
     * @param method
     * @returns {{name: *, accepts: *, returns: *, description: *, display_name: *, version: *, object_types: (*|Array)}}
     */
    function createUserMethodInfo(methodInfo) {
        return {
            name: methodInfo.name,
            accepts: methodInfo.accepts,
            returns: methodInfo.returns,
            description: methodInfo.description,
            displayName : methodInfo.displayName,
            version: methodInfo.version,
            objectTypes: methodInfo.objectTypes,
            supportsStreaming: methodInfo.supportsStreaming
        };
    }

    return {
        getServerById: getServerById,
        getServers: getServers,
        getMethods: getMethods,
        getServerMethodsById: getServerMethodById,
        getMethodId: createMethodId,
        addServer: addServer,
        addServerMethod: addServerMethod,
        removeServerById: removeServerById,
        removeServerMethod: removeServerMethod,

        onServerAdded: onServerAdded,
        onServerRemoved: function (callback) {
            callbacks.add('onServerRemoved', callback);
        },
        onMethodAdded: onMethodAdded,
        onMethodRemoved: function (callback) {
            callbacks.add('onMethodRemoved', callback);
        },
        onServerMethodAdded: onServerMethodAdded,
        onServerMethodRemoved: function (callback) {
            callbacks.add('onServerMethodRemoved', callback);
        }
    }
};

},{"callback-registry":6}],41:[function(require,module,exports){
/*
 The streaming module defines the user objects relevant to the streaming api, and
 attaches to relevant events exposed by the protocol.
 */

module.exports = function (protocol, unregister) {
    'use strict';

    function streamFrontObj(repoMethod) {
        var def = repoMethod.definition;

        return {
            branches: function () {
                var bList = protocol.getBranchList(repoMethod);
                return bList.map(function (branchKey) {
                    return branchFrontObj(repoMethod, branchKey)
                });
            },
            close: function () {
                protocol.closeAllSubscriptions(repoMethod);
                unregister(repoMethod.definition);
            },
            definition: {
                accepts: def.accepts,
                description: def.description,
                displayName: def.displayName,
                name: def.name,
                objectTypes: def.objectTypes,
                returns: def.returns,
                supportsStreaming: def.supportsStreaming
            },
            name: def.name,
            push: function (data, branches) {
                if (typeof branches !== 'string' && !Array.isArray(branches) && branches !== undefined) {
                    throw new Error('invalid branches should be string or string array');
                }
                // TODO validate if is plain object
                if (typeof data !== 'object') {
                    throw new Error('Invalid arguments. Data must be an object.')
                }
                protocol.pushData(repoMethod, data, branches)
            },
            subscriptions: function () {
                var subList = protocol.getSubscriptionList(repoMethod);
                return subList.map(function (sub) {
                    return subscriptionFrontObj(repoMethod, sub)
                });
            }
        }
    }

    function subscriptionFrontObj(repoMethod, subscription) {
        return {
            arguments: subscription.arguments || {},
            branchKey: subscription.branchKey,
            close: function () {
                protocol.closeSingleSubscription(repoMethod, subscription)
            },
            instance: subscription.instance,
            push: function (data) {
                protocol.pushDataToSingle(repoMethod, subscription, data);
            },
            stream: repoMethod.definition
        };
    }

    function branchFrontObj(repoMethod, branchKey) {
        return {
            key: branchKey,
            subscriptions: function () {
                var subList = protocol.getSubscriptionList(repoMethod, branchKey);
                return subList.map(function (sub) {
                    return subscriptionFrontObj(repoMethod, sub)
                });
            },
            close: function () {
                protocol.closeAllSubscriptions(repoMethod, branchKey);
            },
            push: function (data) {
                protocol.pushToBranch(repoMethod, data, branchKey)
            }
        };
    }

    /** Attach to stream 'events' */
    protocol.onSubRequest(function (requestContext, repoMethod) {

        if (!(
            repoMethod &&
            repoMethod.streamCallbacks &&
            typeof repoMethod.streamCallbacks.subscriptionRequestHandler === 'function')
        ) {
            return;
        }

        repoMethod.streamCallbacks.subscriptionRequestHandler({
            accept: function () {
                protocol.acceptRequestOnBranch(requestContext, repoMethod, '');
            },
            acceptOnBranch: function (branch) {
                protocol.acceptRequestOnBranch(requestContext, repoMethod, branch)
            },
            arguments: requestContext.arguments,
            instance: requestContext.instance,
            reject: function (reason) {
                protocol.rejectRequest(requestContext, repoMethod, reason)
            }
        });
    });

    protocol.onSubAdded(function (subscription, repoMethod) {

        if (!(
            repoMethod &&
            repoMethod.streamCallbacks &&
            typeof repoMethod.streamCallbacks.subscriptionAddedHandler === 'function')
        ) {
            return;
        }

        repoMethod.streamCallbacks.subscriptionAddedHandler(subscriptionFrontObj(repoMethod, subscription))

    });

    protocol.onSubRemoved(function (subscriber, repoMethod) {

        if (!(
            repoMethod &&
            repoMethod.streamCallbacks &&
            typeof repoMethod.streamCallbacks.subscriptionRemovedHandler === 'function')
        ) {
            return;
        }

        repoMethod.streamCallbacks.subscriptionRemovedHandler(subscriber)

    });

    return { streamFrontObj: streamFrontObj };
};

},{}],42:[function(require,module,exports){
/*
 * A store for holding method back-objects registered by this instance's server
 */
module.exports = function () {
    'use strict';

    var nextId = 0;
    var _methods = [];

    function add(method) {
        if (typeof method !== 'object') {
            return;
        }

        if (method._repoId !== undefined) {
            return;
        }

        method._repoId = nextId;
        nextId += 1;

        _methods.push(method);

        return method;
    }

    function remove(repoId) {
        if (typeof repoId !== 'number') {
            return new TypeError('Expecting a number');
        }

        _methods = _methods.filter(function (m) {
            return m._repoId !== repoId;
        });
    }

    function getById(id) {
        if (typeof id !== 'number') {
            return new TypeError('Expecting a number');
        }

        return _methods.filter(function (m) {
            return m._repoId === id
        })[0];
    }

    function getList() {
        return _methods.map(function (m) {
            return m;
        });
    }

    function length() {
        return _methods.length;
    }

    return {
        add: add,
        remove: remove,
        getById: getById,
        getList: getList,
        length: length
    };
};

},{}],43:[function(require,module,exports){
/*
 The AGM Server allows users register AGM methods.
 It exposes these methods to AGM clients (using presence messages) and listens for their invocation
 */

var Promise = require('es6-promise').Promise;
var Promisify = require('./helpers/promisify');
var Streaming = require('./agm-server-streaming');

module.exports = function (protocol, vault, instance, configuration) {
    'use strict';

    // Save the reference to the metric function if it exists
    var metric = (configuration.metrics !== undefined) ? configuration.metrics.numberMetric.bind(configuration.metrics) : function () {
    };

    // An array of the server's methods
    var streaming = new Streaming(protocol, unregister);

    protocol.onInvoked(onMethodInvoked);

    var invocations = 0;

    function onMethodInvoked(methodToExecute, invocationId, invocationArgs) {
        metric('Invocations count', invocations++);

        if (!methodToExecute) {
            return;
        }

        // Execute it and save the result
        methodToExecute.theFunction(invocationArgs, function (err, result) {
            if (err) {
                // handle error case
                if (typeof err.message === 'string') {
                    err = err.message;
                } else if (typeof err !== 'string') {
                    err = '';
                }
            }

            // The AGM library only transfers objects. If the result is not an object, put it in one
            if (!result || typeof result !== 'object' || result.constructor === Array) {
                result = { _result: result };
            }

            protocol.methodInvocationResult(methodToExecute, invocationId, err, result)
        });
    }

    // registers a new agm method
    function register(methodDefinition, callback) {

        registerCore(methodDefinition, function (context, resultCallback) {
            // get the result as direct invocation of the callback and return it using resultCallback
            try {
                var result = callback(context.args, context.instance);
                resultCallback(null, result);
            } catch (e) {
                resultCallback(e, null);
            }
        });
    }

    // registers a new async agm method (the result can be returned in async way)
    function registerAsync(methodDefinition, callback) {

        registerCore(methodDefinition, function (context, resultCallback) {
            // invoke the callback passing success and error callbacks
            try {
                callback(context.args, context.instance,
                    // success callback
                    function (result) {
                        resultCallback(null, result);
                    },
                    // error callback
                    function (e) {
                        resultCallback(e, null);
                    });
            } catch (e) {
                resultCallback(e, null);
            }
        });
    }

    // Registers a new streaming agm method
    function createStream(streamDef, callbacks, successCallback, errorCallback) {
        // in callbacks we have subscriptionRequestHandler, subscriptionAddedHandler, subscriptionRemovedHandler

        var promise = new Promise(function (resolve, reject) {
            if (typeof streamDef === 'string') {

                if (streamDef === '') {
                    reject('Invalid stream name.');
                }

                streamDef = { name: streamDef };
            }

            streamDef.supportsStreaming = true;

            // User-supplied subscription callbacks
            if (!callbacks) {
                callbacks = {};
            }

            if (typeof callbacks.subscriptionRequestHandler !== 'function') {
                callbacks.subscriptionRequestHandler = function (request) {
                    request.accept();
                }
            }

            var repoMethod = {
                method: undefined, // to be initialized by protocol
                definition: streamDef, // store un-formatted definition for checkups in un-register method
                streamCallbacks: callbacks
            };

            // Add the method
            vault.add(repoMethod);

            protocol.createStream(repoMethod, streamDef,
                function protocolSuccess() {
                    metric('Registered methods', vault.length());

                    var streamFrobject = streaming.streamFrontObj(repoMethod);

                    resolve(streamFrobject);
                },
                function protocolFail(err) {
                    vault.remove(repoMethod._repoId);

                    reject(err);
                });
        });

        return new Promisify(promise, successCallback, errorCallback);
    }

    // Core method for registering agm method
    function registerCore(methodDefinition, theFunction) {
        // transform the definition
        if (typeof methodDefinition === 'string') {
            methodDefinition = { name: methodDefinition };
        }

        // Add the method ()
        var repoMethod = vault.add({
            definition: methodDefinition, // store un-formatted definition for checkups in un-register method
            theFunction: theFunction
        });

        protocol.register(repoMethod,
            function protocolSuccess() {
                metric('Registered methods', vault.length());
            },
            function protocolFail() {
                vault.remove(repoMethod._repoId);
            });
    }

    // Converts the method definition from camel case to snake case
    function containsProps(filter, object) {
        var match = true;
        Object.keys(filter).forEach(function (prop) {
            if (filter[prop] !== object[prop]) {
                match = false;
            }
        });
        return match;
    }


    // TODO add success/fail here and at gw1+2 implementations?
    // Unregisters a previously registered AGM method
    function unregister(methodFilter) {
        if (typeof methodFilter === 'string') {
            methodFilter = { name: methodFilter };
        }

        var methodsToBeRemoved = vault.getList().filter(function (method) {
            return containsProps(methodFilter, method.definition);
        });

        // update repository
        methodsToBeRemoved.forEach(function (method) {
            vault.remove(method._repoId);
            protocol.unregister(method);
        });

        metric('Registered methods', vault.length());
    }

    return { register: register, registerAsync: registerAsync, unregister: unregister, createStream: createStream };
};

},{"./agm-server-streaming":41,"./helpers/promisify":45,"es6-promise":11}],44:[function(require,module,exports){
(function (global){
var connection = require('tick42-gateway-connection');
var instance = require('./agm-instance');
var nativeAgm = require('./agm-native');
var deprecate = require('util-deprecate');
var pjson = require('../package.json');
var client = require('./agm-client');
var server = require('./agm-server');
var gW1Protocol = require('./protocols/gw1/protocol');
var gW3Protocol = require('./protocols/gw3/protocol');
var repository = require('./agm-repository');
var vault = require('./agm-server-vault');
var Promise = require('es6-promise').Promise;

// Add a global function that makes an AGM instance
agm = function (configuration) {
    'use strict';
    // We will store the library here
    var agm = {};
    agm.version = pjson.version;


    // Init configuration
    if (typeof configuration !== 'object') {
        configuration = {};
    }

    // Validate configuration

    // Init child configuration if it is not already passed by user
    var childConfigurations = ['connection', 'client', 'server'];
    childConfigurations.forEach(function (conf) {
        if (typeof configuration[conf] !== 'object') {
            configuration[conf] = {};
        }
        // Set debug if global debug is not set:
        if (configuration.debug) {
            configuration[conf].debug = true;
        }
    });

    if (typeof configuration.client.remove_server_on_n_missing_heartbeats !== 'number') {
        configuration.client.remove_server_on_n_missing_heartbeats = 3;
    }
    if (typeof configuration.client.method_response_timeout !== 'number') {
        configuration.client.method_response_timeout = 3000;
    }
    if (typeof configuration.client.wait_for_method_timeout !== 'number') {
        configuration.client.wait_for_method_timeout = 3000;
    }

    if (typeof configuration.server.heartbeat_interval !== 'number') {
        configuration.server.heartbeat_interval = 5000;
    }
    if (typeof configuration.server.presence_interval !== 'number') {
        configuration.server.presence_interval = 10000;
    }

    // Determine if we are given a connection object. If not, create it ourselves:
    var c = configuration.connection;
    agm.connection = (typeof c === 'object' && typeof c.send === 'function' && typeof c.on === 'function') ? c : connection(configuration.connection);

    // Create a connection proxy which sets the product name automatically
    var productName = 'agm';
    var agmEnabledConnection = {
        send: function (type, message) {
            agm.connection.send(productName, type, message);
        },
        on: function (type, handler) {
            agm.connection.on(productName, type, handler);
        },
        connected: agm.connection.connected,
        // TODO - stop wrapping connection , just extend it with sendAGM, onAGM
        getPeerId: function() {
            return agm.connection.peerId;
        }
    };
    // Save a reference to the root system object that we are given
    var metricsRoot = configuration.metrics;
    // Create subsystems for our modules and save them in their configuration.
    if (metricsRoot !== undefined) {
        configuration.client.metrics = metricsRoot.subSystem('Client');
        configuration.server.metrics = metricsRoot.subSystem('Server');
    }

    // Initialize our modules
    agm.instance = instance(configuration.instance);
    var clientRepository = repository();
    var serverRepository = vault();
    var protocolPromise;
    var protocolVersion = c.protocolVersion;
    if (protocolVersion === 3) {
        protocolPromise = gW3Protocol(agm.instance, agmEnabledConnection, clientRepository, serverRepository, configuration);
    } else {
        protocolPromise = gW1Protocol(agm.instance, agmEnabledConnection, clientRepository, serverRepository, configuration);
    }

    return new Promise(function(resolve, reject) {
        // wait for protocol to resolve
        protocolPromise.then(function (protocol) {
            agm.client = client(protocol, clientRepository, agm.instance, configuration.client);
            agm.server = server(protocol, serverRepository, agm.instance, configuration.server);

            // Add method aliases
            agm.invoke = agm.client.invoke;
            agm.register = agm.server.register;
            agm.registerAsync = agm.server.registerAsync;
            agm.unregister = agm.server.unregister;
            agm.createStream = agm.server.createStream;
            agm.subscribe = agm.client.subscribe;
            agm.servers = agm.client.servers;
            agm.methods = agm.client.methods;

            agm.methodsForInstance = agm.client.methodsForInstance;
            agm.method = agm.client.method;
            agm.methodAdded = agm.client.methodAdded;
            agm.methodRemoved = agm.client.methodRemoved;

            agm.serverMethodAdded = agm.client.serverMethodAdded;
            agm.serverMethodRemoved = agm.client.serverMethodRemoved;

            agm.serverAdded = agm.client.serverAdded;
            agm.serverRemoved = agm.client.serverRemoved;

            // deprecated API
            agm.methods_for_instance = deprecate(agm.client.methodsForInstance, 'glue.agm.client.methods_for_instance() is deprecated and might be removed from future versions of glue. Use glue.agm.client.methodsForInstance() instead');
            agm.method_added = deprecate(agm.client.methodAdded, 'glue.agm.method_added() is deprecated and might be removed from future versions of glue. Use glue.agm.methodAdded() instead');
            agm.method_removed = deprecate(agm.client.methodRemoved, 'glue.agm.method_removed() is deprecated and might be removed from future versions of glue. Use glue.agm.methodRemoved() instead');
            agm.server_method_added = deprecate(agm.client.serverMethodAdded, 'glue.agm.server_method_added() is deprecated and might be removed from future versions of glue. Use glue.agm.serverMethodAdded() instead');
            agm.server_method_removed = deprecate(agm.client.serverMethodRemoved, 'glue.agm.server_method_removed() is deprecated and might be removed from future versions of glue. Use glue.agm.serverMethodRemoved() instead');
            agm.server_added = deprecate(agm.client.serverAdded, 'glue.agm.server_added() is deprecated and might be removed from future versions of glue. Use glue.agm.serverAdded() instead');
            agm.server_removed = deprecate(agm.client.serverRemoved, 'glue.agm.server_removed() is deprecated and might be removed from future versions of glue. Use glue.agm.serverRemoved() instead');

            resolve(agm);

        })['catch'](function (err) {
            reject(err);
        });
    });

};
agm = global.htmlContainer !== undefined ? nativeAgm : agm;

// Export for browsers
if (global.tick42 === undefined) {
    global.tick42 = {};
}
global.tick42.agm = agm;

module.exports = agm;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../package.json":60,"./agm-client":37,"./agm-instance":38,"./agm-native":39,"./agm-repository":40,"./agm-server":43,"./agm-server-vault":42,"./protocols/gw1/protocol":50,"./protocols/gw3/protocol":56,"es6-promise":11,"tick42-gateway-connection":78,"util-deprecate":109}],45:[function(require,module,exports){
(function (global){
module.exports = function (promise, successCallback, errorCallback) {
    'use strict';
    if (typeof successCallback !== 'function' && typeof errorCallback !== 'function') {
        return promise;
    }

    if (typeof successCallback !== 'function') {
        successCallback = function () {
            if (global.console !== undefined && agm.debug === true) {
                console.log('Success!');
            }
        };
    } else if (typeof errorCallback !== 'function') {
        errorCallback = function () {
            if (global.console !== undefined && agm.debug === true) {
                console.log('An error occurred.');
            }
        };
    }

    promise.then(successCallback, errorCallback);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],46:[function(require,module,exports){
var cuid = require('cuid');

module.exports = function () {
    'use strict';
    return cuid();
};

},{"cuid":7}],47:[function(require,module,exports){
(function (global){
var random = require('./../../helpers/random');
var helpers = require('./helpers');

module.exports = function (configuration, instance, sendRequest, nextResponseSubject) {
    'use strict';

    var STATUS_AWAITING_ACCEPT = 'awaitingAccept'; // not even one server has accepted yet
    var STATUS_SUBSCRIBED = 'subscribed'; // at least one server has responded as 'Accepting'
    var ERR_MSG_SUB_FAILED = 'Subscription failed.';
    var ERR_MSG_SUB_REJECTED = 'Subscription rejected.';
    var ON_CLOSE_MSG_SERVER_INIT = 'ServerInitiated';
    var ON_CLOSE_MSG_CLIENT_INIT = 'ClientInitiated';

    var subscriptionsList = {};

    function subscribe(streamingMethod, argumentObj, targetServers, stuff, success, error) {
        if (targetServers.length === 0) {
            error(ERR_MSG_SUB_FAILED + ' No available servers matched the target params.');
            return;
        }

        // This same Id will be passed to all the servers (as 'InvocationId')
        // so they can respond back with it during the initial handshake
        var subscriptionId = 'subscriptionId_' + random();

        // Register the user's callbacks
        var pendingSub = registerSubscription(
            subscriptionId,
            streamingMethod,
            argumentObj,
            success,
            error,
            stuff.method_response_timeout
        );

        if (typeof pendingSub !== 'object') {
            error(ERR_MSG_SUB_FAILED + ' Unable to register the user callbacks.');
            return;
        }

        // Send a subscription request to each server
        targetServers.forEach(function (target) {

            // Get a response subject for this invocation
            var responseSubject = nextResponseSubject();

            // Add server to the list of ones the client is expecting a response from
            pendingSub.trackedServers.push({
                server: undefined,
                streamId: undefined,
                streamSubjects: {
                    global: undefined,
                    private: undefined
                },
                methodRequestSubject: streamingMethod.info.requestSubject,
                methodResponseSubject: responseSubject
            });

            // Construct a message
            var message = {
                EventStreamAction: 1, // "Subscribe" = client wishes to subscribe
                MethodRequestSubject: streamingMethod.info.requestSubject,
                MethodResponseSubject: responseSubject,
                Client: instance.info(),
                Context: {
                    ArgumentsJson: argumentObj,
                    InvocationId: subscriptionId,
                    ObjectType: stuff.object_type,
                    DisplayContext: stuff.display_context,
                    MethodName: streamingMethod.info.name,
                    ExecutionServer: target.server,
                    Timeout: stuff.method_response_timeout
                }
            };

            // Send it
            sendRequest(message);

            if (global.console !== undefined && configuration.debug === true) {
                console.debug('%c>>> sending MethodInvocationRequestMessage', 'background-color:hsla(198, 51%, 79%, 0.5)');
                console.debug('%c' + JSON.stringify(message), 'background-color:hsla(198, 51%, 79%, 0.5)');
            }

        });


    }

    function registerSubscription(subscriptionId, method, args, success, error, timeout) {

        subscriptionsList[subscriptionId] = {
            status: STATUS_AWAITING_ACCEPT,
            method: method,
            arguments: args,
            success: success,
            error: error,
            trackedServers: [],
            handlers: {
                onData: [],
                onClosed: []
                // onFailed: []
            },
            queued: {
                data: [],
                closers: []
            },
            timeoutId: undefined
        };


        subscriptionsList[subscriptionId].timeoutId = setTimeout(function () {
            if (subscriptionsList[subscriptionId] === undefined) {
                return; // no such subscription
            }

            var subscription = subscriptionsList[subscriptionId];


            if (subscription.status === STATUS_AWAITING_ACCEPT) {
                error({
                    method: method,
                    called_with: args,
                    message: ERR_MSG_SUB_FAILED + ' Subscription attempt timed out after ' + timeout + 'ms.'
                });

                // None of the target servers has answered the subscription attempt
                delete subscriptionsList[subscriptionId];

            } else if (subscription.status === STATUS_SUBSCRIBED &&
                subscription.trackedServers.length > 0) {
                // Clean the trackedServers, removing those without valid streamId
                subscription.trackedServers = subscription.trackedServers.filter(function (server) {
                    return (typeof server.streamId === 'string' && server.streamId !== '')
                });

                subscription.timeoutId = undefined;

                if (subscription.trackedServers.length === 0) {
                    // TODO this might be dead-code, where is closers.push?
                    // There are no open streams, some servers accepted then closed very quickly
                    //	(that's why the status changed but there's no good server with a StreamId)

                    // call the onClosed handlers
                    var closersCount = subscription.queued.closers.length;
                    var closingServer = (closersCount > 0) ? subscription.queued.closers[closersCount - 1] : null;

                    subscription.handlers.onClosed.forEach(function (callback) {
                        if (typeof callback === 'function') {
                            callback({
                                message: ON_CLOSE_MSG_SERVER_INIT,
                                requestArguments: subscription.arguments,
                                server: closingServer,
                                stream: subscription.method
                            })
                        }
                    });

                    delete subscriptionsList[subscriptionId];
                }
            }
        }, timeout);

        return subscriptionsList[subscriptionId]
    }

    function processPublisherMsg(msg) {
        if (!(msg && msg.EventStreamAction && msg.EventStreamAction !== 0)) {
            return;
        }

        if (msg.EventStreamAction === 2) {

            serverIsKickingASubscriber(msg);

        } else if (msg.EventStreamAction === 3) {

            serverAcknowledgesGoodSubscription(msg);

        } else if (msg.EventStreamAction === 5) {

            serverHasPushedSomeDataIntoTheStream(msg);
        }

    }

    /** msg 'Response' Actions */
    // action 2
    function serverIsKickingASubscriber(msg) {
        // Note: this might be either the server rejecting a subscription request OR closing an existing subscription

        // Get ALL subscriptions
        var keys = Object.keys(subscriptionsList);

        // If it is a rejection there may be an InvocationId, it can narrow the search
        if (typeof msg.InvocationId === 'string' && msg.InvocationId !== '') {
            keys = keys.filter(function (k) {
                return k === msg.InvocationId;
            })
        }

        var deletionsList = [];

        // Find the kicking/rejecting server and remove it from the subscription.trackedServers[]
        keys.forEach(function (key) {
            if (typeof subscriptionsList[key] !== 'object') {
                return;
            }

            subscriptionsList[key].trackedServers = subscriptionsList[key].trackedServers.filter(function (server) {
                var isRejecting = (
                    server.methodRequestSubject === msg.MethodRequestSubject && server.methodResponseSubject === msg.MethodResponseSubject
                );

                var isKicking = (
                    server.streamId === msg.StreamId &&
                    (server.streamSubjects.global === msg.EventStreamSubject || server.streamSubjects.private === msg.EventStreamSubject)
                );

                var isRejectingOrKicking = isRejecting || isKicking;

                return !isRejectingOrKicking;
            });

            if (subscriptionsList[key].trackedServers.length === 0) {
                deletionsList.push(key);
            }
        });

        // Call onClosed OR error()
        // and remove the subscription
        deletionsList.forEach(function (key) {
            if (typeof subscriptionsList[key] !== 'object') {
                return;
            }

            if (
                subscriptionsList[key].status === STATUS_AWAITING_ACCEPT &&
                typeof subscriptionsList[key].timeoutId === 'number'
            ) {

                var reason = (typeof msg.ResultMessage === 'string' && msg.ResultMessage !== '')
                    ? ' Publisher said "' + msg.ResultMessage + '".'
                    : ' No reason given.';

                var callArgs = typeof subscriptionsList[key].arguments === 'object'
                    ? JSON.stringify(subscriptionsList[key].arguments)
                    : '{}';

                subscriptionsList[key].error(ERR_MSG_SUB_REJECTED + reason + ' Called with:' + callArgs);
                clearTimeout(subscriptionsList[key].timeoutId);

            } else {

                // The timeout may or may not have expired yet,
                // but the status is 'subscribed' and trackedServers is now empty

                subscriptionsList[key].handlers.onClosed.forEach(function (callback) {
                    if (typeof callback !== 'function') {
                        return;
                    }

                    callback({
                        message: ON_CLOSE_MSG_SERVER_INIT,
                        requestArguments: subscriptionsList[key].arguments,
                        server: helpers.convertInfoToInstance(msg.Server),
                        stream: subscriptionsList[key].method
                    });
                });

            }

            delete subscriptionsList[key];

        });
    }

    // action 3
    function serverAcknowledgesGoodSubscription(msg) {

        var subscriptionId = msg.InvocationId;

        var subscription = subscriptionsList[subscriptionId];

        if (typeof subscription !== 'object') {
            return;
        }

        var acceptingServer = subscription.trackedServers.filter(function (server) {
            return (
                server.methodRequestSubject === msg.MethodRequestSubject &&
                server.methodResponseSubject === msg.MethodResponseSubject
            )
        })[0];

        if (typeof acceptingServer !== 'object') {
            return;
        }

        var isFirstResponse = (subscription.status === STATUS_AWAITING_ACCEPT);

        subscription.status = STATUS_SUBSCRIBED;

        var privateStreamSubject = generatePrivateStreamSubject(subscription.method.name);

        if (typeof acceptingServer.streamId === 'string' && acceptingServer.streamId !== '') {
            return; // already accepted previously
        }

        acceptingServer.server = helpers.convertInfoToInstance(msg.Server);
        acceptingServer.streamId = msg.StreamId;
        acceptingServer.streamSubjects.global = msg.EventStreamSubject;
        acceptingServer.streamSubjects.private = privateStreamSubject;
        // acceptingServer.methodResponseSubject stays the same

        var confirmatoryRequest = {
            EventStreamAction: 3, // "Subscribed" = client confirms intention to subscribe
            EventStreamSubject: privateStreamSubject,
            StreamId: msg.StreamId,
            MethodRequestSubject: msg.MethodRequestSubject,
            MethodResponseSubject: acceptingServer.methodResponseSubject,
            Client: instance.info(),
            Context: {
                ArgumentsJson: subscription.arguments,
                MethodName: subscription.method.name
            }
        };

        sendRequest(confirmatoryRequest);

        if (isFirstResponse) {
            // Pass in the subscription object
            subscription.success({
                onData: function (dataCallback) {
                    if (typeof dataCallback !== 'function') {
                        throw new TypeError('The data callback must be a function.')
                    }

                    this.handlers.onData.push(dataCallback)
                    if (this.handlers.onData.length === 1 && this.queued.data.length > 0) {
                        this.queued.data.forEach(function (dataItem) {
                            dataCallback(dataItem)
                        })
                    }
                }.bind(subscription),
                onClosed: function (closedCallback) {
                    if (typeof closedCallback !== 'function') {
                        throw new TypeError('The callback must be a function.')
                    }
                    this.handlers.onClosed.push(closedCallback)
                }.bind(subscription),
                onFailed: function () { /* Will not be implemented for browser. */
                },
                close: closeSubscription.bind(subscription, subscriptionId),
                requestArguments: subscription.arguments,
                serverInstance: helpers.convertInfoToInstance(msg.Server),
                stream: subscription.method
            });
        }
    }

    // action 5
    function serverHasPushedSomeDataIntoTheStream(msg) {

        // Find the subscription of interest by trawling the dictionary
        for (var key in subscriptionsList) {
            if (subscriptionsList.hasOwnProperty(key) && typeof subscriptionsList[key] === 'object') {

                var isPrivateData;

                var trackedServersFound = subscriptionsList[key].trackedServers.filter(function (ls) {
                    return (
                        ls.streamId === msg.StreamId &&
                        (ls.streamSubjects.global === msg.EventStreamSubject ||
                        ls.streamSubjects.private === msg.EventStreamSubject)
                    );
                });

                if (trackedServersFound.length === 0) {
                    isPrivateData = undefined;
                } else if (trackedServersFound[0].streamSubjects.global === msg.EventStreamSubject) {
                    isPrivateData = false;
                } else if (trackedServersFound[0].streamSubjects.private === msg.EventStreamSubject) {
                    isPrivateData = true;
                }

                if (isPrivateData !== undefined) {
                    // create the arrivedData object
                    var receivedStreamData = {
                        data: msg.ResultContextJson,
                        server: helpers.convertInfoToInstance(msg.Server),
                        requestArguments: subscriptionsList[key].arguments || {},
                        message: msg.ResultMessage,
                        private: isPrivateData
                    };

                    var onDataHandlers = subscriptionsList[key].handlers.onData;
                    var queuedData = subscriptionsList[key].queued.data;

                    if (Array.isArray(onDataHandlers)) {
                        if (onDataHandlers.length > 0) {
                            onDataHandlers.forEach(function (callback) {
                                if (typeof callback === 'function') {
                                    callback(receivedStreamData)
                                }
                            })
                        } else {
                            queuedData.push(receivedStreamData)
                        }
                    }
                }
            }
        }// end for-in
    }

    /** (subscription) Methods */
    function closeSubscription(subId) {

        var responseSubject = nextResponseSubject();

        this.trackedServers.forEach(function (server) {
            sendRequest({
                EventStreamAction: 2,
                Client: instance.info(),
                MethodRequestSubject: server.methodRequestSubject,
                MethodResponseSubject: responseSubject,
                StreamId: server.streamId,
                EventStreamSubject: server.streamSubjects.private
            });
        });

        var sub = this;

        // Call the onClosed handlers
        this.handlers.onClosed.forEach(function (callback) {
            if (typeof callback === 'function') {
                callback({
                    message: ON_CLOSE_MSG_CLIENT_INIT,
                    requestArguments: sub.arguments || {},
                    server: sub.trackedServers[sub.trackedServers.length - 1].server, // the last one of multi-server subscription
                    stream: sub.method
                })
            }
        });

        delete subscriptionsList[subId];
    }

    function generatePrivateStreamSubject(methodName) {

        var appInfo = instance.info();

        var privateStreamSubject = 'ESSpriv-jsb_' +
            appInfo.ApplicationName +
            '_on_' +
            methodName +
            '_' +
            random();

        return privateStreamSubject;
    }

    return { // an instance of the streaming module
        subscribe: subscribe,
        processPublisherMsg: processPublisherMsg
    };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../helpers/random":46,"./helpers":49}],48:[function(require,module,exports){
var random = require('./../../helpers/random');
var callbackRegistry = require('callback-registry');
var Streaming = require('./client-streaming');
var helpers = require('./helpers');

module.exports = function (connection, instance, configuration, repository) {
    'use strict';
    var timers = {};
    var respCounter = 0;
    var callbacks = callbackRegistry();

    var streaming = new Streaming(
        configuration,
        instance,
        function (m) {
            connection.send('MethodInvocationRequestMessage', m)
        },
        nextResponseSubject
    );

    function nextResponseSubject() {
        return 'resp_' + (respCounter++) + '_' + random();
    }

    function createServerInfo(instance) {
        return {
            machine: instance.MachineName,
            pid: instance.ProcessId,
            started: instance.ProcessStartTime,
            user: instance.UserName,
            application: instance.ApplicationName,
            environment: instance.Environment,
            region: instance.Region,
            service_name: instance.ServiceName,
            metrics_repository_id: instance.MetricsRepositoryId,
            state: instance.State
        };
    }

    function createMethod(methodInfo) {
        var method = methodInfo.Method;
        return {
            name: method.Name,
            accepts: method.InputSignature,
            returns: method.ResultSignature,
            requestSubject: methodInfo.MethodRequestSubject,
            description: method.Description,
            displayName: method.DisplayName,
            version: method.Version,
            objectTypes: method.ObjectTypeRestrictions,
            supportsStreaming: helpers.isStreamingFlagSet(method.Flags)
        };
    }

    // Generates a unique ID for a server
    function createServerId(serverInfo) {
        if (serverInfo === undefined) {
            return undefined;
        }

        return [serverInfo.application,
            serverInfo.user,
            serverInfo.machine,
            serverInfo.started,
            serverInfo.pid].join('/').toLowerCase();
    }

    function processServerPresence(presence, isPresence) {

        var instance = presence.Instance;
        var serverInfo = createServerInfo(instance);
        var serverId = createServerId(serverInfo);

        if (isPresence) {
            // test
            // console.debug(new Date(), '  heard presence');
            // if (instance.ApplicationName === 'Dummy server') {
            //     console.debug(new Date(), '  got Dummy server presence', presence);
            // }

            serverId = repository.addServer(serverInfo, serverId);

            if (presence.PublishingInterval) {
                scheduleTimeout(serverId, presence.PublishingInterval);
            }
        }

        // Finally, update the methods
        if (presence.MethodDefinitions !== undefined) {
            updateServerMethods(serverId, presence.MethodDefinitions);
        }
    }

    // This function sets a timeout which removes the server unless - the function is called again before the timeout is over
    function scheduleTimeout(serverId, duration) {

        if (duration === -1) {
            return;
        }
        // Stop the previous timeout
        var timer = timers[serverId];
        if (timer !== undefined) {
            clearTimeout(timer);
        }

        // Set a new one
        timers[serverId] = setTimeout(function () {
            repository.removeServerById(serverId);
        }, duration * (configuration.client.remove_server_on_n_missing_heartbeats + 1));
    }

    // Updates the methods of a server
    function updateServerMethods(serverId, newMethods) {

        // Get an array of the methods the server had before we started this
        var oldMethods = repository.getServerMethodsById(serverId);

        // Get an array of the methods that the server has now
        newMethods = newMethods.map(createMethod).reduce(function (obj, method) {
            var methodId = repository.getMethodId(method);
            obj[methodId] = method;
            return obj;
        }, {});

        // For each of the old methods
        Object.keys(oldMethods).forEach(function (methodId) {
            var method = oldMethods[methodId];
            // Check if it is still there
            if (newMethods[method.id] === undefined) {
                // If it isn't, remove it
                repository.removeServerMethod(serverId, method.id);
            } else {
                // If it is there in both the old array and the new one, we don't need to add it again
                delete newMethods[method.id];
            }
        });
        // Now add the new methods
        Object.keys(newMethods).forEach(function (key) {
            var method = newMethods[key];
            repository.addServerMethod(serverId, method);
        });
    }

    function invoke(id, method, args, target, stuff) {

        var methodInfo = method.info;
        // Construct a message
        var message = {
            MethodRequestSubject: methodInfo.requestSubject,
            MethodResponseSubject: nextResponseSubject(),
            Client: instance.info(),
            Context: {
                ArgumentsJson: args,
                InvocationId: id,
                ObjectType: stuff.object_type,
                DisplayContext: stuff.display_context,
                MethodName: methodInfo.name,
                ExecutionServer: target.info,
                Timeout: stuff.method_response_timeout
            }
        };

        connection.send('MethodInvocationRequestMessage', message);
    }

    function handleInvokeResultMessage(message) {

        // Delegate streaming-related messages to streaming
        if (message && message.EventStreamAction && message.EventStreamAction !== 0) {
            streaming.processPublisherMsg(message);
            return;
        }

        var server = message.Server ? createServerInfo(message.Server) : undefined;

        // parse the result
        var result = message.ResultContextJson;
        // If the result is an empty object, there is no result
        if (result && Object.keys(result).length === 0) {
            result = undefined;
        }

        callbacks.execute('onResult', message.InvocationId, server, message.Status, result, message.ResultMessage);
    }

    function onInvocationResult(callback) {
        callbacks.add('onResult', callback);
    }

    function listenForEvents() {
        connection.on('ServerPresenceMessage', function (msg) {
            processServerPresence(msg, true);
        });
        connection.on('ServerHeartbeatMessage', function (msg) {
            processServerPresence(msg, false);
        });
        connection.on('MethodInvocationResultMessage', handleInvokeResultMessage);
    }

    listenForEvents();

    return {
        invoke: invoke,
        onInvocationResult: onInvocationResult,
        subscribe: streaming.subscribe
    }
};

},{"./../../helpers/random":46,"./client-streaming":47,"./helpers":49,"callback-registry":6}],49:[function(require,module,exports){
/*
* Helper functions used only in this protocol.
* */

function convertInfoToInstance(info) {
    'use strict';

    if (typeof info !== 'object') {
        info = {};
    }

    return {
        application: info.ApplicationName,
        environment: info.Environment,
        machine: info.MachineName,
        pid: info.ProcessId,
        region: info.Region,
        service: info.ServiceName,
        user: info.UserName,
        started: info.ProcessStartTime
    }
}

function isStreamingFlagSet(flags) {
    'use strict';

    if (typeof flags !== 'number' || isNaN(flags)) {
        return false;
    }

    // checking the largest Bit using bitwise ops
    var mask = 32;
    var result = flags & mask;

    return result === mask;
}

module.exports =  {
    isStreamingFlagSet: isStreamingFlagSet,
    convertInfoToInstance: convertInfoToInstance
};

},{}],50:[function(require,module,exports){
var ServerProtocol = require('./server.js');
var ClientProtocol = require('./client.js');
var Promise = require('es6-promise').Promise;

module.exports = function (instance, connection, repository, vault, configuration) {
    'use strict';
    connection.on('Instance', instance._updateIdentity);

    var serverProtocol = new ServerProtocol(connection, instance, configuration, vault);
    var clientProtocol = new ClientProtocol(connection, instance, configuration, repository);

    return new Promise(function (resolve) {

        resolve({
            // method-related
            invoke: clientProtocol.invoke,
            onInvocationResult: clientProtocol.onInvocationResult,
            register: serverProtocol.register,
            unregister: serverProtocol.unregister,
            onInvoked: serverProtocol.onInvoked,
            methodInvocationResult: serverProtocol.methodInvocationResult,

            // stream-related
            subscribe: clientProtocol.subscribe,
            createStream: serverProtocol.createStream,
            getBranchList: serverProtocol.getBranchList,
            getSubscriptionList: serverProtocol.getSubscriptionList,
            closeAllSubscriptions: serverProtocol.closeAllSubscriptions,
            closeSingleSubscription: serverProtocol.closeSingleSubscription,
            pushData: serverProtocol.pushData,
            pushDataToSingle: serverProtocol.pushDataToSingle,
            onSubRequest: serverProtocol.onSubRequest,
            acceptRequestOnBranch: serverProtocol.acceptRequestOnBranch,
            rejectRequest: serverProtocol.rejectRequest,
            onSubAdded: serverProtocol.onSubAdded,
            onSubRemoved: serverProtocol.onSubRemoved
        });
    });
};

},{"./client.js":48,"./server.js":52,"es6-promise":11}],51:[function(require,module,exports){
var random = require('./../../helpers/random');
// TODO use Callbacks = require(~)
var helpers = require('./helpers');

module.exports = function (connection, instance) {
    'use strict';
    // TODO extract these into Callbacks
    var requestHandler = null;
    var subAddedHandler = null;
    var subRemovedHandler = null;

    function sendResult(message) {
        if (typeof message !== 'object') {
            throw new Error('Invalid message.');
        }

        if (typeof message.Status !== 'number') {
            message.Status = 0;
        }

        connection.send('MethodInvocationResultMessage', message);
    }

    function isStreamMsgForStreamingMethod(msg, method) {
        return (
            msg &&
            msg.EventStreamAction &&
            msg.EventStreamAction !== 0 &&
            typeof method === 'object' &&
            method.definition.supportsStreaming === true
        );
    }

    function processSubscriberMsg(msg, streamingMethod) {
        if (!(msg && msg.EventStreamAction && msg.EventStreamAction !== 0)) {
            return;
        }

        if (msg.EventStreamAction === 1) {
            clientWishesToSubscribe(msg, streamingMethod);

        } else if (msg.EventStreamAction === 2) {
            clientWishesToUnsubscribe(msg, streamingMethod);

        } else if (msg.EventStreamAction === 3) {
            clientAcknowledgesItDidSubscribe(msg, streamingMethod);

        } else if (msg.EventStreamAction === 4) {
            clientPerSubHeartbeat(msg);
        }
    }

    /** msg 'Request' Actions */
    // action 1
    function clientWishesToSubscribe(msg, streamingMethod) {

        var requestContext = {
            msg: msg,
            arguments: msg.Context.ArgumentsJson || {},
            instance: helpers.convertInfoToInstance(msg.Client)
        };

        if (typeof requestHandler === 'function') {
            requestHandler(requestContext, streamingMethod);
        }
    }

    // action 2
    function clientWishesToUnsubscribe(msg, streamingMethod) {

        if (!(
            streamingMethod &&
            Array.isArray(streamingMethod.subscriptions) &&
            streamingMethod.subscriptions.length > 0)
        ) {
            return;
        }

        closeIndividualSubscription(streamingMethod, msg.StreamId, msg.EventStreamSubject, false)
    }

    // action 3
    function clientAcknowledgesItDidSubscribe(msg, streamingMethod) {
        // Client indicates it is listening to a specific StreamId

        if (typeof msg.StreamId !== 'string' || msg.StreamId === '') {
            return;
        }

        var branchKey = getBranchKey(streamingMethod, msg.StreamId);

        if (typeof branchKey !== 'string') {
            return;
        }

        if (!Array.isArray(streamingMethod.subscriptions)) {
            return;
        }

        var subscription = {
            branchKey: branchKey,
            instance: helpers.convertInfoToInstance(msg.Client),
            arguments: msg.Context.ArgumentsJson,
            streamId: msg.StreamId,
            privateEventStreamSubject: msg.EventStreamSubject,
            methodResponseSubject: msg.MethodResponseSubject
        };

        // Subscription back-obj is stored
        streamingMethod.subscriptions.push(subscription);

        if (typeof subAddedHandler === 'function') {
            subAddedHandler(subscription, streamingMethod);
        }
    }

    // action 4
    function clientPerSubHeartbeat() {
        // A client may have multiple subscriptions, each one having its own heartbeat
        // Currently not implemented by the GW or the client
    }


    /** (request) Methods */
    function acceptRequestOnBranch(requestContext, streamingMethod, branch) {
        if (typeof branch !== 'string') {
            branch = '';
        }

        var streamId = getStreamId(streamingMethod, branch);

        var msg = requestContext.msg;

        sendResult({
            EventStreamAction: 3,
            EventStreamSubject: streamingMethod.globalEventStreamSubject,
            InvocationId: msg.Context.InvocationId,
            MethodName: streamingMethod.method.Method.Name,
            MethodRequestSubject: streamingMethod.method.MethodRequestSubject,
            MethodResponseSubject: msg.MethodResponseSubject,
            MethodVersion: streamingMethod.method.Method.Version,
            ResultMessage: 'Accepted',
            Server: instance.info(),
            StreamId: streamId
        });
    }

    function getBranchKey(streamingMethod, streamId) {
        if (typeof streamId !== 'string' || typeof streamingMethod !== 'object') {
            return;
        }

        var needle = streamingMethod.branchKeyToStreamIdMap.filter(function (branch) {
            return branch.streamId === streamId;
        })[0];

        if (typeof needle !== 'object' || typeof needle.key !== 'string') {
            return;
        }

        return needle.key;
    }

    function getStreamId(streamingMethod, branchKey) {
        if (typeof branchKey !== 'string') {
            branchKey = '';
        }

        var needleBranch = streamingMethod.branchKeyToStreamIdMap.filter(function (branch) {
            return branch.key === branchKey;
        })[0];

        var streamId = (needleBranch ? needleBranch.streamId : undefined);

        if (typeof    streamId !== 'string' || streamId === '') {
            streamId = generateNewStreamId(streamingMethod.method.Method.Name);
            streamingMethod.branchKeyToStreamIdMap.push({ key: branchKey, streamId: streamId });
        }

        return streamId;
    }

    function generateNewStreamId(streamingMethodName) {
        var appInfo = instance.info();

        var newStreamId = 'streamId-jsb_of_' +
            streamingMethodName +
            '__by_' +
            appInfo.ApplicationName +
            '_' +
            random();

        return newStreamId;
    }

    function rejectRequest(requestContext, streamingMethod, reason) {
        if (typeof reason !== 'string') {
            reason = '';
        }

        var msg = requestContext.msg;

        sendResult({
            EventStreamAction: 2,
            EventStreamSubject: streamingMethod.globalEventStreamSubject,
            // InvocationId: msg.Context.InvocationId,
            MethodName: streamingMethod.method.Method.Name,
            MethodRequestSubject: streamingMethod.method.MethodRequestSubject,
            MethodResponseSubject: msg.MethodResponseSubject,
            MethodVersion: streamingMethod.method.Method.Version,
            ResultMessage: reason,
            Server: instance.info(),
            StreamId: 'default_rejection_streamId'
        });
    }

    /** (subscription) Methods */
    function closeIndividualSubscription(streamingMethod, streamId, privateEventStreamSubject, sendKickMessage) {

        var subscription = streamingMethod.subscriptions.filter(function (subItem) {
            return (
                subItem.privateEventStreamSubject === privateEventStreamSubject &&
                subItem.streamId === streamId
            );
        })[0];

        if (typeof subscription !== 'object') {
            return; // unrecognised subscription
        }

        var initialLength = streamingMethod.subscriptions.length;

        streamingMethod.subscriptions = streamingMethod.subscriptions.filter(function (subItem) {
            return !(
                subItem.privateEventStreamSubject === subscription.privateEventStreamSubject &&
                subItem.streamId === subscription.streamId
            );
        });

        var filteredLength = streamingMethod.subscriptions.length;

        if (filteredLength !== (initialLength - 1)) {
            return; // the subscription wasn't removed
        }

        if (sendKickMessage === true) {
            sendResult({
                EventStreamAction: 2,
                EventStreamSubject: privateEventStreamSubject,
                MethodName: streamingMethod.method.Method.Name,
                MethodRequestSubject: streamingMethod.method.MethodRequestSubject,
                MethodResponseSubject: subscription.methodResponseSubject,
                MethodVersion: streamingMethod.method.Method.Version,
                ResponseContextJson: {},
                Server: instance.info(),
                StreamId: subscription.streamId,
                Status: 0
            });
        }

        if (typeof subRemovedHandler === 'function') {
            var subscriber = subscription.instance;
            subRemovedHandler(subscriber, streamingMethod)
        }
    }

    function closeMultipleSubscriptions(streamingMethod, branchKey) {
        if (typeof streamingMethod !== 'object' || !Array.isArray(streamingMethod.branchKeyToStreamIdMap)) {
            return;
        }

        var streamList = streamingMethod.branchKeyToStreamIdMap;

        if (typeof branchKey === 'string') {
            streamList = streamingMethod.branchKeyToStreamIdMap.filter(function (br) {
                return (typeof br === 'object' && br.key === branchKey);
            });
        }

        // TODO: consider getting the unique branch keys from 'live subscribers'

        streamList.forEach(function (br) {
            var streamId = br.streamId;

            sendResult({
                EventStreamAction: 2,
                EventStreamSubject: streamingMethod.globalEventStreamSubject,
                MethodName: streamingMethod.method.Method.Name,
                MethodRequestSubject: streamingMethod.method.MethodRequestSubject,
                Server: instance.info(),
                StreamId: streamId,
                Status: 0
            });
        });
    }

    function closeSingleSubscription(streamingMethod, subscription) {
        closeIndividualSubscription(
            streamingMethod,
            subscription.streamId,
            subscription.privateEventStreamSubject,
            true
        );
    }

    function pushDataToSingle(streamingMethod, subscription, data) {

        // TODO validate data is a plain object
        if (typeof data !== 'object') {
            throw new Error('Invalid arguments. Data must be an object.');
        }

        sendResult({
            EventStreamAction: 5,
            EventStreamSubject: subscription.privateEventStreamSubject,
            MethodName: streamingMethod.method.Method.Name,
            MethodRequestSubject: streamingMethod.method.MethodRequestSubject,
            ResultContextJson: data,
            Server: instance.info(),
            StreamId: subscription.streamId
        });
    }

    function pushToBranch(streamingMethod, data, branches) {
        if (typeof streamingMethod !== 'object' || !Array.isArray(streamingMethod.branchKeyToStreamIdMap)) {
            return;
        }

        // TODO validate data is a plain object
        if (typeof data !== 'object') {
            throw new Error('Invalid arguments. Data must be an object.');
        }

        if (typeof branches === 'string') {
            branches = [branches]; // user wants to push to single branch
        } else if (!Array.isArray(branches) || branches.length <= 0) {
            branches = null;
        }

        // get the StreamId's from the method's branch map
        var streamIdList = streamingMethod.branchKeyToStreamIdMap
            .filter(function (br) {
                return (
                    branches === null || (Boolean(br) && typeof br.key === 'string' && branches.indexOf(br.key) >= 0)
                );
            }).map(function (br) {
                return br.streamId;
            });

        streamIdList.forEach(function (streamId) {

            sendResult({
                EventStreamAction: 5,
                EventStreamSubject: streamingMethod.globalEventStreamSubject,
                MethodName: streamingMethod.method.Method.Name,
                MethodRequestSubject: streamingMethod.method.MethodRequestSubject,
                ResultContextJson: data,
                Server: instance.info(),
                StreamId: streamId
            });

        });
    }

    function getSubscriptionList(streamingMethod, branchKey) {
        if (typeof streamingMethod !== 'object') {
            return [];
        }

        var subscriptions = [];

        if (typeof branchKey !== 'string') {
            subscriptions = streamingMethod.subscriptions;
        } else {
            subscriptions = streamingMethod.subscriptions.filter(function (sub) {
                return sub.branchKey === branchKey;
            });
        }

        return subscriptions;
    }

    function getBranchList(streamingMethod) {
        if (typeof streamingMethod !== 'object') {
            return [];
        }

        return getUniqueBranchNames(streamingMethod);

        // TODO the agm-api passes each sub to protocol methods for creating the sub front obj
    }

    // Returns the names of branches for which there are live subscriptions
    function getUniqueBranchNames(streamingMethod) {
        var keysWithDuplicates = streamingMethod.subscriptions.map(function (sub) {
            var result = null;
            if (typeof sub === 'object' && typeof sub.branchKey === 'string') {
                result = sub.branchKey;
            }
            return result;
        });

        var seen = [];

        var branchArray = keysWithDuplicates.filter(function (bKey) {
            if (bKey === null || seen.indexOf(bKey) >= 0) {
                return false;
            }
            seen.push(bKey);
            return true;
        });

        return branchArray;
    }

    /** setting user-provided handlers */ // TODO replace innerds with callback.js
    function addRequestHandler(handlerFunc) {
        if (typeof handlerFunc !== 'function') {
            return;
        }

        requestHandler = handlerFunc;
    }

    function addSubAddedHandler(handlerFunc) {
        if (typeof handlerFunc !== 'function') {
            return;
        }

        subAddedHandler = handlerFunc;
    }

    function addSubRemovedHandler(handlerFunc) {
        if (typeof handlerFunc !== 'function') {
            return;
        }

        subRemovedHandler = handlerFunc;
    }

    return { // an instance of the publisher
        isStreamMsg: isStreamMsgForStreamingMethod,
        processSubscriberMsg: processSubscriberMsg,
        pushData: pushToBranch,
        pushDataToSingle: pushDataToSingle,
        closeAllSubscriptions: closeMultipleSubscriptions,
        closeSingleSubscription: closeSingleSubscription,
        getSubscriptionList: getSubscriptionList,
        getBranchList: getBranchList,
        onSubRequest: addRequestHandler,
        acceptRequestOnBranch: acceptRequestOnBranch,
        rejectRequest: rejectRequest,
        onSubAdded: addSubAddedHandler,
        onSubRemoved: addSubRemovedHandler,
        generateNewStreamId: generateNewStreamId

    };
};

},{"./../../helpers/random":46,"./helpers":49}],52:[function(require,module,exports){
var random = require('./../../helpers/random');
var callbackRegistry = require('callback-registry');
var Streaming = require('./server-streaming');
var helpers = require('./helpers');

module.exports = function (connection, instance, configuration, vault) {
    'use strict';
    var invocationMessagesMap = {};  // {invocationId: Invocation_RequestMessage}

    var reqCounter = 0;
    var presenceTimer;
    var heartbeatTimer;
    var callbacks = callbackRegistry();
    var streaming = new Streaming(connection, instance);

    connection.on('MethodInvocationRequestMessage', handleMethodInvocationMessage);

    if (heartbeatTimer === undefined) {
        heartbeatTimer = setInterval(sendHeartbeat, configuration.server.heartbeat_interval);
    }

    function nextRequestSubject() {
        return 'req_' + (reqCounter++) + '_' + random();
    }

    // Constructs a heartbeat message
    function constructHeartbeat() {
        return {
            PublishingInterval: configuration.server.heartbeat_interval,
            Instance: instance.info()
        };
    }

    // Constructs a presence message
    function constructPresence() {
        var methods = vault.getList();

        return {
            PublishingInterval: configuration.server.presence_interval,
            Instance: instance.info(),
            MethodDefinitions: methods.map(function (m) {
                return m.method
            })
        };
    }

    // Sends a presence
    function sendPresence() {
        connection.send('ServerPresenceMessage', constructPresence());
    }

    // Sends a heartbeat
    function sendHeartbeat() {
        connection.send('ServerHeartbeatMessage', constructHeartbeat());
    }

    function createNewMethodMessage(methodIdentifier, subject) {
        // If we are given a string instead of an object, we presume that is the method's name:
        if (typeof methodIdentifier === 'string') {
            methodIdentifier = { name: methodIdentifier };
        }

        // Set default values
        if (typeof methodIdentifier.version !== 'number') {
            methodIdentifier.version = 0;
        }

        // Convert the method definition to the format that AGM requires
        return {
            Method: {
                Name: methodIdentifier.name,
                InputSignature: methodIdentifier.accepts,
                ResultSignature: methodIdentifier.returns,
                Description: methodIdentifier.description,
                DisplayName: methodIdentifier.displayName,
                Version: methodIdentifier.version,
                ObjectTypeRestrictions: methodIdentifier.objectTypes
            },
            MethodRequestSubject: subject
        };
    }

    function register(repoMethod, success) {

        // Get a request subject for this method
        var reqSubj = nextRequestSubject();

        repoMethod.method = createNewMethodMessage(repoMethod.definition, reqSubj);

        announceNewMethod();

        success();
    }

    /** Create a streaming method */
    function createStream(repoMethod, streamDef, success) {

        var reqSubj = nextRequestSubject();

        var streamConverted = createNewMethodMessage(streamDef, reqSubj);
        streamConverted.Method.Flags = 32; // 100000 bitmask with the largest flag (streaming: true)

        // Used for presences
        repoMethod.method = streamConverted;

        // Utility things for this protocol
        repoMethod.globalEventStreamSubject = streamDef.name + '.jsStream.' + random();
        repoMethod.subscriptions = [];
        repoMethod.branchKeyToStreamIdMap = []; // [ {branchKey: '', streamId: 'strj_nds7`8`6y2378yb'}, {...}, ...]

        announceNewMethod();

        success();
    }

    function announceNewMethod() {

        // Send presence so the clients know we have it
        sendPresence();

        // Start sending presence regularly (if we aren't already doing it)
        if (presenceTimer === undefined) {
            presenceTimer = setInterval(sendPresence, configuration.server.presence_interval);
        }
    }

    // Listens for method invocations
    function handleMethodInvocationMessage(message) {
        var subject = message.MethodRequestSubject;
        var methodList = vault.getList();

        var method = methodList.filter(function (m) {
            return m.method.MethodRequestSubject === subject;
        })[0];

        // Stop if the message isn't for us
        if (method === undefined) {
            return;
        }

        // TODO see if have to move this earlier - i.e. if some messages from Client don't have MethodRequestSubject
        // Check if message is stream-related : defer to streaming module
        if (streaming.isStreamMsg(message, method)) {
            streaming.processSubscriberMsg(message, method);
            return;
        }

        var invocationId = message.Context.InvocationId;
        invocationMessagesMap[invocationId] = message;

        var invocationArgs = {
            args: message.Context.ArgumentsJson,
            instance: helpers.convertInfoToInstance(message.Client)
        };
        callbacks.execute('onInvoked', method, invocationId, invocationArgs);
    }

    function onInvoked(callback) {
        callbacks.add('onInvoked', callback);
    }

    function methodInvocationResult(executedMethod, invocationId, err, result) {

        var message = invocationMessagesMap[invocationId];
        if (!message) {
            return;
        }

        // Don't send result if the client does not require it
        if (message.MethodResponseSubject === 'null') {
            return;
        }

        if (executedMethod === undefined) {
            return;
        }

        var resultMessage = {
            MethodRequestSubject: message.MethodRequestSubject,
            MethodResponseSubject: message.MethodResponseSubject,
            MethodName: executedMethod.method.Method.Name,
            InvocationId: invocationId,
            ResultContextJson: result,
            Server: instance.info(),
            ResultMessage: err,
            Status: err ? 1 : 0
        };
        // Send result
        connection.send('MethodInvocationResultMessage', resultMessage);

        delete invocationMessagesMap[invocationId];
    }

    function unregister() {
        sendPresence();
    }

    return {
        register: register,
        onInvoked: onInvoked,
        methodInvocationResult: methodInvocationResult,
        unregister: unregister,

        // stream-related
        createStream: createStream,
        getBranchList: streaming.getBranchList,
        getSubscriptionList: streaming.getSubscriptionList,
        closeAllSubscriptions: streaming.closeAllSubscriptions,
        closeSingleSubscription: streaming.closeSingleSubscription,
        pushDataToSingle: streaming.pushDataToSingle,
        pushData: streaming.pushData,
        onSubRequest: streaming.onSubRequest,
        acceptRequestOnBranch: streaming.acceptRequestOnBranch,
        rejectRequest: streaming.rejectRequest,
        onSubAdded: streaming.onSubAdded,
        onSubRemoved: streaming.onSubRemoved
    }
};

},{"./../../helpers/random":46,"./helpers":49,"./server-streaming":51,"callback-registry":6}],53:[function(require,module,exports){
/**
 * Handles registering methods and sending data to clients
 */


module.exports = function (instance, connection, repository, session, logger) {
    'use strict';
    connection.on('subscribed', handleSubscribed);
    connection.on('event', handleEventData);
    connection.on('subscription-cancelled', handleSubscriptionCancelled);

    var MSG_TYPE_SUBSCRIBE = 'subscribe';
    var STATUS_AWAITING_ACCEPT = 'awaitingAccept'; // not even one server has accepted yet
    var STATUS_SUBSCRIBED = 'subscribed'; // at least one server has responded as 'Accepting'
    var ERR_MSG_SUB_FAILED = 'Subscription failed.';
    var ERR_MSG_SUB_REJECTED = 'Subscription rejected.';
    var ON_CLOSE_MSG_SERVER_INIT = 'ServerInitiated';
    var ON_CLOSE_MSG_CLIENT_INIT = 'ClientInitiated';

    var subscriptionsList = {};
    var subscriptionIdToLocalKeyMap = {};
    var nextSubLocalKey = 0;

    function getNextSubscriptionLocalKey() {
        var current = nextSubLocalKey;
        nextSubLocalKey += 1;

        return current;
    }

    function subscribe(streamingMethod, argumentObj, targetServers, stuff, success, error) {
        if (targetServers.length === 0) {
            error(ERR_MSG_SUB_FAILED + ' No available servers matched the target params.');
            return;
        }

        logger.debug('subscribe to target servers: ', targetServers)

        // Note: used to find the subscription in subList. Do not confuse it with the gw-generated subscription_id
        var subLocalKey = getNextSubscriptionLocalKey();

        var pendingSub = registerSubscription(
            subLocalKey,
            streamingMethod,
            argumentObj,
            success,
            error,
            stuff.method_response_timeout
        );

        if (typeof pendingSub !== 'object') {
            error(ERR_MSG_SUB_FAILED + ' Unable to register the user callbacks.');
            return;
        }

        targetServers.forEach(function(target) {

            var serverId = target.server.id;

            pendingSub.trackedServers.push({
                serverId: serverId,
                subscriptionId: undefined // is assigned by gw3
            });

            var msg = {
                type: MSG_TYPE_SUBSCRIBE,
                server_id: serverId,
                method_id: streamingMethod.info.id,
                arguments_kv: argumentObj
            };

            connection.send(msg, { serverId: serverId, subLocalKey: subLocalKey })
                .then(handleSubscribed)['catch'](handleErrorSubscribing);

        });
    }

    function registerSubscription(subLocalKey, method, args, success, error, timeout) {
        subscriptionsList[subLocalKey] = {
            status: STATUS_AWAITING_ACCEPT,
            method: method,
            arguments: args,
            success: success,
            error: error,
            trackedServers: [],
            handlers: {
                onData: [],
                onClosed: []
                // onFailed: []
            },
            queued: {
                data: [],
                closers: []
            },
            timeoutId: undefined
        };

        subscriptionsList[subLocalKey].timeoutId = setTimeout(function () {
            if (subscriptionsList[subLocalKey] === undefined) {
                return; // no such subscription
            }

            var pendingSub = subscriptionsList[subLocalKey];

            if (pendingSub.status === STATUS_AWAITING_ACCEPT) {
                error({
                    method: method,
                    called_with: args,
                    message: ERR_MSG_SUB_FAILED + ' Subscription attempt timed out after ' + timeout + 'ms.'
                });

                // None of the target servers has answered the subscription attempt
                delete subscriptionsList[subLocalKey];

            } else if (pendingSub.status === STATUS_SUBSCRIBED && pendingSub.trackedServers.length > 0) {
                // Clean the trackedServers, removing those without valid streamId
                pendingSub.trackedServers = pendingSub.trackedServers.filter(function (server) {
                    return (typeof server.streamId !== 'undefined')
                });

                delete pendingSub.timeoutId;

                if (pendingSub.trackedServers.length <= 0) {
                    // There are no open streams, some servers accepted then closed very quickly
                    //  (that's why the status changed but there's no good server with a StreamId)

                    // call the onClosed handlers
                    callOnClosedHandlers(pendingSub);

                    delete subscriptionsList[subLocalKey];
                }
            }
        }, timeout);

        return subscriptionsList[subLocalKey]
    }

    function handleErrorSubscribing(errorResponse) {
        // A target server is rejecting
        logger.debug('Subscription attempt failed', errorResponse);

        var tag = errorResponse._tag;
        var subLocalKey = tag.subLocalKey;

        var pendingSub = subscriptionsList[subLocalKey];

        if (typeof pendingSub !== 'object') {
            return;
        }

        pendingSub.trackedServers = pendingSub.trackedServers.filter(function (server) {
            return server.serverId !== tag.serverId;
        });

        if (pendingSub.trackedServers.length <= 0) {
            clearTimeout(pendingSub.timeoutId);

            if (pendingSub.status === STATUS_AWAITING_ACCEPT) {
                // Reject with reason
                var reason = (typeof errorResponse.reason === 'string' && errorResponse.reason !== '')
                    ? ' Publisher said "' + errorResponse.reason + '".'
                    : ' No reason given.';

                var callArgs = typeof pendingSub.arguments === 'object'
                    ? JSON.stringify(pendingSub.arguments)
                    : '{}';

                pendingSub.error(ERR_MSG_SUB_REJECTED + reason + ' Called with:' + callArgs);


            } else if (pendingSub.status === STATUS_SUBSCRIBED) {
                // The timeout may or may not have expired yet,
                // but the status is 'subscribed' and trackedServers is now empty

                callOnClosedHandlers(pendingSub);
            }


            delete subscriptionsList[subLocalKey];
        }
    }

    function handleSubscribed(msg) {
        logger.debug('handleSubscribed', msg);

        var subLocalKey = msg._tag.subLocalKey;
        var pendingSub = subscriptionsList[subLocalKey];

        if (typeof pendingSub !== 'object') {
            return;
        }

        var serverId = msg._tag.serverId;

        // Add a subscription_id to this trackedServer

        var acceptingServer = pendingSub.trackedServers
            .filter(function(server) {
                return server.serverId === serverId;
            })[0];

        if (typeof acceptingServer !== 'object') {
            return;
        }

        acceptingServer.subscriptionId = msg.subscription_id;
        subscriptionIdToLocalKeyMap[msg.subscription_id] = subLocalKey;

        var isFirstResponse = (pendingSub.status === STATUS_AWAITING_ACCEPT);

        pendingSub.status = STATUS_SUBSCRIBED;

        if (isFirstResponse) {
            // Pass in the subscription object
            pendingSub.success({
                onData: function (dataCallback) {
                    if (typeof dataCallback !== 'function') {
                        throw new TypeError('The data callback must be a function.')
                    }

                    this.handlers.onData.push(dataCallback);
                    if (this.handlers.onData.length === 1 && this.queued.data.length > 0) {
                        this.queued.data.forEach(function (dataItem) {
                            dataCallback(dataItem)
                        })
                    }
                }.bind(pendingSub),
                onClosed: function (closedCallback) {
                    if (typeof closedCallback !== 'function') {
                        throw new TypeError('The callback must be a function.')
                    }
                    this.handlers.onClosed.push(closedCallback)
                }.bind(pendingSub),
                onFailed: function () { /* Will not be implemented for browser. */
                },
                close: closeSubscription.bind(subLocalKey),
                requestArguments: pendingSub.arguments,
                serverInstance: repository.getServerById(serverId).getInfoForUser(),
                stream: pendingSub.method
            });
        }
    }

    function handleEventData(msg) {
        logger.debug('handleEventData', msg);

        var subLocalKey = subscriptionIdToLocalKeyMap[msg.subscription_id];

        if (typeof subLocalKey === 'undefined') {
            return;
        }

        var subscription = subscriptionsList[subLocalKey];

        if (typeof subscription !== 'object') {
            return;
        }

        var trackedServersFound = subscription.trackedServers.filter(function (server) {
            return server.subscriptionId === msg.subscription_id;
        });

        if (trackedServersFound.length !== 1) {
            return;
        }

        var isPrivateData = msg.oob && msg.snapshot;

        var sendingServerId = trackedServersFound[0].serverId;

        // Create the arrivedData object, new object for each handler call
        function receivedStreamData() {
            return {
                data: msg.data,
                server: repository.getServerById(sendingServerId).getInfoForUser(),
                requestArguments: subscription.arguments || {},
                message: null,
                private: isPrivateData
            };
        }

        var onDataHandlers = subscription.handlers.onData;
        var queuedData = subscription.queued.data;

        if (onDataHandlers.length > 0) {
            onDataHandlers.forEach(function (callback) {
                if (typeof callback === 'function') {
                    callback(receivedStreamData())
                }
            })
        } else {
            queuedData.push(receivedStreamData())
        }
    }

    function handleSubscriptionCancelled(msg) {
        logger.debug('handleSubscriptionCancelled', msg);

        var subLocalKey = subscriptionIdToLocalKeyMap[msg.subscription_id];

        if (typeof subLocalKey === 'undefined') {
            return;
        }

        var subscription = subscriptionsList[subLocalKey];

        if (typeof subscription !== 'object') {
            return;
        }

        // Filter tracked servers
        var expectedNewLength = subscription.trackedServers.length - 1;

        subscription.trackedServers = subscription.trackedServers.filter(function(server) {
            if (server.subscriptionId === msg.subscription_id) {
                subscription.queued.closers.push(server.serverId);
                return false;
            } else {
                return true;
            }
        });

        // Check if a server was actually removed
        if (subscription.trackedServers.length !== expectedNewLength) {
            return;
        }

        // Check if this was the last remaining server
        if (subscription.trackedServers.length <= 0) {
            clearTimeout(subscription.timeoutId);
            callOnClosedHandlers(subscription);
            delete subscriptionsList[subLocalKey];
        }

        delete subscriptionIdToLocalKeyMap[msg.subscription_id]
    }

    function callOnClosedHandlers(subscription, reason) {

        var closersCount = subscription.queued.closers.length;
        var closingServerId = (closersCount > 0) ? subscription.queued.closers[closersCount - 1] : null;

        var closingServer = null;
        if (typeof closingServerId === 'number') {
            closingServer = repository.getServerById(closingServerId).getInfoForUser();
        }

        subscription.handlers.onClosed.forEach(function (callback) {
            if (typeof callback !== 'function') {
                return;
            }

            callback({
                message: reason || ON_CLOSE_MSG_SERVER_INIT,
                requestArguments: subscription.arguments,
                server: closingServer,
                stream: subscription.method
            });
        });
    }

    function closeSubscription(subLocalKey) {
        logger.debug('closeSubscription', subLocalKey);

        var subscription = subscriptionsList[subLocalKey];

        if (typeof subscription !== 'object') {
            return;
        }

        // Tell each server that we're unsubscribing
        subscription.trackedServers.forEach(function (server) {
            if (typeof server.subscriptionId === 'undefined') {
                return;
            }

            connection.sendFireAndForget({
                type: 'unsubscribe',
                subscription_id: server.subscriptionId,
                reason_uri: '',
                reason: ON_CLOSE_MSG_CLIENT_INIT
            });

            delete subscriptionIdToLocalKeyMap[server.subscriptionId];
        });

        subscription.trackedServers = [];

        callOnClosedHandlers(subscription, ON_CLOSE_MSG_CLIENT_INIT);

        delete subscriptionsList[subLocalKey];


    }

    return { subscribe: subscribe };
};

},{}],54:[function(require,module,exports){
var callbackRegistry = require('callback-registry');
var Streaming = require('./client-streaming');

/**
 * Handles session lifetime and events
 */
module.exports = function (instance, connection, repository, session, logger) {
    'use strict';
    connection.on('peer-added', handlePeerAdded);
    connection.on('peer-removed', handlePeerRemoved);
    connection.on('methods-added', handleMethodsAddedMessage);
    connection.on('methods-removed', handleMethodsRemovedMessage);

    var callbacks = callbackRegistry();
    var streaming = new Streaming(instance, connection, repository, session, logger);

    function handlePeerAdded(msg) {
        var newPeerId = msg.new_peer_id;
        var remoteId = msg.identity;

        var serverInfo = {
            machine: remoteId.machine,
            pid: remoteId.process,
            instance: remoteId.instance,
            application: remoteId.application,
            environment: remoteId.environment,
            region: remoteId.region,
            user: remoteId.user
        };

        repository.addServer(serverInfo, newPeerId);
    }

    function handlePeerRemoved(msg) {
        var removedPeerId = msg.removed_id;
        var reason = msg.reason;

        repository.removeServerById(removedPeerId, reason);
    }

    function handleMethodsAddedMessage(msg) {
        var serverId = msg.server_id;
        var methods = msg.methods;

        methods.forEach(function (method) {
            var methodInfo = {
                id: method.id,
                name: method.name,
                displayName: method.display_name,
                description: method.description,
                version: method.version,
                objectTypes: method.object_types,
                accepts: method.input_signature,
                returns: method.result_signature
            };

            repository.addServerMethod(serverId, methodInfo);
        });
    }

    function handleMethodsRemovedMessage(msg) {
        var serverId = msg.server_id;
        var methodIdList = msg.methods;

        var server = repository.getServerById(serverId);

        var serverMethodKeys = Object.keys(server.methods);

        serverMethodKeys.forEach(function (methodKey) {

            var method = server.methods[methodKey];

            if (methodIdList.indexOf(method.info.id) > -1) {

                repository.removeServerMethod(serverId, methodKey)
            }

        });
    }

    function invoke(id, method, args, target) {

        var serverId = target.id;
        var methodId = method.info.id;

        logger.debug('sending call (' + id + ') for method id ' + methodId + ' to server ' + serverId);
        var msg = {
            type: 'call',
            server_id: serverId,
            method_id: methodId,
            arguments_kv: args
        };

        // we transfer the invocation id as tag
        connection.send(msg, { invocationId: id, serverId: serverId })
            .then(handleResultMessage);
    }

    function onInvocationResult(callback) {
        callbacks.add('onResult', callback);
    }

    function handleResultMessage(msg) {
        logger.debug('handle result message ' + msg);

        var invocationId = msg._tag.invocationId;
        var result = msg.result;
        var serverId = msg._tag.serverId;
        var server = repository.getServerById(serverId);

        callbacks.execute('onResult', invocationId, server.getInfoForUser(), 0, result, '');
    }

    return {
        invoke: invoke,
        onInvocationResult: onInvocationResult,
        subscribe: streaming.subscribe
    };
};

},{"./client-streaming":53,"callback-registry":6}],55:[function(require,module,exports){
var random = require('./../../helpers/random');
var Promise = require('es6-promise').Promise;
var promisify = require('./../../helpers/promisify');

/**
* Provides way of delegating error and success messages from gw3 to the client or server
*/
module.exports = function (connection, logger) {
    'use strict';

    var peerId = connection.getPeerId();

    connection.on('welcome', handleWelcomeMessage); // subscribe for welcome so we get our peer-id
    connection.on('error', handleErrorMessage);
    connection.on('success', handleSuccessMessage);
    connection.on('result', handleSuccessMessage);
    connection.on('subscribed', handleSuccessMessage);

    var requestsMap = {};

    function handleErrorMessage(msg) {
        var requestId = msg.request_id;
        var entry = requestsMap[requestId];
        if (!entry) {
            return;
        }

        logger.error('error message ' + JSON.stringify(msg));
        entry.error(msg);
    }

    function handleSuccessMessage(msg) {
        var requestId = msg.request_id;

        var entry = requestsMap[requestId];
        if (!entry) {
            return;
        }
        entry.success(msg);
    }

    function handleWelcomeMessage(msg) {
        handleSuccessMessage(msg);
    }

    function getNextRequestId() {
        return random();
    }

    /**
     * Send a message
     * @param msg message to send
     * @param tag a custom object (tag) - it will be transferred to success/error callback
     * @param success
     * @param error
     */
    function send(msg, tag, success, error) {
        // Allows function caller to override request_id
        var requestId = getNextRequestId();
        msg.request_id = msg.request_id ? msg.request_id : requestId;
        msg.peer_id = peerId;

        var promise = new Promise(function (resolve, reject) {
            requestsMap[requestId] = {
                success: function(successMsg) {
                    delete requestsMap[requestId];
                    successMsg._tag = tag;
                    resolve(successMsg);
                },
                error: function(errorMsg) {
                    delete requestsMap[requestId];
                    errorMsg._tag = tag;
                    reject(errorMsg);
                }
            };
            connection.send('tick42-agm', msg);
        });

        return promisify(promise, success, error);
    }

    function sendFireAndForget(msg) {
        // Allows function caller to override request_id
        msg.request_id = msg.request_id ? msg.request_id : getNextRequestId();
        msg.peer_id = peerId;

        connection.send('tick42-agm', msg);
    }

    return {
        send: send,
        sendFireAndForget: sendFireAndForget,
        on: connection.on,
        peerId : peerId
    }
};

},{"./../../helpers/promisify":45,"./../../helpers/random":46,"es6-promise":11}],56:[function(require,module,exports){
var sessionFactory = require('./session');
var serverFactory = require('./server');
var clientFactory = require('./client');
var connectionWrapperFactory = require('./conwrap');
var Promise = require('es6-promise').Promise;

module.exports = function (instance, connection, repository, vault, configuration) {
    'use strict';

    var logger = configuration.logger.subLogger('gw2-protocol');

    if (!connection.getPeerId()) {
        throw new Error('Not logged in! Can not continue');
    }

    var connectionWrapper = connectionWrapperFactory(connection, logger);
    var session = sessionFactory(instance, connectionWrapper, repository, logger.subLogger('session'));
    var server = serverFactory(instance, connectionWrapper, repository, vault, session, logger.subLogger('server'));
    var client = clientFactory(instance, connectionWrapper, repository, session, logger.subLogger('client'));

    return new Promise(function (resolve, reject) {

        session.onConnected(function (err) {
            if (err) {
                reject(err);
                return;
            }

            resolve({
                invoke: client.invoke,
                onInvocationResult: client.onInvocationResult,
                register: server.register,
                // TODO change params
                unregister: server.unregister,
                onInvoked: server.onInvoked,
                methodInvocationResult: server.methodInvocationResult,

                // stream-related
                subscribe: client.subscribe,
                createStream: server.createStream,
                getBranchList: server.getBranchList,
                getSubscriptionList: server.getSubscriptionList,
                closeAllSubscriptions: server.closeAllSubscriptions,
                closeSingleSubscription: server.closeSingleSubscription,
                pushData: server.pushData,
                pushDataToSingle: server.pushDataToSingle,
                onSubRequest: server.onSubRequest,
                acceptRequestOnBranch: server.acceptRequestOnBranch,
                rejectRequest: server.rejectRequest,
                onSubAdded: server.onSubAdded,
                onSubRemoved: server.onSubRemoved
            });
        });
        session.start();
    });
};

},{"./client":54,"./conwrap":55,"./server":58,"./session":59,"es6-promise":11}],57:[function(require,module,exports){
var callbackRegistry = require('callback-registry');

/**
 * Handles registering methods and sending data to clients
 */
module.exports = function (instance, connection, repository, vault, session, logger) {
    'use strict';
    connection.on('add-interest', handleAddInterest);
    connection.on('remove-interest', handleRemoveInterest);

    var SUBSCRIPTION_REQUEST = 'onSubscriptionRequest';
    var SUBSCRIPTION_ADDED = 'onSubscriptionAdded';
    var SUBSCRIPTION_REMOVED = 'onSubscriptionRemoved';
    var ERR_URI_SUBSCRIPTION_FAILED = 'com.tick42.agm.errors.subscription.failure';
    var callbacks = callbackRegistry();
    var nextStreamId = 0;

    // TODO there are many of these incrementing integer id's -> make a helper module
    function getNextStreamId() {
        var current = nextStreamId;
        nextStreamId += 1;
        return current;
    }

    /**
     * Processes a subscription request
     */
    function handleAddInterest(msg) {

        logger.debug('server_AddInterest ', msg);

        var caller = repository.getServerById(msg.caller_id);
        var instance = (typeof caller.getInfoForUser === 'function') ? caller.getInfoForUser() : null;

        // call subscriptionRequestHandler
        var requestContext = {
            msg: msg,
            arguments: msg.arguments_kv || {},
            instance: instance
        };

        var streamingMethod = vault.getById(msg.method_id);

        if (streamingMethod === undefined) {
            sendSubscriptionFailed(
                'No method with id ' + msg.method_id + ' on this server.',
                msg.subscription_id
            );
            return;
        }

        if (streamingMethod.subscriptionsMap && streamingMethod.subscriptionsMap[msg.subscription_id]) {
            sendSubscriptionFailed(
                'A subscription with id ' + msg.subscription_id + ' already exists.',
                msg.subscription_id
            );
            return;
        }

        callbacks.execute(SUBSCRIPTION_REQUEST, requestContext, streamingMethod);
    }

    function sendSubscriptionFailed(reason, subscriptionId) {
        var errorMessage = {
            type: 'error',
            reason_uri: ERR_URI_SUBSCRIPTION_FAILED,
            reason: reason,
            request_id: subscriptionId // this overrides connection wrapper
        };

        connection.sendFireAndForget(errorMessage);
    }

    function acceptRequestOnBranch (requestContext, streamingMethod, branch) {
        console.log('requestContext', requestContext);

        if (typeof branch !== 'string') {
            branch = '';
            console.log('empty branch', branch)
        }

        if (typeof streamingMethod.subscriptionsMap !== 'object') {
            throw new TypeError('The streaming method is missing its subscriptions.');
        }

        if (!Array.isArray(streamingMethod.branchKeyToStreamIdMap)) {
            throw new TypeError('The streaming method is missing its branches.');
        }

        var streamId = getStreamId(streamingMethod, branch);

        // Add a new subscription to the method
        var key = requestContext.msg.subscription_id;

        var subscription = {
            id: key,
            arguments: requestContext.arguments,
            instance: requestContext.instance,
            branchKey: branch,
            streamId: streamId,
            subscribeMsg: requestContext.msg
        };

        streamingMethod.subscriptionsMap[key] = subscription;

        // Inform the gw
        connection.sendFireAndForget({
            type: 'accepted',
            subscription_id: key,
            stream_id: streamId
        });

        // Pass state above-protocol for user objects
        callbacks.execute(SUBSCRIPTION_ADDED, subscription, streamingMethod)
    }

    function getStreamId(streamingMethod, branchKey) {
        if (typeof branchKey !== 'string') {
            branchKey = '';
        }

        var needleBranch = streamingMethod.branchKeyToStreamIdMap.filter(function (branch) {
            return branch.key === branchKey;
        })[0];

        var streamId = (needleBranch ? needleBranch.streamId : undefined);

        if (typeof    streamId !== 'string' || streamId === '') {
            streamId = getNextStreamId();
            streamingMethod.branchKeyToStreamIdMap.push({ key: branchKey, streamId: streamId });
        }

        return streamId;
    }

    function rejectRequest(requestContext, streamingMethod, reason) {
        if (typeof reason !== 'string') {
            reason = '';
        }

        sendSubscriptionFailed(
            'Subscription rejected by user. ' + reason,
            requestContext.msg.subscription_id
        )
    }

    function onSubscriptionLifetimeEvent(eventName, handlerFunc) {
        callbacks.add(eventName, handlerFunc)
    }

    function pushToBranch(streamingMethod, data, branches) {
        if (typeof streamingMethod !== 'object' || !Array.isArray(streamingMethod.branchKeyToStreamIdMap)) {
            return;
        }

        // TODO validate data is a plain object
        if (typeof data !== 'object') {
            throw new Error('Invalid arguments. Data must be an object.');
        }

        if (typeof branches === 'string') {
            branches = [branches]; // user wants to push to single branch
        } else if (!Array.isArray(branches) || branches.length <= 0) {
            branches = null;
        }

        // get the StreamId's from the method's branch map
        var streamIdList = streamingMethod.branchKeyToStreamIdMap
            .filter(function (br) {
                return (
                    branches === null || (Boolean(br) && typeof br.key === 'string' && branches.indexOf(br.key) >= 0)
                );
            }).map(function (br) {
                return br.streamId;
            });

        streamIdList.forEach(function (streamId) {
            connection.sendFireAndForget({
                type: 'publish',
                stream_id: streamId,
                // sequence: null,  // the streamingMethod might be used for this
                // snapshot: false, // ...and this
                data: data
            })
        });
    }

    function pushDataToSingle(streamingMethod, subscription, data) {
        // TODO validate data is a plain object
        if (typeof data !== 'object') {
            throw new Error('Invalid arguments. Data must be an object.');
        }

        connection.sendFireAndForget({
            type: 'post',
            subscription_id: subscription.id,
            // sequence: null,  // the streamingMethod might be used for this
            // snapshot: false, // ...and this
            data: data
        })
    }

    function closeSingleSubscription(streamingMethod, subscription) {

        delete streamingMethod.subscriptionsMap[subscription.id];

        connection.sendFireAndForget({
            type: 'drop-subscription',
            subscription_id: subscription.id,
            reason: 'Server dropping a single subscription'
        });

        var subscriber = subscription.instance;

        callbacks.execute(SUBSCRIPTION_REMOVED, subscriber, streamingMethod);
    }

    function closeMultipleSubscriptions(streamingMethod, branchKey) {
        if (typeof streamingMethod !== 'object' || typeof streamingMethod.subscriptionsMap !== 'object') {
            return;
        }

        var subscriptionsToClose = Object.keys(streamingMethod.subscriptionsMap)
            .map(function(key) {
                return streamingMethod.subscriptionsMap[key];
            });

        if (typeof branchKey === 'string') {
            subscriptionsToClose = subscriptionsToClose.filter(function(sub) {
                return sub.branchKey === branchKey;
            });
        }

        subscriptionsToClose.forEach(function (subscription) {
            delete streamingMethod.subscriptionsMap[subscription.id];

            connection.sendFireAndForget({
                type: 'drop-subscription',
                subscription_id: subscription.id,
                reason: 'Server dropping all subscriptions on stream_id: ' + subscription.streamId
            });
        });
    }

    function getSubscriptionList(streamingMethod, branchKey) {
        if (typeof streamingMethod !== 'object') {
            return [];
        }

        var subscriptions = [];

        var allSubscriptions = Object.keys(streamingMethod.subscriptionsMap).map(function(key) {
            return streamingMethod.subscriptionsMap[key];
        });

        if (typeof branchKey !== 'string') {
            subscriptions = allSubscriptions;
        } else {
            subscriptions = allSubscriptions.filter(function (sub) {
                return sub.branchKey === branchKey;
            });
        }

        return subscriptions;
    }

    function getBranchList(streamingMethod) {
        if (typeof streamingMethod !== 'object') {
            return [];
        }

        var allSubscriptions = Object.keys(streamingMethod.subscriptionsMap).map(function(key) {
            return streamingMethod.subscriptionsMap[key];
        });

        var keysWithDuplicates = allSubscriptions.map(function (sub) {
            var result = null;
            if (typeof sub === 'object' && typeof sub.branchKey === 'string') {
                result = sub.branchKey;
            }
            return result;
        });

        var seen = [];

        var branchArray = keysWithDuplicates.filter(function (bKey) {
            if (bKey === null || seen.indexOf(bKey) >= 0) {
                return false;
            }
            seen.push(bKey);
            return true;
        });

        return branchArray;
    }

    function handleRemoveInterest(msg) {
        logger.debug('handleRemoveInterest', msg);

        var streamingMethod = vault.getById(msg.method_id)

        if (typeof msg.subscription_id !== 'string' ||
            typeof streamingMethod !== 'object' ||
            typeof streamingMethod.subscriptionsMap[msg.subscription_id] !== 'object'
        ) {
            return;
        }

        var subscriber = streamingMethod.subscriptionsMap[msg.subscription_id].instance;

        delete streamingMethod.subscriptionsMap[msg.subscription_id];

        callbacks.execute(SUBSCRIPTION_REMOVED, subscriber, streamingMethod);
    }

    return {
        pushData: pushToBranch,
        pushDataToSingle: pushDataToSingle,
        onSubRequest: onSubscriptionLifetimeEvent.bind(null, SUBSCRIPTION_REQUEST),
        onSubAdded: onSubscriptionLifetimeEvent.bind(null, SUBSCRIPTION_ADDED),
        onSubRemoved: onSubscriptionLifetimeEvent.bind(null, SUBSCRIPTION_REMOVED),
        acceptRequestOnBranch: acceptRequestOnBranch,
        rejectRequest: rejectRequest,
        getSubscriptionList: getSubscriptionList,
        getBranchList: getBranchList,
        closeSingleSubscription: closeSingleSubscription,
        closeMultipleSubscriptions: closeMultipleSubscriptions
    };
};


},{"callback-registry":6}],58:[function(require,module,exports){
var callbackRegistry = require('callback-registry');
var Streaming = require('./server-streaming');

/**
 * Handles registering methods and sending data to clients
 */
module.exports = function (instance, connection, repository, vault, session, logger) {
    'use strict';
    var callbacks = callbackRegistry();
    var streaming = new Streaming(instance, connection, repository, vault, session, logger);

    connection.on('invoke', handleInvokeMessage);

    function handleRegisteredMessage(msg) {
        var methodId = msg._tag.methodId;
        var repoMethod = vault.getById(methodId);

        if (repoMethod && repoMethod.registrationCallbacks) {
            logger.debug('registered method ' + repoMethod.definition.name + ' with id ' + methodId);
            repoMethod.registrationCallbacks.success();
        }
    }

    function handleErrorRegister(msg) {
        logger.warn(msg);

        var methodId = msg._tag.methodId;
        var repoMethod = vault.getById(methodId);

        if (repoMethod && repoMethod.registrationCallbacks) {
            logger.debug('failed to register method ' + repoMethod.definition.name + ' with id ' + methodId);
            repoMethod.registrationCallbacks.fail();
        }
    }

    function handleInvokeMessage(msg) {
        var invocationId = msg.invocation_id;
        var peerId = msg.peer_id;
        var methodId = msg.method_id;
        var args = msg.arguments_kv;

        logger.debug('received invocation for method id "' + methodId + '"');

        var methodList = vault.getList();

        var method = methodList.filter(function (m) {
            return m._repoId === methodId;
        })[0];

        // Stop if the message isn't for us
        if (method === undefined) {
            return;
        }

        var client = repository.getServerById(peerId);
        var invocationArgs = { args: args, instance: client.getInfoForUser() };

        callbacks.execute('onInvoked', method, invocationId, invocationArgs);
    }

    function createStream(repoMethod, streamDef, success, fail) {
        var isStreaming = true;

        // Utility things for this protocol
        repoMethod.subscriptionsMap = {}; // ~subscription_id~ : {id:~, branchKey: '~', arguments: {~}, instance:{~}, etc.}
        repoMethod.branchKeyToStreamIdMap = []; // [ {branchKey: '', streamId: 7}, {...}, ...]

        register(repoMethod, success, fail, isStreaming);
    }

    function register(repoMethod, success, fail, isStreaming) {

        var methodDef = repoMethod.definition;

        // TODO review, why is this type of closure necessary
        repoMethod.registrationCallbacks = {
            success: success,
            fail: fail
        };

        var flags = {};
        if (isStreaming === true) {
            flags = { supportsStreaming: true }
        }

        logger.debug('registering method "' + methodDef.name + '"');
        var registerMsg = {
            type: 'register',
            methods: [{
                id: repoMethod._repoId,
                name: methodDef.name,
                display_name: methodDef.displayName,
                description: methodDef.description,
                version: methodDef.version,
                flags: flags,
                object_types: methodDef.objectTypes,
                input_signature: methodDef.accepts,
                result_signature: methodDef.returns,
                restrictions: undefined
            }]
        };

        connection.send(registerMsg, { methodId: repoMethod._repoId })
            .then(handleRegisteredMessage)['catch'](handleErrorRegister);
    }

    function onInvoked(callback) {
        callbacks.add('onInvoked', callback);
    }

    function methodInvocationResult(registrationId, invocationId, err, result) {
        var msg = {
            type: 'yield',
            invocation_id: invocationId,
            peer_id: session.peerId(),
            result: result
        };

        connection.sendFireAndForget(msg);
    }

    function unregister(method) {
        var msg = {
            type: 'unregister',
            methods: [method._repoId]
        };

        connection.send(msg)
            .then(handleUnregisteredMessage);
    }

    function handleUnregisteredMessage(msg) {
        var requestId = msg.request_id;

        logger.debug('unregistered by requestId ' + requestId);
    }

    return {
        register: register,
        onInvoked: onInvoked,
        methodInvocationResult: methodInvocationResult,
        unregister: unregister,

        createStream: createStream,
        getBranchList: streaming.getBranchList,
        getSubscriptionList: streaming.getSubscriptionList,
        closeAllSubscriptions: streaming.closeMultipleSubscriptions,
        closeSingleSubscription: streaming.closeSingleSubscription,
        pushData: streaming.pushData,
        pushDataToSingle: streaming.pushDataToSingle,
        onSubRequest: streaming.onSubRequest,
        acceptRequestOnBranch: streaming.acceptRequestOnBranch,
        rejectRequest: streaming.rejectRequest,
        onSubAdded: streaming.onSubAdded,
        onSubRemoved: streaming.onSubRemoved
    }
};

},{"./server-streaming":57,"callback-registry":6}],59:[function(require,module,exports){
var callbackRegistry = require('callback-registry');

/**
 * Handles session lifetime and events
 */
module.exports = function (instance, connection, repository, logger) {
    'use strict';
    var domain = 'com.tick42.agm';

    connection.on('leave', handleGoodbyeMessage)

    var myPeerId = connection.peerId;
    var callbacks = callbackRegistry();
    var joined = false;

    function start() {
        logger.debug('starting session ...');
        logger.debug('joining domain "' + domain);

        var joinMsg = {
            type: 'join',
            domain: domain
        };
        connection.send(joinMsg)
            .then(handleJoined);
    }

    function handleJoined() {
        joined = true;
        repository.addServer(instance, myPeerId);
        logger.debug('joined to AGM domain!');
        callbacks.execute('onConnected');
    }

    function stop() {
        logger.debug('stopping session...');
        var msg = ['LEAVE', myPeerId, domain];
        connection.send(msg);
    }

    function handleGoodbyeMessage() {
        joined = false;
        myPeerId = undefined;
    }

    function onConnected(callback) {
        if (connected()) {
            callback();
            return;
        }

        callbacks.add('onConnected', callback);
    }

    function connected() {
        return joined;
    }

    return {
        start: start,
        stop: stop,
        connected: connected,
        peerId: function () {
            return myPeerId;
        },
        onConnected: onConnected
    }
};

},{"callback-registry":6}],60:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "tick42-agm@^3.2.0",
      "C:\\work\\stash\\GLUE-dev\\js-glue"
    ]
  ],
  "_from": "tick42-agm@>=3.2.0 <4.0.0",
  "_id": "tick42-agm@3.2.1",
  "_inCache": true,
  "_installable": true,
  "_location": "/tick42-agm",
  "_nodeVersion": "6.3.0",
  "_npmUser": {},
  "_npmVersion": "3.8.5",
  "_phantomChildren": {},
  "_requested": {
    "name": "tick42-agm",
    "raw": "tick42-agm@^3.2.0",
    "rawSpec": "^3.2.0",
    "scope": null,
    "spec": ">=3.2.0 <4.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/"
  ],
  "_shasum": "8bbc835f300b81777591b455f04a3170ebb44182",
  "_shrinkwrap": null,
  "_spec": "tick42-agm@^3.2.0",
  "_where": "C:\\work\\stash\\GLUE-dev\\js-glue",
  "author": {
    "name": "Tick42",
    "url": "http://www.tick42.com"
  },
  "bin": {
    "build": "./bin/build.js",
    "clean": "./bin/clean.js",
    "file-versionify": "./bin/file-versionify.js",
    "minify": "./bin/minify.js"
  },
  "bugs": {
    "url": "https://jira.tick42.com/browse/APPCTRL"
  },
  "dependencies": {
    "callback-registry": "^1.0.1",
    "cuid": "^1.3.8",
    "es6-promise": "^3.0.2",
    "tick42-gateway-connection": "^2.0.0",
    "util-deprecate": "^1.0.2"
  },
  "description": "JavaScript AGM",
  "devDependencies": {
    "blanket": "^1.1.6",
    "bluebird": "^2.9.30",
    "browserify": "^13.0.0",
    "browserify-replacify": "^0.0.4",
    "browserify-versionify": "^1.0.4",
    "eslint": "^3.1.1",
    "eslint-config-standard": "^5.3.5",
    "eslint-config-tick42": "^1.0.0",
    "eslint-plugin-promise": "^2.0.0",
    "eslint-plugin-standard": "^2.0.0",
    "fs": "0.0.2",
    "http-server": "^0.9.0",
    "jsdom": "^8.1.0",
    "minifyify": "^7.3.2",
    "onchange": "^2.1.2",
    "phantomjs": "^1.9.12",
    "qunitjs": "^1.15.0",
    "shelljs": "^0.6.0"
  },
  "dist": {
    "shasum": "8bbc835f300b81777591b455f04a3170ebb44182",
    "tarball": "http://192.168.0.234:4873/tick42-agm/-/tick42-agm-3.2.1.tgz"
  },
  "gitHead": "b36517ac0a3bcb7a692be161bb2af4e48ee694af",
  "keywords": [
    "agm",
    "javascript",
    "library"
  ],
  "main": "library/agm.js",
  "name": "tick42-agm",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "scripts": {
    "build": "npm run eslint && node bin/clean.js && node bin/build.js && node bin/minify && node bin/file-versionify",
    "eslint": "eslint library",
    "eslint:fix": "eslint library --fix",
    "prepublish": "npm update & npm run build",
    "serve": "http-server -p 8000 -a 127.0.0.1",
    "test": "npm run eslint && mocha --require ./test/test_helper \"test/**/*.js\"",
    "watch": "onchange \"./library/**/*.js\" -iv -e \"./bin\" -- npm run build"
  },
  "title": "Tick42 AGM",
  "version": "3.2.1"
}

},{}],61:[function(require,module,exports){
(function (global){
var application = require("./application");
var instance = require("./instance");
var helpers = require("./helpers");
var PackageJson = require("../package.json");
var deprecate = require('util-deprecate');

module.exports = global.app_manager = function app_manager(agm, windows) {

	var apps = application(agm, function () {
		return instances;
	});
	var instances = instance(agm, apps);
	var manager = {
		applications: apps.all,
		application: apps.get_by_id,
		onAppAdded: helpers.add_callback("added").bind(apps),
		onAppAvailable: helpers.add_callback("available").bind(apps),
		onAppRemoved: helpers.add_callback("removed").bind(apps),
		onAppUnavailable: helpers.add_callback("unavailable").bind(apps),

		instances: instances.all,
		onInstanceStarted: helpers.add_callback("started").bind(instances),
		onInstanceStopped: helpers.add_callback("stopped").bind(instances),
		onInstanceUpdated: helpers.add_callback("updated").bind(instances),

		getBranches: function (success, error) {
			agm.invoke("T42.ACS.GetBranches", {}, "best", {}, function (e) {
				if (success) {
					success(helpers.vals(e.returned.Branches));
				}
			}, error);
		},
		getCurrentBranch: function (success, error) {
			agm.invoke("T42.ACS.GetCurrentBranch", {}, "best", {}, function (e) {
				if (success) {
					success(e.returned.Branch);
				}
			}, error);
		},
		setCurrentBranch: function (branch, success, error) {
			agm.invoke("T42.ACS.SetCurrentBranch", {Branch: branch}, "best", {}, success, error);
		},
		currentUser: function (success, error) {
			agm.invoke("T42.ACS.GetUser", {}, "best", {}, success, error);
		},
		getFunctionalEntitlement: function (fn, success, error) {
			agm.invoke("T42.ACS.GetFunctionalEntitlement", {Function: fn}, "best", {}, function (e) {
				if (success) {
					success(e.returned.Entitlement);
				}
			}, error);
		},
		getFunctionalEntitlementBranch: function (fn, br, success, error) {
			agm.invoke("T42.ACS.GetFunctionalEntitlement", {Function: fn, Branch: br}, "best", {}, function (e) {
				if (success) {
					success(e.returned.Entitlement);
				}
			}, error);
		},
		canI: function (fn, success, error) {
			agm.invoke("T42.ACS.CanI", {Function: fn}, "best", {}, success, error);
		},

		canIBranch: function(fn, branch, success, error) {
			agm.invoke("T42.ACS.CanI", {Function: fn, Branch: branch}, "best", {}, success, error);
		},

		exit: function () {
			agm.invoke("T42.ACS.Shutdown", {}, "all", {},
				function (a) {
					console.log(a);
				},
				function (e) {
					console.log(e);
				});
		},

		setRegion: function (region, success, error){
			agm.invoke("T42.ACS.SetConfigurationRegion", {Region: region}, "best", {}, success, error);
		},

		getRegion: function(success, error){
			agm.invoke("T42.ACS.GetConfigurationRegion", {}, "best", {}, function (e) {
				if (success) {
					success(e.returned.Region);
				}
			}, error);
		},

		_trigger_app_event: apps._trigger,
		_trigger_instance_event: instances._trigger

	};

	function call_with(prop, func) {
		return function (result) {
			func(result[prop]);
		};

	}
	//Create event bindings

	//Tell the app when its instances are added/removed

	manager.onInstanceStarted(function (instance) {
		if (instance.application) {
			//Trigger "instance_started" event on application
			manager._trigger_app_event("instanceStarted", instance, instance.application.name);

			//Trigger "window_opened" event on instance
			var container;
			if (windows && glue) {
				var id = (instance.context && instance.context.guid) ? instance.context.guid : instance.id;
				container = instance.application.configuration.container;
				if(container !== null && container !== ""){
					glue.agm.invoke("T42.Wnd.FindById", {windowId: instance.id}, {application: container}, {}, window_opened, function(e){console.log(e)});
				}
			}
		}

		function window_opened(a) {
			//Wrap the window in a window object, using the glue windows lib
			var w = a.returned [Object.keys(a.returned)[0]];
			var win = glue.windows._from_event(w.windowName, container, w.url, w.windowId, w.windowStyleAttributes, w.windowTitle);

			//Trigger the window opened event
			manager._trigger_instance_event("windowAdded", win, id);
		}
	});

	manager.onInstanceStopped(function (instance) {
		if (instance.application) {
			manager._trigger_app_event("instanceStopped", instance, instance.application.name);

			var id = (instance.context && instance.context.guid) ? instance.context.guid : instance.id;
			manager._trigger_instance_event("windowRemoved", {}, id);

		}
	});

	manager.onInstanceUpdated(function (instance) {
		if (instance.application) {
		// manager._trigger_app_event("instance_stopped", instance, instance.application.name);

		// var id = (instance.context && instance.context.guid) ? instance.context.guid : instance.id;
		// manager._trigger_instance_event("title_changed", {}, id);
		}
	});
	//When an app is removed, remove also its instances

	manager.onAppRemoved(function (app) {
		app.instances.forEach(function (instance) {
			var id = (instance.context && instance.context.guid) ? instance.context.guid : instance.id;
			manager._trigger_instance_event("stopped", {}, id);
		});
	});
	
	var branch_changed_callback;
	manager.onBranchesChanged = function (callback) {
		branch_changed_callback = callback;
	};

	function on_branch_changed(e) {
		if (typeof branch_changed_callback === "function") {
			branch_changed_callback(helpers.vals(e));
		}
	}

	function handle_app_ready(app) {
		if (app.IsReady) {
			manager._trigger_app_event("available", app);
		} else {

			manager._trigger_app_event("unavailable", app);
		}
	}

	function app_failed(e) {
		manager._trigger_instance_event("error", e, e.Context.guid);
	}

	// deprecates
	manager.can_i = deprecate(manager.canI, 'appManager.can_i is deprecated and might be removed from future versions of glue. Use appManager.canI() instead');
	manager.can_i_branch = deprecate(manager.canIbranch, 'appManager.can_i_branch is deprecated and might be removed from future versions of glue. Use appManager.canIbranch() instead');
	manager.current_user = deprecate(manager.currentUser, 'appManager.current_user is deprecated and might be removed from future versions of glue. Use appManager.currentUser() instead');
	manager.set_current_branch = deprecate(manager.setCurrentBranch, 'appManager.set_current_branch is deprecated and might be removed from future versions of glue. Use appManager.setCurrentBranch() instead');
	manager.get_current_branch = deprecate(manager.getCurrentBranch, 'appManager.get_current_branch is deprecated and might be removed from future versions of glue. Use appManager.getCurrentBranch() instead');
	manager.get_branches = deprecate(manager.getBranches, 'appManager.get_branches is deprecated and might be removed from future versions of glue. Use appManager.getBranches() instead');
	manager.get_functional_entitlement_branch = deprecate(manager.getFunctionalEntitlementBranch, 'appManager.get_functional_entitlement_branch is deprecated and might be removed from future versions of glue. Use appManager.getFunctionalEntitlementBranch() instead');
	manager.get_functional_entitlement = deprecate(manager.getFunctionalEntitlement, 'appManager.get_functional_entitlement is deprecated and might be removed from future versions of glue. Use appManager.getFunctionalEntitlement() instead');
	manager.get_region = deprecate(manager.getRegion, 'appManager.get_region is deprecated and might be removed from future versions of glue. Use appManager.getRegion() instead');
	manager.set_region = deprecate(manager.setRegion, 'appManager.set_region is deprecated and might be removed from future versions of glue. Use appManager.setRegion() instead');
	manager.on_app_unavailable = deprecate(manager.onAppUnavailable, 'appManager.on_app_unavailable is deprecated and might be removed from future versions of glue. Use appManager.onAppUnavailable() instead');
	manager.on_app_removed = deprecate(manager.onAppRemoved, 'appManager.on_app_removed is deprecated and might be removed from future versions of glue. Use appManager.onAppRemoved() instead');
	manager.on_app_added = deprecate(manager.onAppAdded, 'appManager.on_app_added is deprecated and might be removed from future versions of glue. Use appManager.onAppAdded() instead');
	manager.on_app_available = deprecate(manager.onAppAvailable, 'appManager.on_app_available is deprecated and might be removed from future versions of glue. Use appManager.onAppAvailable() instead');
	manager.on_branches_changed = deprecate(manager.onBranchesChanged, 'appManager.on_branches_changed  is deprecated and might be removed from future versions of glue. Use appManager.onBranchesChanged() instead');
	manager.on_instance_started = deprecate(manager.onInstanceStarted, 'appManager.on_instance_started is deprecated and might be removed from future versions of glue. Use appManager.onInstanceStarted() instead');
	manager.on_instance_stopped = deprecate(manager.onInstanceStopped, 'appManager.on_instance_stopped is deprecated and might be removed from future versions of glue. Use appManager.onInstanceStopped() instead');
	manager.on_instance_updated= deprecate(manager.onInstanceUpdated, 'appManager.on_instance_updated is deprecated and might be removed from future versions of glue. Use appManager.onInstanceUpdated() instead');

	if (agm && agm.subscribe) {

		manager.agm = agm;
		var handlers = [
			{event: "OnApplicationAdded", trigger: "added", on: apps},
			{event: "OnApplicationRemoved", trigger: "removed", on: apps},
			{event: "OnApplicationChanged", trigger: "changed", on: apps},
			{event: "OnApplicationStarted", trigger: "started", on: instances},
			{event: "OnApplicationStopped", trigger: "stopped", on: instances},
			{event: "OnApplicationUpdated", trigger: "updated", on: instances},
			{event: "OnApplicationAgmServerReady", trigger: "agmReady", on: instances},
			{event: "OnApplicationReady", func: handle_app_ready},
			{event: "OnBranchesModified", func: on_branch_changed},
			{event: "OnApplicationStartFailed", raw_func: app_failed}
		];

         agm.serverMethodAdded(function (resp) {
             if ((resp.server.application.indexOf('AppManager') !== -1 && resp.method.name.indexOf('T42.ACS.OnEvent') !== -1)) {
                agm.subscribe("T42.ACS.OnEvent", {target: "all"})
                    .then(function (subscription) {
                        subscription.onData(function (streamData) {
                            var events = streamData.data;
                            handlers.forEach(function (handler) {
                                var objects = events[handler.event];
                                if (objects) {

                                    if (handler.raw_func !== undefined) {
                                        handler.raw_func(objects);
                                        return;
                                    }

                                    helpers.vals(objects).forEach(function (object) {
                                        if (handler.on !== undefined) {
                                            handler.on._trigger(handler.trigger, object);
                                        } else {
                                            handler.func(object);
                                        }
                                    });
                                }
                            });
                        })
                    });
             }
         });
	}

	manager.version =  PackageJson.version;

	return manager;
};

global.tick42 = global.tick42 ||{};
global.tick42.app_manager = global.app_manager;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../package.json":66,"./application":62,"./helpers":64,"./instance":65,"util-deprecate":109}],62:[function(require,module,exports){
var event_manager = require("./event_manager");
var helpers = require("./helpers");
var deprecate = require('util-deprecate');

module.exports = function(agm, instances) {
	var app_proto = helpers.add_callbacks({

		start: function (params, success, error) {
			params = params || {};
			params.guid = params.guid || Math.floor(Math.random() * 10000000);
			if (agm) {
				agm.invoke("T42.ACS.StartApplication", {Name: this.name, Context: params}, "best", {}, function (e) {
				}, error);
			}
			return instances()._trigger("create", {Context: params});

		}

	}, ["Added", "Removed", "Available", "Unavailable", "InstanceStarted", "InstanceStopped", "Changed"], "on");

	//deprecated
	app_proto.on_added = deprecate(app_proto.onAdded, 'application.on_added is deprecated and might be removed from future versions of glue. Use application.onAdded() instead');
	app_proto.on_removed = deprecate(app_proto.onRemoved, 'application.on_removed is deprecated and might be removed from future versions of glue. Use application.onRemoved() instead');
	app_proto.on_available = deprecate(app_proto.onAvailable, 'application.on_available is deprecated and might be removed from future versions of glue. Use application.onAvailable() instead');
	app_proto.on_unavailable = deprecate(app_proto.onUnavailable, 'application.on_unavailable is deprecated and might be removed from future versions of glue. Use application.onUnavailable() instead');
	app_proto.on_instance_started = deprecate(app_proto.onInstanceStarted, 'application.on_instance_started is deprecated and might be removed from future versions of glue. Use application.onInstanceStarted() instead');
	app_proto.on_instance_stopped = deprecate(app_proto.onInstanceStopped, 'application.on_instance_stopped is deprecated and might be removed from future versions of glue. Use application.onInstanceStopped() instead');
	app_proto.on_changed = deprecate(app_proto.onChanged, 'application.on_changed is deprecated and might be removed from future versions of glue. Use application.onChanged() instead');


	//constructor, init_event, id_field
	function update_app(props, obj) {
		obj.name = props.Name;
		obj.title = props.Title;
		obj.version = props.Version;
		obj.instances = [];
		obj.configuration = {};
		obj.configuration.auto_start = props.AutoStart;
		obj.configuration.caption = props.Caption;
		obj.configuration.hidden = props.IsHidden;
		obj.configuration.container = props.ApplicationName;
		obj.configuration.activityType = props.ActivityType;
		//obj.disabled = props.IsDisabled;
		obj.configuration.allow_multiple = props.AllowMultiple;
		obj.available = props.IsReady || false;
		obj.icon = props.Icon;
		obj.sortOrder = props.SortOrder;
		obj.userProperties = props.UserProperties;
		return obj;
	}

	var appToEventManager = {
		create: function create_app(props) {
			return update_app(props, Object.create(app_proto));
		},
		update: update_app,
		init_event: "added",
		exit_event: "removed",
		id_field: "Name",
		callbacks: {
			available: function () {
				this.available = true;
			},
			changed: function (props) {
				this.icon = props.Icon;
				this.title = props.Title;
				this.configuration.caption = props.Caption;
			},
			unavailable: function () {
				this.available = false;
			},
			instanceStarted: function (instance) {
				this.instances.push(instance);
			},
			instanceStopped: function (instance) {
				this.instances = this.instances.filter(function (my_instance) {
					return my_instance !== instance;
				});
			}
		}
	}
	//deprecated
	appToEventManager.callbacks.instance_started = deprecate(appToEventManager.callbacks.instanceStarted, 'application.instance_started is deprecated and might be removed from future versions of glue. Use application.instanceStarted() instead');
	appToEventManager.callbacks.instance_stopped = deprecate(appToEventManager.callbacks.instanceStopped, 'application.instance_stopped is deprecated and might be removed from future versions of glue. Use application.instanceStopped() instead');


	return event_manager(appToEventManager);
};

},{"./event_manager":63,"./helpers":64,"util-deprecate":109}],63:[function(require,module,exports){
var helpers = require("./helpers");

function exec_callbacks(obj, arr, val) {
	if (arr !== undefined) {
		arr.forEach(function (callback) {
			callback.call(obj, val);
		});
	}
}

module.exports = function create_environment(settings) {
	var objects = {};
	var global_callbacks = {};
	return {
		all: function () {
			return helpers.vals(objects);
		},
		get_by_id: function (id) {
			return objects[id];
		},
		_trigger: function (type, props, id) {
			id = id || ( typeof settings.id_field === "function" ? settings.id_field(props) : props[settings.id_field]);

			//Quit if we receive an event for an object before initiating it.
			if (objects[id] === undefined && ( type !== settings.init_event && type !== settings.create_event)) {
				//console.log ("Received '"+type+"' event before '"+settings.init_event+"'");
				return;
			}


			//Create or retrieve an object, representing the entity
			var obj = objects[id] = objects[id] || init_object(settings.create(props));

			if (type === settings.init_event) {
				//Quit if we receive a init event for an object that is already active
				if (obj.active) {
					//console.log ("Received second '"+settings.init_event+"' for app "+id);
					return;
					//Else, make it active
				} else {
					obj.active = true;
					settings.update(props, obj);
				}
				//When the entity is removed, set it to non-active
			} else if (type === settings.exit_event) {
				obj.active = false;

				//When a create event is received, just return the object without doing anything else
			} else if (type === settings.create_event) {
				return obj;

			} else if (type === settings.update_event) {
				settings.update(props, obj);
			}

			//Execute system callbacks
			if (settings.callbacks[type] !== undefined) {
				settings.callbacks[type].call(obj, props);
			}

			// make sure that errors in user specified callbacks does not
			// break our library
			try {
				//Execute global callbacks
				exec_callbacks(undefined, global_callbacks[type], obj);

				//Execute user-defined callbacks that are attached to the object
				exec_callbacks(obj, obj.callbacks[type], props);
			}
			catch (e){
				console.error(e);
			}
			//When the entity is removed, remove all callbacks (after you execute them)
			if (type === settings.exit_event) {
				obj.callbacks = {};
			}
			return obj;

		},
		//Expose the global callbacks object so that user can register some
		callbacks: global_callbacks
	};
};

function init_object(object) {
	object.callbacks = {};
	object.active = false;
	return object;
}

},{"./helpers":64}],64:[function(require,module,exports){
function noop(){}

function exec_if(condition) {
	return function (app, callback) {
		if (condition(app)) {
			callback.call(app);
		}
	};
}

exports.add_callbacks = function add_callbacks(object, events, prefix) {
	events.forEach(function (event) {
		if (typeof event === "string") {
			event = {name: event, trigger_when: noop};
		}
		object[prefix + event.name] = exports.add_callback(event.name, exec_if(event.trigger_when));
	});
	return object;

};

exports.add_callback = function add_callback(key, on_add){
	return function(callback){
		var obj = this.callbacks;
		if(typeof key !== 'undefined'){
			key = key.charAt(0).toLowerCase() + key.slice(1);
		}
			
		if(obj[key]===undefined){
			obj[key] = [callback];
		}
		else {
			obj[key].push(callback);
		}
		if(typeof on_add === "function"){
			on_add(this, callback);
		}
		return this;
	};
};

exports.vals = function vals(obj) {
	return Object.keys(obj).reduce(function (arr, key) {
		arr.push(obj[key]);
		return arr;
	}, []);
};

},{}],65:[function(require,module,exports){
var event_manager = require("./event_manager");
var helpers = require("./helpers");
var deprecate = require('util-deprecate');

module.exports = function(agm, apps) {
	var instance_proto = helpers.add_callbacks({
		stop: function (params, success, error) {
			agm.invoke("T42.ACS.StopApplication", {Name: this.application.name, Id: this.id}, "best", {}, function (e) {
				console.log(e);
			}, error);
		},
		activate: function (params, success, error) {
			agm.invoke("T42.ACS.ActivateApplication", {Name: this.application.name, Id: this.id}, "best", {}, function (e) {
				console.log(e);
			}, error);
		}
	}, [
		{
			name: "WindowAdded", trigger_when: function (app)  	{
			return app.active && app.main_window !== undefined;
		}
		},
		{
			name: "WindowRemoved", trigger_when: function (app) {
			return app.main_window === undefined;
		}
		},
		{
			name: "Started", trigger_when: function (app) {
			return app.id !== undefined && app.active;
		}
		},
		{
			name: "Stopped", trigger_when: function (app) {
			return app.id !== undefined && !app.active;
		}
		},
		{
			name: "AgmReady", trigger_when: function (app) {
			return app.active && app.agm !== undefined;
		}
		},
		{
		name: "Error", trigger_when: function (app) {
		return app.error !== undefined;
		}
		},
	], "on");

	//deprecated
	instance_proto.on_window_added = deprecate(instance_proto.onWindowAdded, 'instance.on_window_added is deprecated and might be removed from future versions of glue. Use instance.onWindowAdded() instead');
	instance_proto.on_window_removed = deprecate(instance_proto.onWindowRemoved, 'instance.on_window_removed is deprecated and might be removed from future versions of glue. Use instance.onWindowRemoved() instead');
	instance_proto.on_started = deprecate(instance_proto.onStarted, 'instance.on_started is deprecated and might be removed from future versions of glue. Use instance.onStarted() instead');
	instance_proto.on_stopped = deprecate(instance_proto.onStopped, 'instance.on_stopped is deprecated and might be removed from future versions of glue. Use instance.onStopped() instead');
	instance_proto.on_agm_ready = deprecate(instance_proto.onAgmReady, 'instance.on_agm_ready is deprecated and might be removed from future versions of glue. Use instance.onAgmReady() instead');
	instance_proto.on_error = deprecate(instance_proto.onError, 'instance.on_error is deprecated and might be removed from future versions of glue. Use instance.onError() instead');

	function update_instance(props, obj) {
		obj.id = props.Id;
		obj.application = apps.get_by_id(props.Name);
		obj.context = props.Context;
		obj.title = props.Title;
		obj.activityId = props.ActivityId;
		return obj;
	}

	var instanceToEventManager ={
		create: function (props) {
			return update_instance(props, Object.create(instance_proto));
		},
		update: update_instance,
		create_event: "create",
		init_event: "started",
		exit_event: "stopped",
    	update_event: "updated",
		id_field: function (e) {
			return e.Context !== undefined && e.Context.guid !== undefined ? e.Context.guid : e.Id;
		},
		callbacks: {
			agmReady: function (e) {
				//get the first AGM
				var server_name = Object.keys(e.AgmServers)[0];
				//Attach it to the object
				this.agm = convert_agm_instance(e.AgmServers[server_name]);
			},
			error: function (e) {
				this.error = e;
			},
			windowAdded: function (win) {
				this.main_window = win;
				this.windows = this.windows || [];
				this.windows.push(win);
			},
			windowRemoved: function () {
				this.main_window = undefined;
				this.windows = [];
			}
		}
	}

	//deprecated
	instanceToEventManager.callbacks.agm_ready = deprecate(instanceToEventManager.callbacks.agmReady, 'instance.agm_ready is deprecated and might be removed from future versions of glue. Use instance.agmReady() instead');
	instanceToEventManager.callbacks.window_added = deprecate(instanceToEventManager.callbacks.windowAdded, 'instance.window_added is deprecated and might be removed from future versions of glue. Use instance.windowAdded() instead');
	instanceToEventManager.callbacks.window_removed = deprecate(instanceToEventManager.callbacks.windowRemoved, 'instance.window_removed is deprecated and might be removed from future versions of glue. Use instance.windowRemoved() instead');

	return event_manager(instanceToEventManager);
};

function convert_agm_instance(agm) {
	return {
		machine: agm.machineName,
		user: agm.userName,
		environment: agm.environment,
		application: agm.applicationName

	};
}

},{"./event_manager":63,"./helpers":64,"util-deprecate":109}],66:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "tick42-app-manager@2.5.0",
      "C:\\work\\stash\\GLUE-dev\\js-glue"
    ]
  ],
  "_from": "tick42-app-manager@2.5.0",
  "_id": "tick42-app-manager@2.5.0",
  "_inCache": true,
  "_installable": true,
  "_location": "/tick42-app-manager",
  "_nodeVersion": "6.3.0",
  "_npmUser": {},
  "_npmVersion": "3.8.5",
  "_phantomChildren": {},
  "_requested": {
    "name": "tick42-app-manager",
    "raw": "tick42-app-manager@2.5.0",
    "rawSpec": "2.5.0",
    "scope": null,
    "spec": "2.5.0",
    "type": "version"
  },
  "_requiredBy": [
    "/"
  ],
  "_shasum": "db0206f1a681ab28fca166aca2725e1184fe6934",
  "_shrinkwrap": null,
  "_spec": "tick42-app-manager@2.5.0",
  "_where": "C:\\work\\stash\\GLUE-dev\\js-glue",
  "author": {
    "name": "Tick42",
    "url": "http://www.tick42.com"
  },
  "dependencies": {},
  "description": "App Manager API for JavaScript",
  "devDependencies": {
    "blanket": "^1.1.6",
    "bootstrap": "^3.3.4",
    "browserify-versionify": "^1.0.4",
    "grunt": "^0.4.5",
    "grunt-browserify": "^3.3.0",
    "grunt-cli": "^0.1.0",
    "grunt-contrib-clean": "^0.6.0",
    "grunt-contrib-connect": "^0.9.0",
    "grunt-contrib-jshint": "^0.11.0",
    "grunt-contrib-qunit": "^0.5.2",
    "grunt-contrib-uglify": "^0.6.0",
    "grunt-contrib-watch": "^0.6.1",
    "grunt-exorcise": "^1.0.0",
    "http-server": "^0.8.0",
    "jquery": "^2.1.4",
    "lodash": "^3.9.3",
    "phantomjs": "^1.9.12",
    "qunitjs": "^1.15.0",
    "tick42-agm": "^1.3.0",
    "uglifyify": "^3.0.1"
  },
  "directories": {
    "example": "examples"
  },
  "dist": {
    "shasum": "db0206f1a681ab28fca166aca2725e1184fe6934",
    "tarball": "http://192.168.0.234:4873/tick42-app-manager/-/tick42-app-manager-2.5.0.tgz"
  },
  "gitHead": "ccfc9d9b58fe171da36d2633729ad75ad4681b30",
  "license": "ISC",
  "main": "library/app_manager.js",
  "name": "tick42-app-manager",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "repository": {
    "type": "git",
    "url": "https://ibaltadzhieva@stash.tick42.com/scm/ofgw/js-app-manager.git"
  },
  "scripts": {
    "prepublish": "grunt",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "version": "2.5.0"
}

},{}],67:[function(require,module,exports){
/**
 * @module appconfig
 */
var _ = require('./util');
var Model = require('./model');
var helpers = require('./helpers');

var events = {
    connect: 'connect',
    disconnect: 'disconnect',
    update: 'update',
    status: 'status'
};

var EventBus = function () {
    'use strict';
    var subscriptionsByType;
    var on = function (type, once, callback, scope) {
        if (!_.isFunction(callback)) {
            return;
        }

        var subscription = {
            type: type,
            once: once,
            callback: callback,
            scope: scope
        };

        var subscriptions = subscriptionsByType[type];
        if (typeof subscriptions === 'undefined') {
            subscriptions = subscriptionsByType[type] = [];
        }

        subscription.id = subscriptions.push(subscription) - 1;
        return subscription;
    };

    var emit = function () {
        var args = [].slice.call(arguments);
        var type = args.splice(0, 1)[0];
        var subscriptions = subscriptionsByType[type];
        if (typeof subscriptions === 'undefined') {
            subscriptions = subscriptionsByType[type] = [];
        }

        subscriptions.forEach(function (subscription) {
            if (!subscription) {
                return;
            }

            try {
                subscription.callback.apply(subscription.scope, args);
            } catch (x) {
                _.warn('Exception during execution of callback', subscription, args, x);
            }

            if (subscription.once) {
                off(subscription);
            }
        });
    };

    var off = function (subscription) {
        var subscriptions = subscriptionsByType[subscription.type];
        if (typeof subscriptions !== 'undefined') {
            delete subscriptions[subscription.id];
        }
    };

    var resume = function (subscription) {
        if (typeof subscription.id === 'undefined') {
            return on(subscription.type, subscription.once, subscription.callback, subscription.scope);
        } else {
            var subscriptions = subscriptionsByType[subscription.type];
            if (typeof subscriptions === 'undefined') {
                subscriptions = subscriptionsByType[subscription.type] = [];
            }

            subscriptions[subscription.id] = subscription;
            return subscription;
        }
    };

    var reset = function () {
        if (typeof subscriptionsByType !== 'undefined') {
            Object.keys(subscriptionsByType).forEach(function (type) {
                var subscriptions = subscriptionsByType[type];
                if (typeof subscriptions !== 'undefined') {
                    subscriptions.forEach(function (subscription) {
                        delete subscription.id;
                    });
                }
            });
        }

        subscriptionsByType = {};
    };

    reset();
    return {
        on: on,
        emit: emit,
        off: off,
        resume: resume,
        reset: reset

    };
};

var AppConfig = function () {
    'use strict';
    var defaultListen  = true;
    var gateway;
    var initGateway;
    var bus = new EventBus();
    var model = new Model(bus);

    var root = require('./props')(model.root);
    var self = this;

    var gatewayConnection;
    var pollingIntervalId;
    var clearPollingInterval = function () {
        if (typeof pollingIntervalId !== 'undefined') {
            clearInterval(pollingIntervalId);
        }
    };

    // Public API
    self.init = function (settings) {
        settings = settings || {};
        var isIdentityValid = typeof settings.identity === 'object' &&
          Object.keys(settings.identity).length > 0;

        if (isIdentityValid) {
            self.identity = settings.identity;
        }

        defaultListen = settings.defaultListen || defaultListen;
        if (!self.identity) {
            throw new TypeError('identity must be non empty object.');
        }

        model.separator = settings.defaultSeparator || model.separator;

        self.schema = settings.schema || self.schema || 'ApplicationConfiguration';

        initGateway = _.isFunction(settings.gateway)
        ? settings.gateway
        : function () {
            if (typeof settings.gateway === 'undefined') {
                settings.gateway = {};
            }

            if (typeof settings.gateway.instance === 'undefined') {
                settings.gateway.instance = _.uuid();
            }

            return require('./gateway')(settings.gateway);
        };
    };

    self.connect = function (listen, callback, scope) {
        clearPollingInterval();
        var subscription;
        if (arguments.length > 0) {
            if (_.isFunction(listen)) {
                callback = listen;
                scope = callback;
                listen = defaultListen;
            }

            subscription = bus.on(events.connect, true, callback, scope);
        }

        var error;
        if (!self.identity) {
            error = 'identity is not specified. did you forget to call init()?';
        } else {
            if (!gateway) {
                gateway = initGateway();
            }

            if (!listen) {
                gatewayConnection =
                  gateway.connect(
                    self.schema,
                    self.identity,
                    false,
                    function (error, snapshot) {
                        if (typeof error === 'undefined') {
                            model.applySnapshot(snapshot);
                        }

                        bus.emit(events.connect, error);
                    },

                    function (error, status) {
                        bus.emit(events.status, error, status);
                    });
            } else {
                var connectEmitted = false;
                gatewayConnection = gateway.connect(
                  self.schema,
                  self.identity,
                  true,
                  function (error, snapshot, updates) {
                      if (typeof snapshot !== 'undefined') {
                          model.applySnapshot(snapshot);
                      }

                      if (typeof updates !== 'undefined') {
                          model.applyUpdates(updates);
                      }

                      if (!connectEmitted) {
                          connectEmitted = true;
                          bus.emit(events.connect, error);
                      }
                  },

                  function (error, status) {
                      var LISTEN_NOT_SUPPORTED = 8;
                      if (status.code === LISTEN_NOT_SUPPORTED) {
                          pollingIntervalId = setInterval(function () {
                              gateway.disconnect(gatewayConnection);
                              gatewayConnection = gateway.connect(self.schema, self.identity, false, function (error, snapshot) {
                                  model.applySnapshot(snapshot, false);
                              });
                          }, 2000);
                      }
                  });
            }
        }

        if (error) {
            setTimeout(bus.emit, 0, events.connect, error);
            throw new Error(error);
        }

        return subscription;

    };

    self.props = function (section, separator) {
        return root.props(section, separator);
    };

    self.modify = function (modifications, callback, scope) {
        if (typeof modifications === 'object') {
            modifications = [modifications];
        }

        var subscription = bus.on(events.update, true, callback, scope);

        return subscription;
    };

    self.onConnect = function (callback, scope) {
        return bus.on(events.connect, false, callback, scope);

    };

    self.onDisconnect = function (callback, scope) {
        return bus.on(events.disconnect, false, callback, scope);
    };

    self.off = function (subscription) {
        if (subscription) {
            bus.off(subscription);
        }
    };

    self.on = function (subscription) {
        if (subscription) {
            bus.resume(subscription);
        }
    };

    self.disconnect = function (callback, scope) {
        if (_.isFunction(callback)) {
            bus.on(events.disconnect, true, callback, scope);
        }

        clearPollingInterval();
        if (typeof gateway !== 'undefined') {
            gateway.disconnect(gatewayConnection, function (error) {
                bus.emit(events.disconnect, error);
            });

            gateway = undefined;
        } else {
            bus.emit(events.disconnect, 'not connected');
        }
    };
};

AppConfig.prototype.identityEqual = helpers.identityEqual;
AppConfig.prototype.identityToString = helpers.identityToString;

module.exports = function () {
    'use strict';
    return new AppConfig();
};

},{"./gateway":68,"./helpers":69,"./model":70,"./props":71,"./util":72}],68:[function(require,module,exports){
var gatewayConnection = require('tick42-gateway-connection');
var helpers = require('./helpers');
var identityToString = helpers.identityToString;
var PRODUCT = 'appconfig';

var GatewayTransport = function (options) {
    'use strict';
    var connection;
    var dataHandlers = {};
    var statusHandlers = {};
    options = options || {};

    function handleStatusMessage(msg) {
        var handler = statusHandlers[msg.instance];
        if (handler) {
            handler(msg.error, msg.status);
        }
    }

    function handleDataMessage(msg) {
        var schema = msg.schema;
        var schemaHandlers = dataHandlers[schema];
        if (typeof schemaHandlers === 'undefined') {
            return;
        }

        var identityKey = identityToString(msg.identity, true);
        var identityHandlers = schemaHandlers[identityKey];
        if (typeof identityHandlers === 'undefined') {
            return;
        }

        identityHandlers.forEach(function (handler) {
            if (handler) {
                handler(msg.error, msg.snapshot, msg.updates);
            }
        });
    }

    function ensureConnection() {
        if (typeof (connection) === 'undefined') {
            if (typeof options.connection !== 'undefined') {
                connection = options.connection;
            } else {
                connection = gatewayConnection(options.settings, options.custom_connection);
            }
        }
    }

    var dataSubscription;
    var statusSubscription;
    var connect = function (schema, identity, listen, handler, statusHandler) {
        ensureConnection();
        var schemaHandlers = dataHandlers[schema];
        if (typeof schemaHandlers === 'undefined') {
            schemaHandlers = dataHandlers[schema] = {};
        }

        var identityKey = identityToString(identity, true);
        var identityHandlers = schemaHandlers[identityKey];
        if (typeof identityHandlers === 'undefined') {
            identityHandlers = schemaHandlers[identityKey] = [];
        }

        var handlerToRegister;
        var index;
        if (listen) {
            handlerToRegister = handler;
        } else {
            handlerToRegister = function (error, snapshot, updates) {
                handler(error, snapshot, updates);
                delete identityHandlers[index];
            };
        }

        index = identityHandlers.push(handlerToRegister) - 1;

        if (typeof (dataSubscription) === 'undefined') {
            dataSubscription = connection.on(PRODUCT, GatewayTransport.MessageType.DATA, function (msg) {
                handleDataMessage(msg);
            });
        }

        var instance = options.instance;
        statusHandlers[instance] = statusHandler;
        if (typeof (statusSubscription) === 'undefined') {
            statusSubscription = connection.on(PRODUCT, GatewayTransport.MessageType.STATUS, function (msg) {
                handleStatusMessage(msg);
            });
        }

        var msg = {
            schema: schema,
            identity: identity,
            instance: instance,
            listen: listen
        };
        connection.send(PRODUCT, GatewayTransport.MessageType.CONNECT, msg);
        return {
            schema: schema,
            identity: identity,
            listen: listen,
            handler: handler,
            index: index
        };
    };

    var modify = function (schema, identity, modifications) {
        ensureConnection();
        connection.send(PRODUCT, GatewayTransport.MessageType.MODIFY, modifications);
    };

    var disconnect = function (descriptor) {
        var schemaHandlers = dataHandlers[descriptor.schema];
        if (typeof schemaHandlers !== 'undefined') {
            var identityKey = identityToString(descriptor.identity, true);
            var identityHandlers = schemaHandlers[identityKey];
            if (typeof identityHandlers !== 'undefined') {
                var handler = identityHandlers[descriptor.index];
                if (typeof handler !== 'undefined') {
                    var msg = {
                        schema: descriptor.schema,
                        identity: descriptor.identity,
                        instance: options.instance
                    };
                    connection.send(GatewayTransport.MessageType.DISCONNECT, msg);
                    delete identityHandlers[descriptor.index];
                }

                if (identityHandlers.length === 0) {
                    delete schemaHandlers[identityKey];
                }
            }

            if (Object.keys(schemaHandlers).length === 0) {
                delete dataHandlers[descriptor.schema];
            }
        }

        if (Object.keys(dataHandlers).length === 0) {
            if (typeof (dataSubscription) !== 'undefined') {
                connection.off(dataSubscription);
            }
        }

        delete statusHandlers[descriptor.instance];
        if (Object.keys(statusHandlers).length === 0) {
            if (typeof statusSubscription !== 'undefined') {
                connection.off(statusSubscription);
            }
        }
    };

    return {
        connect: connect,
        modify: modify,
        disconnect: disconnect
    };
};

GatewayTransport.MessageType = {
    // { schema: 'ApplicationConfiguration', identity: {}, listen: true, instance: '' }
    CONNECT: 'connect',
    // { schema: 'ApplicationConfiguration', identity: {}, instance: '' }
    DISCONNECT: 'disconnect',
    // { schema: 'ApplicationConfiguration', identity: {}, updates: [], instance: '' }
    MODIFY: 'modify',
    // { schema: 'ApplicationConfiguration', identity: {}, error: '', snapshot: {defaultKeyValue: '', keys: [], props: {}}, updates: [] }
    DATA: 'data',
    // { schema: 'ApplicationConfiguration', identity: {}, instance: '', status: '', error: '' }
    STATUS: 'status'
};

module.exports = GatewayTransport;

},{"./helpers":69,"tick42-gateway-connection":78}],69:[function(require,module,exports){
function escapeIdentityText(text) {
    'use strict';
    if (typeof text === 'string') {
        return text.replace(/[\\]/g, '\\\\').replace(/[:]/g, '\\:');
    } else {
        return text;
    }
}

function identityToString(identity, includeKeys, separator, order) {
    'use strict';
    if (typeof (identity) === 'undefined') {
        return null;
    }

    separator = separator || '/';
    var keys = Object.keys(identity);
    if (typeof (order) === 'function') {
        keys.sort(order);
    } else {
        keys.sort();
    }

    return keys.map(function (key) {
        return includeKeys ? (escapeIdentityText(key) + ':' + escapeIdentityText(identity[key])) : identity[key];
    }).join(separator);
}

function identityEqual(identity1, identity2) {
    'use strict';
    return identityToString(identity1, true) === identityToString(identity2, true);
}

function flatten(props, separator, name) {
    'use strict';
    separator = separator || '.';
    var prefix = name ? name + separator : '';
    var val = {};
    Object.keys(props).forEach(function (key) {
        if (key.indexOf(prefix) !== 0) {
            return;
        }

        var path = key.substring(prefix.length);
        var target = val;
        var parts = path.split(separator);
        var i;
        for (i = 0; i < parts.length - 1; i++) {
            if (!target[parts[i]]) {
                target[parts[i]] = {};
            }

            target = target[parts[i]];
        }

        target[parts[i]] = props[key].value;
    });

    return val;
}

function propEqual(lhs, rhs) {
    'use strict';
    if (lhs.value !== rhs.value) {
        return false;
    }

    for (var i = 0; i < lhs.underlying.length; i++) {
        var lhsUnderlying = lhs.underlying[i];
        var rhsUnderlying = rhs.underlying[i] || {};
        if (lhsUnderlying.value !== rhsUnderlying.value || !identityEqual(lhsUnderlying.parent, rhsUnderlying.parent)) {
            return false;
        }
    }

    return true;
}

module.exports = {
    flatten: flatten,
    propEqual: propEqual,
    identityToString: identityToString,
    identityEqual: identityEqual
};

},{}],70:[function(require,module,exports){
var propEqual = require('./helpers').propEqual;

var UpdateType = {
    Added: 'Added',
    Changed: 'Changed',
    Removed: 'Removed'
};

var Model = function (bus, separator) {
    'use strict';
    this.bus = bus;
    this.root = new ViewModel(this, '', separator || '.');
    this.views = {};
};

var ViewModel = function (model, path, separator) {
    'use strict';
    var self = this;
    self.model = model;
    self.props = {};
    self.separator = separator || model.separator;
    self.path = path;
};

ViewModel.prototype.getViewModel = function (name, separator) {
    'use strict';
    var path = this.path + name + (separator ? separator : '.');
    var model = this.model;
    if (path === '') {
        return model.root;
    }

    if (!model.views[path]) {
        var bestParent = '';
        // fill subview references and choose best parent props to copy from.
        Object.keys(model.views).forEach(function (key) {
            if (path.indexOf(key) === 0) {
                if (bestParent.length < key.length) {
                    bestParent = key;
                }
                // keep subviews sorted.
                var subviews = model.views[key].subviews;
                for (var i = 0; i < subviews.length; i++) {
                    if (subviews[i].indexOf(path)) {
                        subviews.splice(i, 0, path);
                        return;
                    }
                }

                subviews.push(path);
            }
        });

        var viewModel = new ViewModel(model, path, separator);

        var parentProps = bestParent === '' ? model.root.props : model.views[bestParent].model.props;
        Object.keys(parentProps).forEach(function (key) {
            var prop = parentProps[key];
            if (prop.name.indexOf(path) === 0) {
                var name = prop.name.substring(path.length);
                viewModel.props[name] = prop;
            }
        });

        model.views[path] = {
            subviews: [],
            model: viewModel
        };
    }

    return model.views[path].model;
};

ViewModel.prototype.on = function (callback, scope) {
    'use strict';
    return this.model.on(this.path, callback, scope);
};

Model.prototype.on = function (path, callback, scope) {
    'use strict';
    var type = updateTypeForPath(path);
    return this.bus.on(type, false, callback, scope);
};

Model.prototype.applySnapshot = function (snapshot, isSnapshot) {
    'use strict';
    isSnapshot = typeof isSnapshot === 'undefined' ? true : isSnapshot;

    var updates = toUpdates(isSnapshot ? {} : this.root.props, snapshot.props);
    applyUpdatesAndEmitEvents(this, updates, isSnapshot);
};

function updateTypeForPath(path) {
    'use strict';
    var type = 'update';
    if (path !== '') {
        type = type + '|' + path;
    }

    return type;
}

// shallow copy
function cloneUpdateForPath(update, path) {
    'use strict';
    var clone = {
        type: update.type,
        name: update.name.substring(path.length)
    };

    switch (update.type) {
        case UpdateType.Changed:
            clone.oldValue = update.oldValue;
            clone.value = update.value;
            break;
        case UpdateType.Added:
            clone.value = update.value;
            break;
        case UpdateType.Removed:
            break;
        default:
            break;
    }
    return clone;
}

function applyUpdatesAndEmitEvents(model, updates, isSnapshot) {
    'use strict';
    var views = Object.keys(model.views);
    var effectiveUpdates = { '': updates };
    if (views.length > 0) {
        // sort views for prefix search
        if (views.length > 1) {
            views.sort();
        }

        updates.forEach(function (update) {
            var view;
            for (var i = 0; i < views.length; views++) {
                if (update.name.indexOf(views[i]) === 0) {
                    view = views[i];
                    break;
                }
            }

            if (typeof view === 'undefined') {
                return;
            }

            effectiveUpdates[view].push(cloneUpdateForPath(update, view));
        });
    }

    var affectedPaths = Object.keys(effectiveUpdates);
    if (affectedPaths.length > 1) {
        affectedPaths.sort();
    }

    affectedPaths.forEach(function (path) {
        var viewModel = path === '' ? model.root : model.views[path].model;
        if (isSnapshot) {
            viewModel.props = {};
        }

        effectiveUpdates[path].forEach(function (update) {
            switch (update.type) {
                case UpdateType.Added:
               // break omitted
                case UpdateType.Changed:
                // changed works even for missing properties
                    viewModel.props[update.name] = update.value;
                    break;
                case UpdateType.Removed:
                    delete viewModel.props[update.name];
                    break;
                default:
                // do nothing
                    break;
            }
        });
    });

    affectedPaths.forEach(function (path) {
        var type = updateTypeForPath(path);
        model.bus.emit(type, isSnapshot, updates);
    });
}

Model.prototype.applyUpdates = function (updates) {
    'use strict';
    applyUpdatesAndEmitEvents(this, updates, false);
};

function toUpdates(image, snapshot) {
    'use strict';
    snapshot = snapshot || {};
    var updates = [];
    var toDelete = Object.keys(image);
    Object.keys(snapshot).forEach(function (key) {
        var update = {};
        if (typeof image[key] === 'undefined') {
            update.type = UpdateType.Added;
        } else {
            if (!propEqual(image[key], snapshot[key])) {
                update.type = UpdateType.Changed;
                update.oldValue = image[key];
            }

            var indexToDelete;
            for (indexToDelete = 0; indexToDelete < toDelete.length; toDelete++) {
                if (toDelete[indexToDelete] === key) {
                    break;
                }
            }

            if (typeof toDelete[indexToDelete] !== 'undefined') {
                toDelete.splice(indexToDelete, 1);
            }
        }

        if (update.type) {
            update.value = snapshot[key];
            update.name = key;
            updates.push(update);
        }
    });

    toDelete.forEach(function (key) {
        updates.push({
            type: UpdateType.Removed,
            name: key
        });
    });

    return updates;
}

module.exports = Model;

},{"./helpers":69}],71:[function(require,module,exports){
var flatten = require('./helpers').flatten;

var Props = function (model) {
    'use strict';
    var prop = function (name) {
        return model.props[name];
    };

    var val = function val(name) {
        if (typeof name === 'undefined' || typeof model.props[name] === 'undefined') {
            return flatten(model.props, model.separator, name);
        }

        return model.props[name].value;
    };

    var props = function (section, separator) {
        section = section || '';
        if (section === '') {
            // TODO: support separator change for '' (same) section.
            return self;
        }

        separator = separator || model.separator;
        return new Props(model.getViewModel(section, separator));
    };

    var forEach = function (callback, scope) {
        Object.keys(model.props).forEach(function (key) {
            callback.call(scope, model.props[key]);
        });
    };

    var onUpdate = function (callback, scope) {
        model.on(callback, scope);
    };

    var self = {
        prop: prop,
        val: val,
        props: props,
        forEach: forEach,
        onUpdate: onUpdate
    };
    return self;
};

module.exports = Props;

},{"./helpers":69}],72:[function(require,module,exports){
var uuid = function () {
    'use strict';
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0;
        var v = c === 'x' ? r : ((r & 0x3) | 0x8);
        return v.toString(16);
    });
};

var isFunction = function (value) {
    'use strict';
    if (value === undefined || value === null) {
        return false;
    }

    return typeof value === 'function';
};

var isString = function (value) {
    'use strict';
    return typeof value === 'string';
};

var levels = {
    debug: 'debug',
    info: 'info',
    warn: 'warn',
    error: 'error'
};
var log = function (level, args) {
    'use strict';
    if (console) {
        var logger = console[level];
        if (isFunction(logger)) {
            var now = new Date();
            [].splice.call(args, 0, 0, now.getHours() + ':' + now.getMinutes() + ':' + now.getSeconds());
            logger.apply(console, args);
        }
    }
};

var info = function () {
    'use strict';
    log(levels.info, arguments);
};

var warn = function () {
    'use strict';
    log(levels.warn, arguments);
};

var debug = function () {
    'use strict';
    log(levels.debug, arguments);
};

module.exports = {
    uuid: uuid,
    isFunction: isFunction,
    isString: isString,
    log: log,
    warn: warn,
    info: info,
    debug: debug
};

},{}],73:[function(require,module,exports){
function createBridge() {
    'use strict';

    return {};
}

module.exports = createBridge;

},{}],74:[function(require,module,exports){
function createBridge() {
    'use strict';
    var facade = htmlContainer.sharedContextFacade;

    function all() {
        var allObj = facade.all();
        if (!allObj || !allObj.keys) {
            return [];
        }
        return allObj.keys;
    }

    function update(name, data) {
        return facade.update(name, data);
    }

    function set(name, data) {
        facade.set(name, data);
    }

    function subscribe(name, callback) {
        return facade.subscribe(name, callback);
    }

    function unsubscribe(key) {
        facade.unsubscribe(key);
    }

    return {
        all: all,
        update: update,
        set: set,
        subscribe: subscribe,
        unsubscribe: unsubscribe
    };
}

module.exports = createBridge;



},{}],75:[function(require,module,exports){
var PackageJson = require('../package.json');
var hcBridge = require('./bridges/hc.js');
var gwBridge = require('./bridges/gw.js');

function contexts(config) {
    'use strict';
    var bridge = getBridge(config);

    function getBridge(config) {
        if (typeof htmlContainer !== 'undefined') {
            if (!htmlContainer.sharedContextFacade) {
                return 'Your version of HtmlContainer does not support contexts. Get version 1.46.0.0 or later to have that feature.';
            }
            return hcBridge(config);
        }
        return gwBridge(config);
    }

    function all() {
        return bridge.all();
    }

    function update(name, data) {
        return bridge.update(name, data);
    }

    function set(name, data) {
        return bridge.set(name, data);
    }

    function subscribe(name, callback) {
        return bridge.subscribe(name, callback);
    }

    function unsubscribe(key) {
        bridge.unsubscribe(key);
    }

    // bridge being a string means the initializtion failed and there is some error in that string
    if (typeof bridge === 'string') {
        return {
            error: bridge,
            version: PackageJson.version
        };
    }

    return {
        all: all,
        update: update,
        set: set,
        subscribe: subscribe,
        unsubscribe: unsubscribe,
        version: PackageJson.version
    };
}

module.exports = contexts;

},{"../package.json":76,"./bridges/gw.js":73,"./bridges/hc.js":74}],76:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "tick42-contexts@0.0.2",
      "C:\\work\\stash\\GLUE-dev\\js-glue"
    ]
  ],
  "_from": "tick42-contexts@0.0.2",
  "_id": "tick42-contexts@0.0.2",
  "_inCache": true,
  "_installable": true,
  "_location": "/tick42-contexts",
  "_nodeVersion": "5.3.0",
  "_npmUser": {},
  "_npmVersion": "3.3.12",
  "_phantomChildren": {},
  "_requested": {
    "name": "tick42-contexts",
    "raw": "tick42-contexts@0.0.2",
    "rawSpec": "0.0.2",
    "scope": null,
    "spec": "0.0.2",
    "type": "version"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "http://192.168.0.234:4873/tick42-contexts/-/tick42-contexts-0.0.2.tgz",
  "_shasum": "af038bb59ec4309129f392e763b4b55274ceee5e",
  "_shrinkwrap": null,
  "_spec": "tick42-contexts@0.0.2",
  "_where": "C:\\work\\stash\\GLUE-dev\\js-glue",
  "author": {
    "name": "Tick42"
  },
  "bin": {
    "build": "./bin/build.js",
    "clean": "./bin/clean.js",
    "file-versionify": "./bin/file-versionify.js",
    "minify": "./bin/minify.js"
  },
  "dependencies": {
    "tick42-gateway-connection": ">=1.1.9"
  },
  "description": "A library for shared contexts",
  "devDependencies": {
    "browserify": "^13.0.0",
    "browserify-replacify": "^0.0.4",
    "browserify-versionify": "^1.0.4",
    "eslint": "^3.1.1",
    "eslint-config-standard": "^5.3.5",
    "eslint-config-tick42": "^1.0.0",
    "eslint-plugin-promise": "^2.0.0",
    "eslint-plugin-standard": "^2.0.0",
    "minifyify": "^7.3.2",
    "onchange": "^2.1.2"
  },
  "dist": {
    "shasum": "af038bb59ec4309129f392e763b4b55274ceee5e",
    "tarball": "http://192.168.0.234:4873/tick42-contexts/-/tick42-contexts-0.0.2.tgz"
  },
  "gitHead": "ad0ff4156b209cdeb0b8553ff0b3daa33585f76d",
  "license": "ISC",
  "main": "library/main.js",
  "name": "tick42-contexts",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "repository": {
    "type": "git",
    "url": "https://kpopov@stash.tick42.com/scm/tg/js-contexts.git"
  },
  "scripts": {
    "build": "npm run eslint && node bin/clean.js && node bin/build.js && node bin/minify && node bin/file-versionify",
    "eslint": "eslint library",
    "eslint:fix": "eslint library --fix",
    "prepublish": "npm update & npm run build",
    "watch": "onchange \"./library/*.js\" -iv -e \"./bin\" -- npm run build"
  },
  "version": "0.0.2"
}

},{}],77:[function(require,module,exports){
var callbackRegistry = require('callback-registry');
var packageJson = require('../package.json');

/**
 * A template for gateway connections - this is extended from specific protocols and transports.
 */
module.exports = function (settings) {
    'use strict';
    // The message handlers that have to be executed for each received message
    var messageHandlers = {};
    var ids = 0;
    var registry = callbackRegistry();

    return {
        _connected : false,

        // assembles a new message to be sent to gateway,
        // this should be replaced from concrete gateway connection
        _createMessage: function(type, message, id) {
            throw new Error('Not implemented - you should extend the connection with protocol ' + type + message + id);
        },

        // processes a new message calling the distribute method,
        // this should be replaced from concrete if they have different message structure
        _processMessage: function(message) {
            throw new Error('Not implemented - you should extend the connection with protocol ' + message);
        },

        // Executes appropriate message handlers for the message type.
        _distributeMessage: function (message, type) {
            // Retrieve handlers for the message type
            var handlers = messageHandlers[type.toLowerCase()];
            if (handlers !== undefined) {
                // Execute them
                Object.keys(handlers).forEach(function (handlerId) {
                    var handler = handlers[handlerId];
                    if (handler !== undefined) {
                        handler(message);
                    }
                });
            }
        },

        // triggers connection change notifying all users
        _triggerConnectionChanged: function(connected) {
            this._connected = connected;

            if (connected) {
                registry.execute('connected');
            } else {
                registry.execute('disconnected');
            }
        },

        // Attaches a handler
        on: function (product, type, messageHandler) {
            type = type.toLowerCase();
            if (messageHandlers[type] === undefined) {
                messageHandlers[type] = {};
            }

            var id = ids++;
            messageHandlers[type][id] = messageHandler;

            return {
                type: type,
                id: id
            };
        },

        // Remove a handler
        off: function (info) {
            delete messageHandlers[info.type.toLowerCase()][info.id];
        },

        connected: function (callback) {
            if (this._connected) {
                callback(settings.ws || settings.http);
            }

            registry.add('connected', callback);
        },

        disconnected: function (callback) {
            registry.add('disconnected', callback);
        },

        login: function() {
            return true;
        },

        logout: function() {
            return true;
        },

        // Init function that will be called after successful login
        init: function() {
            return true;
        },

        protocolVersion : settings.protocolVersion || 1,

        version: packageJson.version
    }
};


},{"../package.json":86,"callback-registry":6}],78:[function(require,module,exports){
(function (global){
var baseConnection = require('./connection');

/**
 * Check readme.md for detailed description
 */
var connection = function (settings, customConnection) {
    'use strict';
    settings = settings || {};
    var connection = baseConnection(settings);

    // if running in HC we use gw1 protocol and hc transport
    if (global.htmlContainer !== undefined) {
        connection = require('./protocols/gw1')(connection, settings);
        return require('./transports/hc')(connection, settings);
    }

    // if running in the browser - let's check which protocol version user wants
    if (settings.protocolVersion === 3) {
        connection = require('./protocols/gw3')(connection, settings);
    } else if (settings.protocolVersion === 2) {
        connection = require('./protocols/gw2')(connection, settings);
    } else {
        connection = require('./protocols/gw1')(connection, settings);
    }

    if (settings.ws !== undefined) {
        return require('./transports/ws')(connection, settings);
    } else if (settings.http !== undefined) {
        return require('./transports/http')(connection, settings);
    } else if (customConnection !== undefined) {
        return require('./transports/mock')(connection, customConnection, settings);
    } else {
        throw new Error('No connection. Make sure you are running the application from Tick42 HtmlContainer or fill the \'connection.websocket_url\' property.');
    }
};

if (global.tick42 === undefined) {
    global.tick42 = {};
}

global.tick42.connection = connection;

module.exports = connection;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./connection":77,"./protocols/gw1":79,"./protocols/gw2":80,"./protocols/gw3":81,"./transports/hc":82,"./transports/http":83,"./transports/mock":84,"./transports/ws":85}],79:[function(require,module,exports){
// Connection to gateway V1 - the one that runs on the desktop without authentication
var Promise = require('es6-promise').Promise;

module.exports = function(connection) {
    'use strict';

    connection._processMessage = function(message) {
        message = JSON.parse(message);
        connection._distributeMessage(message.message, message.type);
    };

    connection._createMessage = function(type, message, id) {
        return JSON.stringify({
            type: type,
            message: message,
            id: id
        });
    };

    connection.login = function() {
        return new Promise(function(resolve) {
            resolve();
        });
    };
    return connection;
};

},{"es6-promise":11}],80:[function(require,module,exports){
// Connection to gateway V2 - gw1 +  authentication
var Promise = require('es6-promise').Promise;

module.exports = function(connection) {
    'use strict';

    var sessionCookie;
    connection._processMessage = function(message) {
        message = JSON.parse(message);
        var dataType = message.type;

        if (dataType === 'SEND')  {
            message = message.data;
            connection._distributeMessage(message.message, message.type);
        } else {
            connection._distributeMessage(message, message.type);
        }
    };

    connection._createMessage = function(type, message, id) {
        if (type === 'LOGIN') {
            return JSON.stringify(message);
        }

        if (type === 'LOGOUT') {
            return JSON.stringify({ type: 'LOGOUT' });
        }

        return JSON.stringify({
            type: 'SEND',
            sessionCookie: sessionCookie,
            data: {
                type: type,
                message: message,
                id: id
            }
        });
    };

    connection.login = function(message) {
        return new Promise(function(resolve, reject) {
            var request;
            if (message.token) {
                request = {
                    token: message.token,
                    type: 'LOGIN_TOKEN'
                };
            } else if (message.username) {
                request = {
                    user: message.username,
                    password: message.password,
                    type: 'LOGIN'
                };
            } else {
                throw new Error('invalid auth message' + JSON.stringify(message));
            }

            var lrSubs = connection.on('', 'LOGIN_RESPONSE', function (response) {
                connection.off(lrSubs);

                if (response && !response.errorMessage) {
                    sessionCookie = response.sessionCookie;
                    resolve(response);
                } else {
                    reject(response);
                }
            });

            connection.send('', 'LOGIN', request);
        });
    };

    connection.logout = function() {
        connection.send('', 'LOGOUT');
    };

    return connection;
};


},{"es6-promise":11}],81:[function(require,module,exports){
var cuid = require('cuid');
var Promise = require('es6-promise').Promise;
var URLSearchParams = require('url-search-params');

module.exports = function(connection, settings) {
    'use strict';
    var datePrefix = '#T42_DATE_';
    var datePrefixLen = datePrefix.length;
    var dateMinLen = datePrefixLen + 1;// prefix + at least one char (1970/01/01 = 0)
    var datePrefixFirstChar = datePrefix[0];

    connection.instance = cuid();

    connection._processMessage = function(message) {
        message = JSON.parse(message, function(key, value) {
            if (typeof key !== 'string') {
                return value;
            }
            if (key[0] !== datePrefixFirstChar) {
                return value;
            }
            if (value.length < dateMinLen) {
                return value;
            }
            var milliseconds = parseInt(value.substring(datePrefixLen, value.length), 10);
            if (isNaN(milliseconds)) {
                return value;
            }
            return new Date(milliseconds);
        });
        connection._distributeMessage(message, message.type);
    };

    connection._createMessage =  function(type, message) {
        return JSON.stringify(message, function (key, value) {
            // serialize dates as #T42_DATE(<MILLISECONDS_FROM_1970_01_01>)

            if (value === null || typeof value !== 'object') {
                return value;
            }
            // some duck typing
            if (!value.getTime) {
                return value;
            }

            if (!(value instanceof Date)) {
                return value;
            }

            return datePrefix + value.getTime();
        });
    };

    connection.login = function(message) {
        return new Promise(function(resolve, reject) {
            var authentication = {};
            var gwToken = getGatewayToken();
            if (gwToken) {
                authentication.method = 'gateway-token';
                authentication.token = gwToken;
            } else if (message.token) {
                authentication.method = 'access-token';
                authentication.token = message.token;
            } else if (message.username) {
                authentication.method = 'secret';
                authentication.user = message.username;
                authentication.secret = message.password;
            } else {
                throw new Error('invalid auth message' + JSON.stringify(message));
            }

            var requestId = cuid();
            var helloMsg = {
                request_id: requestId,
                type: 'hello',
                identity: { application: settings.application, instance: connection.instance },
                authentication: authentication
            };

            var welcomeSub = connection.on('', 'welcome', function (msg) {
                if (msg.request_id !== requestId) {
                    return;
                }

                connection.off(welcomeSub);
                connection.off(errorSub);
                connection.peerId = msg.peer_id;
                connection.gwToken = gwToken;
                resolve(msg);
            });

            var errorSub = connection.on('', 'error', function (msg) {
                if (msg.request_id !== requestId) {
                    return;
                }

                connection.off(errorSub);
                connection.off(welcomeSub);
                reject(msg);
            });

            connection.send('', 'LOGIN', helloMsg);
        });
    };

    connection.logout = function() {
        connection.send('', 'LOGOUT');
    };

    function getGatewayToken() {
        if (settings.gwTokenProvider) {
            return settings.gwTokenProvider.get();
        }

        if (location && location.search) {
            var searchParams = new URLSearchParams(location.search.slice(1));
            return searchParams.get('t42gwtoken');
        }

        return null;
    }

    return connection;
};


},{"cuid":7,"es6-promise":11,"url-search-params":108}],82:[function(require,module,exports){
(function (global){
/**
 * Connection to HtmlContainer
 */
module.exports = function (connection) {
    'use strict';
    var connectionId = Math.floor(1e10 * Math.random()).toString();
    // Route messages to facade(s)
    connection.send = function (product, type, message) {
        if (product === 'metrics') {
            global.htmlContainer.metricsFacade.send(type, JSON.stringify(message));
        } else if (product === 'log') {
            global.htmlContainer.loggingFacade.send(type, JSON.stringify(message));
        } else if (product === 'appconfig') {
            global.htmlContainer.appConfigFacade.send(type, JSON.stringify(message), connectionId);
        }
    };

    if (global.htmlContainer.appConfigFacade !== undefined) {
        global.htmlContainer.appConfigFacade.initConnection(
            connectionId,
            function (messageAsJson) {
                return connection._handle_message(JSON.parse(messageAsJson));
            });
    }

    global.connections = global.connections || {};
    // Expose function for sending messages:
    global.connections['connection' + connectionId] = connection._handle_message;

    return connection;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],83:[function(require,module,exports){
(function (global){
module.exports = function (connection, settings) {
    'use strict';
    var url = settings.http;
    // polling interval in ms, default is 1 second
    var interval = settings.http_interval_ms;
    if (!interval) {
        interval = 1000;
    }

    function logDebug(message) {
        if (global.console !== undefined && (settings.debug === true || settings.trace === true)) {
            console.log(message);
        }
    }

    function logTrace(message) {
        if (global.console !== undefined && settings.trace === true) {
            console.log(message);
        }
    }

    logDebug('Attemping to connect to Gateway via HTTP with url \'' + url + '\' and polling interval ' + interval + ' ms');

    connection.init = function() {
        poll(url, interval, 0, function (items) {
            for (var index = 0; index < items.length; index++) {
                connection._processMessage(items[index]);
            }
        });
    }

    connection.send = function (product, type, message, id) {
        var msg = connection._createMessage(type, message, id);
        httpPost(url, msg);
    };

    /**
     * Polls data from a given url on some interval
     * @param url       Base server url. A sequence url param may be added based on the seq param
     * @param interval  Interval (in ms) between polling requestts
     * @param seq       Next sequence number we should ask for (if 0 the server will return the last known message)
     * @param ondata    Data callback
     */
    function poll(url, interval, seq, ondata) {
        // construct the get Url - if seq != 0 add as url param to get
        // only messages after this sequence
        var getUrl = url;

        if (seq !== 0) {
            getUrl = url + '?sequence=' + seq + '&no-cache=' + new Date().getTime();
        }

        // create a request
        var xmlhttp = createCORSRequest('GET', getUrl, function () {
            if (seq === 0) {
                logDebug('Connected to Gateway on ' + url);
            }

            logTrace('Response from \'' + getUrl + '\' is ' + xmlhttp.responseText);
            var message = JSON.parse(xmlhttp.responseText);
            // the server returns the number of the next sequence that we must query for
            var nextSeq = message.nextSequence;
            // call user callbacke
            ondata(message.data);
            // re-schedule
            setTimeout(function () {
                poll(url, interval, nextSeq, ondata);
            }, interval);
        });

        xmlhttp.onerror = function (ev) {
            console.log('Error polling data from http server \'' + getUrl + '\' - ' + ev);
            // re-schedule
            setTimeout(function () {
                poll(url, interval, seq, ondata);
            }, interval);
        };

        logTrace('Sending GET to \'' + getUrl + '\'');
        xmlhttp.send();
    }

    /**
     * POSTs a message to a given url
     */
    function httpPost(url, message) {
        // create a request
        var xmlhttp = createCORSRequest('POST', url);
        logTrace('Sending POST to \'' + url + '\' : ' + message);
        xmlhttp.send(message);
    }

    /**
     * Creates CORS request (cross domain requests) for different browsers - XMLHttpRequest withCredentials
     * for Chrome and FF and XDomainRequest for IE
     */
    function createCORSRequest(method, url, resultCallback) {
        var xhr = new XMLHttpRequest();

        if ('withCredentials' in xhr) {
            // Check if the XMLHttpRequest object has a "withCredentials" property.
            // "withCredentials" only exists on XMLHTTPRequest2 objects.
            xhr.open(method, url, true);
            if (typeof resultCallback !== 'undefined') {
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4 && xhr.status === 200) {
                        resultCallback();
                    }
                };
            }
        } else if (typeof XDomainRequest !== 'undefined') {
            // Otherwise, check if XDomainRequest.
            // XDomainRequest only exists in IE, and is IE's way of making CORS requests.
            xhr = new XDomainRequest();
            xhr.open(method, url);
            if (typeof resultCallback !== 'undefined') {
                xhr.onload = resultCallback;
            }
        } else {
            // Otherwise, CORS is not supported by the browser.
            xhr = null;
        }

        return xhr;
    }

    return connection;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],84:[function(require,module,exports){
/**
 * Used for tests
 */
module.exports = function(connection, customConnection) {
    'use strict';
    connection.send = function (product, type, message) {
        customConnection.publish({
            type: type,
            message: message
        });
    };

    customConnection.subscribe(connection._handle_message);
    return connection;
};

},{}],85:[function(require,module,exports){
(function (global){
module.exports = function (connection, settings) {
    'use strict';

    // Load the 'ws' library, but only if we are running under node js
    var WebSocket = require('detect-node') ? require('ws') : global.WebSocket;

    function initiateSocket() {
        var ws = new WebSocket(settings.ws);
        ws.onclose = function () {
            connection._triggerConnectionChanged(false);
        };
        // Log on connection
        ws.onopen = function () {
            connection._triggerConnectionChanged(true);
        };
        // Attach handler
        ws.onmessage = function (message) {
            connection._processMessage(message.data);
        };

        return ws;
    }

    // Holds callback execution until socket connection is established.
    function waitForSocketConnection (callback) {
        if (!callback) {
            return;
        }

        if (socket.readyState === 1) {
            return callback();
        } else if (socket.readyState > 1) {
            // > 1 means closing or closed
            socket = initiateSocket();
        }

        setTimeout(function () {
            waitForSocketConnection(callback);
        }, 50); // wait 5 milliseconds for the connection...
    }

    // Initiate a new socket (this gets re-executed on reconnect)
    var socket = initiateSocket();

    // Create a function for sending a message
    connection.send = function (product, type, message, id) {
        waitForSocketConnection(function() {
            var msg = connection._createMessage(type, message, id);
            if (!msg) {
                return;
            }
            socket.send(msg);
        });
    };

    connection.websocket_url = function (a) {
        settings.websocket_url = a;
        socket.close();
        socket = initiateSocket();
    };

    return connection;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"detect-node":8,"ws":110}],86:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "tick42-gateway-connection@^2.0.3",
      "C:\\work\\stash\\GLUE-dev\\js-glue"
    ]
  ],
  "_from": "tick42-gateway-connection@>=2.0.3 <3.0.0",
  "_id": "tick42-gateway-connection@2.1.2",
  "_inCache": true,
  "_installable": true,
  "_location": "/tick42-gateway-connection",
  "_nodeVersion": "6.3.0",
  "_npmUser": {},
  "_npmVersion": "3.8.5",
  "_phantomChildren": {},
  "_requested": {
    "name": "tick42-gateway-connection",
    "raw": "tick42-gateway-connection@^2.0.3",
    "rawSpec": "^2.0.3",
    "scope": null,
    "spec": ">=2.0.3 <3.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/",
    "/tick42-agm",
    "/tick42-appconfig",
    "/tick42-contexts",
    "/tick42-logger",
    "/tick42-metrics"
  ],
  "_shasum": "4db28853edd5f88c12fec471ad0b74198c512d57",
  "_shrinkwrap": null,
  "_spec": "tick42-gateway-connection@^2.0.3",
  "_where": "C:\\work\\stash\\GLUE-dev\\js-glue",
  "bin": {
    "build": "./bin/build.js",
    "clean": "./bin/clean.js",
    "file-versionify": "./bin/file-versionify.js",
    "minify": "./bin/minify.js"
  },
  "dependencies": {
    "browserify-versionify": "^1.0.4",
    "callback-registry": "^1.0.1",
    "cuid": "^1.3.8",
    "detect-node": "^2.0.3",
    "es6-promise": "^3.2.1",
    "url-search-params": "^0.5.0",
    "ws": "^0.7.2"
  },
  "description": "Tick42 Gateway Connection.",
  "devDependencies": {
    "blanket": "^1.1.6",
    "browserify": "^13.0.0",
    "browserify-replacify": "^0.0.4",
    "browserify-versionify": "^1.0.4",
    "eslint": "^3.1.1",
    "eslint-config-standard": "^5.3.5",
    "eslint-config-tick42": "^1.0.0",
    "eslint-plugin-promise": "^2.0.0",
    "eslint-plugin-standard": "^2.0.0",
    "fs": "0.0.2",
    "jsdom": "^8.1.0",
    "minifyify": "^7.3.2",
    "onchange": "^2.1.2",
    "phantomjs": "^1.9.12",
    "qunitjs": "^1.15.0",
    "shelljs": "^0.6.0"
  },
  "dist": {
    "shasum": "4db28853edd5f88c12fec471ad0b74198c512d57",
    "tarball": "http://192.168.0.234:4873/tick42-gateway-connection/-/tick42-gateway-connection-2.1.2.tgz"
  },
  "gitHead": "3ea3546a8c79909f47ec26677ea8e12e89dcc29f",
  "main": "library/main.js",
  "name": "tick42-gateway-connection",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "readmeFilename": "readme.md",
  "scripts": {
    "build": "npm run eslint && node bin/clean.js && node bin/build.js && node bin/minify && node bin/file-versionify",
    "eslint": "eslint library",
    "eslint:fix": "eslint library --fix ",
    "prepublish": "npm update & npm run build",
    "test": "npm run eslint && mocha --require ./test/test_helper \"test/**/*.js\"",
    "watch": "onchange \"./library/*.js\" -iv -e \"./bin\" -- npm run build"
  },
  "version": "2.1.2"
}

},{}],87:[function(require,module,exports){
var asciiTable = require('ascii-table');
var tick42Connection = require('tick42-gateway-connection');
var PackageJson = require('../package.json');

var levels = ['trace', 'debug', 'info', 'warn', 'error', 'off'];

function serializePath(path) {
    'use strict';
    return path.length === 0 ? '' : path.join('.');
}

var isConnection = function (c) {
    'use strict';
    return typeof c === 'object' && typeof c.send === 'function' && typeof c.on === 'function';
};

function getLevel(logger, level) {
    'use strict';
    // Retrieves the console or publish level of a logger
    // logger - the logger for which to retrieve the level
    // level - a string which can either be "publishLevel" for retrieving the publish level or "c_level" for retrieving the console level.
    if (logger[level] !== undefined) {
        return logger[level];
    } else if (logger.parent !== undefined) {
        return getLevel(logger.parent, level);
    }
}

function messageToTable(title, rows) {
    'use strict';
    // Display message as table in file
    var keys = getAllKeys(rows);
    // fill rows with message properties
    var tableRows = rows.map(function (obj) {
        return keys.map(function (key) {
            return obj[key];
        });
    });

    var tableMessage = asciiTable.factory({
        title: title,
        heading: keys,
        rows: tableRows
    });
    return tableMessage.toString();
}

function getAllKeys(data) {
    'use strict';
    // Accepts an array of objects and returns an array of all the keys from all objects
    var allKeys = [];

    data.forEach(function (obj) {
        Object.keys(obj).forEach(function (key) {
            if (allKeys.indexOf(key) === -1) {
                allKeys.push(key);
            }
        });
    });

    return allKeys;
}

function logger(configuration) {
    'use strict';
    if (typeof configuration.connection !== 'object') {
        configuration.connection = {};
    }

    // Set debug for the connection module if global debug is set
    configuration.connection.debug = configuration.debug;

    // Init connection
    // Determine if we are given a ready 'connection' object or a configuration.
    var connection = isConnection(configuration.connection) ? configuration.connection : tick42Connection(configuration.connection);

    var idKeys = ['system', 'service', 'instance'];

    // Convert instance to string, throw exceptions if it is not full
    var instanceStr = idKeys.map(function (key) {
        var prop = configuration.identity[key];
        if (typeof prop !== 'string') {
            throw new Error('Please specify "' + key + '" in your identity');
        }

        return prop;
    }).join('/');

    var loggerProto = {
        subLogger: function (name) {
            // Check if the sublogger is already created
            var existingSublogger = this.subloggers.filter(function (subLogger) {
                return subLogger.name === name;
            })[0];

            if (existingSublogger !== undefined) {
                return existingSublogger;
            }

            // Check if the name isn't the same as one of the parent properties
            Object.keys(this).forEach(function (key) {
                if (key === name) {
                    throw new Error('This sub logger name is not allowed.');
                }
            });
            // Check if the name isn't the same as one of the parent methods
            Object.keys(loggerProto).forEach(function (key) {
                if (key === name) {
                    throw new Error('This sub logger name is not allowed.');
                }
            });

            var path = this.path.slice(0);
            path.push(this.name);
            return createLogger(name, path, this);
        },

        publishLevel: function (level) {
            if (level !== null && level !== undefined) {
                this._publishLevel = level;
            }

            return getLevel(this, '_publishLevel');
        },

        consoleLevel: function (level) {
            if (level !== null && level !== undefined) {
                this._consoleLevel = level;
            }

            return getLevel(this, '_consoleLevel');
        },

        metricsLevel: function (level, metricsSystem) {
            if (level !== null && level !== undefined) {
                this._metricLevel = level;
            }

            if (metricsSystem !== undefined) {
                if (typeof metricsSystem === 'object' && typeof metricsSystem.objectMetric === 'function') {
                    this.metricSystem = metricsSystem;
                } else {
                    throw new Error('Please specify metric system ');
                }
            }
        },

        table: function (message) {
            // message must be in an array, to be displayed as table
            if (!Array.isArray(message)) {
                throw new Error('The message must be in an array');
            }

            // Retrieve logger name and levels
            var loggerName = getLoggerName(this);

            // Publish in console
            if (shouldPublish(getLevel(this, '_consoleLevel'), 'info')) {
                console.info(loggerName + ':');
                console.table(message);
            }
            // Publish in file
            if (shouldPublish(getLevel(this, '_publishLevel'), 'info')) {
                connection.send('log', 'LogMessage', {
                    instance: instanceStr,
                    level: levels.indexOf('info'),
                    logger: loggerName,
                    message: messageToTable(loggerName, message)
                });
            }
        },

        log: function (message, level) {
            publishMessage(this, level || 'info', message);
        }
    };

    function createLogger(name, path, parent) {
        var logger = Object.create(loggerProto);
        logger.name = name;
        logger.path = path;
        logger.subloggers = [];
        logger.parent = parent;
        if (parent !== undefined) {
            // add sublogger to subloggers array
            parent.subloggers.push(logger);
            // add easy access to sublogger
            parent[logger.name] = logger;
            // create metric system
            if (parent.metricSystem !== undefined) {
                logger.metricsLevel('warn', parent.metricSystem.subSystem(logger.name));
            }
        }

        levels.forEach(function (level) {
            logger[level] = function (message) {
                publishMessage(logger, level, message);
            };
        });

        logger.off = function () {};

        logger.version = PackageJson.version;

        return logger;
    }

    function publishMessage(logger, level, message) {
        // Retrieve logger name and levels
        var loggerName = getLoggerName(logger);

        // Add stack trace if the message is an error
        if (level === 'error') {
            var e = new Error();
            if (e.stack) {
                message = message + '\n' + (e.stack.split('\n')
                    .slice(3)
                    .join('\n'));
            }
        }

        // Publish in console
        if (shouldPublish(getLevel(logger, '_consoleLevel'), level)) {
            if (!console[level]) {
                return;
            }
            console[level](loggerName + ': ' + message);
        }
        // Publish in file
        if (shouldPublish(getLevel(logger, '_publishLevel'), level)) {
            connection.send('log', 'LogMessage', {
                instance: instanceStr,
                level: levels.indexOf(level),
                logger: loggerName,
                message: message
            });
        }

        // Publish in metrics
        if (shouldPublish(getLevel(logger, '_metricLevel'), level)) {
            if (logger.metricSystem !== undefined) {
                logger.metricSystem.objectMetric('LogMessage', {
                    Time: new Date(),
                    Logger: loggerName,
                    Level: level,
                    Message: message
                });

                if (level === 'error') {
                    logger.metricSystem.setState(100, message);
                }
            }
        }
    }

    var shouldPublish = function (publishLevel, messageLevel) {
        return (!publishLevel || levels.indexOf(publishLevel) <= levels.indexOf(messageLevel));
    };

    var getLoggerName = function (logger) {
        var loggerPathAndName = logger.path.slice();
        loggerPathAndName.push(logger.name);
        return '[' + serializePath(loggerPathAndName) + ']';
    };

    var mainLogger = createLogger('main', [], undefined);
    mainLogger.publishLevel('warn');
    mainLogger.consoleLevel('info');
    mainLogger.metricsLevel('warn');

    return mainLogger;
}

if (typeof window !== 'undefined') {
    window.tick42 = window.tick42 || {};
    window.tick42.log = logger;
}

module.exports = logger;

},{"../package.json":88,"ascii-table":5,"tick42-gateway-connection":78}],88:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "tick42-logger@2.0.6",
      "C:\\work\\stash\\GLUE-dev\\js-glue"
    ]
  ],
  "_from": "tick42-logger@2.0.6",
  "_id": "tick42-logger@2.0.6",
  "_inCache": true,
  "_installable": true,
  "_location": "/tick42-logger",
  "_nodeVersion": "6.3.0",
  "_npmUser": {},
  "_npmVersion": "3.8.5",
  "_phantomChildren": {},
  "_requested": {
    "name": "tick42-logger",
    "raw": "tick42-logger@2.0.6",
    "rawSpec": "2.0.6",
    "scope": null,
    "spec": "2.0.6",
    "type": "version"
  },
  "_requiredBy": [
    "/"
  ],
  "_shasum": "04124763b30d2bbe199e38aac715e308e425c023",
  "_shrinkwrap": null,
  "_spec": "tick42-logger@2.0.6",
  "_where": "C:\\work\\stash\\GLUE-dev\\js-glue",
  "author": {
    "name": "Tick42"
  },
  "bin": {
    "build": "./bin/build.js",
    "clean": "./bin/clean.js",
    "file-versionify": "./bin/file-versionify.js",
    "minify": "./bin/minify.js"
  },
  "dependencies": {
    "ascii-table": "0.0.8",
    "tick42-gateway-connection": ">=1.1.9"
  },
  "description": "A library for logging",
  "devDependencies": {
    "blanket": "^1.1.6",
    "browserify": "^13.0.0",
    "browserify-replacify": "^0.0.4",
    "browserify-versionify": "^1.0.4",
    "eslint": "^3.1.1",
    "eslint-config-standard": "^5.3.5",
    "eslint-config-tick42": "^1.0.0",
    "eslint-plugin-promise": "^2.0.0",
    "eslint-plugin-standard": "^2.0.0",
    "fs": "0.0.2",
    "jsdom": "^8.1.0",
    "minifyify": "^7.3.2",
    "onchange": "^2.1.2",
    "phantomjs": "^1.9.12",
    "qunitjs": "^1.15.0",
    "shelljs": "^0.6.0"
  },
  "dist": {
    "shasum": "04124763b30d2bbe199e38aac715e308e425c023",
    "tarball": "http://192.168.0.234:4873/tick42-logger/-/tick42-logger-2.0.6.tgz"
  },
  "gitHead": "34be3019b237911937638a6f4abf1e820f6d1829",
  "license": "ISC",
  "main": "library/logger",
  "name": "tick42-logger",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "repository": {
    "type": "git",
    "url": "https://stash.tick42.com:8443/scm/ofgw/js-logger.git"
  },
  "scripts": {
    "build": "npm run eslint && node bin/clean.js && node bin/build.js && node bin/minify && node bin/file-versionify",
    "eslint": "eslint library",
    "eslint:fix": "eslint library --fix",
    "prepublish": "npm update & npm run build",
    "test": "npm run eslint && mocha --require ./test/test_helper \"test/**/*.js\"",
    "watch": "onchange \"./library/*.js\" -iv -e \"./bin\" -- npm run build"
  },
  "version": "2.0.6"
}

},{}],89:[function(require,module,exports){
"use strict";
var objectMetric_1 = require("../metrics/objectMetric");
var stringMetric_1 = require("../metrics/stringMetric");
var numberMetric_1 = require("../metrics/numberMetric");
var timestampMetric_1 = require("../metrics/timestampMetric");
var MetricSerializer = (function () {
    function MetricSerializer() {
    }
    MetricSerializer.metricToMessage = function (metric) {
        var def = MetricSerializer._getMetricDefinition(metric.name, metric.value, metric.path, metric.type, metric.description, metric.period, metric.resolution);
        return {
            id: metric.id,
            instance: metric.repo.instance,
            definition: def,
            value: MetricSerializer._serializeValue(metric.value, metric),
        };
    };
    MetricSerializer._getMetricDefinition = function (name, value, path, type, description, resolution, period) {
        var def = {
            name: name,
            description: description,
            type: type ? type : MetricSerializer._getTypeFromValue(value),
            path: path,
            resolution: resolution,
            period: period
        };
        if (def.type === objectMetric_1.ObjectMetric.type) {
            def.Composite = Object.keys(value).reduce(function (arr, key) {
                var val = value[key];
                arr.push(MetricSerializer._getMetricDefinition(key, val, path));
                return arr;
            }, []);
        }
        return def;
    };
    MetricSerializer._serializeValue = function (value, metric) {
        if (value && value.constructor === Date) {
            return {
                value: {
                    type: this._valueTypes.indexOf("date"),
                    value: value.valueOf(),
                    isArray: false
                }
            };
        }
        else if (typeof value === "object") {
            return {
                CompositeValue: Object.keys(value).reduce(function (arr, key) {
                    var val = MetricSerializer._serializeValue(value[key]);
                    val.InnerMetricName = key;
                    arr.push(val);
                    return arr;
                }, [])
            };
        }
        else {
            var valueType = metric ? metric.getValueType() : undefined;
            valueType = valueType | this._valueTypes.indexOf(typeof value);
            return { value: { type: valueType, value: value, isArray: false } };
        }
    };
    MetricSerializer._getTypeFromValue = function (value) {
        var typeAsString = value.constructor === Date ? 'timestamp' : typeof value;
        switch (typeAsString) {
            case 'string':
                return stringMetric_1.StringMetric.type;
            case 'number':
                return numberMetric_1.NumberMetric.type;
            case 'timestamp':
                return timestampMetric_1.TimestampMetric.type;
            case 'object':
                return objectMetric_1.ObjectMetric.type;
        }
        return 0;
    };
    MetricSerializer._valueTypes = [
        "boolean",
        "int",
        "number",
        "long",
        "string",
        "date",
        "object"];
    return MetricSerializer;
}());
exports.MetricSerializer = MetricSerializer;

},{"../metrics/numberMetric":94,"../metrics/objectMetric":95,"../metrics/stringMetric":98,"../metrics/timestampMetric":100}],90:[function(require,module,exports){
"use strict";
var metricSerializer_1 = require("./metricSerializer");
var MetricsBridge = (function () {
    function MetricsBridge(repo, connection) {
        var _this = this;
        this._repo = repo;
        this._connection = connection;
        connection.on('metrics', "MetricsSnapshotRequest", function (instanceInfo) {
            if (instanceInfo.Instance !== repo.instance) {
                return;
            }
            _this.sendFull(_this._repo);
        });
    }
    MetricsBridge.prototype.sendFull = function (repo) {
        var rootSystem = repo.root;
        if (!rootSystem) {
            return;
        }
        if (rootSystem.subSystems.length == 0) {
            return;
        }
        this.sendFullSystem(rootSystem);
    };
    MetricsBridge.prototype.sendFullSystem = function (s) {
        var _this = this;
        this.createSystem(s);
        s.subSystems.forEach(function (sub) {
            _this.sendFullSystem((sub));
        });
        s.metrics.forEach(function (m) {
            _this.createMetric(m);
        });
    };
    MetricsBridge.prototype.createMetric = function (metric) {
        this._send("CreateMetric", metricSerializer_1.MetricSerializer.metricToMessage(metric));
    };
    MetricsBridge.prototype.updateMetric = function (metric) {
        this._send("UpdateMetric", metricSerializer_1.MetricSerializer.metricToMessage(metric));
    };
    MetricsBridge.prototype.createSystem = function (system) {
        if (system.parent !== undefined) {
            this._send("CreateMetricSystem", {
                id: system.id,
                instance: system.repo.instance,
                definition: { name: system.name, description: system.description, path: system.path }
            });
        }
    };
    MetricsBridge.prototype.updateSystem = function (system, state) {
        this._send("UpdateMetricSystem", {
            id: system.id,
            instance: system.repo.instance,
            state: state
        });
    };
    MetricsBridge.prototype.heartbeat = function (repo, interval) {
        this._send("HeartbeatMetrics", { publishingInterval: interval, instance: repo.instance });
    };
    MetricsBridge.prototype._send = function (type, message) {
        this._connection.send("metrics", type, message);
    };
    return MetricsBridge;
}());
exports.MetricsBridge = MetricsBridge;

},{"./metricSerializer":89}],91:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var AddressMetric = (function (_super) {
    __extends(AddressMetric, _super);
    function AddressMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, AddressMetric.type, value || '');
    }
    AddressMetric.type = 8;
    return AddressMetric;
}(metric_1.Metric));
exports.AddressMetric = AddressMetric;

},{"./metric":93}],92:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var CountMetric = (function (_super) {
    __extends(CountMetric, _super);
    function CountMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, CountMetric.type, value || 0);
    }
    CountMetric.prototype.increment = function () {
        this.incrementBy(1);
    };
    CountMetric.prototype.decrement = function () {
        this.decrementBy(1);
    };
    CountMetric.prototype.incrementBy = function (n) {
        this.update((this.value || 0) + n);
    };
    CountMetric.prototype.decrementBy = function (n) {
        this.update((this.value || 0) - n);
    };
    CountMetric.prototype.getValueType = function () {
        return 3;
    };
    CountMetric.type = 3;
    return CountMetric;
}(metric_1.Metric));
exports.CountMetric = CountMetric;

},{"./metric":93}],93:[function(require,module,exports){
"use strict";
var Metric = (function () {
    function Metric(def, parent, transport, type, value) {
        this.name = def.name;
        this.description = def.description;
        this.period = def.period;
        this.resolution = def.resolution;
        this.system = parent;
        this.repo = parent.repo;
        this.id = parent.path + "/" + this.name;
        this.value = value;
        this.type = type;
        this.path = parent.path.slice(0);
        this.path.push(parent.name);
        this._transport = transport;
        this._transport.createMetric(this);
    }
    Metric.prototype.update = function (value) {
        this.value = value;
        this._transport.updateMetric(this);
    };
    Metric.prototype.getValueType = function () {
        return undefined;
    };
    Metric.type = 0;
    return Metric;
}());
exports.Metric = Metric;

},{}],94:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var NumberMetric = (function (_super) {
    __extends(NumberMetric, _super);
    function NumberMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, NumberMetric.type, value || 0);
    }
    NumberMetric.prototype.increment = function () {
        this.incrementBy(1);
    };
    NumberMetric.prototype.decrement = function () {
        this.decrementBy(1);
    };
    NumberMetric.prototype.incrementBy = function (n) {
        this.update((this.value || 0) + n);
    };
    NumberMetric.prototype.decrementBy = function (n) {
        this.update((this.value || 0) - n);
    };
    NumberMetric.type = 2;
    return NumberMetric;
}(metric_1.Metric));
exports.NumberMetric = NumberMetric;

},{"./metric":93}],95:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var ObjectMetric = (function (_super) {
    __extends(ObjectMetric, _super);
    function ObjectMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, ObjectMetric.type, value);
    }
    ObjectMetric.prototype.update = function (value) {
        _super.prototype.update.call(this, value);
    };
    ObjectMetric.type = 11;
    return ObjectMetric;
}(metric_1.Metric));
exports.ObjectMetric = ObjectMetric;

},{"./metric":93}],96:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var RateMetric = (function (_super) {
    __extends(RateMetric, _super);
    function RateMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, RateMetric.type, value || 0);
    }
    RateMetric.type = 4;
    return RateMetric;
}(metric_1.Metric));
exports.RateMetric = RateMetric;

},{"./metric":93}],97:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var StatisticsMetric = (function (_super) {
    __extends(StatisticsMetric, _super);
    function StatisticsMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, StatisticsMetric.type, value || 0);
    }
    StatisticsMetric.type = 6;
    return StatisticsMetric;
}(metric_1.Metric));
exports.StatisticsMetric = StatisticsMetric;

},{"./metric":93}],98:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var StringMetric = (function (_super) {
    __extends(StringMetric, _super);
    function StringMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, StringMetric.type, value || '');
    }
    StringMetric.type = 1;
    return StringMetric;
}(metric_1.Metric));
exports.StringMetric = StringMetric;

},{"./metric":93}],99:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var TimespanMetric = (function (_super) {
    __extends(TimespanMetric, _super);
    function TimespanMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, TimespanMetric.type, value || false);
    }
    TimespanMetric.prototype.start = function () {
        this.update(true);
    };
    TimespanMetric.prototype.stop = function () {
        this.update(false);
    };
    TimespanMetric.type = 10;
    return TimespanMetric;
}(metric_1.Metric));
exports.TimespanMetric = TimespanMetric;

},{"./metric":93}],100:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var TimestampMetric = (function (_super) {
    __extends(TimestampMetric, _super);
    function TimestampMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, TimestampMetric.type, value || new Date());
    }
    TimestampMetric.prototype.now = function () {
        this.update(new Date());
    };
    TimestampMetric.type = 7;
    return TimestampMetric;
}(metric_1.Metric));
exports.TimestampMetric = TimestampMetric;

},{"./metric":93}],101:[function(require,module,exports){
"use strict";
var system_1 = require("./system");
var transport_1 = require("./bridge/transport");
var Repository = (function () {
    function Repository(config) {
        this._config = config;
        this._transport = new transport_1.MetricsBridge(this, config.connection);
        this.instance = config.identity.system + '/' + config.identity.service + '/' + config.identity.instance;
        this.identity = config.identity;
        this._startHeartbeating();
        this.root = new system_1.System('', this, this._transport);
        this._initSystemMetrics(this.root, config.clickStream || config.clickStream === undefined);
    }
    Repository.prototype._startHeartbeating = function () {
        var _this = this;
        this._transport.heartbeat(this, this._config.settings.heartbeatInterval);
        setInterval(function () {
            _this._transport.heartbeat(_this, _this._config.settings.heartbeatInterval);
        }, this._config.settings.heartbeatInterval);
    };
    Repository.prototype._initSystemMetrics = function (rootSystem, useClickStream) {
        if (typeof navigator !== 'undefined') {
            rootSystem.stringMetric('UserAgent', navigator.userAgent);
        }
        if (useClickStream && typeof document !== 'undefined') {
            var clickStream_1 = rootSystem.subSystem("ClickStream");
            var documentClickHandler = function (e) {
                if (!e.target) {
                    return;
                }
                clickStream_1.objectMetric("LastBrowserEvent", {
                    type: "click",
                    timestamp: new Date(),
                    target: {
                        className: e.target ? e.target.className : '',
                        id: e.target.id,
                        type: '<' + e.target.tagName.toLowerCase() + '>',
                        href: e.target.href || ""
                    }
                });
            };
            clickStream_1.objectMetric("Page", {
                title: document.title,
                page: window.location.href
            });
            if (document.addEventListener) {
                document.addEventListener('click', documentClickHandler);
            }
            else {
                document.attachEvent('onclick', documentClickHandler);
            }
        }
    };
    return Repository;
}());
exports.Repository = Repository;

},{"./bridge/transport":90,"./system":102}],102:[function(require,module,exports){
"use strict";
var numberMetric_1 = require("./metrics/numberMetric");
var timespanMetric_1 = require("./metrics/timespanMetric");
var stringMetric_1 = require("./metrics/stringMetric");
var addressMetric_1 = require("./metrics/addressMetric");
var objectMetric_1 = require("./metrics/objectMetric");
var timestampMetric_1 = require("./metrics/timestampMetric");
var countMetric_1 = require("./metrics/countMetric");
var statisticsMetric_1 = require("./metrics/statisticsMetric");
var rateMetric_1 = require("./metrics/rateMetric");
var System = (function () {
    function System(name, repo, transport, parent, description) {
        this.metrics = [];
        this.subSystems = [];
        this.name = name;
        this.description = description || '';
        this.repo = repo;
        this.parent = parent;
        this._transport = transport;
        this.path = this._buildPath(this.parent);
        this.id = (this.path.length > 0 ? this.path.join('/') + '/' : '') + this.name;
        this.identity = repo.identity;
        this.root = repo.root;
        this._transport.createSystem(this);
    }
    System.prototype.subSystem = function (name, description) {
        if (!name || name.length === 0) {
            throw new Error('name is required');
        }
        var matchingSystems = this.subSystems.filter(function (s) { return s.name === name; });
        if (matchingSystems.length > 0) {
            return matchingSystems[0];
        }
        var system = new System(name, this.repo, this._transport, this, description);
        this.subSystems.push(system);
        return system;
    };
    System.prototype.setState = function (state, description) {
        this._transport.updateSystem(this, { state: state, description: description });
    };
    System.prototype.stringMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, stringMetric_1.StringMetric.type, value, function (metricDef) {
            return new stringMetric_1.StringMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.numberMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, numberMetric_1.NumberMetric.type, value, function (metricDef) {
            return new numberMetric_1.NumberMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.countMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, countMetric_1.CountMetric.type, value, function (metricDef) {
            return new countMetric_1.CountMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.addressMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, addressMetric_1.AddressMetric.type, value, function (metricDef) {
            return new addressMetric_1.AddressMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.objectMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, objectMetric_1.ObjectMetric.type, value, function (metricDef) {
            return new objectMetric_1.ObjectMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.timespanMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, timespanMetric_1.TimespanMetric.type, value, function (metricDef) {
            return new timespanMetric_1.TimespanMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.timestampMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, timestampMetric_1.TimestampMetric.type, value, function (metricDef) {
            return new timestampMetric_1.TimestampMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.rateMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, rateMetric_1.RateMetric.type, value, function (metricDef) {
            return new rateMetric_1.RateMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.statiticsMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, statisticsMetric_1.StatisticsMetric.type, value, function (metricDef) {
            return new statisticsMetric_1.StatisticsMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype._unionToMetricDef = function (definition) {
        var metricDef;
        if (typeof definition === 'string') {
            metricDef = { name: definition };
        }
        else {
            metricDef = definition;
        }
        if (metricDef.name === undefined) {
            throw new Error('Metric name is required.');
        }
        return metricDef;
    };
    System.prototype._getOrCreateMetric = function (definition, expectedType, value, createFunc) {
        var metricDef = this._unionToMetricDef(definition);
        var matchingMetrics = this.metrics.filter(function (m) { return m.name === metricDef.name; });
        if (matchingMetrics.length > 0) {
            var existingMetric = matchingMetrics[0];
            if (existingMetric.type !== expectedType) {
                throw new Error('A metric named ' + metricDef.name + ' is already defined with different type');
            }
            if (typeof value !== 'undefined') {
                existingMetric.update(value);
            }
            return existingMetric;
        }
        var newMetric = createFunc(metricDef);
        this.metrics.push(newMetric);
        return newMetric;
    };
    System.prototype._buildPath = function (system) {
        if (!system || !system.parent) {
            return [];
        }
        var path = this._buildPath(system.parent);
        path.push(system.name);
        return path;
    };
    return System;
}());
exports.System = System;

},{"./metrics/addressMetric":91,"./metrics/countMetric":92,"./metrics/numberMetric":94,"./metrics/objectMetric":95,"./metrics/rateMetric":96,"./metrics/statisticsMetric":97,"./metrics/stringMetric":98,"./metrics/timespanMetric":99,"./metrics/timestampMetric":100}],103:[function(require,module,exports){
"use strict";
var repository_1 = require("./core/repository");
var tick42_gateway_connection_1 = require('tick42-gateway-connection');
var windowAsAny = typeof window === 'undefined' ? (new Object()) : window;
windowAsAny.tick42 = windowAsAny.tick42 || {};
windowAsAny.tick42.metrics = windowAsAny.tick42.metrics || function (config) {
    if (!config.identity) {
        throw new Error('Identity missing from metrics configuration');
    }
    if (!config.identity.service || typeof config.identity.service !== 'string') {
        throw new Error('Service missing or invalid in metrics identity configuration');
    }
    if (!config.identity.system || typeof config.identity.system !== 'string') {
        throw new Error('System missing or invalid in metrics identity configuration');
    }
    if (!config.identity.instance || typeof config.identity.instance !== 'string') {
        throw new Error('Instancemissing or invalid in metrics identity configuration');
    }
    config.settings = config.settings || {};
    config.settings.heartbeatInterval = config.settings.heartbeatInterval || 15000;
    if (typeof config.connection !== "object") {
        config.connection = {};
    }
    if (!(typeof config.connection === "object" && typeof config.connection.send === "function" && typeof config.connection.on === "function")) {
        config.connection = tick42_gateway_connection_1.connection(config.connection);
    }
    var repo = new repository_1.Repository(config);
    repo['version'] = repo.root['version'] = '2.0.15';
    return repo.root;
};
module.exports = windowAsAny.tick42.metrics;

},{"./core/repository":101,"tick42-gateway-connection":78}],104:[function(require,module,exports){
  var helpers = module.exports = {};

  helpers.invokeAgmSuccessCallback = function (callback, callbackAargument) {
      'use strict';
      if (typeof callback === 'function') {
          callback(callbackAargument);
      }
  }

  helpers.invokeAgmErrorCallback =  function (callback, error) {
      'use strict';
      if (typeof callback === 'function') {
          callback(error.message);
      }
  }

  helpers.execCallbacks =  function (arr, val) {
      'use strict';
      if (arr !== undefined) {
          arr.forEach(function(callback) {
              callback(val);
          });
      }
  }

  helpers.vals = function(obj) {
      'use strict';
      return Object.keys(obj).reduce(function(arr, key) {
          arr.push(obj[key]);
          return arr;
      }, []);
  }

},{}],105:[function(require,module,exports){
var deprecate = require('util-deprecate');
var helpers = require('./helpers');

module.exports.init = init;
module.exports.create = createWindow;

var agm;

function setWindowStyleAttributes(windowStyles) {
    'use strict';
    // Adding windowStyleAttributes
    if (windowStyles !== undefined && typeof windowStyles !== 'object') {
        return JSON.parse(windowStyles);
    } else if (windowStyles !== undefined && typeof windowStyles === 'object') {
        return windowStyles;
    } else {
        return {};
    }
}

function init(a) {
    'use strict';
    agm = a;
}


function createWindow(id, internalId, name, containerObj, url, title, windowStyles) {
    'use strict';

    if (!containerObj) {
        throw new Error('containerObj can not be undefined');
    }

    var resultWindow;

    function addCallback(key, callback) {
        var obj = resultWindow._callbacks;
        if (obj[key] === undefined) {
            obj[key] = [callback];
        } else {
            obj[key].push(callback);
        }
    }

    // Functions for opening, closing, resizing windows
    function open(dimensions, style, success, error) {

        // A wrapper for the standard AGM "open" function
        var theWindow = this;

        // Init style objects if they are null
        dimensions = dimensions || {};
        style = style || {};

        // Take out the sticky-windows related properties from the style object

        var isSticky = style.isSticky;
        delete style.isSticky;

        var stickyGroup = style.stickyGroup;
        delete style.stickyGroup;
        delete style.hasMoveAreaThickness;
        delete style.hasSizeAreaThickness;

        var target = containerObj.getAgmTarget();

        agm.invoke('T42.Html.CreateWindow', {
            // Window name and url
            windowName: theWindow.name,
            url: theWindow.url,
            // dimensions
            top: dimensions.top,
            left: dimensions.left,
            width: dimensions.width,
            height: dimensions.height,
            // Stickywindows - related props
            isSticky: isSticky,
            stickyGroup: stickyGroup,
            // Style attributes
            windowStyleAttributes: JSON.stringify(style)

        },
            target,
            {},
            opened,
            cannotOpen);

        function opened(message) {
            // Add id to the current windows because the current HTML Container
            // doesn't support tracking the updates of the window
            if (message.returned !== undefined) {
                theWindow.id = message.returned.id;
            }
            helpers.invokeAgmSuccessCallback(success, theWindow);
        }

        function cannotOpen(e) {
            // Call the error callback
            if (typeof error === 'function') {
                error(e);
            }
            // Try to bind the returned object in case...
            // bindWindow(theWindow);
        }

        return theWindow;
    }

    function setStyle(style, success, error) {
        return agmAction('T42.Wnd.SetWindowStyle', success, error, { windowStyleAttributes: JSON.stringify(style) });
    }

    function opened() {
        return resultWindow.id !== undefined;
    }

    function handleWindowClose() {
        if (resultWindow.id !== undefined) {
            helpers.execCallbacks(resultWindow._callbacks.onClose);
            resultWindow.id = undefined;
            resultWindow._callbacks = {};
        }
    }

    function close() {
        return agmAction('T42.Wnd.Close', function(win) {
            console.log('"' + win.name +  '" window was closed.');
        }, function (err) {
            console.log('"' + resultWindow.name +  '" window was NOT closed due following error: ', err)
        });
    }

    function navigate(url, success, error) {
        return agmAction('T42.Html.OpenUrl', success, error, { url: url });
    }

    function setTitle(title, success, error) {
        return agmAction('T42.Wnd.SetWindowTitle', success, error, { title: title });
    }

    function getDetails(success, error) {
        var windowId = resultWindow.id;
        agm.invoke('T42.Wnd.FindById', { windowId: resultWindow.id }, containerObj.getAgmTarget(), {}, returnedDimensions, cannotReturnDimensions);

        function returnedDimensions(value) {
            helpers.invokeAgmSuccessCallback(success, value.returned[windowId]);
        }

        function cannotReturnDimensions(e) {
            helpers.invokeAgmErrorCallback(error, e);
        }
    }

    function moveResize(dimensions, success, error) {
        return agmAction('T42.Wnd.ResizeAndMove', success, error, dimensions)
    }

    function addTabButton(buttonInfo, success, error) {
        if (typeof buttonInfo === 'undefined') {
            if (typeof error !== 'function') {
                return;
            } else {
                error('No button info');
            }
        }

        if (buttonInfo.buttonId === undefined) {
            if (typeof error !== 'function') {
                return;
            } else {
                error('No buttonId');
            }
        }

        if (buttonInfo.imageBase64 === undefined) {
            if (typeof error !== 'function') {
                return;
            } else {
                error('No imageBase64');
            }
        }

        // Invoke the AGM method
        agm.invoke('T42.Wnd.AddButton', {
            windowId: resultWindow.id,
            buttonInfo: buttonInfo
        }, containerObj.getAgmTarget(), {}, buttonIsAdded.bind(this), buttonCannotBeAdded.bind(this));

        function buttonIsAdded() {
            var _buttonId = buttonInfo.buttonId;
            resultWindow.buttons[_buttonId] = {
                id: _buttonId,
                info: buttonInfo
            };
            helpers.invokeAgmSuccessCallback(success, this);
        }

        function buttonCannotBeAdded(e) {
            helpers.invokeAgmErrorCallback(error, e);
        }
    }

    function onTitleChanged(callback) {
        callback(resultWindow.title);
        addCallback('onTitleChanged', callback);
    }

    function onAvailable(callback) {
        if (resultWindow.opened()) {
            callback(this);
        }
        return addCallback('onAvailable', callback);
    }

    function onClose(callback) {
        addCallback('onClose', callback);
    }

    function onUrlChanged(callback) {
        addCallback('onUrlChanged', callback);
    }

    function onTabButton(callback) {
        addCallback('onTabButton', callback);
    }

    function activate(success, error) {
        return agmAction('T42.Wnd.Activate', success, error);
    }

    function maximizeRestore(success, error) {
        return agmAction('T42.Wnd.MaximizeOrRestoreDown', success, error);
    }

    function maximize(success, error) {
        return agmAction('T42.Wnd.Maximize', success, error);
    }

    function restore(success, error) {
        return agmAction('T42.Wnd.Restore', success, error);
    }

    function minimize(success, error) {
        return agmAction('T42.Wnd.Minimize', success, error);
    }

    function collapse(success, error) {
        return agmAction('T42.Wnd.Collapse', success, error);
    }

    function titleChanged(title) {
        resultWindow.title = title;
        helpers.execCallbacks(resultWindow._callbacks.onTitleChanged, title);
    }

    function urlChanged(url) {
        resultWindow.url = url;
        helpers.execCallbacks(resultWindow._callbacks.onUrlChanged, url);
    }

    // Adds an alias of an AGM method in the Window prototype
    function agmAction(action, success, error, args) {
        // Stop if the window is closed
        if (resultWindow.url === undefined) {
            if (typeof error === 'function') {
                error('Cannot execute a command on a closed window.');
            }
            return;
        }

        // Add the window ID to the arguments
        args = args || {};
        args.windowId = resultWindow.id;

        // Invoke the AGM method
        agm.invoke(action, args, containerObj.getAgmTarget(), {}, fulfilled, error);

        function fulfilled() {
            helpers.invokeAgmSuccessCallback(success, resultWindow);
        }
    }

    resultWindow = {
        _internalId: internalId,
        _callbacks: {},

        name: name,
        container: containerObj.name,
        url: url,
        id: id,
        application: containerObj.name + '.' + name,
        title: title,
        buttons: {},
        windowStyleAttributes: setWindowStyleAttributes(windowStyles),

        onAvailable: onAvailable,
        onClose: onClose,
        onUrlChanged: onUrlChanged,
        onTitleChanged: onTitleChanged,
        onTabButton: onTabButton,

        maximize: maximize,
        restore: restore,
        minimize: minimize,
        maximizeRestore: maximizeRestore,
        collapse: collapse,
        focus: activate,
        open: open,
        opened: opened,
        getDetails: getDetails,
        moveResize: moveResize,
        setTitle: setTitle,
        setStyle: setStyle,
        navigate: navigate,
        addTabButton: addTabButton,
        close: close,
        handleWindowClose: handleWindowClose,
        titleChanged: titleChanged,
        urlChanged: urlChanged,

        // deprecates
        set_style: deprecate(setStyle, 'window.set_style() is deprecated and might be removed from future versions of glue. Use window.setStyle() instead'),
        on_available: deprecate(onAvailable, 'window.on_available() is deprecated and might be removed from future versions of glue. Use window.onAvailable() instead'),
        on_close: deprecate(onClose, 'window.on_close() is deprecated and might be removed from future versions of glue. Use window.onClose() instead'),
        on_url_changed: deprecate(onUrlChanged, 'window.on_url_changed() is deprecated and might be removed from future versions of glue. Use window.onUrlChanged() instead'),
        set_title: deprecate(setTitle, 'window.set_title() is deprecated and might be removed from future versions of glue. Use window.setTitle() instead'),
        get_details: deprecate(getDetails, 'window.get_details() is deprecated and might be removed from future versions of glue. Use window.getDetails() instead'),
        move_resize: deprecate(moveResize, 'window.move_resize() is deprecated and might be removed from future versions of glue. Use window.moveResize() instead'),
        maximize_restore: deprecate(maximizeRestore, 'window.maximize_restore() is deprecated and might be removed from future versions of glue. Use window.maximizeRestore() instead')

    };
    return resultWindow;
}

},{"./helpers":104,"util-deprecate":109}],106:[function(require,module,exports){
(function (global){
var PackageJson = require('../package.json');
var deprecate = require('util-deprecate');
var windowFactory = require('./window');
var helpers = require('./helpers');

var windows = function (agm) {
    'use strict'

    windowFactory.init(agm);

    if (global.htmlContainer && agm.subscribe) {
        // Only container.
        agm.serverMethodAdded(function (resp) {
            if ((resp.server.application.indexOf('HtmlContainer.') !== -1 && resp.server.application.indexOf('.Internal') !== -1) && resp.method.name.indexOf('T42.Wnd.WindowStateChanged') !== -1) {
                agm.subscribe('T42.Wnd.WindowStateChanged', { target: 'all' }).then(function (stream) {
                    stream.onData(function (streamData) {
                        updateWindow(streamData.data, matchContainer(streamData.server.application));
                    });
                    // attach callbacks
                    // stream.on("end", handleStreamClosed);
                    // stream.on("close", handleStreamClosed);
                });
            }
        });

        agm.serverAdded(function (server) {
            if (server.application.indexOf('HtmlContainer.') !== -1) {
                var container = constructContainerObject(server.application);
                addContainer(containers, container);
                getAllWindowsOnAddedContainer(container);
            }
        });
    }

    // Store windows that are tracked by ID and receive updates
    var windows = {};
    var containers = [];

    if (global.htmlContainer) {
        var myContainer = constructContainerObject(htmlContainer.containerName);
        addContainer(containers, myContainer);
        createWindow(htmlContainer.browserWindowName, myContainer, window.location.href, htmlContainer.windowId, htmlContainer.windowStyleAttributes);
    }

    function ensureContainerAvailiable(container, successCallback, errorCallback) {
        var containerFound = matchContainer(container)
        if (containerFound) {
            successCallback(containerFound);
            return;
        }

        setTimeout(function () {
            var containerFound = matchContainer(container)
            if (containerFound) {
                successCallback(containerFound);
            } else {
                errorCallback();
            }
        }, 2000);
    }

    function matchContainer(containerIdentifier) {
        if (!containerIdentifier) {
            return containers[0];
        }
        return containers.filter(function (container) {
            return container.shortName === containerIdentifier ||
                container.name === containerIdentifier ||
                container.agmApplication === containerIdentifier;
        })[0];
    }

    function constructContainerObject(containerIdentity) {
        var parts = containerIdentity.split('.');
        if (parts.length === 2) {
            parts.splice(0, 0, 'HtmlContainer');
        }

        var agmApplication = parts[0] + '.' + parts[1] + '.' + parts[2];

        return {
            shortName: parts[2],
            name: parts[1] + '.' + parts[2],
            agmApplication: agmApplication,
            getAgmTarget: function () {
                return { application: agmApplication }
            }
        };
    }

    function addContainer(containers, container) {
        if (containers.filter(function(cont) {
            return cont.shortName === container.shortName &&
            cont.name === container.name &&
            cont.agmApplication === container.agmApplication
        }).length  === 0) {
            containers.push(container);
        }
    }

    function getCallbacks(callbacks, containerName) {
        if (callbacks.containersCallbacks[containerName] !== undefined) {
            return callbacks.allContainersCallbacks.concat(callbacks.containersCallbacks[containerName]);
        } else {
            return callbacks.allContainersCallbacks;
        }
    }

    function putCallbacks(globalCallbacks, callback, container) {
        if (container === undefined) {
            globalCallbacks.allContainersCallbacks.push(callback);
        } else {
            if (globalCallbacks.containersCallbacks[container] === undefined) {
                globalCallbacks.containersCallbacks[container] = [callback];
            } else {
                globalCallbacks.containersCallbacks[container].push(callback);
            }
        }
    }

    function updateWindow(windowInfo, containerName) {
        var theWindow = getWindow(windowInfo.windowName, containerName, windowInfo.url, windowInfo.windowId, windowInfo.windowStyleAttributes, windowInfo.windowTitle);

        if (theWindow.id === undefined) {
            theWindow.id = windowInfo.windowId;
            helpers.execCallbacks(theWindow._callbacks.onAvailable, theWindow);
        }

        if (windowInfo.state === 'TitleChanged') {
            theWindow.titleChanged(windowInfo.windowTitle);
        }

        if (windowInfo.state === 'UrlChanged') {
            theWindow.urlChanged(windowInfo.url);
        }

        if (windowInfo.state === 'Created') {
            // Execute global "window_added" callbacks
            helpers.execCallbacks(getCallbacks(windowAddedCallbacks, containerName), theWindow);
        }

        // Clear the window on close event
        if (windowInfo.state === 'Closed') {
            // Execute global "window_removed" callbacks
            helpers.execCallbacks(getCallbacks(windowRemovedCallbacks, containerName), theWindow);

            delete windows[theWindow._internalId];

            theWindow.handleWindowClose();
        }

        // ButtonClicked
        if (windowInfo.state === 'ButtonClicked') {
            // Execute global "window_added" callbacks
            if (theWindow.buttons !== undefined && Object.keys(theWindow.buttons).length !== 0) {
                if (theWindow._callbacks.onTabButton === undefined) {
                    return;
                }
                helpers.execCallbacks(theWindow._callbacks.onTabButton, windowInfo.buttonId, theWindow.buttons[windowInfo.buttonId].info);

                theWindow._callbacks.onTabButton.forEach(function (callback) {
                    callback(windowInfo.buttonId, theWindow.buttons[windowInfo.buttonId].info);
                });
            }
        }
    }

    // Create a dictionary to store the callbacks for the method "window_added".
    var windowAddedCallbacks = {
        containersCallbacks: {},
        allContainersCallbacks: []
    };

    // Create a dictionary to store the callbacks for the method "window_removed".
    var windowRemovedCallbacks = {
        containersCallbacks: {},
        allContainersCallbacks: []
    };

    function createWindowId(name, container) {
        return container.agmApplication + '.' + name;
    }

    function createWindow(name, container, url, id, windowStyles, title) {
        var windowId = createWindowId(name, container);

        var windowObj = windowFactory.create(id, windowId, name, container, url, title, windowStyles);

        windows[windowId] = windowObj;

        return windowObj;
    }

    // It is not guaranteed to return the window with the same URL and ID
    function getWindow(name, container, url, id, windowStyles, title) {

        var windowId = createWindowId(name, container);

        var existingWindow = windows[windowId];

        if (existingWindow !== undefined) {
            return existingWindow;
        } else {
            // Init object
            return createWindow(name, container, url, id, windowStyles, title);
        }
    }

    function my() {
        var h;
        if (typeof window !== 'undefined') {
            h = window.htmlContainer;
        }
        // Retrieve the current window (the onw in which your application currently resides).
        if (h === undefined) {
            return undefined;
        } else {
            return getWindow(h.browserWindowName, matchContainer(h.containerName), window.location.href, h.windowId, h.windowStyleAttributes, document.title);
        }
    }

    function open(name, url, container, dimensions, style, success, error) {
        container = container || 'Internal';
        ensureContainerAvailiable(container, function (container) {
            return getWindow(name, container, url, undefined, style)
                    .open(dimensions, style, success, error);
        }, function () {
            error('can not find container')
        });
    }

    function find (name, container, success) {

        container = matchContainer(container);

        var windowsForListing = Object.keys(windows).reduce(function (memo, winId) {
            var window = windows[winId];
            if (window.container === container.name && window.name === name) {
                memo.push(window);
            }
            return memo;
        }, []);

        if (typeof success !== 'function') {
            return windowsForListing[0];
        }

        success(windowsForListing[0]);
    }

    function list (container, success) {

        container = matchContainer(container);

        var windowsForListing = Object.keys(windows).reduce(function (memo, winId) {
            var window = windows[winId];
            if (window.container === container.name) {
                memo.push(window);
            }
            return memo;
        }, []);

        if (typeof success !== 'function') {

            return windowsForListing;
        }

        success(windowsForListing);
    }

    function windowAdded(callback, container) {
        // Add the current callback to the callback dictionary.
        putCallbacks(windowAddedCallbacks, callback, container);
    }

    function windowRemoved(callback, container) {
        // Add the current callback to the callback dictionary.
        putCallbacks(windowRemovedCallbacks, callback, container);
    }

    function containerAdded(callback) {
        agm.serverAdded(function (server) {
            if (server.application.indexOf('HtmlContainer.') !== -1) {
                helpers.invokeAgmSuccessCallback(callback, server.application);
            }
        });
    }

    function containerRemoved(callback) {
        agm.serverRemoved(function (server) {
            if (server.application.indexOf('HtmlContainer.') !== -1) {
                helpers.invokeAgmSuccessCallback(callback, server.application);
            }
        });
    }

    function getAllWindowsOnAddedContainer(container) {
        agm.invoke('T42.Wnd.ListWindows', {}, 'best', {},
                        function (listOfWindows) {
                            Object.keys(listOfWindows.returned).forEach(function (existingWindow) {
                                var windowInfo = listOfWindows.returned[existingWindow];
                                // Storing all window
                                var theWindow = getWindow(windowInfo.windowName, container, windowInfo.url, windowInfo.windowId, windowInfo.windowStyleAttributes, windowInfo.windowTitle)
                                helpers.execCallbacks(getCallbacks(windowAddedCallbacks, container.name), theWindow);
                            });
                        },
                        // Error callback if the windows cannot be listed.
                        function (e) {
                            console.log('Unable to load existing windows. ' + e);
                        }
                    );
    }

    // The API itself
    var api = {
        my: my,
        open: open,
        find: find,
        list: list,
        windowAdded: windowAdded,
        windowRemoved: windowRemoved,
        containerAdded: containerAdded,
        containerRemoved: containerRemoved,

        _from_event: function(name, container, url, id, windowStyles, title) {
            container = matchContainer(container);
            return getWindow(name, container, url, id, windowStyles, title);
        }
    };

    // deprecates
    api.window_added = deprecate(api.windowAdded, 'window.window_added() is deprecated and might be removed from future versions of glue. Use window.windowAdded() instead');
    api.window_removed = deprecate(api.windowRemoved, 'window.window_removed() is deprecated and might be removed from future versions of glue. Use window.windowRemoved() instead');
    api.container_added = deprecate(api.containerAdded, 'window.container_added() is deprecated and might be removed from future versions of glue. Use window.containerAdded() instead');
    api.container_removed = deprecate(api.containerRemoved, 'window.container_removed() is deprecated and might be removed from future versions of glue. Use window.containerRemoved() instead');

    api.version = PackageJson.version;

    return api;
};

if (typeof window !== 'undefined') {
    window.tick42 = window.tick42 || {};
    window.tick42.windows = windows;
}

module.exports = windows;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../package.json":107,"./helpers":104,"./window":105,"util-deprecate":109}],107:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "tick42-windows@2.2.6",
      "C:\\work\\stash\\GLUE-dev\\js-glue"
    ]
  ],
  "_from": "tick42-windows@2.2.6",
  "_id": "tick42-windows@2.2.6",
  "_inCache": true,
  "_installable": true,
  "_location": "/tick42-windows",
  "_nodeVersion": "5.3.0",
  "_npmUser": {},
  "_npmVersion": "3.3.12",
  "_phantomChildren": {},
  "_requested": {
    "name": "tick42-windows",
    "raw": "tick42-windows@2.2.6",
    "rawSpec": "2.2.6",
    "scope": null,
    "spec": "2.2.6",
    "type": "version"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "http://192.168.0.234:4873/tick42-windows/-/tick42-windows-2.2.6.tgz",
  "_shasum": "5116922a0825e87ec1a728f9937e594449abb47e",
  "_shrinkwrap": null,
  "_spec": "tick42-windows@2.2.6",
  "_where": "C:\\work\\stash\\GLUE-dev\\js-glue",
  "author": {
    "name": "Tick42"
  },
  "bin": {
    "build": "./bin/build.js",
    "clean": "./bin/clean.js",
    "file-versionify": "./bin/file-versionify.js",
    "minify": "./bin/minify.js"
  },
  "dependencies": {
    "es6-promise": "^3.0.2",
    "util-deprecate": "^1.0.2"
  },
  "description": "A windowing API for the Tick42 HTML Container",
  "devDependencies": {
    "blanket": "^1.1.6",
    "browserify": "^13.0.0",
    "browserify-replacify": "^0.0.4",
    "browserify-versionify": "^1.0.4",
    "eslint": "^3.1.1",
    "eslint-config-standard": "^5.3.5",
    "eslint-config-tick42": "^1.0.0",
    "eslint-plugin-promise": "^2.0.0",
    "eslint-plugin-standard": "^2.0.0",
    "fs": "0.0.2",
    "jscs": "^3.0.7",
    "jsdom": "^8.1.0",
    "jshint": "^2.9.1",
    "minifyify": "^7.3.2",
    "onchange": "^2.1.2",
    "phantomjs": "^1.9.12",
    "qunitjs": "^1.15.0",
    "shelljs": "^0.6.0"
  },
  "directories": {
    "test": "tests"
  },
  "dist": {
    "shasum": "5116922a0825e87ec1a728f9937e594449abb47e",
    "tarball": "http://192.168.0.234:4873/tick42-windows/-/tick42-windows-2.2.6.tgz"
  },
  "gitHead": "56db8ebd39e135d6023485ef187445d4082de8d2",
  "license": "ISC",
  "main": "library/windows.js",
  "name": "tick42-windows",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "repository": {
    "type": "git",
    "url": "https://stash.tick42.com:8443/scm/ofgw/js-windows.git"
  },
  "scripts": {
    "build": "npm run eslint && node bin/clean.js && node bin/build.js && node bin/minify && node bin/file-versionify",
    "eslint": "eslint library",
    "eslint:fix": "eslint library --fix",
    "prepublish": "npm update & npm run build",
    "test": "npm run eslint && mocha --require ./test/test_helper \"test/**/*.js\"",
    "watch": "onchange \"./library/*.js\" -iv -e \"./bin\" -- npm run build"
  },
  "version": "2.2.6"
}

},{}],108:[function(require,module,exports){
(function (global){
/*!
Copyright (C) 2015 by WebReflection

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
'use strict';

function encode(str) {
  return encodeURIComponent(str).replace(find, replacer);
}

function decode(str) {
  return decodeURIComponent(str.replace(plus, ' '));
}

function URLSearchParams(query) {
  this[secret] = Object.create(null);
  if (!query) return;
  for (var
    index, value,
    pairs = (query || '').split('&'),
    i = 0,
    length = pairs.length; i < length; i++
  ) {
    value = pairs[i];
    index = value.indexOf('=');
    if (-1 < index) {
      this.append(
        decode(value.slice(0, index)),
        decode(value.slice(index + 1))
      );
    }
  }
}

var
  URLSearchParamsProto = URLSearchParams.prototype,
  find = /[!'\(\)~]|%20|%00/g,
  plus = /\+/g,
  replace = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  },
  replacer = function (match) {
    return replace[match];
  },
  iterable = isIterable(),
  secret = '__URLSearchParams__:' + Math.random()
;

function isIterable() {
  try {
    return !!Symbol.iterator;
  } catch(error) {
    return false;
  }
}

URLSearchParamsProto.append = function append(name, value) {
  var dict = this[secret];
  if (name in dict) {
    dict[name].push('' + value);
  } else {
    dict[name] = ['' + value];
  }
};

URLSearchParamsProto.delete = function del(name) {
  delete this[secret][name];
};

URLSearchParamsProto.get = function get(name) {
  var dict = this[secret];
  return name in dict ? dict[name][0] : null;
};

URLSearchParamsProto.getAll = function getAll(name) {
  var dict = this[secret];
  return name in dict ? dict[name].slice(0) : [];
};

URLSearchParamsProto.has = function has(name) {
  return name in this[secret];
};

URLSearchParamsProto.set = function set(name, value) {
  this[secret][name] = ['' + value];
};

URLSearchParamsProto.forEach = function forEach(callback, thisArg) {
  var dict = this[secret];
  Object.getOwnPropertyNames(dict).forEach(function(name) {
    dict[name].forEach(function(value) {
      callback.call(thisArg, value, name, this);
    }, this);
  }, this);
};

URLSearchParamsProto.keys = function keys() {
  var items = [];
  this.forEach(function(value, name) { items.push(name); });
  var iterator = {
    next: function() {
      var value = items.shift();
      return {done: value === undefined, value: value};
    }
  };

  if (iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator;
    };
  }

  return iterator;
};

URLSearchParamsProto.values = function values() {
  var items = [];
  this.forEach(function(value) { items.push(value); });
  var iterator = {
    next: function() {
      var value = items.shift();
      return {done: value === undefined, value: value};
    }
  };

  if (iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator;
    };
  }

  return iterator;
};

URLSearchParamsProto.entries = function entries() {
  var items = [];
  this.forEach(function(value, name) { items.push([name, value]); });
  var iterator = {
    next: function() {
      var value = items.shift();
      return {done: value === undefined, value: value};
    }
  };

  if (iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator;
    };
  }

  return iterator;
};

if (iterable) {
  URLSearchParamsProto[Symbol.iterator] = URLSearchParamsProto.entries;
}

/*
URLSearchParamsProto.toBody = function() {
  return new Blob(
    [this.toString()],
    {type: 'application/x-www-form-urlencoded'}
  );
};
*/

URLSearchParamsProto.toJSON = function toJSON() {
  return {};
};

URLSearchParamsProto.toString = function toString() {
  var dict = this[secret], query = [], i, key, name, value;
  for (key in dict) {
    name = encode(key);
    for (
      i = 0,
      value = dict[key];
      i < value.length; i++
    ) {
      query.push(name + '=' + encode(value[i]));
    }
  }
  return query.join('&');
};

module.exports = global.URLSearchParams || URLSearchParams;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],109:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],110:[function(require,module,exports){

/**
 * Module dependencies.
 */

var global = (function() { return this; })();

/**
 * WebSocket constructor.
 */

var WebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Module exports.
 */

module.exports = WebSocket ? ws : null;

/**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it's
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object) opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
  var instance;
  if (protocols) {
    instance = new WebSocket(uri, protocols);
  } else {
    instance = new WebSocket(uri);
  }
  return instance;
}

if (WebSocket) ws.prototype = WebSocket.prototype;

},{}],111:[function(require,module,exports){
module.exports={
  "name": "tick42-glue",
  "version": "3.0.0-beta.3",
  "description": "A JavaScript library which provides support for Tick42 GLUE.",
  "main": "./library/main.js",
  "bin": {
    "init-dev-mode": "bin/init-dev-mode.js",
    "remove-installed-dependencies": "bin/remove-installed-dependencies.js",
    "remove-development-dependencies": "bin/remove-development-dependencies.js",
    "build": "./bin/build.js",
    "clean": "./bin/clean.js",
    "file-versionify": "bin/file-versionify.js",
    "minify": "./bin/minify.js"
  },
  "scripts": {
    "eslint": "eslint library",
    "eslint:fix": "eslint library --fix",
    "test": "npm run eslint && mocha --require ./test/test_helper \"test/**/*.js\"",
    "build": "npm run eslint && node bin/clean.js && node bin/build.js && node bin/minify && node bin/file-versionify",
    "build:dev": "npm run eslint:fix && node bin/clean && node bin/build",
    "prepublish": "npm update && npm run build",
    "init:develop": "node bin/init-dev-mode",
    "clear:develop": "node bin/remove-development-dependencies",
    "watch": "onchange \"./library/*.js\" \"./node_modules/tick42-*/library/*.js\"  \"./node_modules/tick42-*/library_js/*.js\" \"../node_modules/tick42-*/library/**.js\"  \"../node_modules/tick42-*/library_js/*.js\" -iv -e \"./bin\" -- npm run build:dev",
    "watch:develop": "node bin/remove-installed-dependencies && npm run watch",
    "watch:prod": "npm install && npm run watch"
  },
  "repository": {
    "type": "git",
    "url": "https://bmarinov@stash.tick42.com:8443/scm/ofgw/js-glue.git"
  },
  "author": {
    "name": "Tick42",
    "url": "http://www.tick42.com"
  },
  "license": "ISC",
  "dependencies": {
    "cuid": "^1.3.8",
    "detect-node": "^2.0.3",
    "es5-shim": "^4.1.14",
    "object-assign": "^4.1.0",
    "tick42-activity": "^2.2.1",
    "tick42-agm": "^3.2.0",
    "tick42-app-manager": "^2.3.6",
    "tick42-appconfig": "^0.1.2",
    "tick42-contexts": "^0.0.2",
    "tick42-gateway-connection": "^2.0.3",
    "tick42-logger": "^2.0.5",
    "tick42-metrics": "^2.0.15",
    "tick42-windows": "^2.2.3"
  },
  "devDependencies": {
      "eslint": "^3.1.1",
      "eslint-config-standard": "^5.3.5",
      "eslint-config-tick42": "^1.0.0",
      "eslint-plugin-promise": "^2.0.0",
      "eslint-plugin-standard": "^2.0.0",
      "browserify": "^13.0.0",
      "browserify-replacify": "^0.0.4",
      "browserify-versionify": "^1.0.4",
      "chai": "^3.5.0",
      "fs": "0.0.2",
      "jsdom": "^8.1.0",
      "jshint": "^2.9.1",
      "minifyify": "^7.3.2",
      "mocha": "^2.4.5",
      "onchange": "^2.1.2",
      "shelljs": "^0.6.0"
  }
}

},{}]},{},[3])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWJyYXJ5L2NvbmZpZy5qcyIsImxpYnJhcnkvZ2x1ZS5qcyIsImxpYnJhcnkvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy9hc2NpaS10YWJsZS9hc2NpaS10YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9hc2NpaS10YWJsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jYWxsYmFjay1yZWdpc3RyeS9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3VpZC9kaXN0L2Jyb3dzZXItY3VpZC5qcyIsIm5vZGVfbW9kdWxlcy9kZXRlY3Qtbm9kZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtc2hpbS9lczUtc2hhbS5qcyIsIm5vZGVfbW9kdWxlcy9lczUtc2hpbS9lczUtc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hY3Rpdml0eS9saWJyYXJ5X2pzL0FQSS9hY3Rpdml0eUFQSS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9BUEkvYWN0aXZpdHlNYW5hZ2VtZW50QVBJLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hY3Rpdml0eS9saWJyYXJ5X2pzL0FQSS9hY3Rpdml0eU15QVBJLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hY3Rpdml0eS9saWJyYXJ5X2pzL2FjdGl2aXR5Q29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hY3Rpdml0eS9saWJyYXJ5X2pzL2FjdGl2aXR5TW9kdWxlLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hY3Rpdml0eS9saWJyYXJ5X2pzL2JyaWRnZXMvaGNCcmlkZ2UuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvY29udHJhY3RzL2FjdGl2aXR5U3RhdHVzLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hY3Rpdml0eS9saWJyYXJ5X2pzL2NvbnRyYWN0cy9lbnRpdHlFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9jb3JlL2FjdGl2aXR5QUdNLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hY3Rpdml0eS9saWJyYXJ5X2pzL2NvcmUvYWN0aXZpdHlNYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hY3Rpdml0eS9saWJyYXJ5X2pzL2NvcmUvbG9jYWxXaW5kb3dGYWN0b3J5LmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hY3Rpdml0eS9saWJyYXJ5X2pzL2NvcmUvcHJveHlXaW5kb3dGYWN0b3J5LmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hY3Rpdml0eS9saWJyYXJ5X2pzL2VudGl0aWVzL2FjdGl2aXR5LmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hY3Rpdml0eS9saWJyYXJ5X2pzL2VudGl0aWVzL2FjdGl2aXR5RW50aXR5LmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hY3Rpdml0eS9saWJyYXJ5X2pzL2VudGl0aWVzL2FjdGl2aXR5VHlwZS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9lbnRpdGllcy9hY3Rpdml0eVdpbmRvdy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9lbnRpdGllcy93aW5kb3dUeXBlLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hY3Rpdml0eS9saWJyYXJ5X2pzL2hlbHBlcnMvZW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvaGVscGVycy9sb2dnZXIuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvaGVscGVycy9wcm9taXNlRXh0ZW5zaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9oZWxwZXJzL3JlYWR5TWFya2VyLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hY3Rpdml0eS9saWJyYXJ5X2pzL2hlbHBlcnMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWdtL2xpYnJhcnkvYWdtLWNsaWVudC1pbnZva2UuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFnbS9saWJyYXJ5L2FnbS1jbGllbnQuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFnbS9saWJyYXJ5L2FnbS1pbnN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWdtL2xpYnJhcnkvYWdtLW5hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWdtL2xpYnJhcnkvYWdtLXJlcG9zaXRvcnkuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFnbS9saWJyYXJ5L2FnbS1zZXJ2ZXItc3RyZWFtaW5nLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hZ20vbGlicmFyeS9hZ20tc2VydmVyLXZhdWx0LmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hZ20vbGlicmFyeS9hZ20tc2VydmVyLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hZ20vbGlicmFyeS9hZ20uanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFnbS9saWJyYXJ5L2hlbHBlcnMvcHJvbWlzaWZ5LmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hZ20vbGlicmFyeS9oZWxwZXJzL3JhbmRvbS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWdtL2xpYnJhcnkvcHJvdG9jb2xzL2d3MS9jbGllbnQtc3RyZWFtaW5nLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hZ20vbGlicmFyeS9wcm90b2NvbHMvZ3cxL2NsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWdtL2xpYnJhcnkvcHJvdG9jb2xzL2d3MS9oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hZ20vbGlicmFyeS9wcm90b2NvbHMvZ3cxL3Byb3RvY29sLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hZ20vbGlicmFyeS9wcm90b2NvbHMvZ3cxL3NlcnZlci1zdHJlYW1pbmcuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFnbS9saWJyYXJ5L3Byb3RvY29scy9ndzEvc2VydmVyLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hZ20vbGlicmFyeS9wcm90b2NvbHMvZ3czL2NsaWVudC1zdHJlYW1pbmcuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFnbS9saWJyYXJ5L3Byb3RvY29scy9ndzMvY2xpZW50LmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hZ20vbGlicmFyeS9wcm90b2NvbHMvZ3czL2NvbndyYXAuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFnbS9saWJyYXJ5L3Byb3RvY29scy9ndzMvcHJvdG9jb2wuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFnbS9saWJyYXJ5L3Byb3RvY29scy9ndzMvc2VydmVyLXN0cmVhbWluZy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWdtL2xpYnJhcnkvcHJvdG9jb2xzL2d3My9zZXJ2ZXIuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFnbS9saWJyYXJ5L3Byb3RvY29scy9ndzMvc2Vzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWdtL3BhY2thZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy90aWNrNDItYXBwLW1hbmFnZXIvbGlicmFyeS9hcHBfbWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYXBwLW1hbmFnZXIvbGlicmFyeS9hcHBsaWNhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYXBwLW1hbmFnZXIvbGlicmFyeS9ldmVudF9tYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hcHAtbWFuYWdlci9saWJyYXJ5L2hlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFwcC1tYW5hZ2VyL2xpYnJhcnkvaW5zdGFuY2UuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFwcC1tYW5hZ2VyL3BhY2thZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy90aWNrNDItYXBwY29uZmlnL2xpYnJhcnkvYXBwY29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hcHBjb25maWcvbGlicmFyeS9nYXRld2F5LmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hcHBjb25maWcvbGlicmFyeS9oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hcHBjb25maWcvbGlicmFyeS9tb2RlbC5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYXBwY29uZmlnL2xpYnJhcnkvcHJvcHMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFwcGNvbmZpZy9saWJyYXJ5L3V0aWwuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWNvbnRleHRzL2xpYnJhcnkvYnJpZGdlcy9ndy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItY29udGV4dHMvbGlicmFyeS9icmlkZ2VzL2hjLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1jb250ZXh0cy9saWJyYXJ5L21haW4uanMiLCJub2RlX21vZHVsZXMvdGljazQyLWNvbnRleHRzL3BhY2thZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy90aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uL2xpYnJhcnkvY29ubmVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uL2xpYnJhcnkvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uL2xpYnJhcnkvcHJvdG9jb2xzL2d3MS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uL2xpYnJhcnkvcHJvdG9jb2xzL2d3Mi5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uL2xpYnJhcnkvcHJvdG9jb2xzL2d3My5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uL2xpYnJhcnkvdHJhbnNwb3J0cy9oYy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uL2xpYnJhcnkvdHJhbnNwb3J0cy9odHRwLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb24vbGlicmFyeS90cmFuc3BvcnRzL21vY2suanMiLCJub2RlX21vZHVsZXMvdGljazQyLWdhdGV3YXktY29ubmVjdGlvbi9saWJyYXJ5L3RyYW5zcG9ydHMvd3MuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWdhdGV3YXktY29ubmVjdGlvbi9wYWNrYWdlLmpzb24iLCJub2RlX21vZHVsZXMvdGljazQyLWxvZ2dlci9saWJyYXJ5L2xvZ2dlci5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItbG9nZ2VyL3BhY2thZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy90aWNrNDItbWV0cmljcy9saWJyYXJ5X2pzL2NvcmUvYnJpZGdlL21ldHJpY1NlcmlhbGl6ZXIuanMiLCJub2RlX21vZHVsZXMvdGljazQyLW1ldHJpY3MvbGlicmFyeV9qcy9jb3JlL2JyaWRnZS90cmFuc3BvcnQuanMiLCJub2RlX21vZHVsZXMvdGljazQyLW1ldHJpY3MvbGlicmFyeV9qcy9jb3JlL21ldHJpY3MvYWRkcmVzc01ldHJpYy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItbWV0cmljcy9saWJyYXJ5X2pzL2NvcmUvbWV0cmljcy9jb3VudE1ldHJpYy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItbWV0cmljcy9saWJyYXJ5X2pzL2NvcmUvbWV0cmljcy9tZXRyaWMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLW1ldHJpY3MvbGlicmFyeV9qcy9jb3JlL21ldHJpY3MvbnVtYmVyTWV0cmljLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1tZXRyaWNzL2xpYnJhcnlfanMvY29yZS9tZXRyaWNzL29iamVjdE1ldHJpYy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItbWV0cmljcy9saWJyYXJ5X2pzL2NvcmUvbWV0cmljcy9yYXRlTWV0cmljLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1tZXRyaWNzL2xpYnJhcnlfanMvY29yZS9tZXRyaWNzL3N0YXRpc3RpY3NNZXRyaWMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLW1ldHJpY3MvbGlicmFyeV9qcy9jb3JlL21ldHJpY3Mvc3RyaW5nTWV0cmljLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1tZXRyaWNzL2xpYnJhcnlfanMvY29yZS9tZXRyaWNzL3RpbWVzcGFuTWV0cmljLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1tZXRyaWNzL2xpYnJhcnlfanMvY29yZS9tZXRyaWNzL3RpbWVzdGFtcE1ldHJpYy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItbWV0cmljcy9saWJyYXJ5X2pzL2NvcmUvcmVwb3NpdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItbWV0cmljcy9saWJyYXJ5X2pzL2NvcmUvc3lzdGVtLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1tZXRyaWNzL2xpYnJhcnlfanMvbWV0cmljc01vZHVsZS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItd2luZG93cy9saWJyYXJ5L2hlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLXdpbmRvd3MvbGlicmFyeS93aW5kb3cuanMiLCJub2RlX21vZHVsZXMvdGljazQyLXdpbmRvd3MvbGlicmFyeS93aW5kb3dzLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi13aW5kb3dzL3BhY2thZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy91cmwtc2VhcmNoLXBhcmFtcy9idWlsZC91cmwtc2VhcmNoLXBhcmFtcy5ub2RlLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvd3MvbGliL2Jyb3dzZXIuanMiLCJwYWNrYWdlLmpzb24iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pvQkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25qQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDamhFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDam9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN1VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29uZmlndXJhdGlvbikge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgY3VpZCA9IHJlcXVpcmUoJ2N1aWQnKTtcbiAgICB2YXIgb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuICAgIHZhciBoYztcblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBoYyA9IHdpbmRvdy5odG1sQ29udGFpbmVyXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGVmYXVsdENvbmZpZ3VyYXRpb24oKSB7XG4gICAgICAgIHZhciB1aWQgPSBjdWlkKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhcHBDb25maWdGYWNhZGVDb25maWc6IGhjID8gaGMuYXBwQ29uZmlnRmFjYWRlLmNvbmZpZyA6IHsgaWRlbnRpdHk6IHt9IH0sXG4gICAgICAgICAgICBhcHBsaWNhdGlvbjogZ2V0QXBwbGljYXRpb25OYW1lKHVpZCksXG4gICAgICAgICAgICBtZXRyaWNzOiBnZXRNZXRyaWNzRGVmYXVsdHModWlkKSxcbiAgICAgICAgICAgIGFnbTogeyBwcmVzZW5jZUludGVydmFsOiAzMDAwIH0sXG4gICAgICAgICAgICBnYXRld2F5OiBnZXRHYXRld2F5RGVmYXVsdHMoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE1ldHJpY3NEZWZhdWx0cyh1aWQpIHtcbiAgICAgICAgdmFyIGRvY3VtZW50VGl0bGUgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQudGl0bGUgOiAnbmtub3duJztcbiAgICAgICAgLy8gY2hlY2sgZm9yIGVtcHR5IHRpdGxlc1xuICAgICAgICBkb2N1bWVudFRpdGxlID0gZG9jdW1lbnRUaXRsZSB8fCAnbm9uZSc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzeXN0ZW06IGhjID8gJ0h0bWxDb250YWluZXIuJyArIGhjLmNvbnRhaW5lck5hbWUgOiAnQnJvd3NlcicsXG4gICAgICAgICAgICBzZXJ2aWNlOiBoYyA/ICdKUy4nICsgaGMuYnJvd3NlcldpbmRvd05hbWUgOiBkb2N1bWVudFRpdGxlLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGhjID8gJ34nICsgaGMubWFjaGluZU5hbWUgOiAnficgKyB1aWRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEdhdGV3YXlEZWZhdWx0cygpIHtcbiAgICAgICAgdmFyIGdhdGV3YXlVUkwgPSAnbG9jYWxob3N0OjIyMDM3JztcbiAgICAgICAgdmFyIGlzU1NMID0gaXNTZWN1cmVDb25uZWN0aW9uKCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdzOiBpc1NTTCA/ICd3c3M6Ly8nICsgZ2F0ZXdheVVSTCA6ICd3czovLycgKyBnYXRld2F5VVJMLFxuICAgICAgICAgICAgaHR0cDogaXNTU0wgPyAnaHR0cHM6JyArIGdhdGV3YXlVUkwgOiAnaHR0cDovLycgKyBnYXRld2F5VVJMLFxuICAgICAgICAgICAgcHJvdG9jb2xWZXJzaW9uIDogMVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTZWN1cmVDb25uZWN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2F0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnByb3RvY29sICE9PSAnaHR0cDonO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlZmF1bHRzIHRvIHNlY3VyZSBmb3Igbm9kZSBlbnYuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEFwcGxpY2F0aW9uTmFtZSh1aWQpIHtcbiAgICAgICAgaWYgKGhjKSB7XG4gICAgICAgICAgICByZXR1cm4gaGMuY29udGFpbmVyTmFtZSArICcuJyArIGhjLmJyb3dzZXJXaW5kb3dOYW1lXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuICh3aW5kb3cuYWdtX2FwcGxpY2F0aW9uIHx8IGRvY3VtZW50LnRpdGxlKSArIHVpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnTm9kZUpTJyArIHVpZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcENvbmZpZyhzZXR0aW5ncykge1xuICAgICAgICB2YXIgaWRlbnRpdHkgPSB7fTtcblxuICAgICAgICBPYmplY3Qua2V5cyhzZXR0aW5ncy5pZGVudGl0eSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZGVudGl0eVtrZXldID0gc3VwcGxhbnQoc2V0dGluZ3MuaWRlbnRpdHlba2V5XSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG9iamVjdEFzc2lnbih7fSwgc2V0dGluZ3MsIHsgaWRlbnRpdHk6IGlkZW50aXR5IH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3VwcGxhbnQodGVtcGxhdGUsIHBhdHRlcm4pIHtcbiAgICAgICAgdmFyIHAgPSBwYXR0ZXJuIHx8IC9cXHsoW157fV0qKVxcfS9nO1xuICAgICAgICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZShwLCBmdW5jdGlvbiAobWF0Y2gsIGtleSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcztcbiAgICAgICAgICAgIGtleS5zcGxpdCgnLicpLmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVtwYXJ0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyB2YWx1ZSA6IG1hdGNoO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdHMgPSBnZXREZWZhdWx0Q29uZmlndXJhdGlvbigpO1xuICAgIHZhciBvcHRpb25zID0gb2JqZWN0QXNzaWduKHt9LCBkZWZhdWx0cywgY29uZmlndXJhdGlvbik7XG4gICAgb3B0aW9ucy5nYXRld2F5LndzID0gb3B0aW9ucy5nYXRld2F5LndzIHx8IGRlZmF1bHRzLmdhdGV3YXkud3M7XG4gICAgb3B0aW9ucy5nYXRld2F5Lmh0dHAgPSBvcHRpb25zLmdhdGV3YXkud3MgfHwgZGVmYXVsdHMuZ2F0ZXdheS5odHRwO1xuXG4gICAgdmFyIGdhdGV3YXlDb25uZWN0aW9uID0ge307XG4gICAgaWYgKGhjICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZ2F0ZXdheUNvbm5lY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmIChyZXF1aXJlKCdkZXRlY3Qtbm9kZScpIHx8ICgnV2ViU29ja2V0JyBpbiB3aW5kb3cgJiYgd2luZG93LldlYlNvY2tldC5DTE9TSU5HID09PSAyKSkge1xuICAgICAgICBnYXRld2F5Q29ubmVjdGlvbiA9IHsgd3M6IG9wdGlvbnMuZ2F0ZXdheS53cywgcHJvdG9jb2xWZXJzaW9uOiBvcHRpb25zLmdhdGV3YXkucHJvdG9jb2xWZXJzaW9uIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2F0ZXdheUNvbm5lY3Rpb24gPSB7IGh0dHA6IG9wdGlvbnMuZ2F0ZXdheS5odHRwLCBwcm90b2NvbFZlcnNpb246IG9wdGlvbnMuZ2F0ZXdheS5wcm90b2NvbFZlcnNpb24gIH07XG4gICAgfVxuXG4gICAgaWYgKGdhdGV3YXlDb25uZWN0aW9uKSB7XG4gICAgICAgIGdhdGV3YXlDb25uZWN0aW9uLmFwcGxpY2F0aW9uID0gb3B0aW9ucy5hcHBsaWNhdGlvbjtcbiAgICAgICAgZ2F0ZXdheUNvbm5lY3Rpb24uZ3dUb2tlblByb3ZpZGVyID0gb3B0aW9ucy5nd1Rva2VuUHJvdmlkZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29ubmVjdGlvbjogZ2F0ZXdheUNvbm5lY3Rpb24sXG4gICAgICAgIGFwcENvbmZpZzogYXBwQ29uZmlnKGRlZmF1bHRzLmFwcENvbmZpZ0ZhY2FkZUNvbmZpZyksIC8vIE5vdCBjb25maWd1cmFibGUgY3VycmVudGx5XG4gICAgICAgIGxvZ2dlcjoge1xuICAgICAgICAgICAgaWRlbnRpdHk6IHtcbiAgICAgICAgICAgICAgICBzeXN0ZW06IG9wdGlvbnMubWV0cmljcy5zeXN0ZW0sXG4gICAgICAgICAgICAgICAgc2VydmljZTogb3B0aW9ucy5tZXRyaWNzLnNlcnZpY2UsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IG9wdGlvbnMubWV0cmljcy5pbnN0YW5jZVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtZXRyaWNzOiB7XG4gICAgICAgICAgICBpZGVudGl0eToge1xuICAgICAgICAgICAgICAgIHN5c3RlbTogb3B0aW9ucy5tZXRyaWNzLnN5c3RlbSxcbiAgICAgICAgICAgICAgICBzZXJ2aWNlOiBvcHRpb25zLm1ldHJpY3Muc2VydmljZSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogb3B0aW9ucy5tZXRyaWNzLmluc3RhbmNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFnbToge1xuICAgICAgICAgICAgaW5zdGFuY2U6IHsgYXBwbGljYXRpb246IG9wdGlvbnMuYXBwbGljYXRpb24gfSxcbiAgICAgICAgICAgIHNlcnZlcjoge1xuICAgICAgICAgICAgICAgIGhlYXJiZWF0X2ludGVydmFsOiBkZWZhdWx0cy5hZ20uaGVhcnRiZWF0SW50ZXJ2YWwsIC8vIE5vdCBjb25maWd1cmFibGUgY3VycmVudGx5XG4gICAgICAgICAgICAgICAgcHJlc2VuY2VfaW50ZXJ2YWw6IG9wdGlvbnMuYWdtLnByZXNlbmNlSW50ZXJ2YWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgbWV0cmljcyA9IHJlcXVpcmUoJ3RpY2s0Mi1tZXRyaWNzJyk7XG4gICAgdmFyIGFnbSA9IHJlcXVpcmUoJ3RpY2s0Mi1hZ20nKTtcbiAgICB2YXIgZ2F0ZXdheUNvbm5lY3Rpb24gPSByZXF1aXJlKCd0aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uJyk7XG4gICAgdmFyIGxvZ2dlciA9IHJlcXVpcmUoJ3RpY2s0Mi1sb2dnZXInKTtcbiAgICB2YXIgYXBwY29uZmlnID0gcmVxdWlyZSgndGljazQyLWFwcGNvbmZpZycpO1xuICAgIHZhciB3aW5kb3dzID0gcmVxdWlyZSgndGljazQyLXdpbmRvd3MnKTtcbiAgICB2YXIgYXBwTWFuYWdlciA9IHJlcXVpcmUoJ3RpY2s0Mi1hcHAtbWFuYWdlcicpO1xuICAgIHZhciBhY3Rpdml0eSA9IHJlcXVpcmUoJ3RpY2s0Mi1hY3Rpdml0eScpO1xuICAgIHZhciBjb250ZXh0cyA9IHJlcXVpcmUoJ3RpY2s0Mi1jb250ZXh0cycpO1xuICAgIHZhciBQcm9taXNlID0gcmVxdWlyZSgnZXM2LXByb21pc2UnKS5Qcm9taXNlO1xuICAgIHZhciBwanNvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpO1xuICAgIHZhciBnZXRDb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZy5qcycpO1xuXG4gICAgLy8gSW5pdCB0aGUgR0xVRSBuYW1lc3BhY2VcbiAgICB2YXIgaGMgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuaHRtbENvbnRhaW5lcjtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIC8vIGd3UHJvdG9jb2xWZXJzaW9uIDIgcmVxdWlyZXMgYXV0aCAoVE9ETyAtIHdlIHNob3VsZCBjaGFuZ2UgMyB0byBiZSB0aGUgc2FtZSlcbiAgICAgICAgaWYgKCFvcHRpb25zLmF1dGggJiYgb3B0aW9ucy5nYXRld2F5LnByb3RvY29sVmVyc2lvbiA+IDEpIHtcbiAgICAgICAgICAgIHJlamVjdCgnWW91IG5lZWQgdG8gcHJvdmlkZSBhdXRoIGluZm9ybWF0aW9uJylcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBnbHVlQ29uZmlnID0gZ2V0Q29uZmlnKG9wdGlvbnMpO1xuICAgICAgICB2YXIgX2Nvbm5lY3Rpb24gPSBnYXRld2F5Q29ubmVjdGlvbihnbHVlQ29uZmlnLmNvbm5lY3Rpb24pO1xuXG4gICAgICAgIGdsdWVDb25maWcuYWdtLmNvbm5lY3Rpb24gPSBfY29ubmVjdGlvbjtcbiAgICAgICAgZ2x1ZUNvbmZpZy5sb2dnZXIuY29ubmVjdGlvbiA9IF9jb25uZWN0aW9uO1xuICAgICAgICBnbHVlQ29uZmlnLm1ldHJpY3MuY29ubmVjdGlvbiA9IF9jb25uZWN0aW9uO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmF1dGgpIHtcbiAgICAgICAgICAgIHZhciBhdXRoUmVxdWVzdDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hdXRoID09PSAnc3RyaW5nJyB8fCBvcHRpb25zLmF1dGggaW5zdGFuY2VvZiBTdHJpbmcgfHwgdHlwZW9mIG9wdGlvbnMuYXV0aCA9PT0gJ251bWJlcicgfHwgb3B0aW9ucy5hdXRoIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgYXV0aFJlcXVlc3QgPSB7IHRva2VuOiBvcHRpb25zLmF1dGggfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9wdGlvbnMuYXV0aCkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgICAgICAgICAgYXV0aFJlcXVlc3QgPSBvcHRpb25zLmF1dGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhdXRoIG9iamVjdCAtICcgKyBKU09OLnN0cmluZ2lmeShhdXRoUmVxdWVzdCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29ubmVjdGlvbi5sb2dpbihhdXRoUmVxdWVzdClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY2xpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGllbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsdWVDb25maWcuYWdtLmluc3RhbmNlLm1hY2hpbmUgPSBjbGllbnQuaXBBZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2x1ZUNvbmZpZy5hZ20uaW5zdGFuY2UudXNlciA9IGNsaWVudC51c2VybmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF9jb25maWd1cmUoZ2x1ZUNvbmZpZylcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGdsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGdsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pWydjYXRjaCddKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKF9jb25maWd1cmUoZ2x1ZUNvbmZpZykpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gX2NvbmZpZ3VyZShjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBfYWdtLCBfd2luZG93cywgX2FwcE1hbmFnZXIsIF9hcHBDb25maWcsIF9hY3Rpdml0aWVzLCBfbG9nZ2VyLCBfcm9vdE1ldHJpY3MsIF9tZXRyaWNzLCBfaW5mbywgX2ZlZWRiYWNrLCBfY29udGV4dHM7XG5cbiAgICAgICAgICAgICAgICAvLyBMb2dnZXJcbiAgICAgICAgICAgICAgICBfbG9nZ2VyID0gbG9nZ2VyKGNvbmZpZ3VyYXRpb24ubG9nZ2VyKTtcblxuICAgICAgICAgICAgICAgIC8vIE1ldHJpY3NcbiAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uLm1ldHJpY3MubG9nZ2VyID0gX2xvZ2dlci5zdWJMb2dnZXIoJ21ldHJpY3MnKTtcbiAgICAgICAgICAgICAgICBfcm9vdE1ldHJpY3MgPSBtZXRyaWNzKGNvbmZpZ3VyYXRpb24ubWV0cmljcyk7XG4gICAgICAgICAgICAgICAgX21ldHJpY3MgPSBfcm9vdE1ldHJpY3Muc3ViU3lzdGVtKCdBcHAnKTtcbiAgICAgICAgICAgICAgICBfbG9nZ2VyLm1ldHJpY3NMZXZlbCgnd2FybicsIF9tZXRyaWNzLnBhcmVudC5zdWJTeXN0ZW0oJ0xvZ0V2ZW50cycpKTtcblxuICAgICAgICAgICAgICAgIC8vIEFHTVxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24uYWdtLm1ldHJpY3MgPSBfcm9vdE1ldHJpY3Muc3ViU3lzdGVtKCdBR00nKTtcbiAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uLmFnbS5sb2dnZXIgPSBfbG9nZ2VyLnN1YkxvZ2dlcignYWdtJyk7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbi5hZ20ubG9nZ2VyLmNvbnNvbGVMZXZlbCgnZGVidWcnKTtcblxuICAgICAgICAgICAgICAgIGFnbShjb25maWd1cmF0aW9uLmFnbSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGFnbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2FnbSA9IGFnbTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2luZG93c1xuICAgICAgICAgICAgICAgICAgICAgICAgX3dpbmRvd3MgPSB3aW5kb3dzKF9hZ20pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBNYW5hZ2VyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYXBwTWFuYWdlciA9IGFwcE1hbmFnZXIoX2FnbSwgX3dpbmRvd3MpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBDb25maWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGMuYXBwQ29uZmlnRmFjYWRlICYmIGhjLmFwcENvbmZpZ0ZhY2FkZS5jb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FwcENvbmZpZyA9IGFwcGNvbmZpZygpLmluaXQoZ2x1ZUNvbmZpZy5hcHBDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFjdGl2aXRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGMuYWN0aXZpdHlGYWNhZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFjdGl2aXR5TG9nZ2VyID0gX2xvZ2dlci5zdWJMb2dnZXIoJ2FjdGl2aXR5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2aXR5TG9nZ2VyLnB1Ymxpc2hMZXZlbCgnZGVidWcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZpdHlMb2dnZXIuY29uc29sZUxldmVsKCdpbmZvJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2aXR5TG9nZ2VyLm1ldHJpY3NMZXZlbCgnb2ZmJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FjdGl2aXRpZXMgPSBhY3Rpdml0eSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ206IF9hZ20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXI6IGFjdGl2aXR5TG9nZ2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHRzID0gY29udGV4dHMoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgX2luZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2x1ZVZlcnNpb246IHBqc29uLnZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZpdGllczogX2FjdGl2aXRpZXMgPyBfYWN0aXZpdGllcy52ZXJzaW9uIDogJ3Vua25vd24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldHJpY3M6IF9tZXRyaWNzLnJlcG8udmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ206IF9hZ20udmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dzOiBfd2luZG93cy52ZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcjogX2xvZ2dlci52ZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcE1hbmFnZXI6IF9hcHBNYW5hZ2VyLnZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbjogX2Nvbm5lY3Rpb24udmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0czogX2NvbnRleHRzLnZlcnNpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9mZWVkYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9hZ20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYWdtLmludm9rZSgnVDQyLkFDUy5GZWVkYmFjaycsIHt9LCAnYmVzdCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZpdGllczogX2FjdGl2aXRpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdtOiBfYWdtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcENvbmZpZzogX2FwcENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBNYW5hZ2VyOiBfYXBwTWFuYWdlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uOiBfY29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0czogX2NvbnRleHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlZWRiYWNrOiBfZmVlZGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbzogX2luZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyOiBfbG9nZ2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldHJpY3M6IF9tZXRyaWNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb246IHBqc29uLnZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93czogX3dpbmRvd3NcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSlcbn07XG4iLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gRG8gbm90IGRvIGFueXRoaW5nIGlmIHRoZXJlIGlzIG5vIHN1cHBvcnQgb2YgRUNNQVNjcmlwdCA1XG4gICAgaWYgKHR5cGVvZiBbXS5mb3JFYWNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlcXVpcmUoJ2VzNS1zaGltJyk7XG4gICAgICAgIHJlcXVpcmUoJ2VzNS1zaGltL2VzNS1zaGFtJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdCBsb2dpYyB0aGF0IHdlIGZvbGxvdzpcbiAgICAgKiB2MSBzdXBwb3J0cyBhdXRvSW5pdFxuICAgICAqIHYyLCB2MyBkb2VzIG5vdCBzdXBwb3J0IGF1dG8taW5pdCAtdGhpcyBtZWFucyB0aGF0IHlvdSBzaG91bGQgdXNlIEdsdWUgZmFjdG9yeSBtZXRob2QgdG8gaW5pdCBnbHVlXG4gICAgICovXG4gICAgdmFyIGNyZWF0ZUdsdWUgPSByZXF1aXJlKCcuL2dsdWUnKTtcbiAgICB2YXIgY29uZmlnID0gZ2xvYmFsLmdsdWVDb25maWcgfHwge307XG5cbiAgICBjb25maWcuZ2F0ZXdheSA9IGNvbmZpZy5nYXRld2F5IHx8IHt9O1xuICAgIGNvbmZpZy5nYXRld2F5LnByb3RvY29sVmVyc2lvbiA9IGNvbmZpZy5nYXRld2F5LnByb3RvY29sVmVyc2lvbiB8fCAzO1xuICAgIHZhciBhdXRvSW5pdCA9IGNvbmZpZy5hdXRvSW5pdCB8fCBjb25maWcuZ2F0ZXdheS5wcm90b2NvbFZlcnNpb24gPT09IDE7XG5cbiAgICBpZiAoYXV0b0luaXQgJiYgY29uZmlnLmdhdGV3YXkucHJvdG9jb2xWZXJzaW9uID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsdWUgYXV0byBpbml0IGlzIG9ubHkgc3VwcG9ydGVkIGZvciBnYXRld2F5IHByb3RvY29sIHZlcnNpb24gMSAtIHN3aXRjaCB0byAxIG9yIHR1cm4gb2ZmIGF1dG8gaW5pdCcpO1xuICAgIH1cblxuICAgIC8vIGlmIGluIG5vZGUgc3dpdGNoIHRvIHYyXG4gICAgaWYgKHJlcXVpcmUoJ2RldGVjdC1ub2RlJykpIHtcbiAgICAgICAgYXV0b0luaXQgPSBmYWxzZTtcbiAgICAgICAgY29uZmlnLmdhdGV3YXkucHJvdG9jb2xWZXJzaW9uID0gMjtcbiAgICB9XG5cbiAgICBpZiAoYXV0b0luaXQpIHtcbiAgICAgICAgY3JlYXRlR2x1ZShjb25maWcpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZ2x1ZSkge1xuICAgICAgICAgICAgICAgIGdsb2JhbC5nbHVlID0gZ2x1ZTtcbiAgICAgICAgICAgIH0pWydjYXRjaCddKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2Vycm9yIGF1dG8gaW5pdGlhbGluZyBnbHVlJywgZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGZhY3RvcnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAoIShvcHRpb25zLmdhdGV3YXkgJiYgb3B0aW9ucy5nYXRld2F5LnByb3RvY29sVmVyc2lvbikpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZ2F0ZXdheS5wcm90b2NvbFZlcnNpb24gPSBjb25maWcuZ2F0ZXdheS5wcm90b2NvbFZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUdsdWUob3B0aW9ucyk7XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3aW5kb3cuR2x1ZSA9IGZhY3Rvcnk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5XG59KCkpO1xuIiwiLyoqXG4gKiAoYykgMjAxMyBCZWF1IFNvcmVuc2VuXG4gKiBNSVQgTGljZW5zZWRcbiAqIEZvciBhbGwgZGV0YWlscyBhbmQgZG9jdW1lbnRhdGlvbjpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zb3JlbnNlbi9hc2NpaS10YWJsZVxuICovXG5cbjsoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAsIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuXG4vKipcbiAqIEFzY2lpVGFibGUgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHRpdGxlIG9yIEpTT04gdGFibGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YWJsZSBvcHRpb25zXG4gKiAgLSBgcHJlZml4YCAtIHN0cmluZyBwcmVmaXggYWRkZWQgdG8gZWFjaCBsaW5lIG9uIHJlbmRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEFzY2lpVGFibGUobmFtZSwgb3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHRoaXMucmVzZXQobmFtZSlcbn1cblxuLyohXG4gKiBDdXJyZW50IGxpYnJhcnkgdmVyc2lvbiwgc2hvdWxkIG1hdGNoIGBwYWNrYWdlLmpzb25gXG4gKi9cblxuQXNjaWlUYWJsZS5WRVJTSU9OID0gJzAuMC44J1xuXG4vKiFcbiAqIEFsaWdubWVudCBjb25zdGFudHNcbiAqL1xuXG5Bc2NpaVRhYmxlLkxFRlQgPSAwXG5Bc2NpaVRhYmxlLkNFTlRFUiA9IDFcbkFzY2lpVGFibGUuUklHSFQgPSAyXG5cbi8qIVxuICogU3RhdGljIG1ldGhvZHNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyB0YWJsZSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdGl0bGUgb3IgSlNPTiB0YWJsZVxuICogQHBhcmFtIHtPYmplY3R9IHRhYmxlIG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5mYWN0b3J5ID0gZnVuY3Rpb24obmFtZSwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IEFzY2lpVGFibGUobmFtZSwgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBBbGlnbiB0aGUgYSBzdHJpbmcgYXQgdGhlIGdpdmVuIGxlbmd0aFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgaW5wdXRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpbmcgbGVuZ3RoXG4gKiBAcGFyYW0ge051bWJlcn0gcGFkZGluZyBjaGFyYWN0ZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5hbGlnbiA9IGZ1bmN0aW9uKGRpciwgc3RyLCBsZW4sIHBhZCkge1xuICBpZiAoZGlyID09PSBBc2NpaVRhYmxlLkxFRlQpIHJldHVybiBBc2NpaVRhYmxlLmFsaWduTGVmdChzdHIsIGxlbiwgcGFkKVxuICBpZiAoZGlyID09PSBBc2NpaVRhYmxlLlJJR0hUKSByZXR1cm4gQXNjaWlUYWJsZS5hbGlnblJpZ2h0KHN0ciwgbGVuLCBwYWQpXG4gIGlmIChkaXIgPT09IEFzY2lpVGFibGUuQ0VOVEVSKSByZXR1cm4gQXNjaWlUYWJsZS5hbGlnbkNlbnRlcihzdHIsIGxlbiwgcGFkKVxuICByZXR1cm4gQXNjaWlUYWJsZS5hbGlnbkF1dG8oc3RyLCBsZW4sIHBhZClcbn1cblxuLyoqXG4gKiBMZWZ0IGFsaWduIGEgc3RyaW5nIGJ5IHBhZGRpbmcgaXQgYXQgYSBnaXZlbiBsZW5ndGhcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaW5nIGxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IHBhZGRpbmcgY2hhcmFjdGVyIChvcHRpb25hbCwgZGVmYXVsdCAnJylcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5hbGlnbkxlZnQgPSBmdW5jdGlvbihzdHIsIGxlbiwgcGFkKSB7XG4gIGlmICghbGVuIHx8IGxlbiA8IDApIHJldHVybiAnJ1xuICBpZiAoc3RyID09PSB1bmRlZmluZWQgfHwgc3RyID09PSBudWxsKSBzdHIgPSAnJ1xuICBpZiAodHlwZW9mIHBhZCA9PT0gJ3VuZGVmaW5lZCcpIHBhZCA9ICcgJ1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHN0ciA9IHN0ci50b1N0cmluZygpXG4gIHZhciBhbGVuID0gbGVuICsgMSAtIHN0ci5sZW5ndGhcbiAgaWYgKGFsZW4gPD0gMCkgcmV0dXJuIHN0clxuICByZXR1cm4gc3RyICsgQXJyYXkobGVuICsgMSAtIHN0ci5sZW5ndGgpLmpvaW4ocGFkKVxufVxuXG4vKipcbiAqIENlbnRlciBhbGlnbiBhIHN0cmluZyBieSBwYWRkaW5nIGl0IGF0IGEgZ2l2ZW4gbGVuZ3RoXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmluZyBsZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWRkaW5nIGNoYXJhY3RlciAob3B0aW9uYWwsIGRlZmF1bHQgJycpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUuYWxpZ25DZW50ZXIgPSBmdW5jdGlvbihzdHIsIGxlbiwgcGFkKSB7XG4gIGlmICghbGVuIHx8IGxlbiA8IDApIHJldHVybiAnJ1xuICBpZiAoc3RyID09PSB1bmRlZmluZWQgfHwgc3RyID09PSBudWxsKSBzdHIgPSAnJ1xuICBpZiAodHlwZW9mIHBhZCA9PT0gJ3VuZGVmaW5lZCcpIHBhZCA9ICcgJ1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHN0ciA9IHN0ci50b1N0cmluZygpXG4gIHZhciBuTGVuID0gc3RyLmxlbmd0aFxuICAgICwgaGFsZiA9IE1hdGguZmxvb3IobGVuIC8gMiAtIG5MZW4gLyAyKVxuICAgICwgb2RkcyA9IE1hdGguYWJzKChuTGVuICUgMikgLSAobGVuICUgMikpXG4gICAgLCBsZW4gPSBzdHIubGVuZ3RoXG5cbiAgcmV0dXJuIEFzY2lpVGFibGUuYWxpZ25SaWdodCgnJywgaGFsZiwgcGFkKSBcbiAgICArIHN0clxuICAgICsgQXNjaWlUYWJsZS5hbGlnbkxlZnQoJycsIGhhbGYgKyBvZGRzLCBwYWQpXG59XG5cbi8qKlxuICogUmlnaHQgYWxpZ24gYSBzdHJpbmcgYnkgcGFkZGluZyBpdCBhdCBhIGdpdmVuIGxlbmd0aFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpbmcgbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFkZGluZyBjaGFyYWN0ZXIgKG9wdGlvbmFsLCBkZWZhdWx0ICcnKVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLmFsaWduUmlnaHQgPSBmdW5jdGlvbihzdHIsIGxlbiwgcGFkKSB7XG4gIGlmICghbGVuIHx8IGxlbiA8IDApIHJldHVybiAnJ1xuICBpZiAoc3RyID09PSB1bmRlZmluZWQgfHwgc3RyID09PSBudWxsKSBzdHIgPSAnJ1xuICBpZiAodHlwZW9mIHBhZCA9PT0gJ3VuZGVmaW5lZCcpIHBhZCA9ICcgJ1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHN0ciA9IHN0ci50b1N0cmluZygpXG4gIHZhciBhbGVuID0gbGVuICsgMSAtIHN0ci5sZW5ndGhcbiAgaWYgKGFsZW4gPD0gMCkgcmV0dXJuIHN0clxuICByZXR1cm4gQXJyYXkobGVuICsgMSAtIHN0ci5sZW5ndGgpLmpvaW4ocGFkKSArIHN0clxufVxuXG4vKipcbiAqIEF1dG8gYWxpZ24gc3RyaW5nIHZhbHVlIGJhc2VkIG9uIG9iamVjdCB0eXBlXG4gKlxuICogQHBhcmFtIHtBbnl9IG9iamVjdCB0byBzdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpbmcgbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFkZGluZyBjaGFyYWN0ZXIgKG9wdGlvbmFsLCBkZWZhdWx0ICcnKVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLmFsaWduQXV0byA9IGZ1bmN0aW9uKHN0ciwgbGVuLCBwYWQpIHtcbiAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkIHx8IHN0ciA9PT0gbnVsbCkgc3RyID0gJydcbiAgdmFyIHR5cGUgPSB0b1N0cmluZy5jYWxsKHN0cilcbiAgcGFkIHx8IChwYWQgPSAnICcpXG4gIGxlbiA9ICtsZW5cbiAgaWYgKHR5cGUgIT09ICdbb2JqZWN0IFN0cmluZ10nKSB7XG4gICAgc3RyID0gc3RyLnRvU3RyaW5nKClcbiAgfVxuICBpZiAoc3RyLmxlbmd0aCA8IGxlbikge1xuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOiByZXR1cm4gQXNjaWlUYWJsZS5hbGlnblJpZ2h0KHN0ciwgbGVuLCBwYWQpXG4gICAgICBkZWZhdWx0OiByZXR1cm4gQXNjaWlUYWJsZS5hbGlnbkxlZnQoc3RyLCBsZW4sIHBhZClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG4vKipcbiAqIEZpbGwgYW4gYXJyYXkgYXQgYSBnaXZlbiBzaXplIHdpdGggdGhlIGdpdmVuIHZhbHVlXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGFycmF5IHNpemVcbiAqIEBwYXJhbSB7QW55fSBmaWxsIHZhbHVlXG4gKiBAcmV0dXJuIHtBcnJheX0gZmlsbGVkIGFycmF5XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUuYXJyYXlGaWxsID0gZnVuY3Rpb24obGVuLCBmaWxsKSB7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkobGVuKVxuICBmb3IgKHZhciBpID0gMDsgaSAhPT0gbGVuOyBpKyspIHtcbiAgICBhcnJbaV0gPSBmaWxsO1xuICB9XG4gIHJldHVybiBhcnJcbn1cblxuLyohXG4gKiBJbnN0YW5jZSBtZXRob2RzXG4gKi9cblxuLyoqXG4gKiBSZXNldCB0aGUgdGFibGUgc3RhdGUgYmFjayB0byBkZWZhdWx0c1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdGl0bGUgb3IgSlNPTiB0YWJsZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5yZXNldCA9IFxuQXNjaWlUYWJsZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRoaXMuX19uYW1lID0gJydcbiAgdGhpcy5fX25hbWVBbGlnbiA9IEFzY2lpVGFibGUuQ0VOVEVSXG4gIHRoaXMuX19yb3dzID0gW11cbiAgdGhpcy5fX21heENlbGxzID0gMFxuICB0aGlzLl9fYWxpZ25zID0gW11cbiAgdGhpcy5fX2NvbE1heGVzID0gW11cbiAgdGhpcy5fX3NwYWNpbmcgPSAxXG4gIHRoaXMuX19oZWFkaW5nID0gbnVsbFxuICB0aGlzLl9faGVhZGluZ0FsaWduID0gQXNjaWlUYWJsZS5DRU5URVJcbiAgdGhpcy5zZXRCb3JkZXIoKVxuXG4gIGlmICh0b1N0cmluZy5jYWxsKG5hbWUpID09PSAnW29iamVjdCBTdHJpbmddJykge1xuICAgIHRoaXMuX19uYW1lID0gbmFtZVxuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwobmFtZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgdGhpcy5mcm9tSlNPTihuYW1lKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogU2V0IHRoZSB0YWJsZSBib3JkZXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaG9yaXpvbnRhbCBlZGdlcyAob3B0aW9uYWwsIGRlZmF1bHQgYHxgKVxuICogQHBhcmFtIHtTdHJpbmd9IHZlcnRpY2FsIGVkZ2VzIChvcHRpb25hbCwgZGVmYXVsdCBgLWApXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9wIGNvcm5lcnMgKG9wdGlvbmFsLCBkZWZhdWx0IGAuYClcbiAqIEBwYXJhbSB7U3RyaW5nfSBib3R0b20gY29ybmVycyAob3B0aW9uYWwsIGRlZmF1bHQgYCdgKVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5zZXRCb3JkZXIgPSBmdW5jdGlvbihlZGdlLCBmaWxsLCB0b3AsIGJvdHRvbSkge1xuICB0aGlzLl9fYm9yZGVyID0gdHJ1ZVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGZpbGwgPSB0b3AgPSBib3R0b20gPSBlZGdlXG4gIH1cbiAgdGhpcy5fX2VkZ2UgPSBlZGdlIHx8ICd8J1xuICB0aGlzLl9fZmlsbCA9IGZpbGwgfHwgJy0nXG4gIHRoaXMuX190b3AgPSB0b3AgfHwgJy4nXG4gIHRoaXMuX19ib3R0b20gPSBib3R0b20gfHwgXCInXCJcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBSZW1vdmUgYWxsIHRhYmxlIGJvcmRlcnNcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLnJlbW92ZUJvcmRlciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9fYm9yZGVyID0gZmFsc2VcbiAgdGhpcy5fX2VkZ2UgPSAnICdcbiAgdGhpcy5fX2ZpbGwgPSAnICdcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNvbHVtbiBhbGlnbm1lbnQgYXQgYSBnaXZlbiBpbmRleFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2x1bW4gaW5kZXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbGlnbm1lbnQgZGlyZWN0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLnNldEFsaWduID0gZnVuY3Rpb24oaWR4LCBkaXIpIHtcbiAgdGhpcy5fX2FsaWduc1tpZHhdID0gZGlyXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogU2V0IHRoZSB0aXRsZSBvZiB0aGUgdGFibGVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGl0bGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuc2V0VGl0bGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRoaXMuX19uYW1lID0gbmFtZVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIEdldCB0aGUgdGl0bGUgb2YgdGhlIHRhYmxlXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSB0aXRsZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX25hbWVcbn1cblxuLyoqXG4gKiBTZXQgdGFibGUgdGl0bGUgYWxpZ25tZW50XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRpcmVjdGlvblxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5zZXRUaXRsZUFsaWduID0gZnVuY3Rpb24oZGlyKSB7XG4gIHRoaXMuX19uYW1lQWxpZ24gPSBkaXJcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBBc2NpaVRhYmxlIHNvcnRpbmcgc2hvcnRjdXQgdG8gc29ydCByb3dzXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc29ydGluZyBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uKG1ldGhvZCkge1xuICB0aGlzLl9fcm93cy5zb3J0KG1ldGhvZClcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBTb3J0IHJvd3MgYmFzZWQgb24gc29ydCBtZXRob2QgZm9yIGdpdmVuIGNvbHVtblxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2x1bW4gaW5kZXhcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNvcnRpbmcgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLnNvcnRDb2x1bW4gPSBmdW5jdGlvbihpZHgsIG1ldGhvZCkge1xuICB0aGlzLl9fcm93cy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gbWV0aG9kKGFbaWR4XSwgYltpZHhdKVxuICB9KVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIFNldCB0YWJsZSBoZWFkaW5nIGZvciBjb2x1bW5zXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5zZXRIZWFkaW5nID0gZnVuY3Rpb24ocm93KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSB8fCB0b1N0cmluZy5jYWxsKHJvdykgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICByb3cgPSBzbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgfVxuICB0aGlzLl9faGVhZGluZyA9IHJvd1xuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIEdldCB0YWJsZSBoZWFkaW5nIGZvciBjb2x1bW5zXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGNvcHkgb2YgaGVhZGluZ3NcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuZ2V0SGVhZGluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX2hlYWRpbmcuc2xpY2UoKVxufVxuXG4vKipcbiAqIFNldCBoZWFkaW5nIGFsaWdubWVudFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb25cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuc2V0SGVhZGluZ0FsaWduID0gZnVuY3Rpb24oZGlyKSB7XG4gIHRoaXMuX19oZWFkaW5nQWxpZ24gPSBkaXJcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBBZGQgYSByb3cgb2YgaW5mb3JtYXRpb24gdG8gdGhlIHRhYmxlXG4gKiBcbiAqIEBwYXJhbSB7Li4ufEFycmF5fSBhcmd1bWVudCB2YWx1ZXMgaW4gb3JkZXIgb2YgY29sdW1uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5hZGRSb3cgPSBmdW5jdGlvbihyb3cpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxIHx8IHRvU3RyaW5nLmNhbGwocm93KSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHJvdyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICB9XG4gIHRoaXMuX19tYXhDZWxscyA9IE1hdGgubWF4KHRoaXMuX19tYXhDZWxscywgcm93Lmxlbmd0aClcbiAgdGhpcy5fX3Jvd3MucHVzaChyb3cpXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogR2V0IGEgY29weSBvZiBhbGwgcm93cyBvZiB0aGUgdGFibGVcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gY29weSBvZiByb3dzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLmdldFJvd3MgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19yb3dzLnNsaWNlKCkubWFwKGZ1bmN0aW9uKHJvdykge1xuICAgIHJldHVybiByb3cuc2xpY2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEFkZCByb3dzIGluIHRoZSBmb3JtYXQgb2YgYSByb3cgbWF0cml4XG4gKlxuICogQHBhcmFtIHtBcnJheX0gcm93IG1hdHJpeFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5hZGRSb3dNYXRyaXggPSBmdW5jdGlvbihyb3dzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuYWRkUm93KHJvd3NbaV0pXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBBZGQgcm93cyBmcm9tIHRoZSBnaXZlbiBkYXRhIGFycmF5LCBwcm9jZXNzZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHJvd0NhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGFcbiAqIEBwYXJhbSAoRnVuY3Rpb24pIHJvd0NhbGxiYWNrXG4gKiBAcGFyYW0gKEJvb2xlYW4pIGFzTWF0cml4IC0gY29udHJvbHMgaWYgdGhlIHJvdyBjcmVhdGVkIGJ5IHJvd0NhbGxiYWNrIHNob3VsZCBiZSBhc3NpZ25lZCBhcyByb3cgbWF0cml4XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLmFkZERhdGEgPSBmdW5jdGlvbihkYXRhLCByb3dDYWxsYmFjaywgYXNNYXRyaXgpIHtcbiAgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmb3IgKHZhciBpbmRleCA9IDAsIGxpbWl0ID0gZGF0YS5sZW5ndGg7IGluZGV4IDwgbGltaXQ7IGluZGV4KyspIHtcbiAgICB2YXIgcm93ID0gcm93Q2FsbGJhY2soZGF0YVtpbmRleF0pO1xuICAgIGlmKGFzTWF0cml4KSB7XG4gICAgICB0aGlzLmFkZFJvd01hdHJpeChyb3cpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZFJvdyhyb3cpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG4gIC8qKlxuICogUmVzZXQgdGhlIGN1cnJlbnQgcm93IHN0YXRlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5jbGVhclJvd3MgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fX3Jvd3MgPSBbXVxuICB0aGlzLl9fbWF4Q2VsbHMgPSAwXG4gIHRoaXMuX19jb2xNYXhlcyA9IFtdXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQXBwbHkgYW4gZXZlbiBzcGFjZWQgY29sdW1uIGp1c3RpZmljYXRpb25cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uIC8gb2ZmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLnNldEp1c3RpZnkgPSBmdW5jdGlvbih2YWwpIHtcbiAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMCAmJiAodmFsID0gdHJ1ZSlcbiAgdGhpcy5fX2p1c3RpZnkgPSAhIXZhbFxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIGN1cnJlbnQgaW5zdGFuY2UgdG8gYSBKU09OIHN0cnVjdHVyZVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0ganNvbiByZXByZXNlbnRhdGlvblxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB0aXRsZTogdGhpcy5nZXRUaXRsZSgpXG4gICwgaGVhZGluZzogdGhpcy5nZXRIZWFkaW5nKClcbiAgLCByb3dzOiB0aGlzLmdldFJvd3MoKVxuICB9XG59XG5cbi8qKlxuICogUG9wdWxhdGUgdGhlIHRhYmxlIGZyb20gYSBKU09OIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBqc29uIHJlcHJlc2VudGF0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLnBhcnNlID0gXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdGhpc1xuICAgIC5jbGVhcigpXG4gICAgLnNldFRpdGxlKG9iai50aXRsZSlcbiAgICAuc2V0SGVhZGluZyhvYmouaGVhZGluZylcbiAgICAuYWRkUm93TWF0cml4KG9iai5yb3dzKVxufVxuXG4vKipcbiAqIFJlbmRlciB0aGUgdGFibGUgd2l0aCB0aGUgY3VycmVudCBpbmZvcm1hdGlvblxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gZm9ybWF0dGVkIHRhYmxlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLnJlbmRlciA9XG5Bc2NpaVRhYmxlLnByb3RvdHlwZS52YWx1ZU9mID1cbkFzY2lpVGFibGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgYm9keSA9IFtdXG4gICAgLCBtTGVuID0gdGhpcy5fX21heENlbGxzXG4gICAgLCBtYXggPSBBc2NpaVRhYmxlLmFycmF5RmlsbChtTGVuLCAwKVxuICAgICwgdG90YWwgPSBtTGVuICogM1xuICAgICwgcm93cyA9IHRoaXMuX19yb3dzXG4gICAgLCBqdXN0aWZ5XG4gICAgLCBib3JkZXIgPSB0aGlzLl9fYm9yZGVyXG4gICAgLCBhbGwgPSB0aGlzLl9faGVhZGluZyBcbiAgICAgICAgPyBbdGhpcy5fX2hlYWRpbmddLmNvbmNhdChyb3dzKVxuICAgICAgICA6IHJvd3NcblxuICAvLyBDYWxjdWxhdGUgbWF4IHRhYmxlIGNlbGwgbGVuZ3RocyBhY3Jvc3MgYWxsIHJvd3NcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcm93ID0gYWxsW2ldXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBtTGVuOyBrKyspIHtcbiAgICAgIHZhciBjZWxsID0gcm93W2tdXG4gICAgICBtYXhba10gPSBNYXRoLm1heChtYXhba10sIGNlbGwgPyBjZWxsLnRvU3RyaW5nKCkubGVuZ3RoIDogMClcbiAgICB9XG4gIH1cbiAgdGhpcy5fX2NvbE1heGVzID0gbWF4XG4gIGp1c3RpZnkgPSB0aGlzLl9fanVzdGlmeSA/IE1hdGgubWF4LmFwcGx5KG51bGwsIG1heCkgOiAwXG5cbiAgLy8gR2V0IFxuICBtYXguZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgdG90YWwgKz0ganVzdGlmeSA/IGp1c3RpZnkgOiB4ICsgc2VsZi5fX3NwYWNpbmdcbiAgfSlcbiAganVzdGlmeSAmJiAodG90YWwgKz0gbWF4Lmxlbmd0aClcbiAgdG90YWwgLT0gdGhpcy5fX3NwYWNpbmdcblxuICAvLyBIZWFkaW5nXG4gIGJvcmRlciAmJiBib2R5LnB1c2godGhpcy5fc2VwZXJhdG9yKHRvdGFsIC0gbUxlbiArIDEsIHRoaXMuX190b3ApKVxuICBpZiAodGhpcy5fX25hbWUpIHtcbiAgICBib2R5LnB1c2godGhpcy5fcmVuZGVyVGl0bGUodG90YWwgLSBtTGVuICsgMSkpXG4gICAgYm9yZGVyICYmIGJvZHkucHVzaCh0aGlzLl9zZXBlcmF0b3IodG90YWwgLSBtTGVuICsgMSkpXG4gIH1cbiAgaWYgKHRoaXMuX19oZWFkaW5nKSB7XG4gICAgYm9keS5wdXNoKHRoaXMuX3JlbmRlclJvdyh0aGlzLl9faGVhZGluZywgJyAnLCB0aGlzLl9faGVhZGluZ0FsaWduKSlcbiAgICBib2R5LnB1c2godGhpcy5fcm93U2VwZXJhdG9yKG1MZW4sIHRoaXMuX19maWxsKSlcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX19yb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgYm9keS5wdXNoKHRoaXMuX3JlbmRlclJvdyh0aGlzLl9fcm93c1tpXSwgJyAnKSlcbiAgfVxuICBib3JkZXIgJiYgYm9keS5wdXNoKHRoaXMuX3NlcGVyYXRvcih0b3RhbCAtIG1MZW4gKyAxLCB0aGlzLl9fYm90dG9tKSlcblxuICB2YXIgcHJlZml4ID0gdGhpcy5vcHRpb25zLnByZWZpeCB8fCAnJ1xuICByZXR1cm4gcHJlZml4ICsgYm9keS5qb2luKCdcXG4nICsgcHJlZml4KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGxpbmUgc2VwZXJhdG9yXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmluZyBzaXplXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lkZSB2YWx1ZXMgKGRlZmF1bHQgJ3wnKVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuX3NlcGVyYXRvciA9IGZ1bmN0aW9uKGxlbiwgc2VwKSB7XG4gIHNlcCB8fCAoc2VwID0gdGhpcy5fX2VkZ2UpXG4gIHJldHVybiBzZXAgKyBBc2NpaVRhYmxlLmFsaWduUmlnaHQoc2VwLCBsZW4sIHRoaXMuX19maWxsKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJvdyBzZXBlcmF0b3JcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHNlcGVyYXRvclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuX3Jvd1NlcGVyYXRvciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYmxhbmtzID0gQXNjaWlUYWJsZS5hcnJheUZpbGwodGhpcy5fX21heENlbGxzLCB0aGlzLl9fZmlsbClcbiAgcmV0dXJuIHRoaXMuX3JlbmRlclJvdyhibGFua3MsIHRoaXMuX19maWxsKVxufVxuXG4vKipcbiAqIFJlbmRlciB0aGUgdGFibGUgdGl0bGUgaW4gYSBjZW50ZXJlZCBib3hcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaW5nIHNpemVcbiAqIEByZXR1cm4ge1N0cmluZ30gZm9ybWF0dGVkIHRpdGxlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5fcmVuZGVyVGl0bGUgPSBmdW5jdGlvbihsZW4pIHtcbiAgdmFyIG5hbWUgPSAnICcgKyB0aGlzLl9fbmFtZSArICcgJ1xuICAgICwgc3RyID0gQXNjaWlUYWJsZS5hbGlnbih0aGlzLl9fbmFtZUFsaWduLCBuYW1lLCBsZW4gLSAxLCAnICcpXG4gIHJldHVybiB0aGlzLl9fZWRnZSArIHN0ciArIHRoaXMuX19lZGdlXG59XG5cbi8qKlxuICogUmVuZGVyIGFuIGludmRpdmlkdWFsIHJvd1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHJvd1xuICogQHBhcmFtIHtTdHJpbmd9IGNvbHVtbiBzZXBlcmF0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3RhbCByb3cgYWxpZ25tZW50IChvcHRpb25hbCwgZGVmYXVsdCBgYXV0b2ApXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGZvcm1hdHRlZCByb3dcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLl9yZW5kZXJSb3cgPSBmdW5jdGlvbihyb3csIHN0ciwgYWxpZ24pIHtcbiAgdmFyIHRtcCA9IFsnJ11cbiAgICAsIG1heCA9IHRoaXMuX19jb2xNYXhlc1xuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5fX21heENlbGxzOyBrKyspIHtcbiAgICB2YXIgY2VsbCA9IHJvd1trXVxuICAgICAgLCBqdXN0ID0gdGhpcy5fX2p1c3RpZnkgPyBNYXRoLm1heC5hcHBseShudWxsLCBtYXgpIDogbWF4W2tdXG4gICAgICAvLyAsIHBhZCA9IGsgPT09IHRoaXMuX19tYXhDZWxscyAtIDEgPyBqdXN0IDoganVzdCArIHRoaXMuX19zcGFjaW5nXG4gICAgICAsIHBhZCA9IGp1c3RcbiAgICAgICwgY0FsaWduID0gdGhpcy5fX2FsaWduc1trXVxuICAgICAgLCB1c2UgPSBhbGlnblxuICAgICAgLCBtZXRob2QgPSAnYWxpZ25BdXRvJ1xuICBcbiAgICBpZiAodHlwZW9mIGFsaWduID09PSAndW5kZWZpbmVkJykgdXNlID0gY0FsaWduXG5cbiAgICBpZiAodXNlID09PSBBc2NpaVRhYmxlLkxFRlQpIG1ldGhvZCA9ICdhbGlnbkxlZnQnXG4gICAgaWYgKHVzZSA9PT0gQXNjaWlUYWJsZS5DRU5URVIpIG1ldGhvZCA9ICdhbGlnbkNlbnRlcidcbiAgICBpZiAodXNlID09PSBBc2NpaVRhYmxlLlJJR0hUKSBtZXRob2QgPSAnYWxpZ25SaWdodCdcblxuICAgIHRtcC5wdXNoKEFzY2lpVGFibGVbbWV0aG9kXShjZWxsLCBwYWQsIHN0cikpXG4gIH1cbiAgdmFyIGZyb250ID0gdG1wLmpvaW4oc3RyICsgdGhpcy5fX2VkZ2UgKyBzdHIpXG4gIGZyb250ID0gZnJvbnQuc3Vic3RyKDEsIGZyb250Lmxlbmd0aClcbiAgcmV0dXJuIGZyb250ICsgc3RyICsgdGhpcy5fX2VkZ2Vcbn1cblxuLyohXG4gKiBBbGlhc2VzXG4gKi9cblxuLy8gQ3JlYXRlIG1ldGhvZCBzaG9ydGN1dHMgdG8gYWxsIGFsaWdubWVudCBtZXRob2RzIGZvciBlYWNoIGRpcmVjdGlvblxuO1snTGVmdCcsICdSaWdodCcsICdDZW50ZXInXS5mb3JFYWNoKGZ1bmN0aW9uKGRpcikge1xuICB2YXIgY29uc3RhbnQgPSBBc2NpaVRhYmxlW2Rpci50b1VwcGVyQ2FzZSgpXVxuXG4gIDtbJ3NldEFsaWduJywgJ3NldFRpdGxlQWxpZ24nLCAnc2V0SGVhZGluZ0FsaWduJ10uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAvLyBDYWxsIHRoZSBiYXNlIG1ldGhvZCB3aXRoIHRoZSBkaXJlY3Rpb24gY29uc3RhbnQgYXMgdGhlIGxhc3QgYXJndW1lbnRcbiAgICBBc2NpaVRhYmxlLnByb3RvdHlwZVttZXRob2QgKyBkaXJdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKS5jb25jYXQoY29uc3RhbnQpXG4gICAgICByZXR1cm4gdGhpc1ttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgfVxuICB9KVxufSlcblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5pZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gQXNjaWlUYWJsZVxufSBlbHNlIHtcbiAgdGhpcy5Bc2NpaVRhYmxlID0gQXNjaWlUYWJsZVxufVxuXG59KS5jYWxsKHRoaXMpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2FzY2lpLXRhYmxlJykiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcclxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHJcblx0dmFyIGNhbGxiYWNrcyA9IHt9O1xyXG5cclxuXHRmdW5jdGlvbiBhZGQoa2V5LCBjYWxsYmFjaykge1xyXG5cdFx0dmFyIGNhbGxiYWNrc0ZvcktleSA9IGNhbGxiYWNrc1trZXldO1xyXG5cclxuXHRcdGlmICghY2FsbGJhY2tzRm9yS2V5KSB7XHJcblx0XHRcdGNhbGxiYWNrc0ZvcktleSA9IFtdO1xyXG5cdFx0XHRjYWxsYmFja3Nba2V5XSA9IGNhbGxiYWNrc0ZvcktleTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbmV3TGVuID0gY2FsbGJhY2tzRm9yS2V5LnB1c2goY2FsbGJhY2spO1xyXG5cdFx0dmFyIGl0ZW1JbmRleCA9IG5ld0xlbiAtIDE7XHJcblxyXG5cdFx0Ly8gY2FsbGJhY2sgaWQgaXMgZm9ybWVkIGFzIDxpdGVtLWluZGV4Pl88a2V5Piwgd2UgdXNlIHRoYXQgaWQgdG8gcmVtb3ZlIHRoZSBjYWxsYmFjayBcclxuXHRcdHJldHVybiBpdGVtSW5kZXggKyAnXycgKyBrZXk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZW1vdmUoY2FsbGJhY2tJZCkge1xyXG5cdFx0dmFyIHBhcnRzID0gY2FsbGJhY2tJZC5zcGxpdCgnXycpO1xyXG5cdFx0aWYgKHBhcnRzLmxlbmd0aCAhPT0gMikge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGluZGV4ID0gcGFydHNbMF07XHJcblx0XHR2YXIga2V5ID0gcGFydHNbMV07XHJcblx0XHRcclxuXHRcdHZhciBjYWxsYmFja0FycmF5ID0gY2FsbGJhY2tzW2tleV07XHJcblx0XHRpZiAoIWNhbGxiYWNrQXJyYXkgfHwgY2FsbGJhY2tBcnJheS5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRlbGV0ZSBjYWxsYmFja0FycmF5W2luZGV4XTtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZXhlY3V0ZShrZXksIGFyZ3VtZW50c0Fycikge1xyXG5cdFx0dmFyIGNhbGxiYWNrc0ZvcktleSA9IGNhbGxiYWNrc1trZXldO1xyXG5cdFx0aWYgKCFjYWxsYmFja3NGb3JLZXkgfHwgY2FsbGJhY2tzRm9yS2V5Lmxlbmd0aCA9PT0gMCl7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYXJncyA9IFtdLnNwbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblxyXG5cdFx0Y2FsbGJhY2tzRm9yS2V5LmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcblx0XHRcdGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHRhZGQ6IGFkZCxcclxuXHRcdHJlbW92ZTogcmVtb3ZlLFxyXG5cdFx0ZXhlY3V0ZTogZXhlY3V0ZVxyXG5cdH07XHJcbn07XHJcbiIsIi8qKlxuICogY3VpZC5qc1xuICogQ29sbGlzaW9uLXJlc2lzdGFudCBVSUQgZ2VuZXJhdG9yIGZvciBicm93c2VycyBhbmQgbm9kZS5cbiAqIFNlcXVlbnRpYWwgZm9yIGZhc3QgZGIgbG9va3VwcyBhbmQgcmVjZW5jeSBzb3J0aW5nLlxuICogU2FmZSBmb3IgZWxlbWVudCBJRHMgYW5kIHNlcnZlci1zaWRlIGxvb2t1cHMuXG4gKlxuICogRXh0cmFjdGVkIGZyb20gQ0xDVFJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEVyaWMgRWxsaW90dCAyMDEyXG4gKiBNSVQgTGljZW5zZVxuICovXG5cbi8qZ2xvYmFsIHdpbmRvdywgbmF2aWdhdG9yLCBkb2N1bWVudCwgcmVxdWlyZSwgcHJvY2VzcywgbW9kdWxlICovXG4oZnVuY3Rpb24gKGFwcCkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBuYW1lc3BhY2UgPSAnY3VpZCcsXG4gICAgYyA9IDAsXG4gICAgYmxvY2tTaXplID0gNCxcbiAgICBiYXNlID0gMzYsXG4gICAgZGlzY3JldGVWYWx1ZXMgPSBNYXRoLnBvdyhiYXNlLCBibG9ja1NpemUpLFxuXG4gICAgcGFkID0gZnVuY3Rpb24gcGFkKG51bSwgc2l6ZSkge1xuICAgICAgdmFyIHMgPSBcIjAwMDAwMDAwMFwiICsgbnVtO1xuICAgICAgcmV0dXJuIHMuc3Vic3RyKHMubGVuZ3RoLXNpemUpO1xuICAgIH0sXG5cbiAgICByYW5kb21CbG9jayA9IGZ1bmN0aW9uIHJhbmRvbUJsb2NrKCkge1xuICAgICAgcmV0dXJuIHBhZCgoTWF0aC5yYW5kb20oKSAqXG4gICAgICAgICAgICBkaXNjcmV0ZVZhbHVlcyA8PCAwKVxuICAgICAgICAgICAgLnRvU3RyaW5nKGJhc2UpLCBibG9ja1NpemUpO1xuICAgIH0sXG5cbiAgICBzYWZlQ291bnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGMgPSAoYyA8IGRpc2NyZXRlVmFsdWVzKSA/IGMgOiAwO1xuICAgICAgYysrOyAvLyB0aGlzIGlzIG5vdCBzdWJsaW1pbmFsXG4gICAgICByZXR1cm4gYyAtIDE7XG4gICAgfSxcblxuICAgIGFwaSA9IGZ1bmN0aW9uIGN1aWQoKSB7XG4gICAgICAvLyBTdGFydGluZyB3aXRoIGEgbG93ZXJjYXNlIGxldHRlciBtYWtlc1xuICAgICAgLy8gaXQgSFRNTCBlbGVtZW50IElEIGZyaWVuZGx5LlxuICAgICAgdmFyIGxldHRlciA9ICdjJywgLy8gaGFyZC1jb2RlZCBhbGxvd3MgZm9yIHNlcXVlbnRpYWwgYWNjZXNzXG5cbiAgICAgICAgLy8gdGltZXN0YW1wXG4gICAgICAgIC8vIHdhcm5pbmc6IHRoaXMgZXhwb3NlcyB0aGUgZXhhY3QgZGF0ZSBhbmQgdGltZVxuICAgICAgICAvLyB0aGF0IHRoZSB1aWQgd2FzIGNyZWF0ZWQuXG4gICAgICAgIHRpbWVzdGFtcCA9IChuZXcgRGF0ZSgpLmdldFRpbWUoKSkudG9TdHJpbmcoYmFzZSksXG5cbiAgICAgICAgLy8gUHJldmVudCBzYW1lLW1hY2hpbmUgY29sbGlzaW9ucy5cbiAgICAgICAgY291bnRlcixcblxuICAgICAgICAvLyBBIGZldyBjaGFycyB0byBnZW5lcmF0ZSBkaXN0aW5jdCBpZHMgZm9yIGRpZmZlcmVudFxuICAgICAgICAvLyBjbGllbnRzIChzbyBkaWZmZXJlbnQgY29tcHV0ZXJzIGFyZSBmYXIgbGVzc1xuICAgICAgICAvLyBsaWtlbHkgdG8gZ2VuZXJhdGUgdGhlIHNhbWUgaWQpXG4gICAgICAgIGZpbmdlcnByaW50ID0gYXBpLmZpbmdlcnByaW50KCksXG5cbiAgICAgICAgLy8gR3JhYiBzb21lIG1vcmUgY2hhcnMgZnJvbSBNYXRoLnJhbmRvbSgpXG4gICAgICAgIHJhbmRvbSA9IHJhbmRvbUJsb2NrKCkgKyByYW5kb21CbG9jaygpO1xuXG4gICAgICAgIGNvdW50ZXIgPSBwYWQoc2FmZUNvdW50ZXIoKS50b1N0cmluZyhiYXNlKSwgYmxvY2tTaXplKTtcblxuICAgICAgcmV0dXJuICAobGV0dGVyICsgdGltZXN0YW1wICsgY291bnRlciArIGZpbmdlcnByaW50ICsgcmFuZG9tKTtcbiAgICB9O1xuXG4gIGFwaS5zbHVnID0gZnVuY3Rpb24gc2x1ZygpIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLnRvU3RyaW5nKDM2KSxcbiAgICAgIGNvdW50ZXIsXG4gICAgICBwcmludCA9IGFwaS5maW5nZXJwcmludCgpLnNsaWNlKDAsMSkgK1xuICAgICAgICBhcGkuZmluZ2VycHJpbnQoKS5zbGljZSgtMSksXG4gICAgICByYW5kb20gPSByYW5kb21CbG9jaygpLnNsaWNlKC0yKTtcblxuICAgICAgY291bnRlciA9IHNhZmVDb3VudGVyKCkudG9TdHJpbmcoMzYpLnNsaWNlKC00KTtcblxuICAgIHJldHVybiBkYXRlLnNsaWNlKC0yKSArXG4gICAgICBjb3VudGVyICsgcHJpbnQgKyByYW5kb207XG4gIH07XG5cbiAgYXBpLmdsb2JhbENvdW50ID0gZnVuY3Rpb24gZ2xvYmFsQ291bnQoKSB7XG4gICAgLy8gV2Ugd2FudCB0byBjYWNoZSB0aGUgcmVzdWx0cyBvZiB0aGlzXG4gICAgdmFyIGNhY2hlID0gKGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgIGNvdW50ID0gMDtcblxuICAgICAgICBmb3IgKGkgaW4gd2luZG93KSB7XG4gICAgICAgICAgY291bnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgIH0oKSk7XG5cbiAgICBhcGkuZ2xvYmFsQ291bnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWNoZTsgfTtcbiAgICByZXR1cm4gY2FjaGU7XG4gIH07XG5cbiAgYXBpLmZpbmdlcnByaW50ID0gZnVuY3Rpb24gYnJvd3NlclByaW50KCkge1xuICAgIHJldHVybiBwYWQoKG5hdmlnYXRvci5taW1lVHlwZXMubGVuZ3RoICtcbiAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQubGVuZ3RoKS50b1N0cmluZygzNikgK1xuICAgICAgYXBpLmdsb2JhbENvdW50KCkudG9TdHJpbmcoMzYpLCA0KTtcbiAgfTtcblxuICAvLyBkb24ndCBjaGFuZ2UgYW55dGhpbmcgZnJvbSBoZXJlIGRvd24uXG4gIGlmIChhcHAucmVnaXN0ZXIpIHtcbiAgICBhcHAucmVnaXN0ZXIobmFtZXNwYWNlLCBhcGkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBhcGk7XG4gIH0gZWxzZSB7XG4gICAgYXBwW25hbWVzcGFjZV0gPSBhcGk7XG4gIH1cblxufSh0aGlzLmFwcGxpdHVkZSB8fCB0aGlzKSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuXG4vLyBPbmx5IE5vZGUuSlMgaGFzIGEgcHJvY2VzcyB2YXJpYWJsZSB0aGF0IGlzIG9mIFtbQ2xhc3NdXSBwcm9jZXNzXG50cnkge1xuIG1vZHVsZS5leHBvcnRzID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nIFxufSBjYXRjaChlKSB7fVxuIiwiLyohXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cbiAqIEBsaWNlbnNlIGVzNS1zaGltIENvcHlyaWdodCAyMDA5LTIwMTUgYnkgY29udHJpYnV0b3JzLCBNSVQgTGljZW5zZVxuICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKi9cblxuLy8gdmltOiB0cz00IHN0cz00IHN3PTQgZXhwYW5kdGFiXG5cbi8vIEFkZCBzZW1pY29sb24gdG8gcHJldmVudCBJSUZFIGZyb20gYmVpbmcgcGFzc2VkIGFzIGFyZ3VtZW50IHRvIGNvbmNhdGVuYXRlZCBjb2RlLlxuO1xuXG4vLyBVTUQgKFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbilcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdW1kanMvdW1kL2Jsb2IvbWFzdGVyL3RlbXBsYXRlcy9yZXR1cm5FeHBvcnRzLmpzXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKiBnbG9iYWwgZGVmaW5lLCBleHBvcnRzLCBtb2R1bGUgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgICAvLyBsaWtlIE5vZGUuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgICAgIHJvb3QucmV0dXJuRXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBjYWxsID0gRnVuY3Rpb24uY2FsbDtcbiAgICB2YXIgcHJvdG90eXBlT2ZPYmplY3QgPSBPYmplY3QucHJvdG90eXBlO1xuICAgIHZhciBvd25zID0gY2FsbC5iaW5kKHByb3RvdHlwZU9mT2JqZWN0Lmhhc093blByb3BlcnR5KTtcbiAgICB2YXIgaXNFbnVtZXJhYmxlID0gY2FsbC5iaW5kKHByb3RvdHlwZU9mT2JqZWN0LnByb3BlcnR5SXNFbnVtZXJhYmxlKTtcbiAgICB2YXIgdG9TdHIgPSBjYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QudG9TdHJpbmcpO1xuXG4gICAgLy8gSWYgSlMgZW5naW5lIHN1cHBvcnRzIGFjY2Vzc29ycyBjcmVhdGluZyBzaG9ydGN1dHMuXG4gICAgdmFyIGRlZmluZUdldHRlcjtcbiAgICB2YXIgZGVmaW5lU2V0dGVyO1xuICAgIHZhciBsb29rdXBHZXR0ZXI7XG4gICAgdmFyIGxvb2t1cFNldHRlcjtcbiAgICB2YXIgc3VwcG9ydHNBY2Nlc3NvcnMgPSBvd25zKHByb3RvdHlwZU9mT2JqZWN0LCAnX19kZWZpbmVHZXR0ZXJfXycpO1xuICAgIGlmIChzdXBwb3J0c0FjY2Vzc29ycykge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xuICAgICAgICBkZWZpbmVHZXR0ZXIgPSBjYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QuX19kZWZpbmVHZXR0ZXJfXyk7XG4gICAgICAgIGRlZmluZVNldHRlciA9IGNhbGwuYmluZChwcm90b3R5cGVPZk9iamVjdC5fX2RlZmluZVNldHRlcl9fKTtcbiAgICAgICAgbG9va3VwR2V0dGVyID0gY2FsbC5iaW5kKHByb3RvdHlwZU9mT2JqZWN0Ll9fbG9va3VwR2V0dGVyX18pO1xuICAgICAgICBsb29rdXBTZXR0ZXIgPSBjYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QuX19sb29rdXBTZXR0ZXJfXyk7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUgKi9cbiAgICB9XG5cbiAgICB2YXIgaXNQcmltaXRpdmUgPSBmdW5jdGlvbiBpc1ByaW1pdGl2ZShvKSB7XG4gICAgICAgIHJldHVybiBvID09IG51bGwgfHwgKHR5cGVvZiBvICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgbyAhPT0gJ2Z1bmN0aW9uJyk7XG4gICAgfTtcblxuICAgIC8vIEVTNSAxNS4yLjMuMlxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy4yXG4gICAgaWYgKCFPYmplY3QuZ2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3VlcyNpc3N1ZS8yXG4gICAgICAgIC8vIGh0dHA6Ly9lam9obi5vcmcvYmxvZy9vYmplY3RnZXRwcm90b3R5cGVvZi9cbiAgICAgICAgLy8gcmVjb21tZW5kZWQgYnkgZnNjaGFlZmVyIG9uIGdpdGh1YlxuICAgICAgICAvL1xuICAgICAgICAvLyBzdXJlLCBhbmQgd2VicmVmbGVjdGlvbiBzYXlzIF5fXlxuICAgICAgICAvLyAuLi4gdGhpcyB3aWxsIG5lcmV2ZXIgcG9zc2libHkgcmV0dXJuIG51bGxcbiAgICAgICAgLy8gLi4uIE9wZXJhIE1pbmkgYnJlYWtzIGhlcmUgd2l0aCBpbmZpbml0ZSBsb29wc1xuICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YgPSBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihvYmplY3QpIHtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gICAgICAgICAgICB2YXIgcHJvdG8gPSBvYmplY3QuX19wcm90b19fO1xuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xuICAgICAgICAgICAgaWYgKHByb3RvIHx8IHByb3RvID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b1N0cihvYmplY3QuY29uc3RydWN0b3IpID09PSAnW29iamVjdCBGdW5jdGlvbl0nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm90b3R5cGVPZk9iamVjdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ29ycmVjdGx5IHJldHVybiBudWxsIGZvciBPYmplY3RzIGNyZWF0ZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZShudWxsKWBcbiAgICAgICAgICAgICAgICAvLyAoc2hhbW1lZCBvciBuYXRpdmUpIG9yIGB7IF9fcHJvdG9fXzogbnVsbH1gLiAgQWxzbyByZXR1cm5zIG51bGwgZm9yXG4gICAgICAgICAgICAgICAgLy8gY3Jvc3MtcmVhbG0gb2JqZWN0cyBvbiBicm93c2VycyB0aGF0IGxhY2sgYF9fcHJvdG9fX2Agc3VwcG9ydCAobGlrZVxuICAgICAgICAgICAgICAgIC8vIElFIDwxMSksIGJ1dCB0aGF0J3MgdGhlIGJlc3Qgd2UgY2FuIGRvLlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEVTNSAxNS4yLjMuM1xuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy4zXG5cbiAgICB2YXIgZG9lc0dldE93blByb3BlcnR5RGVzY3JpcHRvcldvcmsgPSBmdW5jdGlvbiBkb2VzR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yV29yayhvYmplY3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9iamVjdC5zZW50aW5lbCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsICdzZW50aW5lbCcpLnZhbHVlID09PSAwO1xuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBjaGVjayB3aGV0aGVyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciB3b3JrcyBpZiBpdCdzIGdpdmVuLiBPdGhlcndpc2UsIHNoaW0gcGFydGlhbGx5LlxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcldvcmtzT25PYmplY3QgPSBkb2VzR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yV29yayh7fSk7XG4gICAgICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JXb3Jrc09uRG9tID0gdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICBkb2VzR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yV29yayhkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgICAgIGlmICghZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yV29ya3NPbkRvbSB8fCAhZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yV29ya3NPbk9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvckZhbGxiYWNrID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciB8fCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JGYWxsYmFjaykge1xuICAgICAgICB2YXIgRVJSX05PTl9PQkpFQ1QgPSAnT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciBjYWxsZWQgb24gYSBub24tb2JqZWN0OiAnO1xuXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgaWYgKGlzUHJpbWl0aXZlKG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUl9OT05fT0JKRUNUICsgb2JqZWN0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbWFrZSBhIHZhbGlhbnQgYXR0ZW1wdCB0byB1c2UgdGhlIHJlYWwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG4gICAgICAgICAgICAvLyBmb3IgSTgncyBET00gZWxlbWVudHMuXG4gICAgICAgICAgICBpZiAoZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yRmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yRmFsbGJhY2suY2FsbChPYmplY3QsIG9iamVjdCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdGhlIHNoaW0gaWYgdGhlIHJlYWwgb25lIGRvZXNuJ3Qgd29ya1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3I7XG5cbiAgICAgICAgICAgIC8vIElmIG9iamVjdCBkb2VzIG5vdCBvd25zIHByb3BlcnR5IHJldHVybiB1bmRlZmluZWQgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICBpZiAoIW93bnMob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgb2JqZWN0IGhhcyBhIHByb3BlcnR5IHRoZW4gaXQncyBmb3Igc3VyZSBgY29uZmlndXJhYmxlYCwgYW5kXG4gICAgICAgICAgICAvLyBwcm9iYWJseSBgZW51bWVyYWJsZWAuIERldGVjdCBlbnVtZXJhYmlsaXR5IHRob3VnaC5cbiAgICAgICAgICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogaXNFbnVtZXJhYmxlKG9iamVjdCwgcHJvcGVydHkpLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gSWYgSlMgZW5naW5lIHN1cHBvcnRzIGFjY2Vzc29yIHByb3BlcnRpZXMgdGhlbiBwcm9wZXJ0eSBtYXkgYmUgYVxuICAgICAgICAgICAgLy8gZ2V0dGVyIG9yIHNldHRlci5cbiAgICAgICAgICAgIGlmIChzdXBwb3J0c0FjY2Vzc29ycykge1xuICAgICAgICAgICAgICAgIC8vIFVuZm9ydHVuYXRlbHkgYF9fbG9va3VwR2V0dGVyX19gIHdpbGwgcmV0dXJuIGEgZ2V0dGVyIGV2ZW5cbiAgICAgICAgICAgICAgICAvLyBpZiBvYmplY3QgaGFzIG93biBub24gZ2V0dGVyIHByb3BlcnR5IGFsb25nIHdpdGggYSBzYW1lIG5hbWVkXG4gICAgICAgICAgICAgICAgLy8gaW5oZXJpdGVkIGdldHRlci4gVG8gYXZvaWQgbWlzYmVoYXZpb3Igd2UgdGVtcG9yYXJ5IHJlbW92ZVxuICAgICAgICAgICAgICAgIC8vIGBfX3Byb3RvX19gIHNvIHRoYXQgYF9fbG9va3VwR2V0dGVyX19gIHdpbGwgcmV0dXJuIGdldHRlciBvbmx5XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQncyBvd25lZCBieSBhbiBvYmplY3QuXG4gICAgICAgICAgICAgICAgdmFyIHByb3RvdHlwZSA9IG9iamVjdC5fX3Byb3RvX187XG4gICAgICAgICAgICAgICAgdmFyIG5vdFByb3RvdHlwZU9mT2JqZWN0ID0gb2JqZWN0ICE9PSBwcm90b3R5cGVPZk9iamVjdDtcbiAgICAgICAgICAgICAgICAvLyBhdm9pZCByZWN1cnNpb24gcHJvYmxlbSwgYnJlYWtpbmcgaW4gT3BlcmEgTWluaSB3aGVuXG4gICAgICAgICAgICAgICAgLy8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnKVxuICAgICAgICAgICAgICAgIC8vIG9yIGFueSBvdGhlciBPYmplY3QucHJvdG90eXBlIGFjY2Vzc29yXG4gICAgICAgICAgICAgICAgaWYgKG5vdFByb3RvdHlwZU9mT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGVPZk9iamVjdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZ2V0dGVyID0gbG9va3VwR2V0dGVyKG9iamVjdCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgICAgIHZhciBzZXR0ZXIgPSBsb29rdXBTZXR0ZXIob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobm90UHJvdG90eXBlT2ZPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25jZSB3ZSBoYXZlIGdldHRlciBhbmQgc2V0dGVyIHdlIGNhbiBwdXQgdmFsdWVzIGJhY2suXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGdldHRlciB8fCBzZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdldHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvci5nZXQgPSBnZXR0ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvci5zZXQgPSBzZXR0ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgd2FzIGFjY2Vzc29yIHByb3BlcnR5IHdlJ3JlIGRvbmUgYW5kIHJldHVybiBoZXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIG9yZGVyIHRvIGF2b2lkIGFkZGluZyBgdmFsdWVgIHRvIHRoZSBkZXNjcmlwdG9yLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHdlIGdvdCB0aGlzIGZhciB3ZSBrbm93IHRoYXQgb2JqZWN0IGhhcyBhbiBvd24gcHJvcGVydHkgdGhhdCBpc1xuICAgICAgICAgICAgLy8gbm90IGFuIGFjY2Vzc29yIHNvIHdlIHNldCBpdCBhcyBhIHZhbHVlIGFuZCByZXR1cm4gZGVzY3JpcHRvci5cbiAgICAgICAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgICAgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICAgICAgfTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xuICAgIH1cblxuICAgIC8vIEVTNSAxNS4yLjMuNFxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy40XG4gICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcykge1xuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBFUzUgMTUuMi4zLjVcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4yLjMuNVxuICAgIGlmICghT2JqZWN0LmNyZWF0ZSkge1xuXG4gICAgICAgIC8vIENvbnRyaWJ1dGVkIGJ5IEJyYW5kb24gQmVudmllLCBPY3RvYmVyLCAyMDEyXG4gICAgICAgIHZhciBjcmVhdGVFbXB0eTtcbiAgICAgICAgdmFyIHN1cHBvcnRzUHJvdG8gPSAhKHsgX19wcm90b19fOiBudWxsIH0gaW5zdGFuY2VvZiBPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgcHJvZHVjZXMgZmFsc2UgcG9zaXRpdmVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gT3BlcmEgTWluaSA9PiBub3QgYSByZWxpYWJsZSBjaGVja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9iamVjdC5wcm90b3R5cGUuX19wcm90b19fID09PSBudWxsXG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGRvY3VtZW50LmRvbWFpbiBhbmQgYWN0aXZlIHggc3VwcG9ydFxuICAgICAgICAvLyBObyBuZWVkIHRvIHVzZSBhY3RpdmUgeCBhcHByb2FjaCB3aGVuIGRvY3VtZW50LmRvbWFpbiBpcyBub3Qgc2V0XG4gICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxuICAgICAgICAvLyB2YXJpYXRpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2tpdGNhbWJyaWRnZS9lczUtc2hpbS9jb21taXQvNGY3MzhhYzA2NjM0NlxuICAgICAgICAvKiBnbG9iYWwgQWN0aXZlWE9iamVjdCAqL1xuICAgICAgICB2YXIgc2hvdWxkVXNlQWN0aXZlWCA9IGZ1bmN0aW9uIHNob3VsZFVzZUFjdGl2ZVgoKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gZWFybHkgaWYgZG9jdW1lbnQuZG9tYWluIG5vdCBzZXRcbiAgICAgICAgICAgIGlmICghZG9jdW1lbnQuZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIW5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRoaXMgc3VwcG9ydHMgSUU4IHdoZW4gZG9jdW1lbnQuZG9tYWluIGlzIHVzZWRcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMTUwXG4gICAgICAgIC8vIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2l0Y2FtYnJpZGdlL2VzNS1zaGltL2NvbW1pdC80ZjczOGFjMDY2MzQ2XG4gICAgICAgIHZhciBnZXRFbXB0eVZpYUFjdGl2ZVggPSBmdW5jdGlvbiBnZXRFbXB0eVZpYUFjdGl2ZVgoKSB7XG4gICAgICAgICAgICB2YXIgZW1wdHk7XG4gICAgICAgICAgICB2YXIgeERvYztcblxuICAgICAgICAgICAgeERvYyA9IG5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gJ3NjcmlwdCc7XG4gICAgICAgICAgICB4RG9jLndyaXRlKCc8JyArIHNjcmlwdCArICc+PC8nICsgc2NyaXB0ICsgJz4nKTtcbiAgICAgICAgICAgIHhEb2MuY2xvc2UoKTtcblxuICAgICAgICAgICAgZW1wdHkgPSB4RG9jLnBhcmVudFdpbmRvdy5PYmplY3QucHJvdG90eXBlO1xuICAgICAgICAgICAgeERvYyA9IG51bGw7XG5cbiAgICAgICAgICAgIHJldHVybiBlbXB0eTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUaGUgb3JpZ2luYWwgaW1wbGVtZW50YXRpb24gdXNpbmcgYW4gaWZyYW1lXG4gICAgICAgIC8vIGJlZm9yZSB0aGUgYWN0aXZleCBhcHByb2FjaCB3YXMgYWRkZWRcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMTUwXG4gICAgICAgIHZhciBnZXRFbXB0eVZpYUlGcmFtZSA9IGZ1bmN0aW9uIGdldEVtcHR5VmlhSUZyYW1lKCkge1xuICAgICAgICAgICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgdmFyIGVtcHR5O1xuXG4gICAgICAgICAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2NyaXB0LXVybCAqL1xuICAgICAgICAgICAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNjcmlwdC11cmwgKi9cblxuICAgICAgICAgICAgZW1wdHkgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3QucHJvdG90eXBlO1xuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICAgICAgICBpZnJhbWUgPSBudWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyogZ2xvYmFsIGRvY3VtZW50ICovXG4gICAgICAgIGlmIChzdXBwb3J0c1Byb3RvIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNyZWF0ZUVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IF9fcHJvdG9fXzogbnVsbCB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEluIG9sZCBJRSBfX3Byb3RvX18gY2FuJ3QgYmUgdXNlZCB0byBtYW51YWxseSBzZXQgYG51bGxgLCBub3IgZG9lc1xuICAgICAgICAgICAgLy8gYW55IG90aGVyIG1ldGhvZCBleGlzdCB0byBtYWtlIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gbm90aGluZyxcbiAgICAgICAgICAgIC8vIGFzaWRlIGZyb20gT2JqZWN0LnByb3RvdHlwZSBpdHNlbGYuIEluc3RlYWQsIGNyZWF0ZSBhIG5ldyBnbG9iYWxcbiAgICAgICAgICAgIC8vIG9iamVjdCBhbmQgKnN0ZWFsKiBpdHMgT2JqZWN0LnByb3RvdHlwZSBhbmQgc3RyaXAgaXQgYmFyZS4gVGhpcyBpc1xuICAgICAgICAgICAgLy8gdXNlZCBhcyB0aGUgcHJvdG90eXBlIHRvIGNyZWF0ZSBudWxsYXJ5IG9iamVjdHMuXG4gICAgICAgICAgICBjcmVhdGVFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggYXBwcm9hY2ggdG8gdXNlXG4gICAgICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMTUwXG4gICAgICAgICAgICAgICAgdmFyIGVtcHR5ID0gc2hvdWxkVXNlQWN0aXZlWCgpID8gZ2V0RW1wdHlWaWFBY3RpdmVYKCkgOiBnZXRFbXB0eVZpYUlGcmFtZSgpO1xuXG4gICAgICAgICAgICAgICAgZGVsZXRlIGVtcHR5LmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbXB0eS5oYXNPd25Qcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICBkZWxldGUgZW1wdHkucHJvcGVydHlJc0VudW1lcmFibGU7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVtcHR5LmlzUHJvdG90eXBlT2Y7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVtcHR5LnRvTG9jYWxlU3RyaW5nO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbXB0eS50b1N0cmluZztcbiAgICAgICAgICAgICAgICBkZWxldGUgZW1wdHkudmFsdWVPZjtcblxuICAgICAgICAgICAgICAgIHZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge307XG4gICAgICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gZW1wdHk7XG4gICAgICAgICAgICAgICAgLy8gc2hvcnQtY2lyY3VpdCBmdXR1cmUgY2FsbHNcbiAgICAgICAgICAgICAgICBjcmVhdGVFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG5cbiAgICAgICAgICAgIHZhciBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgVHlwZSA9IGZ1bmN0aW9uIFR5cGUoKSB7fTsgLy8gQW4gZW1wdHkgY29uc3RydWN0b3IuXG5cbiAgICAgICAgICAgIGlmIChwcm90b3R5cGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBjcmVhdGVFbXB0eSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvdG90eXBlICE9PSBudWxsICYmIGlzUHJpbWl0aXZlKHByb3RvdHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBgcGFyZW50YCBjYW4gYmUgYG51bGxgXG4gICAgICAgICAgICAgICAgICAgIC8vIE9SICphbnkqIGBpbnN0YW5jZW9mIE9iamVjdGAgIChPYmplY3R8RnVuY3Rpb258QXJyYXl8UmVnRXhwfGV0YylcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGB0eXBlb2ZgIHRobywgYi9jIGluIG9sZCBJRSwgRE9NIGVsZW1lbnRzIGFyZSBub3QgYGluc3RhbmNlb2YgT2JqZWN0YFxuICAgICAgICAgICAgICAgICAgICAvLyBsaWtlIHRoZXkgYXJlIGluIG1vZGVybiBicm93c2Vycy4gVXNpbmcgYE9iamVjdC5jcmVhdGVgIG9uIERPTSBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICAvLyBpcy4uLmVyci4uLnByb2JhYmx5IGluYXBwcm9wcmlhdGUsIGJ1dCB0aGUgbmF0aXZlIHZlcnNpb24gYWxsb3dzIGZvciBpdC5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0IHByb3RvdHlwZSBtYXkgb25seSBiZSBhbiBPYmplY3Qgb3IgbnVsbCcpOyAvLyBzYW1lIG1zZyBhcyBDaHJvbWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgVHlwZS5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFR5cGUoKTtcbiAgICAgICAgICAgICAgICAvLyBJRSBoYXMgbm8gYnVpbHQtaW4gaW1wbGVtZW50YXRpb24gb2YgYE9iamVjdC5nZXRQcm90b3R5cGVPZmBcbiAgICAgICAgICAgICAgICAvLyBuZWl0aGVyIGBfX3Byb3RvX19gLCBidXQgdGhpcyBtYW51YWxseSBzZXR0aW5nIGBfX3Byb3RvX19gIHdpbGxcbiAgICAgICAgICAgICAgICAvLyBndWFyYW50ZWUgdGhhdCBgT2JqZWN0LmdldFByb3RvdHlwZU9mYCB3aWxsIHdvcmsgYXMgZXhwZWN0ZWQgd2l0aFxuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgY3JlYXRlZCB1c2luZyBgT2JqZWN0LmNyZWF0ZWBcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICAgICAgICAgICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqZWN0LCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBFUzUgMTUuMi4zLjZcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4yLjMuNlxuXG4gICAgLy8gUGF0Y2ggZm9yIFdlYktpdCBhbmQgSUU4IHN0YW5kYXJkIG1vZGVcbiAgICAvLyBEZXNpZ25lZCBieSBoYXggPGhheC5naXRodWIuY29tPlxuICAgIC8vIHJlbGF0ZWQgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMjaXNzdWUvNVxuICAgIC8vIElFOCBSZWZlcmVuY2U6XG4gICAgLy8gICAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kZDI4MjkwMC5hc3B4XG4gICAgLy8gICAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kZDIyOTkxNi5hc3B4XG4gICAgLy8gV2ViS2l0IEJ1Z3M6XG4gICAgLy8gICAgIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0zNjQyM1xuXG4gICAgdmFyIGRvZXNEZWZpbmVQcm9wZXJ0eVdvcmsgPSBmdW5jdGlvbiBkb2VzRGVmaW5lUHJvcGVydHlXb3JrKG9iamVjdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ3NlbnRpbmVsJywge30pO1xuICAgICAgICAgICAgcmV0dXJuICdzZW50aW5lbCcgaW4gb2JqZWN0O1xuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBjaGVjayB3aGV0aGVyIGRlZmluZVByb3BlcnR5IHdvcmtzIGlmIGl0J3MgZ2l2ZW4uIE90aGVyd2lzZSxcbiAgICAvLyBzaGltIHBhcnRpYWxseS5cbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIHZhciBkZWZpbmVQcm9wZXJ0eVdvcmtzT25PYmplY3QgPSBkb2VzRGVmaW5lUHJvcGVydHlXb3JrKHt9KTtcbiAgICAgICAgdmFyIGRlZmluZVByb3BlcnR5V29ya3NPbkRvbSA9IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgICAgIGRvZXNEZWZpbmVQcm9wZXJ0eVdvcmsoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xuICAgICAgICBpZiAoIWRlZmluZVByb3BlcnR5V29ya3NPbk9iamVjdCB8fCAhZGVmaW5lUHJvcGVydHlXb3Jrc09uRG9tKSB7XG4gICAgICAgICAgICB2YXIgZGVmaW5lUHJvcGVydHlGYWxsYmFjayA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzRmFsbGJhY2sgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGRlZmluZVByb3BlcnR5RmFsbGJhY2spIHtcbiAgICAgICAgdmFyIEVSUl9OT05fT0JKRUNUX0RFU0NSSVBUT1IgPSAnUHJvcGVydHkgZGVzY3JpcHRpb24gbXVzdCBiZSBhbiBvYmplY3Q6ICc7XG4gICAgICAgIHZhciBFUlJfTk9OX09CSkVDVF9UQVJHRVQgPSAnT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxlZCBvbiBub24tb2JqZWN0OiAnO1xuICAgICAgICB2YXIgRVJSX0FDQ0VTU09SU19OT1RfU1VQUE9SVEVEID0gJ2dldHRlcnMgJiBzZXR0ZXJzIGNhbiBub3QgYmUgZGVmaW5lZCBvbiB0aGlzIGphdmFzY3JpcHQgZW5naW5lJztcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmltaXRpdmUob2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJSX05PTl9PQkpFQ1RfVEFSR0VUICsgb2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1ByaW1pdGl2ZShkZXNjcmlwdG9yKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJSX05PTl9PQkpFQ1RfREVTQ1JJUFRPUiArIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbWFrZSBhIHZhbGlhbnQgYXR0ZW1wdCB0byB1c2UgdGhlIHJlYWwgZGVmaW5lUHJvcGVydHlcbiAgICAgICAgICAgIC8vIGZvciBJOCdzIERPTSBlbGVtZW50cy5cbiAgICAgICAgICAgIGlmIChkZWZpbmVQcm9wZXJ0eUZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5RmFsbGJhY2suY2FsbChPYmplY3QsIG9iamVjdCwgcHJvcGVydHksIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdGhlIHNoaW0gaWYgdGhlIHJlYWwgb25lIGRvZXNuJ3Qgd29ya1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgaXQncyBhIGRhdGEgcHJvcGVydHkuXG4gICAgICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICAgICAgLy8gZmFpbCBzaWxlbnRseSBpZiAnd3JpdGFibGUnLCAnZW51bWVyYWJsZScsIG9yICdjb25maWd1cmFibGUnXG4gICAgICAgICAgICAgICAgLy8gYXJlIHJlcXVlc3RlZCBidXQgbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgLy8gYWx0ZXJuYXRlIGFwcHJvYWNoOlxuICAgICAgICAgICAgICAgIGlmICggLy8gY2FuJ3QgaW1wbGVtZW50IHRoZXNlIGZlYXR1cmVzOyBhbGxvdyBmYWxzZSBidXQgbm90IHRydWVcbiAgICAgICAgICAgICAgICAgICAgKCd3cml0YWJsZScgaW4gZGVzY3JpcHRvciAmJiAhZGVzY3JpcHRvci53cml0YWJsZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKCdlbnVtZXJhYmxlJyBpbiBkZXNjcmlwdG9yICYmICFkZXNjcmlwdG9yLmVudW1lcmFibGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICgnY29uZmlndXJhYmxlJyBpbiBkZXNjcmlwdG9yICYmICFkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSlcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICdUaGlzIGltcGxlbWVudGF0aW9uIG9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBkb2VzIG5vdCBzdXBwb3J0IGNvbmZpZ3VyYWJsZSwgZW51bWVyYWJsZSwgb3Igd3JpdGFibGUuJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydHNBY2Nlc3NvcnMgJiYgKGxvb2t1cEdldHRlcihvYmplY3QsIHByb3BlcnR5KSB8fCBsb29rdXBTZXR0ZXIob2JqZWN0LCBwcm9wZXJ0eSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFzIGFjY2Vzc29ycyBhcmUgc3VwcG9ydGVkIG9ubHkgb24gZW5naW5lcyBpbXBsZW1lbnRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gYF9fcHJvdG9fX2Agd2UgY2FuIHNhZmVseSBvdmVycmlkZSBgX19wcm90b19fYCB3aGlsZSBkZWZpbmluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBhIHByb3BlcnR5IHRvIG1ha2Ugc3VyZSB0aGF0IHdlIGRvbid0IGhpdCBhbiBpbmhlcml0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gYWNjZXNzb3IuXG4gICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm90b3R5cGUgPSBvYmplY3QuX19wcm90b19fO1xuICAgICAgICAgICAgICAgICAgICBvYmplY3QuX19wcm90b19fID0gcHJvdG90eXBlT2ZPYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlbGV0aW5nIGEgcHJvcGVydHkgYW55d2F5IHNpbmNlIGdldHRlciAvIHNldHRlciBtYXkgYmVcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVmaW5lZCBvbiBvYmplY3QgaXRzZWxmLlxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0W3Byb3BlcnR5XSA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldHRpbmcgb3JpZ2luYWwgYF9fcHJvdG9fX2AgYmFjayBub3cuXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RbcHJvcGVydHldID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBoYXNHZXR0ZXIgPSAnZ2V0JyBpbiBkZXNjcmlwdG9yO1xuICAgICAgICAgICAgICAgIHZhciBoYXNTZXR0ZXIgPSAnc2V0JyBpbiBkZXNjcmlwdG9yO1xuICAgICAgICAgICAgICAgIGlmICghc3VwcG9ydHNBY2Nlc3NvcnMgJiYgKGhhc0dldHRlciB8fCBoYXNTZXR0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGdvdCB0aGF0IGZhciB0aGVuIGdldHRlcnMgYW5kIHNldHRlcnMgY2FuIGJlIGRlZmluZWQgISFcbiAgICAgICAgICAgICAgICBpZiAoaGFzR2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZUdldHRlcihvYmplY3QsIHByb3BlcnR5LCBkZXNjcmlwdG9yLmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXNTZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lU2V0dGVyKG9iamVjdCwgcHJvcGVydHksIGRlc2NyaXB0b3Iuc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEVTNSAxNS4yLjMuN1xuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy43XG4gICAgaWYgKCFPYmplY3QuZGVmaW5lUHJvcGVydGllcyB8fCBkZWZpbmVQcm9wZXJ0aWVzRmFsbGJhY2spIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKG9iamVjdCwgcHJvcGVydGllcykge1xuICAgICAgICAgICAgLy8gbWFrZSBhIHZhbGlhbnQgYXR0ZW1wdCB0byB1c2UgdGhlIHJlYWwgZGVmaW5lUHJvcGVydGllc1xuICAgICAgICAgICAgaWYgKGRlZmluZVByb3BlcnRpZXNGYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0aWVzRmFsbGJhY2suY2FsbChPYmplY3QsIG9iamVjdCwgcHJvcGVydGllcyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0aGUgc2hpbSBpZiB0aGUgcmVhbCBvbmUgZG9lc24ndCB3b3JrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eSAhPT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIHByb3BlcnRpZXNbcHJvcGVydHldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRVM1IDE1LjIuMy44XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjhcbiAgICBpZiAoIU9iamVjdC5zZWFsKSB7XG4gICAgICAgIE9iamVjdC5zZWFsID0gZnVuY3Rpb24gc2VhbChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qob2JqZWN0KSAhPT0gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LnNlYWwgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIE9iamVjdHMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG1pc2xlYWRpbmcgYW5kIGJyZWFrcyBmZWF0dXJlLWRldGVjdGlvbiwgYnV0XG4gICAgICAgICAgICAvLyBhbGxvd3MgXCJzZWN1cmFibGVcIiBjb2RlIHRvIFwiZ3JhY2VmdWxseVwiIGRlZ3JhZGUgdG8gd29ya2luZ1xuICAgICAgICAgICAgLy8gYnV0IGluc2VjdXJlIGNvZGUuXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEVTNSAxNS4yLjMuOVxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy45XG4gICAgaWYgKCFPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUgPSBmdW5jdGlvbiBmcmVlemUob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KG9iamVjdCkgIT09IG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5mcmVlemUgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIE9iamVjdHMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG1pc2xlYWRpbmcgYW5kIGJyZWFrcyBmZWF0dXJlLWRldGVjdGlvbiwgYnV0XG4gICAgICAgICAgICAvLyBhbGxvd3MgXCJzZWN1cmFibGVcIiBjb2RlIHRvIFwiZ3JhY2VmdWxseVwiIGRlZ3JhZGUgdG8gd29ya2luZ1xuICAgICAgICAgICAgLy8gYnV0IGluc2VjdXJlIGNvZGUuXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGRldGVjdCBhIFJoaW5vIGJ1ZyBhbmQgcGF0Y2ggaXRcbiAgICB0cnkge1xuICAgICAgICBPYmplY3QuZnJlZXplKGZ1bmN0aW9uICgpIHt9KTtcbiAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSA9IChmdW5jdGlvbiAoZnJlZXplT2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gZnJlZXplKG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyZWV6ZU9iamVjdChvYmplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0oT2JqZWN0LmZyZWV6ZSkpO1xuICAgIH1cblxuICAgIC8vIEVTNSAxNS4yLjMuMTBcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4yLjMuMTBcbiAgICBpZiAoIU9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucykge1xuICAgICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnMgPSBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyhvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qob2JqZWN0KSAhPT0gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBPYmplY3RzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhpcyBpcyBtaXNsZWFkaW5nIGFuZCBicmVha3MgZmVhdHVyZS1kZXRlY3Rpb24sIGJ1dFxuICAgICAgICAgICAgLy8gYWxsb3dzIFwic2VjdXJhYmxlXCIgY29kZSB0byBcImdyYWNlZnVsbHlcIiBkZWdyYWRlIHRvIHdvcmtpbmdcbiAgICAgICAgICAgIC8vIGJ1dCBpbnNlY3VyZSBjb2RlLlxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBFUzUgMTUuMi4zLjExXG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjExXG4gICAgaWYgKCFPYmplY3QuaXNTZWFsZWQpIHtcbiAgICAgICAgT2JqZWN0LmlzU2VhbGVkID0gZnVuY3Rpb24gaXNTZWFsZWQob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KG9iamVjdCkgIT09IG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5pc1NlYWxlZCBjYW4gb25seSBiZSBjYWxsZWQgb24gT2JqZWN0cy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBFUzUgMTUuMi4zLjEyXG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjEyXG4gICAgaWYgKCFPYmplY3QuaXNGcm96ZW4pIHtcbiAgICAgICAgT2JqZWN0LmlzRnJvemVuID0gZnVuY3Rpb24gaXNGcm96ZW4ob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KG9iamVjdCkgIT09IG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5pc0Zyb3plbiBjYW4gb25seSBiZSBjYWxsZWQgb24gT2JqZWN0cy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBFUzUgMTUuMi4zLjEzXG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjEzXG4gICAgaWYgKCFPYmplY3QuaXNFeHRlbnNpYmxlKSB7XG4gICAgICAgIE9iamVjdC5pc0V4dGVuc2libGUgPSBmdW5jdGlvbiBpc0V4dGVuc2libGUob2JqZWN0KSB7XG4gICAgICAgICAgICAvLyAxLiBJZiBUeXBlKE8pIGlzIG5vdCBPYmplY3QgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgICAgICAgICAgaWYgKE9iamVjdChvYmplY3QpICE9PSBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuaXNFeHRlbnNpYmxlIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBPYmplY3RzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMi4gUmV0dXJuIHRoZSBCb29sZWFuIHZhbHVlIG9mIHRoZSBbW0V4dGVuc2libGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBPLlxuICAgICAgICAgICAgdmFyIG5hbWUgPSAnJztcbiAgICAgICAgICAgIHdoaWxlIChvd25zKG9iamVjdCwgbmFtZSkpIHtcbiAgICAgICAgICAgICAgICBuYW1lICs9ICc/JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iamVjdFtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBvd25zKG9iamVjdCwgbmFtZSk7XG4gICAgICAgICAgICBkZWxldGUgb2JqZWN0W25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cblxufSkpO1xuIiwiLyohXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cbiAqIEBsaWNlbnNlIGVzNS1zaGltIENvcHlyaWdodCAyMDA5LTIwMTUgYnkgY29udHJpYnV0b3JzLCBNSVQgTGljZW5zZVxuICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKi9cblxuLy8gdmltOiB0cz00IHN0cz00IHN3PTQgZXhwYW5kdGFiXG5cbi8vIEFkZCBzZW1pY29sb24gdG8gcHJldmVudCBJSUZFIGZyb20gYmVpbmcgcGFzc2VkIGFzIGFyZ3VtZW50IHRvIGNvbmNhdGVuYXRlZCBjb2RlLlxuO1xuXG4vLyBVTUQgKFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbilcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdW1kanMvdW1kL2Jsb2IvbWFzdGVyL3RlbXBsYXRlcy9yZXR1cm5FeHBvcnRzLmpzXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKiBnbG9iYWwgZGVmaW5lLCBleHBvcnRzLCBtb2R1bGUgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgICAvLyBsaWtlIE5vZGUuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgICAgIHJvb3QucmV0dXJuRXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBCcmluZ3MgYW4gZW52aXJvbm1lbnQgYXMgY2xvc2UgdG8gRUNNQVNjcmlwdCA1IGNvbXBsaWFuY2VcbiAgICAgKiBhcyBpcyBwb3NzaWJsZSB3aXRoIHRoZSBmYWNpbGl0aWVzIG9mIGVyc3R3aGlsZSBlbmdpbmVzLlxuICAgICAqXG4gICAgICogQW5ub3RhdGVkIEVTNTogaHR0cDovL2VzNS5naXRodWIuY29tLyAoc3BlY2lmaWMgbGlua3MgYmVsb3cpXG4gICAgICogRVM1IFNwZWM6IGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9wdWJsaWNhdGlvbnMvZmlsZXMvRUNNQS1TVC9FY21hLTI2Mi5wZGZcbiAgICAgKiBSZXF1aXJlZCByZWFkaW5nOiBodHRwOi8vamF2YXNjcmlwdHdlYmxvZy53b3JkcHJlc3MuY29tLzIwMTEvMTIvMDUvZXh0ZW5kaW5nLWphdmFzY3JpcHQtbmF0aXZlcy9cbiAgICAgKi9cblxuICAgIC8vIFNob3J0Y3V0IHRvIGFuIG9mdGVuIGFjY2Vzc2VkIHByb3BlcnRpZXMsIGluIG9yZGVyIHRvIGF2b2lkIG11bHRpcGxlXG4gICAgLy8gZGVyZWZlcmVuY2UgdGhhdCBjb3N0cyB1bml2ZXJzYWxseS4gVGhpcyBhbHNvIGhvbGRzIGEgcmVmZXJlbmNlIHRvIGtub3duLWdvb2RcbiAgICAvLyBmdW5jdGlvbnMuXG4gICAgdmFyICRBcnJheSA9IEFycmF5O1xuICAgIHZhciBBcnJheVByb3RvdHlwZSA9ICRBcnJheS5wcm90b3R5cGU7XG4gICAgdmFyICRPYmplY3QgPSBPYmplY3Q7XG4gICAgdmFyIE9iamVjdFByb3RvdHlwZSA9ICRPYmplY3QucHJvdG90eXBlO1xuICAgIHZhciAkRnVuY3Rpb24gPSBGdW5jdGlvbjtcbiAgICB2YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSAkRnVuY3Rpb24ucHJvdG90eXBlO1xuICAgIHZhciAkU3RyaW5nID0gU3RyaW5nO1xuICAgIHZhciBTdHJpbmdQcm90b3R5cGUgPSAkU3RyaW5nLnByb3RvdHlwZTtcbiAgICB2YXIgJE51bWJlciA9IE51bWJlcjtcbiAgICB2YXIgTnVtYmVyUHJvdG90eXBlID0gJE51bWJlci5wcm90b3R5cGU7XG4gICAgdmFyIGFycmF5X3NsaWNlID0gQXJyYXlQcm90b3R5cGUuc2xpY2U7XG4gICAgdmFyIGFycmF5X3NwbGljZSA9IEFycmF5UHJvdG90eXBlLnNwbGljZTtcbiAgICB2YXIgYXJyYXlfcHVzaCA9IEFycmF5UHJvdG90eXBlLnB1c2g7XG4gICAgdmFyIGFycmF5X3Vuc2hpZnQgPSBBcnJheVByb3RvdHlwZS51bnNoaWZ0O1xuICAgIHZhciBhcnJheV9jb25jYXQgPSBBcnJheVByb3RvdHlwZS5jb25jYXQ7XG4gICAgdmFyIGFycmF5X2pvaW4gPSBBcnJheVByb3RvdHlwZS5qb2luO1xuICAgIHZhciBjYWxsID0gRnVuY3Rpb25Qcm90b3R5cGUuY2FsbDtcbiAgICB2YXIgYXBwbHkgPSBGdW5jdGlvblByb3RvdHlwZS5hcHBseTtcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXg7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluO1xuXG4gICAgLy8gSGF2aW5nIGEgdG9TdHJpbmcgbG9jYWwgdmFyaWFibGUgbmFtZSBicmVha3MgaW4gT3BlcmEgc28gdXNlIHRvX3N0cmluZy5cbiAgICB2YXIgdG9fc3RyaW5nID0gT2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gICAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG9uZS12YXItZGVjbGFyYXRpb24tcGVyLWxpbmUsIG5vLXJlZGVjbGFyZSwgbWF4LXN0YXRlbWVudHMtcGVyLWxpbmUgKi9cbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xuICAgIHZhciBpc0NhbGxhYmxlOyAvKiBpbmxpbmVkIGZyb20gaHR0cHM6Ly9ucG1qcy5jb20vaXMtY2FsbGFibGUgKi8gdmFyIGZuVG9TdHIgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcsIGNvbnN0cnVjdG9yUmVnZXggPSAvXlxccypjbGFzcyAvLCBpc0VTNkNsYXNzRm4gPSBmdW5jdGlvbiBpc0VTNkNsYXNzRm4odmFsdWUpIHsgdHJ5IHsgdmFyIGZuU3RyID0gZm5Ub1N0ci5jYWxsKHZhbHVlKTsgdmFyIHNpbmdsZVN0cmlwcGVkID0gZm5TdHIucmVwbGFjZSgvXFwvXFwvLipcXG4vZywgJycpOyB2YXIgbXVsdGlTdHJpcHBlZCA9IHNpbmdsZVN0cmlwcGVkLnJlcGxhY2UoL1xcL1xcKlsuXFxzXFxTXSpcXCpcXC8vZywgJycpOyB2YXIgc3BhY2VTdHJpcHBlZCA9IG11bHRpU3RyaXBwZWQucmVwbGFjZSgvXFxuL21nLCAnICcpLnJlcGxhY2UoLyB7Mn0vZywgJyAnKTsgcmV0dXJuIGNvbnN0cnVjdG9yUmVnZXgudGVzdChzcGFjZVN0cmlwcGVkKTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IC8qIG5vdCBhIGZ1bmN0aW9uICovIH0gfSwgdHJ5RnVuY3Rpb25PYmplY3QgPSBmdW5jdGlvbiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSkgeyB0cnkgeyBpZiAoaXNFUzZDbGFzc0ZuKHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH0gZm5Ub1N0ci5jYWxsKHZhbHVlKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH0sIGZuQ2xhc3MgPSAnW29iamVjdCBGdW5jdGlvbl0nLCBnZW5DbGFzcyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsIGlzQ2FsbGFibGUgPSBmdW5jdGlvbiBpc0NhbGxhYmxlKHZhbHVlKSB7IGlmICghdmFsdWUpIHsgcmV0dXJuIGZhbHNlOyB9IGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH0gaWYgKGhhc1RvU3RyaW5nVGFnKSB7IHJldHVybiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSk7IH0gaWYgKGlzRVM2Q2xhc3NGbih2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9IHZhciBzdHJDbGFzcyA9IHRvX3N0cmluZy5jYWxsKHZhbHVlKTsgcmV0dXJuIHN0ckNsYXNzID09PSBmbkNsYXNzIHx8IHN0ckNsYXNzID09PSBnZW5DbGFzczsgfTtcblxuICAgIHZhciBpc1JlZ2V4OyAvKiBpbmxpbmVkIGZyb20gaHR0cHM6Ly9ucG1qcy5jb20vaXMtcmVnZXggKi8gdmFyIHJlZ2V4RXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYywgdHJ5UmVnZXhFeGVjID0gZnVuY3Rpb24gdHJ5UmVnZXhFeGVjKHZhbHVlKSB7IHRyeSB7IHJlZ2V4RXhlYy5jYWxsKHZhbHVlKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH0sIHJlZ2V4Q2xhc3MgPSAnW29iamVjdCBSZWdFeHBdJzsgaXNSZWdleCA9IGZ1bmN0aW9uIGlzUmVnZXgodmFsdWUpIHsgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9IHJldHVybiBoYXNUb1N0cmluZ1RhZyA/IHRyeVJlZ2V4RXhlYyh2YWx1ZSkgOiB0b19zdHJpbmcuY2FsbCh2YWx1ZSkgPT09IHJlZ2V4Q2xhc3M7IH07XG4gICAgdmFyIGlzU3RyaW5nOyAvKiBpbmxpbmVkIGZyb20gaHR0cHM6Ly9ucG1qcy5jb20vaXMtc3RyaW5nICovIHZhciBzdHJWYWx1ZSA9IFN0cmluZy5wcm90b3R5cGUudmFsdWVPZiwgdHJ5U3RyaW5nT2JqZWN0ID0gZnVuY3Rpb24gdHJ5U3RyaW5nT2JqZWN0KHZhbHVlKSB7IHRyeSB7IHN0clZhbHVlLmNhbGwodmFsdWUpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfSwgc3RyaW5nQ2xhc3MgPSAnW29iamVjdCBTdHJpbmddJzsgaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkgeyBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgeyByZXR1cm4gdHJ1ZTsgfSBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH0gcmV0dXJuIGhhc1RvU3RyaW5nVGFnID8gdHJ5U3RyaW5nT2JqZWN0KHZhbHVlKSA6IHRvX3N0cmluZy5jYWxsKHZhbHVlKSA9PT0gc3RyaW5nQ2xhc3M7IH07XG4gICAgLyogZXNsaW50LWVuYWJsZSBvbmUtdmFyLWRlY2xhcmF0aW9uLXBlci1saW5lLCBuby1yZWRlY2xhcmUsIG1heC1zdGF0ZW1lbnRzLXBlci1saW5lICovXG5cbiAgICAvKiBpbmxpbmVkIGZyb20gaHR0cDovL25wbWpzLmNvbS9kZWZpbmUtcHJvcGVydGllcyAqL1xuICAgIHZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gJE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiAoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICAgICAgJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosICd4JywgeyBlbnVtZXJhYmxlOiBmYWxzZSwgdmFsdWU6IG9iaiB9KTtcbiAgICAgICAgICAgIGZvciAodmFyIF8gaW4gb2JqKSB7IC8vIGpzY3M6aWdub3JlIGRpc2FsbG93VW51c2VkVmFyaWFibGVzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iai54ID09PSBvYmo7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgLyogdGhpcyBpcyBFUzMgKi9cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0oKSk7XG4gICAgdmFyIGRlZmluZVByb3BlcnRpZXMgPSAoZnVuY3Rpb24gKGhhcykge1xuICAgICAgICAvLyBEZWZpbmUgY29uZmlndXJhYmxlLCB3cml0YWJsZSwgYW5kIG5vbi1lbnVtZXJhYmxlIHByb3BzXG4gICAgICAgIC8vIGlmIHRoZXkgZG9uJ3QgZXhpc3QuXG4gICAgICAgIHZhciBkZWZpbmVQcm9wZXJ0eTtcbiAgICAgICAgaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgbWV0aG9kLCBmb3JjZUFzc2lnbikge1xuICAgICAgICAgICAgICAgIGlmICghZm9yY2VBc3NpZ24gJiYgKG5hbWUgaW4gb2JqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWV0aG9kXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqZWN0W25hbWVdID0gbWV0aG9kO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhvYmplY3QsIG1hcCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gbWFwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhcy5jYWxsKG1hcCwgbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCBtYXBbbmFtZV0sIGZvcmNlQXNzaWduKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfShPYmplY3RQcm90b3R5cGUuaGFzT3duUHJvcGVydHkpKTtcblxuICAgIC8vXG4gICAgLy8gVXRpbFxuICAgIC8vID09PT09PVxuICAgIC8vXG5cbiAgICAvKiByZXBsYWNlYWJsZSB3aXRoIGh0dHBzOi8vbnBtanMuY29tL3BhY2thZ2UvZXMtYWJzdHJhY3QgL2hlbHBlcnMvaXNQcmltaXRpdmUgKi9cbiAgICB2YXIgaXNQcmltaXRpdmUgPSBmdW5jdGlvbiBpc1ByaW1pdGl2ZShpbnB1dCkge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiBpbnB1dDtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09PSBudWxsIHx8ICh0eXBlICE9PSAnb2JqZWN0JyAmJiB0eXBlICE9PSAnZnVuY3Rpb24nKTtcbiAgICB9O1xuXG4gICAgdmFyIGlzQWN0dWFsTmFOID0gJE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBpc0FjdHVhbE5hTih4KSB7XG4gICAgICAgIHJldHVybiB4ICE9PSB4O1xuICAgIH07XG5cbiAgICB2YXIgRVMgPSB7XG4gICAgICAgIC8vIEVTNSA5LjRcbiAgICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4OS40XG4gICAgICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL3RvLWludGVnZXJcbiAgICAgICAgLyogcmVwbGFjZWFibGUgd2l0aCBodHRwczovL25wbWpzLmNvbS9wYWNrYWdlL2VzLWFic3RyYWN0IEVTNS5Ub0ludGVnZXIgKi9cbiAgICAgICAgVG9JbnRlZ2VyOiBmdW5jdGlvbiBUb0ludGVnZXIobnVtKSB7XG4gICAgICAgICAgICB2YXIgbiA9ICtudW07XG4gICAgICAgICAgICBpZiAoaXNBY3R1YWxOYU4obikpIHtcbiAgICAgICAgICAgICAgICBuID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobiAhPT0gMCAmJiBuICE9PSAoMSAvIDApICYmIG4gIT09IC0oMSAvIDApKSB7XG4gICAgICAgICAgICAgICAgbiA9IChuID4gMCB8fCAtMSkgKiBNYXRoLmZsb29yKE1hdGguYWJzKG4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qIHJlcGxhY2VhYmxlIHdpdGggaHR0cHM6Ly9ucG1qcy5jb20vcGFja2FnZS9lcy1hYnN0cmFjdCBFUzUuVG9QcmltaXRpdmUgKi9cbiAgICAgICAgVG9QcmltaXRpdmU6IGZ1bmN0aW9uIFRvUHJpbWl0aXZlKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgdmFsLCB2YWx1ZU9mLCB0b1N0cjtcbiAgICAgICAgICAgIGlmIChpc1ByaW1pdGl2ZShpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZU9mID0gaW5wdXQudmFsdWVPZjtcbiAgICAgICAgICAgIGlmIChpc0NhbGxhYmxlKHZhbHVlT2YpKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gdmFsdWVPZi5jYWxsKGlucHV0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmltaXRpdmUodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvU3RyID0gaW5wdXQudG9TdHJpbmc7XG4gICAgICAgICAgICBpZiAoaXNDYWxsYWJsZSh0b1N0cikpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSB0b1N0ci5jYWxsKGlucHV0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmltaXRpdmUodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBFUzUgOS45XG4gICAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDkuOVxuICAgICAgICAvKiByZXBsYWNlYWJsZSB3aXRoIGh0dHBzOi8vbnBtanMuY29tL3BhY2thZ2UvZXMtYWJzdHJhY3QgRVM1LlRvT2JqZWN0ICovXG4gICAgICAgIFRvT2JqZWN0OiBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgaWYgKG8gPT0gbnVsbCkgeyAvLyB0aGlzIG1hdGNoZXMgYm90aCBudWxsIGFuZCB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FuJ3QgY29udmVydCBcIiArIG8gKyAnIHRvIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRPYmplY3Qobyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyogcmVwbGFjZWFibGUgd2l0aCBodHRwczovL25wbWpzLmNvbS9wYWNrYWdlL2VzLWFic3RyYWN0IEVTNS5Ub1VpbnQzMiAqL1xuICAgICAgICBUb1VpbnQzMjogZnVuY3Rpb24gVG9VaW50MzIoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHggPj4+IDA7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9cbiAgICAvLyBGdW5jdGlvblxuICAgIC8vID09PT09PT09XG4gICAgLy9cblxuICAgIC8vIEVTLTUgMTUuMy40LjVcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4zLjQuNVxuXG4gICAgdmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkoKSB7fTtcblxuICAgIGRlZmluZVByb3BlcnRpZXMoRnVuY3Rpb25Qcm90b3R5cGUsIHtcbiAgICAgICAgYmluZDogZnVuY3Rpb24gYmluZCh0aGF0KSB7IC8vIC5sZW5ndGggaXMgMVxuICAgICAgICAgICAgLy8gMS4gTGV0IFRhcmdldCBiZSB0aGUgdGhpcyB2YWx1ZS5cbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgICAgICAgICAgLy8gMi4gSWYgSXNDYWxsYWJsZShUYXJnZXQpIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgICAgICAgICBpZiAoIWlzQ2FsbGFibGUodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJyArIHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAzLiBMZXQgQSBiZSBhIG5ldyAocG9zc2libHkgZW1wdHkpIGludGVybmFsIGxpc3Qgb2YgYWxsIG9mIHRoZVxuICAgICAgICAgICAgLy8gICBhcmd1bWVudCB2YWx1ZXMgcHJvdmlkZWQgYWZ0ZXIgdGhpc0FyZyAoYXJnMSwgYXJnMiBldGMpLCBpbiBvcmRlci5cbiAgICAgICAgICAgIC8vIFhYWCBzbGljZWRBcmdzIHdpbGwgc3RhbmQgaW4gZm9yIFwiQVwiIGlmIHVzZWRcbiAgICAgICAgICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvLyBmb3Igbm9ybWFsIGNhbGxcbiAgICAgICAgICAgIC8vIDQuIExldCBGIGJlIGEgbmV3IG5hdGl2ZSBFQ01BU2NyaXB0IG9iamVjdC5cbiAgICAgICAgICAgIC8vIDExLiBTZXQgdGhlIFtbUHJvdG90eXBlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiB0byB0aGUgc3RhbmRhcmRcbiAgICAgICAgICAgIC8vICAgYnVpbHQtaW4gRnVuY3Rpb24gcHJvdG90eXBlIG9iamVjdCBhcyBzcGVjaWZpZWQgaW4gMTUuMy4zLjEuXG4gICAgICAgICAgICAvLyAxMi4gU2V0IHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAgICAgLy8gICAxNS4zLjQuNS4xLlxuICAgICAgICAgICAgLy8gMTMuIFNldCB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAgICAgLy8gICAxNS4zLjQuNS4yLlxuICAgICAgICAgICAgLy8gMTQuIFNldCB0aGUgW1tIYXNJbnN0YW5jZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgICAgICAvLyAgIDE1LjMuNC41LjMuXG4gICAgICAgICAgICB2YXIgYm91bmQ7XG4gICAgICAgICAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyAxNS4zLjQuNS4yIFtbQ29uc3RydWN0XV1cbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2Qgb2YgYSBmdW5jdGlvbiBvYmplY3QsXG4gICAgICAgICAgICAgICAgICAgIC8vIEYgdGhhdCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgYmluZCBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhXG4gICAgICAgICAgICAgICAgICAgIC8vIGxpc3Qgb2YgYXJndW1lbnRzIEV4dHJhQXJncywgdGhlIGZvbGxvd2luZyBzdGVwcyBhcmUgdGFrZW46XG4gICAgICAgICAgICAgICAgICAgIC8vIDEuIExldCB0YXJnZXQgYmUgdGhlIHZhbHVlIG9mIEYncyBbW1RhcmdldEZ1bmN0aW9uXV1cbiAgICAgICAgICAgICAgICAgICAgLy8gICBpbnRlcm5hbCBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAgICAgLy8gMi4gSWYgdGFyZ2V0IGhhcyBubyBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZCwgYVxuICAgICAgICAgICAgICAgICAgICAvLyAgIFR5cGVFcnJvciBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgICAgICAgICAgICAgICAgICAvLyAzLiBMZXQgYm91bmRBcmdzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZEFyZ3NdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgICAgICAvLyA0LiBMZXQgYXJncyBiZSBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyAgIGxpc3QgYm91bmRBcmdzIGluIHRoZSBzYW1lIG9yZGVyIGZvbGxvd2VkIGJ5IHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgICAgIC8vICAgdmFsdWVzIGFzIHRoZSBsaXN0IEV4dHJhQXJncyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICAgICAgICAgICAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgICAgICAvLyAgIG1ldGhvZCBvZiB0YXJnZXQgcHJvdmlkaW5nIGFyZ3MgYXMgdGhlIGFyZ3VtZW50cy5cblxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gYXBwbHkuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheV9jb25jYXQuY2FsbChhcmdzLCBhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDE1LjMuNC41LjEgW1tDYWxsXV1cbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kIG9mIGEgZnVuY3Rpb24gb2JqZWN0LCBGLFxuICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgYmluZCBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgdmFsdWUgYW5kIGEgbGlzdCBvZiBhcmd1bWVudHMgRXh0cmFBcmdzLCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0ZXBzIGFyZSB0YWtlbjpcbiAgICAgICAgICAgICAgICAgICAgLy8gMS4gTGV0IGJvdW5kQXJncyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRBcmdzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAgICAgLy8gMi4gTGV0IGJvdW5kVGhpcyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRUaGlzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAgICAgLy8gMy4gTGV0IHRhcmdldCBiZSB0aGUgdmFsdWUgb2YgRidzIFtbVGFyZ2V0RnVuY3Rpb25dXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgICAgICAvLyA0LiBMZXQgYXJncyBiZSBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyAgIGxpc3QgYm91bmRBcmdzIGluIHRoZSBzYW1lIG9yZGVyIGZvbGxvd2VkIGJ5IHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgICAgIC8vICAgdmFsdWVzIGFzIHRoZSBsaXN0IEV4dHJhQXJncyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICAgICAgICAgICAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgIC8vICAgb2YgdGFyZ2V0IHByb3ZpZGluZyBib3VuZFRoaXMgYXMgdGhlIHRoaXMgdmFsdWUgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vICAgcHJvdmlkaW5nIGFyZ3MgYXMgdGhlIGFyZ3VtZW50cy5cblxuICAgICAgICAgICAgICAgICAgICAvLyBlcXVpdjogdGFyZ2V0LmNhbGwodGhpcywgLi4uYm91bmRBcmdzLCAuLi5hcmdzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHkuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheV9jb25jYXQuY2FsbChhcmdzLCBhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIDE1LiBJZiB0aGUgW1tDbGFzc11dIGludGVybmFsIHByb3BlcnR5IG9mIFRhcmdldCBpcyBcIkZ1bmN0aW9uXCIsIHRoZW5cbiAgICAgICAgICAgIC8vICAgICBhLiBMZXQgTCBiZSB0aGUgbGVuZ3RoIHByb3BlcnR5IG9mIFRhcmdldCBtaW51cyB0aGUgbGVuZ3RoIG9mIEEuXG4gICAgICAgICAgICAvLyAgICAgYi4gU2V0IHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gZWl0aGVyIDAgb3IgTCwgd2hpY2hldmVyIGlzXG4gICAgICAgICAgICAvLyAgICAgICBsYXJnZXIuXG4gICAgICAgICAgICAvLyAxNi4gRWxzZSBzZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byAwLlxuXG4gICAgICAgICAgICB2YXIgYm91bmRMZW5ndGggPSBtYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcblxuICAgICAgICAgICAgLy8gMTcuIFNldCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIHRoZSB2YWx1ZXNcbiAgICAgICAgICAgIC8vICAgc3BlY2lmaWVkIGluIDE1LjMuNS4xLlxuICAgICAgICAgICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlfcHVzaC5jYWxsKGJvdW5kQXJncywgJyQnICsgaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFhYWCBCdWlsZCBhIGR5bmFtaWMgZnVuY3Rpb24gd2l0aCBkZXNpcmVkIGFtb3VudCBvZiBhcmd1bWVudHMgaXMgdGhlIG9ubHlcbiAgICAgICAgICAgIC8vIHdheSB0byBzZXQgdGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiBhIGZ1bmN0aW9uLlxuICAgICAgICAgICAgLy8gSW4gZW52aXJvbm1lbnRzIHdoZXJlIENvbnRlbnQgU2VjdXJpdHkgUG9saWNpZXMgZW5hYmxlZCAoQ2hyb21lIGV4dGVuc2lvbnMsXG4gICAgICAgICAgICAvLyBmb3IgZXguKSBhbGwgdXNlIG9mIGV2YWwgb3IgRnVuY3Rpb24gY29zdHJ1Y3RvciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgICAgICAgICAgLy8gSG93ZXZlciBpbiBhbGwgb2YgdGhlc2UgZW52aXJvbm1lbnRzIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGV4aXN0c1xuICAgICAgICAgICAgLy8gYW5kIHNvIHRoaXMgY29kZSB3aWxsIG5ldmVyIGJlIGV4ZWN1dGVkLlxuICAgICAgICAgICAgYm91bmQgPSAkRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBhcnJheV9qb2luLmNhbGwoYm91bmRBcmdzLCAnLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCBkYW5nbGluZyByZWZlcmVuY2VzLlxuICAgICAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgIC8vIDE4LiBTZXQgdGhlIFtbRXh0ZW5zaWJsZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgdG8gdHJ1ZS5cblxuICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgLy8gMTkuIExldCB0aHJvd2VyIGJlIHRoZSBbW1Rocm93VHlwZUVycm9yXV0gZnVuY3Rpb24gT2JqZWN0ICgxMy4yLjMpLlxuICAgICAgICAgICAgLy8gMjAuIENhbGwgdGhlIFtbRGVmaW5lT3duUHJvcGVydHldXSBpbnRlcm5hbCBtZXRob2Qgb2YgRiB3aXRoXG4gICAgICAgICAgICAvLyAgIGFyZ3VtZW50cyBcImNhbGxlclwiLCBQcm9wZXJ0eURlc2NyaXB0b3Ige1tbR2V0XV06IHRocm93ZXIsIFtbU2V0XV06XG4gICAgICAgICAgICAvLyAgIHRocm93ZXIsIFtbRW51bWVyYWJsZV1dOiBmYWxzZSwgW1tDb25maWd1cmFibGVdXTogZmFsc2V9LCBhbmRcbiAgICAgICAgICAgIC8vICAgZmFsc2UuXG4gICAgICAgICAgICAvLyAyMS4gQ2FsbCB0aGUgW1tEZWZpbmVPd25Qcm9wZXJ0eV1dIGludGVybmFsIG1ldGhvZCBvZiBGIHdpdGhcbiAgICAgICAgICAgIC8vICAgYXJndW1lbnRzIFwiYXJndW1lbnRzXCIsIFByb3BlcnR5RGVzY3JpcHRvciB7W1tHZXRdXTogdGhyb3dlcixcbiAgICAgICAgICAgIC8vICAgW1tTZXRdXTogdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sXG4gICAgICAgICAgICAvLyAgIGFuZCBmYWxzZS5cblxuICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgLy8gTk9URSBGdW5jdGlvbiBvYmplY3RzIGNyZWF0ZWQgdXNpbmcgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgZG8gbm90XG4gICAgICAgICAgICAvLyBoYXZlIGEgcHJvdG90eXBlIHByb3BlcnR5IG9yIHRoZSBbW0NvZGVdXSwgW1tGb3JtYWxQYXJhbWV0ZXJzXV0sIGFuZFxuICAgICAgICAgICAgLy8gW1tTY29wZV1dIGludGVybmFsIHByb3BlcnRpZXMuXG4gICAgICAgICAgICAvLyBYWFggY2FuJ3QgZGVsZXRlIHByb3RvdHlwZSBpbiBwdXJlLWpzLlxuXG4gICAgICAgICAgICAvLyAyMi4gUmV0dXJuIEYuXG4gICAgICAgICAgICByZXR1cm4gYm91bmQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIF9QbGVhc2Ugbm90ZTogU2hvcnRjdXRzIGFyZSBkZWZpbmVkIGFmdGVyIGBGdW5jdGlvbi5wcm90b3R5cGUuYmluZGAgYXMgd2VcbiAgICAvLyB1c2UgaXQgaW4gZGVmaW5pbmcgc2hvcnRjdXRzLlxuICAgIHZhciBvd25zID0gY2FsbC5iaW5kKE9iamVjdFByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4gICAgdmFyIHRvU3RyID0gY2FsbC5iaW5kKE9iamVjdFByb3RvdHlwZS50b1N0cmluZyk7XG4gICAgdmFyIGFycmF5U2xpY2UgPSBjYWxsLmJpbmQoYXJyYXlfc2xpY2UpO1xuICAgIHZhciBhcnJheVNsaWNlQXBwbHkgPSBhcHBseS5iaW5kKGFycmF5X3NsaWNlKTtcbiAgICB2YXIgc3RyU2xpY2UgPSBjYWxsLmJpbmQoU3RyaW5nUHJvdG90eXBlLnNsaWNlKTtcbiAgICB2YXIgc3RyU3BsaXQgPSBjYWxsLmJpbmQoU3RyaW5nUHJvdG90eXBlLnNwbGl0KTtcbiAgICB2YXIgc3RySW5kZXhPZiA9IGNhbGwuYmluZChTdHJpbmdQcm90b3R5cGUuaW5kZXhPZik7XG4gICAgdmFyIHB1c2hDYWxsID0gY2FsbC5iaW5kKGFycmF5X3B1c2gpO1xuICAgIHZhciBpc0VudW0gPSBjYWxsLmJpbmQoT2JqZWN0UHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlKTtcbiAgICB2YXIgYXJyYXlTb3J0ID0gY2FsbC5iaW5kKEFycmF5UHJvdG90eXBlLnNvcnQpO1xuXG4gICAgLy9cbiAgICAvLyBBcnJheVxuICAgIC8vID09PT09XG4gICAgLy9cblxuICAgIHZhciBpc0FycmF5ID0gJEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcblxuICAgIC8vIEVTNSAxNS40LjQuMTJcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTNcbiAgICAvLyBSZXR1cm4gbGVuK2FyZ0NvdW50LlxuICAgIC8vIFtidWdmaXgsIGllbHQ4XVxuICAgIC8vIElFIDwgOCBidWc6IFtdLnVuc2hpZnQoMCkgPT09IHVuZGVmaW5lZCBidXQgc2hvdWxkIGJlIFwiMVwiXG4gICAgdmFyIGhhc1Vuc2hpZnRSZXR1cm5WYWx1ZUJ1ZyA9IFtdLnVuc2hpZnQoMCkgIT09IDE7XG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICB1bnNoaWZ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhcnJheV91bnNoaWZ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9LCBoYXNVbnNoaWZ0UmV0dXJuVmFsdWVCdWcpO1xuXG4gICAgLy8gRVM1IDE1LjQuMy4yXG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC4zLjJcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5XG4gICAgZGVmaW5lUHJvcGVydGllcygkQXJyYXksIHsgaXNBcnJheTogaXNBcnJheSB9KTtcblxuICAgIC8vIFRoZSBJc0NhbGxhYmxlKCkgY2hlY2sgaW4gdGhlIEFycmF5IGZ1bmN0aW9uc1xuICAgIC8vIGhhcyBiZWVuIHJlcGxhY2VkIHdpdGggYSBzdHJpY3QgY2hlY2sgb24gdGhlXG4gICAgLy8gaW50ZXJuYWwgY2xhc3Mgb2YgdGhlIG9iamVjdCB0byB0cmFwIGNhc2VzIHdoZXJlXG4gICAgLy8gdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIHdhcyBhY3R1YWxseSBhIHJlZ3VsYXJcbiAgICAvLyBleHByZXNzaW9uIGxpdGVyYWwsIHdoaWNoIGluIFY4IGFuZFxuICAgIC8vIEphdmFTY3JpcHRDb3JlIGlzIGEgdHlwZW9mIFwiZnVuY3Rpb25cIi4gIE9ubHkgaW5cbiAgICAvLyBWOCBhcmUgcmVndWxhciBleHByZXNzaW9uIGxpdGVyYWxzIHBlcm1pdHRlZCBhc1xuICAgIC8vIHJlZHVjZSBwYXJhbWV0ZXJzLCBzbyBpdCBpcyBkZXNpcmFibGUgaW4gdGhlXG4gICAgLy8gZ2VuZXJhbCBjYXNlIGZvciB0aGUgc2hpbSB0byBtYXRjaCB0aGUgbW9yZVxuICAgIC8vIHN0cmljdCBhbmQgY29tbW9uIGJlaGF2aW9yIG9mIHJlamVjdGluZyByZWd1bGFyXG4gICAgLy8gZXhwcmVzc2lvbnMuXG5cbiAgICAvLyBFUzUgMTUuNC40LjE4XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE4XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvYXJyYXkvZm9yRWFjaFxuXG4gICAgLy8gQ2hlY2sgZmFpbHVyZSBvZiBieS1pbmRleCBhY2Nlc3Mgb2Ygc3RyaW5nIGNoYXJhY3RlcnMgKElFIDwgOSlcbiAgICAvLyBhbmQgZmFpbHVyZSBvZiBgMCBpbiBib3hlZFN0cmluZ2AgKFJoaW5vKVxuICAgIHZhciBib3hlZFN0cmluZyA9ICRPYmplY3QoJ2EnKTtcbiAgICB2YXIgc3BsaXRTdHJpbmcgPSBib3hlZFN0cmluZ1swXSAhPT0gJ2EnIHx8ICEoMCBpbiBib3hlZFN0cmluZyk7XG5cbiAgICB2YXIgcHJvcGVybHlCb3hlc0NvbnRleHQgPSBmdW5jdGlvbiBwcm9wZXJseUJveGVkKG1ldGhvZCkge1xuICAgICAgICAvLyBDaGVjayBub2RlIDAuNi4yMSBidWcgd2hlcmUgdGhpcmQgcGFyYW1ldGVyIGlzIG5vdCBib3hlZFxuICAgICAgICB2YXIgcHJvcGVybHlCb3hlc05vblN0cmljdCA9IHRydWU7XG4gICAgICAgIHZhciBwcm9wZXJseUJveGVzU3RyaWN0ID0gdHJ1ZTtcbiAgICAgICAgdmFyIHRocmV3RXhjZXB0aW9uID0gZmFsc2U7XG4gICAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLmNhbGwoJ2ZvbycsIGZ1bmN0aW9uIChfLCBfXywgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJseUJveGVzTm9uU3RyaWN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIG1ldGhvZC5jYWxsKFsxXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICAgICAgICAgICAgcHJvcGVybHlCb3hlc1N0cmljdCA9IHR5cGVvZiB0aGlzID09PSAnc3RyaW5nJztcbiAgICAgICAgICAgICAgICB9LCAneCcpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocmV3RXhjZXB0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISFtZXRob2QgJiYgIXRocmV3RXhjZXB0aW9uICYmIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgJiYgcHJvcGVybHlCb3hlc1N0cmljdDtcbiAgICB9O1xuXG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4vKiwgdGhpc0FyZyovKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogb2JqZWN0O1xuICAgICAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBFUy5Ub1VpbnQzMihzZWxmLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgVDtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIFQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAoIWlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZm9yRWFjaCBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKCsraSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW52b2tlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGNhbGwsIHBhc3NpbmcgYXJndW1lbnRzOlxuICAgICAgICAgICAgICAgICAgICAvLyBjb250ZXh0LCBwcm9wZXJ0eSB2YWx1ZSwgcHJvcGVydHkga2V5LCB0aGlzQXJnIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIFQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja2ZuKHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja2ZuLmNhbGwoVCwgc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sICFwcm9wZXJseUJveGVzQ29udGV4dChBcnJheVByb3RvdHlwZS5mb3JFYWNoKSk7XG5cbiAgICAvLyBFUzUgMTUuNC40LjE5XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE5XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vQ29yZV9KYXZhU2NyaXB0XzEuNV9SZWZlcmVuY2UvT2JqZWN0cy9BcnJheS9tYXBcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4vKiwgdGhpc0FyZyovKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogb2JqZWN0O1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAkQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBUO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgVCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgICAgIGlmICghaXNDYWxsYWJsZShjYWxsYmFja2ZuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5tYXAgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgVCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IGNhbGxiYWNrZm4oc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IGNhbGxiYWNrZm4uY2FsbChULCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH0sICFwcm9wZXJseUJveGVzQ29udGV4dChBcnJheVByb3RvdHlwZS5tYXApKTtcblxuICAgIC8vIEVTNSAxNS40LjQuMjBcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMjBcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZS9PYmplY3RzL0FycmF5L2ZpbHRlclxuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbi8qLCB0aGlzQXJnKi8pIHtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgdmFyIFQ7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBUID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGNhbGxiYWNrZm4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLmZpbHRlciBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzZWxmW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIFQgPT09ICd1bmRlZmluZWQnID8gY2FsbGJhY2tmbih2YWx1ZSwgaSwgb2JqZWN0KSA6IGNhbGxiYWNrZm4uY2FsbChULCB2YWx1ZSwgaSwgb2JqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaENhbGwocmVzdWx0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLmZpbHRlcikpO1xuXG4gICAgLy8gRVM1IDE1LjQuNC4xNlxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xNlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2V2ZXJ5XG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICBldmVyeTogZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmbi8qLCB0aGlzQXJnKi8pIHtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIFQ7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBUID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGNhbGxiYWNrZm4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLmV2ZXJ5IGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiAhKHR5cGVvZiBUID09PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrZm4oc2VsZltpXSwgaSwgb2JqZWN0KSA6IGNhbGxiYWNrZm4uY2FsbChULCBzZWxmW2ldLCBpLCBvYmplY3QpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUuZXZlcnkpKTtcblxuICAgIC8vIEVTNSAxNS40LjQuMTdcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTdcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb21lXG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4vKiwgdGhpc0FyZyAqLykge1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IG9iamVjdDtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBFUy5Ub1VpbnQzMihzZWxmLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgVDtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIFQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAoIWlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuc29tZSBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHNlbGYgJiYgKHR5cGVvZiBUID09PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrZm4oc2VsZltpXSwgaSwgb2JqZWN0KSA6IGNhbGxiYWNrZm4uY2FsbChULCBzZWxmW2ldLCBpLCBvYmplY3QpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUuc29tZSkpO1xuXG4gICAgLy8gRVM1IDE1LjQuNC4yMVxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4yMVxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL09iamVjdHMvQXJyYXkvcmVkdWNlXG4gICAgdmFyIHJlZHVjZUNvZXJjZXNUb09iamVjdCA9IGZhbHNlO1xuICAgIGlmIChBcnJheVByb3RvdHlwZS5yZWR1Y2UpIHtcbiAgICAgICAgcmVkdWNlQ29lcmNlc1RvT2JqZWN0ID0gdHlwZW9mIEFycmF5UHJvdG90eXBlLnJlZHVjZS5jYWxsKCdlczUnLCBmdW5jdGlvbiAoXywgX18sIF9fXywgbGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgIH0pID09PSAnb2JqZWN0JztcbiAgICB9XG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuLyosIGluaXRpYWxWYWx1ZSovKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogb2JqZWN0O1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcblxuICAgICAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgICAgIGlmICghaXNDYWxsYWJsZShjYWxsYmFja2ZuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5yZWR1Y2UgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5vIHZhbHVlIHRvIHJldHVybiBpZiBubyBpbml0aWFsIHZhbHVlIGFuZCBhbiBlbXB0eSBhcnJheVxuICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBzZWxmW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGFycmF5IGNvbnRhaW5zIG5vIHZhbHVlcywgbm8gaW5pdGlhbCB2YWx1ZSB0byByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCsraSA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFja2ZuKHJlc3VsdCwgc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9LCAhcmVkdWNlQ29lcmNlc1RvT2JqZWN0KTtcblxuICAgIC8vIEVTNSAxNS40LjQuMjJcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMjJcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZS9PYmplY3RzL0FycmF5L3JlZHVjZVJpZ2h0XG4gICAgdmFyIHJlZHVjZVJpZ2h0Q29lcmNlc1RvT2JqZWN0ID0gZmFsc2U7XG4gICAgaWYgKEFycmF5UHJvdG90eXBlLnJlZHVjZVJpZ2h0KSB7XG4gICAgICAgIHJlZHVjZVJpZ2h0Q29lcmNlc1RvT2JqZWN0ID0gdHlwZW9mIEFycmF5UHJvdG90eXBlLnJlZHVjZVJpZ2h0LmNhbGwoJ2VzNScsIGZ1bmN0aW9uIChfLCBfXywgX19fLCBsaXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgfSkgPT09ICdvYmplY3QnO1xuICAgIH1cbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuLyosIGluaXRpYWwqLykge1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IG9iamVjdDtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBFUy5Ub1VpbnQzMihzZWxmLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAoIWlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5vIHZhbHVlIHRvIHJldHVybiBpZiBubyBpbml0aWFsIHZhbHVlLCBlbXB0eSBhcnJheVxuICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVkdWNlUmlnaHQgb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICB2YXIgaSA9IGxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNlbGZbaS0tXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgYXJyYXkgY29udGFpbnMgbm8gdmFsdWVzLCBubyBpbml0aWFsIHZhbHVlIHRvIHJldHVyblxuICAgICAgICAgICAgICAgICAgICBpZiAoLS1pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVkdWNlUmlnaHQgb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2tmbihyZXN1bHQsIHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoaS0tKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH0sICFyZWR1Y2VSaWdodENvZXJjZXNUb09iamVjdCk7XG5cbiAgICAvLyBFUzUgMTUuNC40LjE0XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE0XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZlxuICAgIHZhciBoYXNGaXJlZm94MkluZGV4T2ZCdWcgPSBBcnJheVByb3RvdHlwZS5pbmRleE9mICYmIFswLCAxXS5pbmRleE9mKDEsIDIpICE9PSAtMTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudC8qLCBmcm9tSW5kZXggKi8pIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBFUy5Ub1VpbnQzMihzZWxmLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGkgPSBFUy5Ub0ludGVnZXIoYXJndW1lbnRzWzFdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaGFuZGxlIG5lZ2F0aXZlIGluZGljZXNcbiAgICAgICAgICAgIGkgPSBpID49IDAgPyBpIDogbWF4KDAsIGxlbmd0aCArIGkpO1xuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHNlbGYgJiYgc2VsZltpXSA9PT0gc2VhcmNoRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9LCBoYXNGaXJlZm94MkluZGV4T2ZCdWcpO1xuXG4gICAgLy8gRVM1IDE1LjQuNC4xNVxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xNVxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2xhc3RJbmRleE9mXG4gICAgdmFyIGhhc0ZpcmVmb3gyTGFzdEluZGV4T2ZCdWcgPSBBcnJheVByb3RvdHlwZS5sYXN0SW5kZXhPZiAmJiBbMCwgMV0ubGFzdEluZGV4T2YoMCwgLTMpICE9PSAtMTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50LyosIGZyb21JbmRleCAqLykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcblxuICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpID0gbGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGkgPSBtaW4oaSwgRVMuVG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGFuZGxlIG5lZ2F0aXZlIGluZGljZXNcbiAgICAgICAgICAgIGkgPSBpID49IDAgPyBpIDogbGVuZ3RoIC0gTWF0aC5hYnMoaSk7XG4gICAgICAgICAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiBzZWxmICYmIHNlYXJjaEVsZW1lbnQgPT09IHNlbGZbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfSwgaGFzRmlyZWZveDJMYXN0SW5kZXhPZkJ1Zyk7XG5cbiAgICAvLyBFUzUgMTUuNC40LjEyXG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjEyXG4gICAgdmFyIHNwbGljZU5vb3BSZXR1cm5zRW1wdHlBcnJheSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gWzEsIDJdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gYS5zcGxpY2UoKTtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSAyICYmIGlzQXJyYXkocmVzdWx0KSAmJiByZXN1bHQubGVuZ3RoID09PSAwO1xuICAgIH0oKSk7XG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICAvLyBTYWZhcmkgNS4wIGJ1ZyB3aGVyZSAuc3BsaWNlKCkgcmV0dXJucyB1bmRlZmluZWRcbiAgICAgICAgc3BsaWNlOiBmdW5jdGlvbiBzcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50KSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5X3NwbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgIXNwbGljZU5vb3BSZXR1cm5zRW1wdHlBcnJheSk7XG5cbiAgICB2YXIgc3BsaWNlV29ya3NXaXRoRW1wdHlPYmplY3QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgIEFycmF5UHJvdG90eXBlLnNwbGljZS5jYWxsKG9iaiwgMCwgMCwgMSk7XG4gICAgICAgIHJldHVybiBvYmoubGVuZ3RoID09PSAxO1xuICAgIH0oKSk7XG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICBzcGxpY2U6IGZ1bmN0aW9uIHNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IG1heChFUy5Ub0ludGVnZXIodGhpcy5sZW5ndGgpLCAwKTtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB0eXBlb2YgZGVsZXRlQ291bnQgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgYXJncyA9IGFycmF5U2xpY2UoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2hDYWxsKGFyZ3MsIHRoaXMubGVuZ3RoIC0gc3RhcnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbMV0gPSBFUy5Ub0ludGVnZXIoZGVsZXRlQ291bnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnJheV9zcGxpY2UuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICB9LCAhc3BsaWNlV29ya3NXaXRoRW1wdHlPYmplY3QpO1xuICAgIHZhciBzcGxpY2VXb3Jrc1dpdGhMYXJnZVNwYXJzZUFycmF5cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFBlciBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzI5NVxuICAgICAgICAvLyBTYWZhcmkgNy84IGJyZWFrcyB3aXRoIHNwYXJzZSBhcnJheXMgb2Ygc2l6ZSAxZTUgb3IgZ3JlYXRlclxuICAgICAgICB2YXIgYXJyID0gbmV3ICRBcnJheSgxZTUpO1xuICAgICAgICAvLyBub3RlOiB0aGUgaW5kZXggTVVTVCBiZSA4IG9yIGxhcmdlciBvciB0aGUgdGVzdCB3aWxsIGZhbHNlIHBhc3NcbiAgICAgICAgYXJyWzhdID0gJ3gnO1xuICAgICAgICBhcnIuc3BsaWNlKDEsIDEpO1xuICAgICAgICAvLyBub3RlOiB0aGlzIHRlc3QgbXVzdCBiZSBkZWZpbmVkICphZnRlciogdGhlIGluZGV4T2Ygc2hpbVxuICAgICAgICAvLyBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8zMTNcbiAgICAgICAgcmV0dXJuIGFyci5pbmRleE9mKCd4JykgPT09IDc7XG4gICAgfSgpKTtcbiAgICB2YXIgc3BsaWNlV29ya3NXaXRoU21hbGxTcGFyc2VBcnJheXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQZXIgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8yOTVcbiAgICAgICAgLy8gT3BlcmEgMTIuMTUgYnJlYWtzIG9uIHRoaXMsIG5vIGlkZWEgd2h5LlxuICAgICAgICB2YXIgbiA9IDI1NjtcbiAgICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgICBhcnJbbl0gPSAnYSc7XG4gICAgICAgIGFyci5zcGxpY2UobiArIDEsIDAsICdiJyk7XG4gICAgICAgIHJldHVybiBhcnJbbl0gPT09ICdhJztcbiAgICB9KCkpO1xuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgc3BsaWNlOiBmdW5jdGlvbiBzcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50KSB7XG4gICAgICAgICAgICB2YXIgTyA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIEEgPSBbXTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBFUy5Ub1VpbnQzMihPLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgcmVsYXRpdmVTdGFydCA9IEVTLlRvSW50ZWdlcihzdGFydCk7XG4gICAgICAgICAgICB2YXIgYWN0dWFsU3RhcnQgPSByZWxhdGl2ZVN0YXJ0IDwgMCA/IG1heCgobGVuICsgcmVsYXRpdmVTdGFydCksIDApIDogbWluKHJlbGF0aXZlU3RhcnQsIGxlbik7XG4gICAgICAgICAgICB2YXIgYWN0dWFsRGVsZXRlQ291bnQgPSBtaW4obWF4KEVTLlRvSW50ZWdlcihkZWxldGVDb3VudCksIDApLCBsZW4gLSBhY3R1YWxTdGFydCk7XG5cbiAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgIHZhciBmcm9tO1xuICAgICAgICAgICAgd2hpbGUgKGsgPCBhY3R1YWxEZWxldGVDb3VudCkge1xuICAgICAgICAgICAgICAgIGZyb20gPSAkU3RyaW5nKGFjdHVhbFN0YXJ0ICsgayk7XG4gICAgICAgICAgICAgICAgaWYgKG93bnMoTywgZnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgQVtrXSA9IE9bZnJvbV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGsgKz0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGl0ZW1zID0gYXJyYXlTbGljZShhcmd1bWVudHMsIDIpO1xuICAgICAgICAgICAgdmFyIGl0ZW1Db3VudCA9IGl0ZW1zLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciB0bztcbiAgICAgICAgICAgIGlmIChpdGVtQ291bnQgPCBhY3R1YWxEZWxldGVDb3VudCkge1xuICAgICAgICAgICAgICAgIGsgPSBhY3R1YWxTdGFydDtcbiAgICAgICAgICAgICAgICB2YXIgbWF4SyA9IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50O1xuICAgICAgICAgICAgICAgIHdoaWxlIChrIDwgbWF4Sykge1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gJFN0cmluZyhrICsgYWN0dWFsRGVsZXRlQ291bnQpO1xuICAgICAgICAgICAgICAgICAgICB0byA9ICRTdHJpbmcoayArIGl0ZW1Db3VudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvd25zKE8sIGZyb20pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPW3RvXSA9IE9bZnJvbV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgT1t0b107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgayArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrID0gbGVuO1xuICAgICAgICAgICAgICAgIHZhciBtaW5LID0gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQgKyBpdGVtQ291bnQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGsgPiBtaW5LKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBPW2sgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgayAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbUNvdW50ID4gYWN0dWFsRGVsZXRlQ291bnQpIHtcbiAgICAgICAgICAgICAgICBrID0gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGsgPiBhY3R1YWxTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gJFN0cmluZyhrICsgYWN0dWFsRGVsZXRlQ291bnQgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgdG8gPSAkU3RyaW5nKGsgKyBpdGVtQ291bnQgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG93bnMoTywgZnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9bdG9dID0gT1tmcm9tXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBPW3RvXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBrIC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgayA9IGFjdHVhbFN0YXJ0O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIE9ba10gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgICAgICBrICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPLmxlbmd0aCA9IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50ICsgaXRlbUNvdW50O1xuXG4gICAgICAgICAgICByZXR1cm4gQTtcbiAgICAgICAgfVxuICAgIH0sICFzcGxpY2VXb3Jrc1dpdGhMYXJnZVNwYXJzZUFycmF5cyB8fCAhc3BsaWNlV29ya3NXaXRoU21hbGxTcGFyc2VBcnJheXMpO1xuXG4gICAgdmFyIG9yaWdpbmFsSm9pbiA9IEFycmF5UHJvdG90eXBlLmpvaW47XG4gICAgdmFyIGhhc1N0cmluZ0pvaW5CdWc7XG4gICAgdHJ5IHtcbiAgICAgICAgaGFzU3RyaW5nSm9pbkJ1ZyA9IEFycmF5LnByb3RvdHlwZS5qb2luLmNhbGwoJzEyMycsICcsJykgIT09ICcxLDIsMyc7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYXNTdHJpbmdKb2luQnVnID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGhhc1N0cmluZ0pvaW5CdWcpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICAgICAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VwID0gdHlwZW9mIHNlcGFyYXRvciA9PT0gJ3VuZGVmaW5lZCcgPyAnLCcgOiBzZXBhcmF0b3I7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsSm9pbi5jYWxsKGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogdGhpcywgc2VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFzU3RyaW5nSm9pbkJ1Zyk7XG4gICAgfVxuXG4gICAgdmFyIGhhc0pvaW5VbmRlZmluZWRCdWcgPSBbMSwgMl0uam9pbih1bmRlZmluZWQpICE9PSAnMSwyJztcbiAgICBpZiAoaGFzSm9pblVuZGVmaW5lZEJ1Zykge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgICAgICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIHZhciBzZXAgPSB0eXBlb2Ygc2VwYXJhdG9yID09PSAndW5kZWZpbmVkJyA/ICcsJyA6IHNlcGFyYXRvcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxKb2luLmNhbGwodGhpcywgc2VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFzSm9pblVuZGVmaW5lZEJ1Zyk7XG4gICAgfVxuXG4gICAgdmFyIHB1c2hTaGltID0gZnVuY3Rpb24gcHVzaChpdGVtKSB7XG4gICAgICAgIHZhciBPID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgIHZhciBuID0gRVMuVG9VaW50MzIoTy5sZW5ndGgpO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgT1tuICsgaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgTy5sZW5ndGggPSBuICsgaTtcbiAgICAgICAgcmV0dXJuIG4gKyBpO1xuICAgIH07XG5cbiAgICB2YXIgcHVzaElzTm90R2VuZXJpYyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEFycmF5LnByb3RvdHlwZS5wdXNoLmNhbGwob2JqLCB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0ICE9PSAxIHx8IG9iai5sZW5ndGggIT09IDEgfHwgdHlwZW9mIG9ialswXSAhPT0gJ3VuZGVmaW5lZCcgfHwgIW93bnMob2JqLCAwKTtcbiAgICB9KCkpO1xuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgcHVzaDogZnVuY3Rpb24gcHVzaChpdGVtKSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheV9wdXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHVzaFNoaW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH0sIHB1c2hJc05vdEdlbmVyaWMpO1xuXG4gICAgLy8gVGhpcyBmaXhlcyBhIHZlcnkgd2VpcmQgYnVnIGluIE9wZXJhIDEwLjYgd2hlbiBwdXNoaW5nIGB1bmRlZmluZWRcbiAgICB2YXIgcHVzaFVuZGVmaW5lZElzV2VpcmQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJyID0gW107XG4gICAgICAgIHZhciByZXN1bHQgPSBhcnIucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0ICE9PSAxIHx8IGFyci5sZW5ndGggIT09IDEgfHwgdHlwZW9mIGFyclswXSAhPT0gJ3VuZGVmaW5lZCcgfHwgIW93bnMoYXJyLCAwKTtcbiAgICB9KCkpO1xuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHsgcHVzaDogcHVzaFNoaW0gfSwgcHVzaFVuZGVmaW5lZElzV2VpcmQpO1xuXG4gICAgLy8gRVM1IDE1LjIuMy4xNFxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuNC40LjEwXG4gICAgLy8gRml4IGJveGVkIHN0cmluZyBidWdcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIHNsaWNlOiBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgdmFyIGFyciA9IGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogdGhpcztcbiAgICAgICAgICAgIHJldHVybiBhcnJheVNsaWNlQXBwbHkoYXJyLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfSwgc3BsaXRTdHJpbmcpO1xuXG4gICAgdmFyIHNvcnRJZ25vcmVzTm9uRnVuY3Rpb25zID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFsxLCAyXS5zb3J0KG51bGwpO1xuICAgICAgICAgICAgWzEsIDJdLnNvcnQoe30pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KCkpO1xuICAgIHZhciBzb3J0VGhyb3dzT25SZWdleCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgYSBwcm9ibGVtIGluIEZpcmVmb3ggNCwgaW4gd2hpY2ggYHR5cGVvZiAvYS8gPT09ICdmdW5jdGlvbidgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBbMSwgMl0uc29ydCgvYS8pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KCkpO1xuICAgIHZhciBzb3J0SWdub3Jlc1VuZGVmaW5lZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGFwcGxpZXMgaW4gSUUgOCwgZm9yIG9uZS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFsxLCAyXS5zb3J0KHVuZGVmaW5lZCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0oKSk7XG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVGbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21wYXJlRm4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5U29ydCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNDYWxsYWJsZShjb21wYXJlRm4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLnNvcnQgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlTb3J0KHRoaXMsIGNvbXBhcmVGbik7XG4gICAgICAgIH1cbiAgICB9LCBzb3J0SWdub3Jlc05vbkZ1bmN0aW9ucyB8fCAhc29ydElnbm9yZXNVbmRlZmluZWQgfHwgIXNvcnRUaHJvd3NPblJlZ2V4KTtcblxuICAgIC8vXG4gICAgLy8gT2JqZWN0XG4gICAgLy8gPT09PT09XG4gICAgLy9cblxuICAgIC8vIEVTNSAxNS4yLjMuMTRcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4yLjMuMTRcblxuICAgIC8vIGh0dHA6Ly93aGF0dGhlaGVhZHNhaWQuY29tLzIwMTAvMTAvYS1zYWZlci1vYmplY3Qta2V5cy1jb21wYXRpYmlsaXR5LWltcGxlbWVudGF0aW9uXG4gICAgdmFyIGhhc0RvbnRFbnVtQnVnID0gIWlzRW51bSh7ICd0b1N0cmluZyc6IG51bGwgfSwgJ3RvU3RyaW5nJyk7XG4gICAgdmFyIGhhc1Byb3RvRW51bUJ1ZyA9IGlzRW51bShmdW5jdGlvbiAoKSB7fSwgJ3Byb3RvdHlwZScpO1xuICAgIHZhciBoYXNTdHJpbmdFbnVtQnVnID0gIW93bnMoJ3gnLCAnMCcpO1xuICAgIHZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciBjdG9yID0gby5jb25zdHJ1Y3RvcjtcbiAgICAgICAgcmV0dXJuIGN0b3IgJiYgY3Rvci5wcm90b3R5cGUgPT09IG87XG4gICAgfTtcbiAgICB2YXIgYmxhY2tsaXN0ZWRLZXlzID0ge1xuICAgICAgICAkd2luZG93OiB0cnVlLFxuICAgICAgICAkY29uc29sZTogdHJ1ZSxcbiAgICAgICAgJHBhcmVudDogdHJ1ZSxcbiAgICAgICAgJHNlbGY6IHRydWUsXG4gICAgICAgICRmcmFtZTogdHJ1ZSxcbiAgICAgICAgJGZyYW1lczogdHJ1ZSxcbiAgICAgICAgJGZyYW1lRWxlbWVudDogdHJ1ZSxcbiAgICAgICAgJHdlYmtpdEluZGV4ZWREQjogdHJ1ZSxcbiAgICAgICAgJHdlYmtpdFN0b3JhZ2VJbmZvOiB0cnVlLFxuICAgICAgICAkZXh0ZXJuYWw6IHRydWVcbiAgICB9O1xuICAgIHZhciBoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKiBnbG9iYWxzIHdpbmRvdyAqL1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBrIGluIHdpbmRvdykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIWJsYWNrbGlzdGVkS2V5c1snJCcgKyBrXSAmJiBvd25zKHdpbmRvdywgaykgJiYgd2luZG93W2tdICE9PSBudWxsICYmIHR5cGVvZiB3aW5kb3dba10gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKHdpbmRvd1trXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KCkpO1xuICAgIHZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnKSB7XG4gICAgICAgICAgICByZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG9iamVjdCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGRvbnRFbnVtcyA9IFtcbiAgICAgICAgJ3RvU3RyaW5nJyxcbiAgICAgICAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgICAgICAgJ3ZhbHVlT2YnLFxuICAgICAgICAnaGFzT3duUHJvcGVydHknLFxuICAgICAgICAnaXNQcm90b3R5cGVPZicsXG4gICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICAgICAgICdjb25zdHJ1Y3RvcidcbiAgICBdO1xuICAgIHZhciBkb250RW51bXNMZW5ndGggPSBkb250RW51bXMubGVuZ3RoO1xuXG4gICAgLy8gdGFrZW4gZGlyZWN0bHkgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL2lzLWFyZ3VtZW50cy9ibG9iL21hc3Rlci9pbmRleC5qc1xuICAgIC8vIGNhbiBiZSByZXBsYWNlZCB3aXRoIHJlcXVpcmUoJ2lzLWFyZ3VtZW50cycpIGlmIHdlIGV2ZXIgdXNlIGEgYnVpbGQgcHJvY2VzcyBpbnN0ZWFkXG4gICAgdmFyIGlzU3RhbmRhcmRBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHIodmFsdWUpID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcbiAgICB9O1xuICAgIHZhciBpc0xlZ2FjeUFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIHZhbHVlLmxlbmd0aCA+PSAwICYmXG4gICAgICAgICAgICAhaXNBcnJheSh2YWx1ZSkgJiZcbiAgICAgICAgICAgIGlzQ2FsbGFibGUodmFsdWUuY2FsbGVlKTtcbiAgICB9O1xuICAgIHZhciBpc0FyZ3VtZW50cyA9IGlzU3RhbmRhcmRBcmd1bWVudHMoYXJndW1lbnRzKSA/IGlzU3RhbmRhcmRBcmd1bWVudHMgOiBpc0xlZ2FjeUFyZ3VtZW50cztcblxuICAgIGRlZmluZVByb3BlcnRpZXMoJE9iamVjdCwge1xuICAgICAgICBrZXlzOiBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGlzRm4gPSBpc0NhbGxhYmxlKG9iamVjdCk7XG4gICAgICAgICAgICB2YXIgaXNBcmdzID0gaXNBcmd1bWVudHMob2JqZWN0KTtcbiAgICAgICAgICAgIHZhciBpc09iamVjdCA9IG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JztcbiAgICAgICAgICAgIHZhciBpc1N0ciA9IGlzT2JqZWN0ICYmIGlzU3RyaW5nKG9iamVjdCk7XG5cbiAgICAgICAgICAgIGlmICghaXNPYmplY3QgJiYgIWlzRm4gJiYgIWlzQXJncykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5rZXlzIGNhbGxlZCBvbiBhIG5vbi1vYmplY3QnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRoZUtleXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBza2lwUHJvdG8gPSBoYXNQcm90b0VudW1CdWcgJiYgaXNGbjtcbiAgICAgICAgICAgIGlmICgoaXNTdHIgJiYgaGFzU3RyaW5nRW51bUJ1ZykgfHwgaXNBcmdzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaENhbGwodGhlS2V5cywgJFN0cmluZyhpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzQXJncykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHNraXBQcm90byAmJiBuYW1lID09PSAncHJvdG90eXBlJykgJiYgb3ducyhvYmplY3QsIG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoQ2FsbCh0aGVLZXlzLCAkU3RyaW5nKG5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhc0RvbnRFbnVtQnVnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNraXBDb25zdHJ1Y3RvciA9IGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneShvYmplY3QpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9udEVudW1zTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbnRFbnVtID0gZG9udEVudW1zW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShza2lwQ29uc3RydWN0b3IgJiYgZG9udEVudW0gPT09ICdjb25zdHJ1Y3RvcicpICYmIG93bnMob2JqZWN0LCBkb250RW51bSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hDYWxsKHRoZUtleXMsIGRvbnRFbnVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGVLZXlzO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIga2V5c1dvcmtzV2l0aEFyZ3VtZW50cyA9ICRPYmplY3Qua2V5cyAmJiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBTYWZhcmkgNS4wIGJ1Z1xuICAgICAgICByZXR1cm4gJE9iamVjdC5rZXlzKGFyZ3VtZW50cykubGVuZ3RoID09PSAyO1xuICAgIH0oMSwgMikpO1xuICAgIHZhciBrZXlzSGFzQXJndW1lbnRzTGVuZ3RoQnVnID0gJE9iamVjdC5rZXlzICYmIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdLZXlzID0gJE9iamVjdC5rZXlzKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoICE9PSAxIHx8IGFyZ0tleXMubGVuZ3RoICE9PSAxIHx8IGFyZ0tleXNbMF0gIT09IDE7XG4gICAgfSgxKSk7XG4gICAgdmFyIG9yaWdpbmFsS2V5cyA9ICRPYmplY3Qua2V5cztcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKCRPYmplY3QsIHtcbiAgICAgICAga2V5czogZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsS2V5cyhhcnJheVNsaWNlKG9iamVjdCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxLZXlzKG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCAha2V5c1dvcmtzV2l0aEFyZ3VtZW50cyB8fCBrZXlzSGFzQXJndW1lbnRzTGVuZ3RoQnVnKTtcblxuICAgIC8vXG4gICAgLy8gRGF0ZVxuICAgIC8vID09PT1cbiAgICAvL1xuXG4gICAgdmFyIGhhc05lZ2F0aXZlTW9udGhZZWFyQnVnID0gbmV3IERhdGUoLTM1MDk4MjczMjk2MDAyOTIpLmdldFVUQ01vbnRoKCkgIT09IDA7XG4gICAgdmFyIGFOZWdhdGl2ZVRlc3REYXRlID0gbmV3IERhdGUoLTE1MDk4NDIyODk2MDAyOTIpO1xuICAgIHZhciBhUG9zaXRpdmVUZXN0RGF0ZSA9IG5ldyBEYXRlKDE0NDk2NjI0MDAwMDApO1xuICAgIHZhciBoYXNUb1VUQ1N0cmluZ0Zvcm1hdEJ1ZyA9IGFOZWdhdGl2ZVRlc3REYXRlLnRvVVRDU3RyaW5nKCkgIT09ICdNb24sIDAxIEphbiAtNDU4NzUgMTE6NTk6NTkgR01UJztcbiAgICB2YXIgaGFzVG9EYXRlU3RyaW5nRm9ybWF0QnVnO1xuICAgIHZhciBoYXNUb1N0cmluZ0Zvcm1hdEJ1ZztcbiAgICB2YXIgdGltZVpvbmVPZmZzZXQgPSBhTmVnYXRpdmVUZXN0RGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgIGlmICh0aW1lWm9uZU9mZnNldCA8IC03MjApIHtcbiAgICAgICAgaGFzVG9EYXRlU3RyaW5nRm9ybWF0QnVnID0gYU5lZ2F0aXZlVGVzdERhdGUudG9EYXRlU3RyaW5nKCkgIT09ICdUdWUgSmFuIDAyIC00NTg3NSc7XG4gICAgICAgIGhhc1RvU3RyaW5nRm9ybWF0QnVnID0gISgvXlRodSBEZWMgMTAgMjAxNSBcXGRcXGQ6XFxkXFxkOlxcZFxcZCBHTVRbLVxcK11cXGRcXGRcXGRcXGQoPzogfCQpLykudGVzdChhUG9zaXRpdmVUZXN0RGF0ZS50b1N0cmluZygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBoYXNUb0RhdGVTdHJpbmdGb3JtYXRCdWcgPSBhTmVnYXRpdmVUZXN0RGF0ZS50b0RhdGVTdHJpbmcoKSAhPT0gJ01vbiBKYW4gMDEgLTQ1ODc1JztcbiAgICAgICAgaGFzVG9TdHJpbmdGb3JtYXRCdWcgPSAhKC9eV2VkIERlYyAwOSAyMDE1IFxcZFxcZDpcXGRcXGQ6XFxkXFxkIEdNVFstXFwrXVxcZFxcZFxcZFxcZCg/OiB8JCkvKS50ZXN0KGFQb3NpdGl2ZVRlc3REYXRlLnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIHZhciBvcmlnaW5hbEdldEZ1bGxZZWFyID0gY2FsbC5iaW5kKERhdGUucHJvdG90eXBlLmdldEZ1bGxZZWFyKTtcbiAgICB2YXIgb3JpZ2luYWxHZXRNb250aCA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRNb250aCk7XG4gICAgdmFyIG9yaWdpbmFsR2V0RGF0ZSA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXREYXRlKTtcbiAgICB2YXIgb3JpZ2luYWxHZXRVVENGdWxsWWVhciA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRVVENGdWxsWWVhcik7XG4gICAgdmFyIG9yaWdpbmFsR2V0VVRDTW9udGggPSBjYWxsLmJpbmQoRGF0ZS5wcm90b3R5cGUuZ2V0VVRDTW9udGgpO1xuICAgIHZhciBvcmlnaW5hbEdldFVUQ0RhdGUgPSBjYWxsLmJpbmQoRGF0ZS5wcm90b3R5cGUuZ2V0VVRDRGF0ZSk7XG4gICAgdmFyIG9yaWdpbmFsR2V0VVRDRGF5ID0gY2FsbC5iaW5kKERhdGUucHJvdG90eXBlLmdldFVUQ0RheSk7XG4gICAgdmFyIG9yaWdpbmFsR2V0VVRDSG91cnMgPSBjYWxsLmJpbmQoRGF0ZS5wcm90b3R5cGUuZ2V0VVRDSG91cnMpO1xuICAgIHZhciBvcmlnaW5hbEdldFVUQ01pbnV0ZXMgPSBjYWxsLmJpbmQoRGF0ZS5wcm90b3R5cGUuZ2V0VVRDTWludXRlcyk7XG4gICAgdmFyIG9yaWdpbmFsR2V0VVRDU2Vjb25kcyA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRVVENTZWNvbmRzKTtcbiAgICB2YXIgb3JpZ2luYWxHZXRVVENNaWxsaXNlY29uZHMgPSBjYWxsLmJpbmQoRGF0ZS5wcm90b3R5cGUuZ2V0VVRDTWlsbGlzZWNvbmRzKTtcbiAgICB2YXIgZGF5TmFtZSA9IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J107XG4gICAgdmFyIG1vbnRoTmFtZSA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXTtcbiAgICB2YXIgZGF5c0luTW9udGggPSBmdW5jdGlvbiBkYXlzSW5Nb250aChtb250aCwgeWVhcikge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxHZXREYXRlKG5ldyBEYXRlKHllYXIsIG1vbnRoLCAwKSk7XG4gICAgfTtcblxuICAgIGRlZmluZVByb3BlcnRpZXMoRGF0ZS5wcm90b3R5cGUsIHtcbiAgICAgICAgZ2V0RnVsbFllYXI6IGZ1bmN0aW9uIGdldEZ1bGxZZWFyKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzIHx8ICEodGhpcyBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBub3QgYSBEYXRlIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB5ZWFyID0gb3JpZ2luYWxHZXRGdWxsWWVhcih0aGlzKTtcbiAgICAgICAgICAgIGlmICh5ZWFyIDwgMCAmJiBvcmlnaW5hbEdldE1vbnRoKHRoaXMpID4gMTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWVhciArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWVhcjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TW9udGg6IGZ1bmN0aW9uIGdldE1vbnRoKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzIHx8ICEodGhpcyBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBub3QgYSBEYXRlIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB5ZWFyID0gb3JpZ2luYWxHZXRGdWxsWWVhcih0aGlzKTtcbiAgICAgICAgICAgIHZhciBtb250aCA9IG9yaWdpbmFsR2V0TW9udGgodGhpcyk7XG4gICAgICAgICAgICBpZiAoeWVhciA8IDAgJiYgbW9udGggPiAxMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoO1xuICAgICAgICB9LFxuICAgICAgICBnZXREYXRlOiBmdW5jdGlvbiBnZXREYXRlKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzIHx8ICEodGhpcyBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBub3QgYSBEYXRlIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB5ZWFyID0gb3JpZ2luYWxHZXRGdWxsWWVhcih0aGlzKTtcbiAgICAgICAgICAgIHZhciBtb250aCA9IG9yaWdpbmFsR2V0TW9udGgodGhpcyk7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG9yaWdpbmFsR2V0RGF0ZSh0aGlzKTtcbiAgICAgICAgICAgIGlmICh5ZWFyIDwgMCAmJiBtb250aCA+IDExKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vbnRoID09PSAxMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGRheXMgPSBkYXlzSW5Nb250aCgwLCB5ZWFyICsgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChkYXlzIC0gZGF0ZSkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFVUQ0Z1bGxZZWFyOiBmdW5jdGlvbiBnZXRVVENGdWxsWWVhcigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcyB8fCAhKHRoaXMgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RoaXMgaXMgbm90IGEgRGF0ZSBvYmplY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgeWVhciA9IG9yaWdpbmFsR2V0VVRDRnVsbFllYXIodGhpcyk7XG4gICAgICAgICAgICBpZiAoeWVhciA8IDAgJiYgb3JpZ2luYWxHZXRVVENNb250aCh0aGlzKSA+IDExKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHllYXIgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHllYXI7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFVUQ01vbnRoOiBmdW5jdGlvbiBnZXRVVENNb250aCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcyB8fCAhKHRoaXMgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RoaXMgaXMgbm90IGEgRGF0ZSBvYmplY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgeWVhciA9IG9yaWdpbmFsR2V0VVRDRnVsbFllYXIodGhpcyk7XG4gICAgICAgICAgICB2YXIgbW9udGggPSBvcmlnaW5hbEdldFVUQ01vbnRoKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHllYXIgPCAwICYmIG1vbnRoID4gMTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb250aDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VVRDRGF0ZTogZnVuY3Rpb24gZ2V0VVRDRGF0ZSgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcyB8fCAhKHRoaXMgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RoaXMgaXMgbm90IGEgRGF0ZSBvYmplY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgeWVhciA9IG9yaWdpbmFsR2V0VVRDRnVsbFllYXIodGhpcyk7XG4gICAgICAgICAgICB2YXIgbW9udGggPSBvcmlnaW5hbEdldFVUQ01vbnRoKHRoaXMpO1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBvcmlnaW5hbEdldFVUQ0RhdGUodGhpcyk7XG4gICAgICAgICAgICBpZiAoeWVhciA8IDAgJiYgbW9udGggPiAxMSkge1xuICAgICAgICAgICAgICAgIGlmIChtb250aCA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkYXlzID0gZGF5c0luTW9udGgoMCwgeWVhciArIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoZGF5cyAtIGRhdGUpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICB9XG4gICAgfSwgaGFzTmVnYXRpdmVNb250aFllYXJCdWcpO1xuXG4gICAgZGVmaW5lUHJvcGVydGllcyhEYXRlLnByb3RvdHlwZSwge1xuICAgICAgICB0b1VUQ1N0cmluZzogZnVuY3Rpb24gdG9VVENTdHJpbmcoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMgfHwgISh0aGlzIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aGlzIGlzIG5vdCBhIERhdGUgb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRheSA9IG9yaWdpbmFsR2V0VVRDRGF5KHRoaXMpO1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBvcmlnaW5hbEdldFVUQ0RhdGUodGhpcyk7XG4gICAgICAgICAgICB2YXIgbW9udGggPSBvcmlnaW5hbEdldFVUQ01vbnRoKHRoaXMpO1xuICAgICAgICAgICAgdmFyIHllYXIgPSBvcmlnaW5hbEdldFVUQ0Z1bGxZZWFyKHRoaXMpO1xuICAgICAgICAgICAgdmFyIGhvdXIgPSBvcmlnaW5hbEdldFVUQ0hvdXJzKHRoaXMpO1xuICAgICAgICAgICAgdmFyIG1pbnV0ZSA9IG9yaWdpbmFsR2V0VVRDTWludXRlcyh0aGlzKTtcbiAgICAgICAgICAgIHZhciBzZWNvbmQgPSBvcmlnaW5hbEdldFVUQ1NlY29uZHModGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gZGF5TmFtZVtkYXldICsgJywgJyArXG4gICAgICAgICAgICAgICAgKGRhdGUgPCAxMCA/ICcwJyArIGRhdGUgOiBkYXRlKSArICcgJyArXG4gICAgICAgICAgICAgICAgbW9udGhOYW1lW21vbnRoXSArICcgJyArXG4gICAgICAgICAgICAgICAgeWVhciArICcgJyArXG4gICAgICAgICAgICAgICAgKGhvdXIgPCAxMCA/ICcwJyArIGhvdXIgOiBob3VyKSArICc6JyArXG4gICAgICAgICAgICAgICAgKG1pbnV0ZSA8IDEwID8gJzAnICsgbWludXRlIDogbWludXRlKSArICc6JyArXG4gICAgICAgICAgICAgICAgKHNlY29uZCA8IDEwID8gJzAnICsgc2Vjb25kIDogc2Vjb25kKSArICcgR01UJztcbiAgICAgICAgfVxuICAgIH0sIGhhc05lZ2F0aXZlTW9udGhZZWFyQnVnIHx8IGhhc1RvVVRDU3RyaW5nRm9ybWF0QnVnKTtcblxuICAgIC8vIE9wZXJhIDEyIGhhcyBgLGBcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKERhdGUucHJvdG90eXBlLCB7XG4gICAgICAgIHRvRGF0ZVN0cmluZzogZnVuY3Rpb24gdG9EYXRlU3RyaW5nKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzIHx8ICEodGhpcyBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBub3QgYSBEYXRlIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkYXkgPSB0aGlzLmdldERheSgpO1xuICAgICAgICAgICAgdmFyIGRhdGUgPSB0aGlzLmdldERhdGUoKTtcbiAgICAgICAgICAgIHZhciBtb250aCA9IHRoaXMuZ2V0TW9udGgoKTtcbiAgICAgICAgICAgIHZhciB5ZWFyID0gdGhpcy5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgcmV0dXJuIGRheU5hbWVbZGF5XSArICcgJyArXG4gICAgICAgICAgICAgICAgbW9udGhOYW1lW21vbnRoXSArICcgJyArXG4gICAgICAgICAgICAgICAgKGRhdGUgPCAxMCA/ICcwJyArIGRhdGUgOiBkYXRlKSArICcgJyArXG4gICAgICAgICAgICAgICAgeWVhcjtcbiAgICAgICAgfVxuICAgIH0sIGhhc05lZ2F0aXZlTW9udGhZZWFyQnVnIHx8IGhhc1RvRGF0ZVN0cmluZ0Zvcm1hdEJ1Zyk7XG5cbiAgICAvLyBjYW4ndCB1c2UgZGVmaW5lUHJvcGVydGllcyBoZXJlIGJlY2F1c2Ugb2YgdG9TdHJpbmcgZW51bWVyYXRpb24gaXNzdWUgaW4gSUUgPD0gOFxuICAgIGlmIChoYXNOZWdhdGl2ZU1vbnRoWWVhckJ1ZyB8fCBoYXNUb1N0cmluZ0Zvcm1hdEJ1Zykge1xuICAgICAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzIHx8ICEodGhpcyBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBub3QgYSBEYXRlIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkYXkgPSB0aGlzLmdldERheSgpO1xuICAgICAgICAgICAgdmFyIGRhdGUgPSB0aGlzLmdldERhdGUoKTtcbiAgICAgICAgICAgIHZhciBtb250aCA9IHRoaXMuZ2V0TW9udGgoKTtcbiAgICAgICAgICAgIHZhciB5ZWFyID0gdGhpcy5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgdmFyIGhvdXIgPSB0aGlzLmdldEhvdXJzKCk7XG4gICAgICAgICAgICB2YXIgbWludXRlID0gdGhpcy5nZXRNaW51dGVzKCk7XG4gICAgICAgICAgICB2YXIgc2Vjb25kID0gdGhpcy5nZXRTZWNvbmRzKCk7XG4gICAgICAgICAgICB2YXIgdGltZXpvbmVPZmZzZXQgPSB0aGlzLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgICAgICB2YXIgaG91cnNPZmZzZXQgPSBNYXRoLmZsb29yKE1hdGguYWJzKHRpbWV6b25lT2Zmc2V0KSAvIDYwKTtcbiAgICAgICAgICAgIHZhciBtaW51dGVzT2Zmc2V0ID0gTWF0aC5mbG9vcihNYXRoLmFicyh0aW1lem9uZU9mZnNldCkgJSA2MCk7XG4gICAgICAgICAgICByZXR1cm4gZGF5TmFtZVtkYXldICsgJyAnICtcbiAgICAgICAgICAgICAgICBtb250aE5hbWVbbW9udGhdICsgJyAnICtcbiAgICAgICAgICAgICAgICAoZGF0ZSA8IDEwID8gJzAnICsgZGF0ZSA6IGRhdGUpICsgJyAnICtcbiAgICAgICAgICAgICAgICB5ZWFyICsgJyAnICtcbiAgICAgICAgICAgICAgICAoaG91ciA8IDEwID8gJzAnICsgaG91ciA6IGhvdXIpICsgJzonICtcbiAgICAgICAgICAgICAgICAobWludXRlIDwgMTAgPyAnMCcgKyBtaW51dGUgOiBtaW51dGUpICsgJzonICtcbiAgICAgICAgICAgICAgICAoc2Vjb25kIDwgMTAgPyAnMCcgKyBzZWNvbmQgOiBzZWNvbmQpICsgJyBHTVQnICtcbiAgICAgICAgICAgICAgICAodGltZXpvbmVPZmZzZXQgPiAwID8gJy0nIDogJysnKSArXG4gICAgICAgICAgICAgICAgKGhvdXJzT2Zmc2V0IDwgMTAgPyAnMCcgKyBob3Vyc09mZnNldCA6IGhvdXJzT2Zmc2V0KSArXG4gICAgICAgICAgICAgICAgKG1pbnV0ZXNPZmZzZXQgPCAxMCA/ICcwJyArIG1pbnV0ZXNPZmZzZXQgOiBtaW51dGVzT2Zmc2V0KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcbiAgICAgICAgICAgICRPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0ZS5wcm90b3R5cGUsICd0b1N0cmluZycsIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRVM1IDE1LjkuNS40M1xuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjkuNS40M1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIFN0cmluZyB2YWx1ZSByZXByZXNlbnQgdGhlIGluc3RhbmNlIGluIHRpbWVcbiAgICAvLyByZXByZXNlbnRlZCBieSB0aGlzIERhdGUgb2JqZWN0LiBUaGUgZm9ybWF0IG9mIHRoZSBTdHJpbmcgaXMgdGhlIERhdGUgVGltZVxuICAgIC8vIHN0cmluZyBmb3JtYXQgZGVmaW5lZCBpbiAxNS45LjEuMTUuIEFsbCBmaWVsZHMgYXJlIHByZXNlbnQgaW4gdGhlIFN0cmluZy5cbiAgICAvLyBUaGUgdGltZSB6b25lIGlzIGFsd2F5cyBVVEMsIGRlbm90ZWQgYnkgdGhlIHN1ZmZpeCBaLiBJZiB0aGUgdGltZSB2YWx1ZSBvZlxuICAgIC8vIHRoaXMgb2JqZWN0IGlzIG5vdCBhIGZpbml0ZSBOdW1iZXIgYSBSYW5nZUVycm9yIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAgdmFyIG5lZ2F0aXZlRGF0ZSA9IC02MjE5ODc1NTIwMDAwMDtcbiAgICB2YXIgbmVnYXRpdmVZZWFyU3RyaW5nID0gJy0wMDAwMDEnO1xuICAgIHZhciBoYXNOZWdhdGl2ZURhdGVCdWcgPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyAmJiBuZXcgRGF0ZShuZWdhdGl2ZURhdGUpLnRvSVNPU3RyaW5nKCkuaW5kZXhPZihuZWdhdGl2ZVllYXJTdHJpbmcpID09PSAtMTtcbiAgICB2YXIgaGFzU2FmYXJpNTFEYXRlQnVnID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgJiYgbmV3IERhdGUoLTEpLnRvSVNPU3RyaW5nKCkgIT09ICcxOTY5LTEyLTMxVDIzOjU5OjU5Ljk5OVonO1xuXG4gICAgdmFyIGdldFRpbWUgPSBjYWxsLmJpbmQoRGF0ZS5wcm90b3R5cGUuZ2V0VGltZSk7XG5cbiAgICBkZWZpbmVQcm9wZXJ0aWVzKERhdGUucHJvdG90eXBlLCB7XG4gICAgICAgIHRvSVNPU3RyaW5nOiBmdW5jdGlvbiB0b0lTT1N0cmluZygpIHtcbiAgICAgICAgICAgIGlmICghaXNGaW5pdGUodGhpcykgfHwgIWlzRmluaXRlKGdldFRpbWUodGhpcykpKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRvcGUgUGhvdG9zaG9wIHJlcXVpcmVzIHRoZSBzZWNvbmQgY2hlY2suXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nIGNhbGxlZCBvbiBub24tZmluaXRlIHZhbHVlLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgeWVhciA9IG9yaWdpbmFsR2V0VVRDRnVsbFllYXIodGhpcyk7XG5cbiAgICAgICAgICAgIHZhciBtb250aCA9IG9yaWdpbmFsR2V0VVRDTW9udGgodGhpcyk7XG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xMTFcbiAgICAgICAgICAgIHllYXIgKz0gTWF0aC5mbG9vcihtb250aCAvIDEyKTtcbiAgICAgICAgICAgIG1vbnRoID0gKG1vbnRoICUgMTIgKyAxMikgJSAxMjtcblxuICAgICAgICAgICAgLy8gdGhlIGRhdGUgdGltZSBzdHJpbmcgZm9ybWF0IGlzIHNwZWNpZmllZCBpbiAxNS45LjEuMTUuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW21vbnRoICsgMSwgb3JpZ2luYWxHZXRVVENEYXRlKHRoaXMpLCBvcmlnaW5hbEdldFVUQ0hvdXJzKHRoaXMpLCBvcmlnaW5hbEdldFVUQ01pbnV0ZXModGhpcyksIG9yaWdpbmFsR2V0VVRDU2Vjb25kcyh0aGlzKV07XG4gICAgICAgICAgICB5ZWFyID0gKFxuICAgICAgICAgICAgICAgICh5ZWFyIDwgMCA/ICctJyA6ICh5ZWFyID4gOTk5OSA/ICcrJyA6ICcnKSkgK1xuICAgICAgICAgICAgICAgIHN0clNsaWNlKCcwMDAwMCcgKyBNYXRoLmFicyh5ZWFyKSwgKDAgPD0geWVhciAmJiB5ZWFyIDw9IDk5OTkpID8gLTQgOiAtNilcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgLy8gcGFkIG1vbnRocywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIGFuZCBzZWNvbmRzIHRvIGhhdmUgdHdvIGRpZ2l0cy5cbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBzdHJTbGljZSgnMDAnICsgcmVzdWx0W2ldLCAtMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwYWQgbWlsbGlzZWNvbmRzIHRvIGhhdmUgdGhyZWUgZGlnaXRzLlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICB5ZWFyICsgJy0nICsgYXJyYXlTbGljZShyZXN1bHQsIDAsIDIpLmpvaW4oJy0nKSArXG4gICAgICAgICAgICAgICAgJ1QnICsgYXJyYXlTbGljZShyZXN1bHQsIDIpLmpvaW4oJzonKSArICcuJyArXG4gICAgICAgICAgICAgICAgc3RyU2xpY2UoJzAwMCcgKyBvcmlnaW5hbEdldFVUQ01pbGxpc2Vjb25kcyh0aGlzKSwgLTMpICsgJ1onXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfSwgaGFzTmVnYXRpdmVEYXRlQnVnIHx8IGhhc1NhZmFyaTUxRGF0ZUJ1Zyk7XG5cbiAgICAvLyBFUzUgMTUuOS41LjQ0XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuOS41LjQ0XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBwcm92aWRlcyBhIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIERhdGUgb2JqZWN0IGZvciB1c2UgYnlcbiAgICAvLyBKU09OLnN0cmluZ2lmeSAoMTUuMTIuMykuXG4gICAgdmFyIGRhdGVUb0pTT05Jc1N1cHBvcnRlZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5wcm90b3R5cGUudG9KU09OICYmXG4gICAgICAgICAgICAgICAgbmV3IERhdGUoTmFOKS50b0pTT04oKSA9PT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIG5ldyBEYXRlKG5lZ2F0aXZlRGF0ZSkudG9KU09OKCkuaW5kZXhPZihuZWdhdGl2ZVllYXJTdHJpbmcpICE9PSAtMSAmJlxuICAgICAgICAgICAgICAgIERhdGUucHJvdG90eXBlLnRvSlNPTi5jYWxsKHsgLy8gZ2VuZXJpY1xuICAgICAgICAgICAgICAgICAgICB0b0lTT1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KCkpO1xuICAgIGlmICghZGF0ZVRvSlNPTklzU3VwcG9ydGVkKSB7XG4gICAgICAgIERhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTihrZXkpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIHRvSlNPTiBtZXRob2QgaXMgY2FsbGVkIHdpdGggYXJndW1lbnQga2V5LCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgICAvLyBzdGVwcyBhcmUgdGFrZW46XG5cbiAgICAgICAgICAgIC8vIDEuICBMZXQgTyBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgVG9PYmplY3QsIGdpdmluZyBpdCB0aGUgdGhpc1xuICAgICAgICAgICAgLy8gdmFsdWUgYXMgaXRzIGFyZ3VtZW50LlxuICAgICAgICAgICAgLy8gMi4gTGV0IHR2IGJlIEVTLlRvUHJpbWl0aXZlKE8sIGhpbnQgTnVtYmVyKS5cbiAgICAgICAgICAgIHZhciBPID0gJE9iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciB0diA9IEVTLlRvUHJpbWl0aXZlKE8pO1xuICAgICAgICAgICAgLy8gMy4gSWYgdHYgaXMgYSBOdW1iZXIgYW5kIGlzIG5vdCBmaW5pdGUsIHJldHVybiBudWxsLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0diA9PT0gJ251bWJlcicgJiYgIWlzRmluaXRlKHR2KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gNC4gTGV0IHRvSVNPIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tHZXRdXSBpbnRlcm5hbCBtZXRob2Qgb2ZcbiAgICAgICAgICAgIC8vIE8gd2l0aCBhcmd1bWVudCBcInRvSVNPU3RyaW5nXCIuXG4gICAgICAgICAgICB2YXIgdG9JU08gPSBPLnRvSVNPU3RyaW5nO1xuICAgICAgICAgICAgLy8gNS4gSWYgSXNDYWxsYWJsZSh0b0lTTykgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIGlmICghaXNDYWxsYWJsZSh0b0lTTykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0b0lTT1N0cmluZyBwcm9wZXJ0eSBpcyBub3QgY2FsbGFibGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDYuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZCBvZlxuICAgICAgICAgICAgLy8gIHRvSVNPIHdpdGggTyBhcyB0aGUgdGhpcyB2YWx1ZSBhbmQgYW4gZW1wdHkgYXJndW1lbnQgbGlzdC5cbiAgICAgICAgICAgIHJldHVybiB0b0lTTy5jYWxsKE8pO1xuXG4gICAgICAgICAgICAvLyBOT1RFIDEgVGhlIGFyZ3VtZW50IGlzIGlnbm9yZWQuXG5cbiAgICAgICAgICAgIC8vIE5PVEUgMiBUaGUgdG9KU09OIGZ1bmN0aW9uIGlzIGludGVudGlvbmFsbHkgZ2VuZXJpYzsgaXQgZG9lcyBub3RcbiAgICAgICAgICAgIC8vIHJlcXVpcmUgdGhhdCBpdHMgdGhpcyB2YWx1ZSBiZSBhIERhdGUgb2JqZWN0LiBUaGVyZWZvcmUsIGl0IGNhbiBiZVxuICAgICAgICAgICAgLy8gdHJhbnNmZXJyZWQgdG8gb3RoZXIga2luZHMgb2Ygb2JqZWN0cyBmb3IgdXNlIGFzIGEgbWV0aG9kLiBIb3dldmVyLFxuICAgICAgICAgICAgLy8gaXQgZG9lcyByZXF1aXJlIHRoYXQgYW55IHN1Y2ggb2JqZWN0IGhhdmUgYSB0b0lTT1N0cmluZyBtZXRob2QuIEFuXG4gICAgICAgICAgICAvLyBvYmplY3QgaXMgZnJlZSB0byB1c2UgdGhlIGFyZ3VtZW50IGtleSB0byBmaWx0ZXIgaXRzXG4gICAgICAgICAgICAvLyBzdHJpbmdpZmljYXRpb24uXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRVM1IDE1LjkuNC4yXG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuOS40LjJcbiAgICAvLyBiYXNlZCBvbiB3b3JrIHNoYXJlZCBieSBEYW5pZWwgRnJpZXNlbiAoZGFudG1hbilcbiAgICAvLyBodHRwOi8vZ2lzdC5naXRodWIuY29tLzMwMzI0OVxuICAgIHZhciBzdXBwb3J0c0V4dGVuZGVkWWVhcnMgPSBEYXRlLnBhcnNlKCcrMDMzNjU4LTA5LTI3VDAxOjQ2OjQwLjAwMFonKSA9PT0gMWUxNTtcbiAgICB2YXIgYWNjZXB0c0ludmFsaWREYXRlcyA9ICFpc05hTihEYXRlLnBhcnNlKCcyMDEyLTA0LTA0VDI0OjAwOjAwLjUwMFonKSkgfHwgIWlzTmFOKERhdGUucGFyc2UoJzIwMTItMTEtMzFUMjM6NTk6NTkuMDAwWicpKSB8fCAhaXNOYU4oRGF0ZS5wYXJzZSgnMjAxMi0xMi0zMVQyMzo1OTo2MC4wMDBaJykpO1xuICAgIHZhciBkb2VzTm90UGFyc2VZMktOZXdZZWFyID0gaXNOYU4oRGF0ZS5wYXJzZSgnMjAwMC0wMS0wMVQwMDowMDowMC4wMDBaJykpO1xuICAgIGlmIChkb2VzTm90UGFyc2VZMktOZXdZZWFyIHx8IGFjY2VwdHNJbnZhbGlkRGF0ZXMgfHwgIXN1cHBvcnRzRXh0ZW5kZWRZZWFycykge1xuICAgICAgICAvLyBYWFggZ2xvYmFsIGFzc2lnbm1lbnQgd29uJ3Qgd29yayBpbiBlbWJlZGRpbmdzIHRoYXQgdXNlXG4gICAgICAgIC8vIGFuIGFsdGVybmF0ZSBvYmplY3QgZm9yIHRoZSBjb250ZXh0LlxuICAgICAgICAvKiBnbG9iYWwgRGF0ZTogdHJ1ZSAqL1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuICAgICAgICB2YXIgbWF4U2FmZVVuc2lnbmVkMzJCaXQgPSBNYXRoLnBvdygyLCAzMSkgLSAxO1xuICAgICAgICB2YXIgaGFzU2FmYXJpU2lnbmVkSW50QnVnID0gaXNBY3R1YWxOYU4obmV3IERhdGUoMTk3MCwgMCwgMSwgMCwgMCwgMCwgbWF4U2FmZVVuc2lnbmVkMzJCaXQgKyAxKS5nZXRUaW1lKCkpO1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1pbXBsaWNpdC1nbG9iYWxzICovXG4gICAgICAgIERhdGUgPSAoZnVuY3Rpb24gKE5hdGl2ZURhdGUpIHtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1pbXBsaWNpdC1nbG9iYWxzICovXG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5kZWYgKi9cbiAgICAgICAgICAgIC8vIERhdGUubGVuZ3RoID09PSA3XG4gICAgICAgICAgICB2YXIgRGF0ZVNoaW0gPSBmdW5jdGlvbiBEYXRlKFksIE0sIEQsIGgsIG0sIHMsIG1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBOYXRpdmVEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWNvbmRzID0gcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbGxpcyA9IG1zO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzU2FmYXJpU2lnbmVkSW50QnVnICYmIGxlbmd0aCA+PSA3ICYmIG1zID4gbWF4U2FmZVVuc2lnbmVkMzJCaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdvcmsgYXJvdW5kIGEgU2FmYXJpIDgvOSBidWcgd2hlcmUgaXQgdHJlYXRzIHRoZSBzZWNvbmRzIGFzIHNpZ25lZFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1zVG9TaGlmdCA9IE1hdGguZmxvb3IobXMgLyBtYXhTYWZlVW5zaWduZWQzMkJpdCkgKiBtYXhTYWZlVW5zaWduZWQzMkJpdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzVG9TaGlmdCA9IE1hdGguZmxvb3IobXNUb1NoaWZ0IC8gMWUzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZHMgKz0gc1RvU2hpZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaWxsaXMgLT0gc1RvU2hpZnQgKiAxZTM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IGxlbmd0aCA9PT0gMSAmJiAkU3RyaW5nKFkpID09PSBZID8gLy8gaXNTdHJpbmcoWSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGV4cGxpY2l0bHkgcGFzcyBpdCB0aHJvdWdoIHBhcnNlOlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5hdGl2ZURhdGUoRGF0ZVNoaW0ucGFyc2UoWSkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gbWFudWFsbHkgbWFrZSBjYWxscyBkZXBlbmRpbmcgb24gYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxlbmd0aCBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPj0gNyA/IG5ldyBOYXRpdmVEYXRlKFksIE0sIEQsIGgsIG0sIHNlY29uZHMsIG1pbGxpcykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID49IDYgPyBuZXcgTmF0aXZlRGF0ZShZLCBNLCBELCBoLCBtLCBzZWNvbmRzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPj0gNSA/IG5ldyBOYXRpdmVEYXRlKFksIE0sIEQsIGgsIG0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA+PSA0ID8gbmV3IE5hdGl2ZURhdGUoWSwgTSwgRCwgaCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID49IDMgPyBuZXcgTmF0aXZlRGF0ZShZLCBNLCBEKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPj0gMiA/IG5ldyBOYXRpdmVEYXRlKFksIE0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA+PSAxID8gbmV3IE5hdGl2ZURhdGUoWSBpbnN0YW5jZW9mIE5hdGl2ZURhdGUgPyArWSA6IFkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5hdGl2ZURhdGUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRlID0gTmF0aXZlRGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzUHJpbWl0aXZlKGRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbWl4dXBzIHdpdGggdW5maXhlZCBEYXRlIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKGRhdGUsIHsgY29uc3RydWN0b3I6IERhdGVTaGltIH0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIDE1LjkuMS4xNSBEYXRlIFRpbWUgU3RyaW5nIEZvcm1hdC5cbiAgICAgICAgICAgIHZhciBpc29EYXRlRXhwcmVzc2lvbiA9IG5ldyBSZWdFeHAoJ14nICtcbiAgICAgICAgICAgICAgICAnKFxcXFxkezR9fFsrLV1cXFxcZHs2fSknICsgLy8gZm91ci1kaWdpdCB5ZWFyIGNhcHR1cmUgb3Igc2lnbiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA2LWRpZ2l0IGV4dGVuZGVkIHllYXJcbiAgICAgICAgICAgICAgICAnKD86LShcXFxcZHsyfSknICsgLy8gb3B0aW9uYWwgbW9udGggY2FwdHVyZVxuICAgICAgICAgICAgICAgICcoPzotKFxcXFxkezJ9KScgKyAvLyBvcHRpb25hbCBkYXkgY2FwdHVyZVxuICAgICAgICAgICAgICAgICcoPzonICsgLy8gY2FwdHVyZSBob3VyczptaW51dGVzOnNlY29uZHMubWlsbGlzZWNvbmRzXG4gICAgICAgICAgICAgICAgICAgICdUKFxcXFxkezJ9KScgKyAvLyBob3VycyBjYXB0dXJlXG4gICAgICAgICAgICAgICAgICAgICc6KFxcXFxkezJ9KScgKyAvLyBtaW51dGVzIGNhcHR1cmVcbiAgICAgICAgICAgICAgICAgICAgJyg/OicgKyAvLyBvcHRpb25hbCA6c2Vjb25kcy5taWxsaXNlY29uZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICc6KFxcXFxkezJ9KScgKyAvLyBzZWNvbmRzIGNhcHR1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgICcoPzooXFxcXC5cXFxcZHsxLH0pKT8nICsgLy8gbWlsbGlzZWNvbmRzIGNhcHR1cmVcbiAgICAgICAgICAgICAgICAgICAgJyk/JyArXG4gICAgICAgICAgICAgICAgJygnICsgLy8gY2FwdHVyZSBVVEMgb2Zmc2V0IGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAnWnwnICsgLy8gVVRDIGNhcHR1cmVcbiAgICAgICAgICAgICAgICAgICAgJyg/OicgKyAvLyBvZmZzZXQgc3BlY2lmaWVyICsvLWhvdXJzOm1pbnV0ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICcoWy0rXSknICsgLy8gc2lnbiBjYXB0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAnKFxcXFxkezJ9KScgKyAvLyBob3VycyBvZmZzZXQgY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgJzooXFxcXGR7Mn0pJyArIC8vIG1pbnV0ZXMgb2Zmc2V0IGNhcHR1cmVcbiAgICAgICAgICAgICAgICAgICAgJyknICtcbiAgICAgICAgICAgICAgICAnKT8pPyk/KT8nICtcbiAgICAgICAgICAgICckJyk7XG5cbiAgICAgICAgICAgIHZhciBtb250aHMgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzQsIDM2NV07XG5cbiAgICAgICAgICAgIHZhciBkYXlGcm9tTW9udGggPSBmdW5jdGlvbiBkYXlGcm9tTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IG1vbnRoID4gMSA/IDEgOiAwO1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoc1ttb250aF0gK1xuICAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKCh5ZWFyIC0gMTk2OSArIHQpIC8gNCkgLVxuICAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKCh5ZWFyIC0gMTkwMSArIHQpIC8gMTAwKSArXG4gICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKHllYXIgLSAxNjAxICsgdCkgLyA0MDApICtcbiAgICAgICAgICAgICAgICAgICAgMzY1ICogKHllYXIgLSAxOTcwKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgdG9VVEMgPSBmdW5jdGlvbiB0b1VUQyh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBtcyA9IHQ7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1NhZmFyaVNpZ25lZEludEJ1ZyAmJiBtcyA+IG1heFNhZmVVbnNpZ25lZDMyQml0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdvcmsgYXJvdW5kIGEgU2FmYXJpIDgvOSBidWcgd2hlcmUgaXQgdHJlYXRzIHRoZSBzZWNvbmRzIGFzIHNpZ25lZFxuICAgICAgICAgICAgICAgICAgICB2YXIgbXNUb1NoaWZ0ID0gTWF0aC5mbG9vcihtcyAvIG1heFNhZmVVbnNpZ25lZDMyQml0KSAqIG1heFNhZmVVbnNpZ25lZDMyQml0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc1RvU2hpZnQgPSBNYXRoLmZsb29yKG1zVG9TaGlmdCAvIDFlMyk7XG4gICAgICAgICAgICAgICAgICAgIHMgKz0gc1RvU2hpZnQ7XG4gICAgICAgICAgICAgICAgICAgIG1zIC09IHNUb1NoaWZ0ICogMWUzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJE51bWJlcihuZXcgTmF0aXZlRGF0ZSgxOTcwLCAwLCAxLCAwLCAwLCBzLCBtcykpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gQ29weSBhbnkgY3VzdG9tIG1ldGhvZHMgYSAzcmQgcGFydHkgbGlicmFyeSBtYXkgaGF2ZSBhZGRlZFxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIE5hdGl2ZURhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ducyhOYXRpdmVEYXRlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIERhdGVTaGltW2tleV0gPSBOYXRpdmVEYXRlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb3B5IFwibmF0aXZlXCIgbWV0aG9kcyBleHBsaWNpdGx5OyB0aGV5IG1heSBiZSBub24tZW51bWVyYWJsZVxuICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyhEYXRlU2hpbSwge1xuICAgICAgICAgICAgICAgIG5vdzogTmF0aXZlRGF0ZS5ub3csXG4gICAgICAgICAgICAgICAgVVRDOiBOYXRpdmVEYXRlLlVUQ1xuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICBEYXRlU2hpbS5wcm90b3R5cGUgPSBOYXRpdmVEYXRlLnByb3RvdHlwZTtcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnRpZXMoRGF0ZVNoaW0ucHJvdG90eXBlLCB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3I6IERhdGVTaGltXG4gICAgICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICAgICAgLy8gVXBncmFkZSBEYXRlLnBhcnNlIHRvIGhhbmRsZSBzaW1wbGlmaWVkIElTTyA4NjAxIHN0cmluZ3NcbiAgICAgICAgICAgIHZhciBwYXJzZVNoaW0gPSBmdW5jdGlvbiBwYXJzZShzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBpc29EYXRlRXhwcmVzc2lvbi5leGVjKHN0cmluZyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBhcnNlIG1vbnRocywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvdmlkZSBkZWZhdWx0IHZhbHVlcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFyc2UgdGhlIFVUQyBvZmZzZXQgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ZWFyID0gJE51bWJlcihtYXRjaFsxXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBtb250aCA9ICROdW1iZXIobWF0Y2hbMl0gfHwgMSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF5ID0gJE51bWJlcihtYXRjaFszXSB8fCAxKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3VyID0gJE51bWJlcihtYXRjaFs0XSB8fCAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbnV0ZSA9ICROdW1iZXIobWF0Y2hbNV0gfHwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmQgPSAkTnVtYmVyKG1hdGNoWzZdIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmQgPSBNYXRoLmZsb29yKCROdW1iZXIobWF0Y2hbN10gfHwgMCkgKiAxMDAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGltZSB6b25lIGlzIG1pc3NlZCwgbG9jYWwgb2Zmc2V0IHNob3VsZCBiZSB1c2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAoRVMgNS4xIGJ1ZylcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2J1Z3MuZWNtYXNjcmlwdC5vcmcvc2hvd19idWcuY2dpP2lkPTExMlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNMb2NhbFRpbWUgPSBCb29sZWFuKG1hdGNoWzRdICYmICFtYXRjaFs4XSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduT2Zmc2V0ID0gbWF0Y2hbOV0gPT09ICctJyA/IDEgOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvdXJPZmZzZXQgPSAkTnVtYmVyKG1hdGNoWzEwXSB8fCAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbnV0ZU9mZnNldCA9ICROdW1iZXIobWF0Y2hbMTFdIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzTWludXRlc09yU2Vjb25kc09yTWlsbGlzZWNvbmRzID0gbWludXRlID4gMCB8fCBzZWNvbmQgPiAwIHx8IG1pbGxpc2Vjb25kID4gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaG91ciA8IChoYXNNaW51dGVzT3JTZWNvbmRzT3JNaWxsaXNlY29uZHMgPyAyNCA6IDI1KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbWludXRlIDwgNjAgJiYgc2Vjb25kIDwgNjAgJiYgbWlsbGlzZWNvbmQgPCAxMDAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBtb250aCA+IC0xICYmIG1vbnRoIDwgMTIgJiYgaG91ck9mZnNldCA8IDI0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW51dGVPZmZzZXQgPCA2MCAmJiAvLyBkZXRlY3QgaW52YWxpZCBvZmZzZXRzXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXkgPiAtMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF5IDwgKGRheUZyb21Nb250aCh5ZWFyLCBtb250aCArIDEpIC0gZGF5RnJvbU1vbnRoKHllYXIsIG1vbnRoKSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRheUZyb21Nb250aCh5ZWFyLCBtb250aCkgKyBkYXkpICogMjQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvdXIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvdXJPZmZzZXQgKiBzaWduT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICApICogNjA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlc3VsdCArIG1pbnV0ZSArIG1pbnV0ZU9mZnNldCAqIHNpZ25PZmZzZXQpICogNjAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFxuICAgICAgICAgICAgICAgICAgICAgICAgKSAqIDEwMDAgKyBtaWxsaXNlY29uZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0xvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRvVVRDKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLTguNjRlMTUgPD0gcmVzdWx0ICYmIHJlc3VsdCA8PSA4LjY0ZTE1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gTmF0aXZlRGF0ZS5wYXJzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnRpZXMoRGF0ZVNoaW0sIHsgcGFyc2U6IHBhcnNlU2hpbSB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIERhdGVTaGltO1xuICAgICAgICB9KERhdGUpKTtcbiAgICAgICAgLyogZ2xvYmFsIERhdGU6IGZhbHNlICovXG4gICAgfVxuXG4gICAgLy8gRVM1IDE1LjkuNC40XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuOS40LjRcbiAgICBpZiAoIURhdGUubm93KSB7XG4gICAgICAgIERhdGUubm93ID0gZnVuY3Rpb24gbm93KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gTnVtYmVyXG4gICAgLy8gPT09PT09XG4gICAgLy9cblxuICAgIC8vIEVTNS4xIDE1LjcuNC41XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNy40LjVcbiAgICB2YXIgaGFzVG9GaXhlZEJ1Z3MgPSBOdW1iZXJQcm90b3R5cGUudG9GaXhlZCAmJiAoXG4gICAgICAoMC4wMDAwOCkudG9GaXhlZCgzKSAhPT0gJzAuMDAwJyB8fFxuICAgICAgKDAuOSkudG9GaXhlZCgwKSAhPT0gJzEnIHx8XG4gICAgICAoMS4yNTUpLnRvRml4ZWQoMikgIT09ICcxLjI1JyB8fFxuICAgICAgKDEwMDAwMDAwMDAwMDAwMDAxMjgpLnRvRml4ZWQoMCkgIT09ICcxMDAwMDAwMDAwMDAwMDAwMTI4J1xuICAgICk7XG5cbiAgICB2YXIgdG9GaXhlZEhlbHBlcnMgPSB7XG4gICAgICAgIGJhc2U6IDFlNyxcbiAgICAgICAgc2l6ZTogNixcbiAgICAgICAgZGF0YTogWzAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgICBtdWx0aXBseTogZnVuY3Rpb24gbXVsdGlwbHkobiwgYykge1xuICAgICAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgICAgIHZhciBjMiA9IGM7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgdG9GaXhlZEhlbHBlcnMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIGMyICs9IG4gKiB0b0ZpeGVkSGVscGVycy5kYXRhW2ldO1xuICAgICAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLmRhdGFbaV0gPSBjMiAlIHRvRml4ZWRIZWxwZXJzLmJhc2U7XG4gICAgICAgICAgICAgICAgYzIgPSBNYXRoLmZsb29yKGMyIC8gdG9GaXhlZEhlbHBlcnMuYmFzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRpdmlkZTogZnVuY3Rpb24gZGl2aWRlKG4pIHtcbiAgICAgICAgICAgIHZhciBpID0gdG9GaXhlZEhlbHBlcnMuc2l6ZTtcbiAgICAgICAgICAgIHZhciBjID0gMDtcbiAgICAgICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGMgKz0gdG9GaXhlZEhlbHBlcnMuZGF0YVtpXTtcbiAgICAgICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5kYXRhW2ldID0gTWF0aC5mbG9vcihjIC8gbik7XG4gICAgICAgICAgICAgICAgYyA9IChjICUgbikgKiB0b0ZpeGVkSGVscGVycy5iYXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBudW1Ub1N0cmluZzogZnVuY3Rpb24gbnVtVG9TdHJpbmcoKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRvRml4ZWRIZWxwZXJzLnNpemU7XG4gICAgICAgICAgICB2YXIgcyA9ICcnO1xuICAgICAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHMgIT09ICcnIHx8IGkgPT09IDAgfHwgdG9GaXhlZEhlbHBlcnMuZGF0YVtpXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9ICRTdHJpbmcodG9GaXhlZEhlbHBlcnMuZGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IHQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzICs9IHN0clNsaWNlKCcwMDAwMDAwJywgMCwgNyAtIHQubGVuZ3RoKSArIHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfSxcbiAgICAgICAgcG93OiBmdW5jdGlvbiBwb3coeCwgbiwgYWNjKSB7XG4gICAgICAgICAgICByZXR1cm4gKG4gPT09IDAgPyBhY2MgOiAobiAlIDIgPT09IDEgPyBwb3coeCwgbiAtIDEsIGFjYyAqIHgpIDogcG93KHggKiB4LCBuIC8gMiwgYWNjKSkpO1xuICAgICAgICB9LFxuICAgICAgICBsb2c6IGZ1bmN0aW9uIGxvZyh4KSB7XG4gICAgICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgICAgICB2YXIgeDIgPSB4O1xuICAgICAgICAgICAgd2hpbGUgKHgyID49IDQwOTYpIHtcbiAgICAgICAgICAgICAgICBuICs9IDEyO1xuICAgICAgICAgICAgICAgIHgyIC89IDQwOTY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoeDIgPj0gMikge1xuICAgICAgICAgICAgICAgIG4gKz0gMTtcbiAgICAgICAgICAgICAgICB4MiAvPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHRvRml4ZWRTaGltID0gZnVuY3Rpb24gdG9GaXhlZChmcmFjdGlvbkRpZ2l0cykge1xuICAgICAgICB2YXIgZiwgeCwgcywgbSwgZSwgeiwgaiwgaztcblxuICAgICAgICAvLyBUZXN0IGZvciBOYU4gYW5kIHJvdW5kIGZyYWN0aW9uRGlnaXRzIGRvd25cbiAgICAgICAgZiA9ICROdW1iZXIoZnJhY3Rpb25EaWdpdHMpO1xuICAgICAgICBmID0gaXNBY3R1YWxOYU4oZikgPyAwIDogTWF0aC5mbG9vcihmKTtcblxuICAgICAgICBpZiAoZiA8IDAgfHwgZiA+IDIwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTnVtYmVyLnRvRml4ZWQgY2FsbGVkIHdpdGggaW52YWxpZCBudW1iZXIgb2YgZGVjaW1hbHMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHggPSAkTnVtYmVyKHRoaXMpO1xuXG4gICAgICAgIGlmIChpc0FjdHVhbE5hTih4KSkge1xuICAgICAgICAgICAgcmV0dXJuICdOYU4nO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgaXQgaXMgdG9vIGJpZyBvciBzbWFsbCwgcmV0dXJuIHRoZSBzdHJpbmcgdmFsdWUgb2YgdGhlIG51bWJlclxuICAgICAgICBpZiAoeCA8PSAtMWUyMSB8fCB4ID49IDFlMjEpIHtcbiAgICAgICAgICAgIHJldHVybiAkU3RyaW5nKHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcyA9ICcnO1xuXG4gICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgICAgcyA9ICctJztcbiAgICAgICAgICAgIHggPSAteDtcbiAgICAgICAgfVxuXG4gICAgICAgIG0gPSAnMCc7XG5cbiAgICAgICAgaWYgKHggPiAxZS0yMSkge1xuICAgICAgICAgICAgLy8gMWUtMjEgPCB4IDwgMWUyMVxuICAgICAgICAgICAgLy8gLTcwIDwgbG9nMih4KSA8IDcwXG4gICAgICAgICAgICBlID0gdG9GaXhlZEhlbHBlcnMubG9nKHggKiB0b0ZpeGVkSGVscGVycy5wb3coMiwgNjksIDEpKSAtIDY5O1xuICAgICAgICAgICAgeiA9IChlIDwgMCA/IHggKiB0b0ZpeGVkSGVscGVycy5wb3coMiwgLWUsIDEpIDogeCAvIHRvRml4ZWRIZWxwZXJzLnBvdygyLCBlLCAxKSk7XG4gICAgICAgICAgICB6ICo9IDB4MTAwMDAwMDAwMDAwMDA7IC8vIE1hdGgucG93KDIsIDUyKTtcbiAgICAgICAgICAgIGUgPSA1MiAtIGU7XG5cbiAgICAgICAgICAgIC8vIC0xOCA8IGUgPCAxMjJcbiAgICAgICAgICAgIC8vIHggPSB6IC8gMiBeIGVcbiAgICAgICAgICAgIGlmIChlID4gMCkge1xuICAgICAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLm11bHRpcGx5KDAsIHopO1xuICAgICAgICAgICAgICAgIGogPSBmO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGogPj0gNykge1xuICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5tdWx0aXBseSgxZTcsIDApO1xuICAgICAgICAgICAgICAgICAgICBqIC09IDc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMubXVsdGlwbHkodG9GaXhlZEhlbHBlcnMucG93KDEwLCBqLCAxKSwgMCk7XG4gICAgICAgICAgICAgICAgaiA9IGUgLSAxO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGogPj0gMjMpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMuZGl2aWRlKDEgPDwgMjMpO1xuICAgICAgICAgICAgICAgICAgICBqIC09IDIzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLmRpdmlkZSgxIDw8IGopO1xuICAgICAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLm11bHRpcGx5KDEsIDEpO1xuICAgICAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLmRpdmlkZSgyKTtcbiAgICAgICAgICAgICAgICBtID0gdG9GaXhlZEhlbHBlcnMubnVtVG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMubXVsdGlwbHkoMCwgeik7XG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMubXVsdGlwbHkoMSA8PCAoLWUpLCAwKTtcbiAgICAgICAgICAgICAgICBtID0gdG9GaXhlZEhlbHBlcnMubnVtVG9TdHJpbmcoKSArIHN0clNsaWNlKCcwLjAwMDAwMDAwMDAwMDAwMDAwMDAwJywgMiwgMiArIGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGYgPiAwKSB7XG4gICAgICAgICAgICBrID0gbS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChrIDw9IGYpIHtcbiAgICAgICAgICAgICAgICBtID0gcyArIHN0clNsaWNlKCcwLjAwMDAwMDAwMDAwMDAwMDAwMDAnLCAwLCBmIC0gayArIDIpICsgbTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbSA9IHMgKyBzdHJTbGljZShtLCAwLCBrIC0gZikgKyAnLicgKyBzdHJTbGljZShtLCBrIC0gZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtID0gcyArIG07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9O1xuICAgIGRlZmluZVByb3BlcnRpZXMoTnVtYmVyUHJvdG90eXBlLCB7IHRvRml4ZWQ6IHRvRml4ZWRTaGltIH0sIGhhc1RvRml4ZWRCdWdzKTtcblxuICAgIHZhciBoYXNUb1ByZWNpc2lvblVuZGVmaW5lZEJ1ZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gMS4wLnRvUHJlY2lzaW9uKHVuZGVmaW5lZCkgPT09ICcxJztcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9KCkpO1xuICAgIHZhciBvcmlnaW5hbFRvUHJlY2lzaW9uID0gTnVtYmVyUHJvdG90eXBlLnRvUHJlY2lzaW9uO1xuICAgIGRlZmluZVByb3BlcnRpZXMoTnVtYmVyUHJvdG90eXBlLCB7XG4gICAgICAgIHRvUHJlY2lzaW9uOiBmdW5jdGlvbiB0b1ByZWNpc2lvbihwcmVjaXNpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgcHJlY2lzaW9uID09PSAndW5kZWZpbmVkJyA/IG9yaWdpbmFsVG9QcmVjaXNpb24uY2FsbCh0aGlzKSA6IG9yaWdpbmFsVG9QcmVjaXNpb24uY2FsbCh0aGlzLCBwcmVjaXNpb24pO1xuICAgICAgICB9XG4gICAgfSwgaGFzVG9QcmVjaXNpb25VbmRlZmluZWRCdWcpO1xuXG4gICAgLy9cbiAgICAvLyBTdHJpbmdcbiAgICAvLyA9PT09PT1cbiAgICAvL1xuXG4gICAgLy8gRVM1IDE1LjUuNC4xNFxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjUuNC4xNFxuXG4gICAgLy8gW2J1Z2ZpeCwgSUUgbHQgOSwgZmlyZWZveCA0LCBLb25xdWVyb3IsIE9wZXJhLCBvYnNjdXJlIGJyb3dzZXJzXVxuICAgIC8vIE1hbnkgYnJvd3NlcnMgZG8gbm90IHNwbGl0IHByb3Blcmx5IHdpdGggcmVndWxhciBleHByZXNzaW9ucyBvciB0aGV5XG4gICAgLy8gZG8gbm90IHBlcmZvcm0gdGhlIHNwbGl0IGNvcnJlY3RseSB1bmRlciBvYnNjdXJlIGNvbmRpdGlvbnMuXG4gICAgLy8gU2VlIGh0dHA6Ly9ibG9nLnN0ZXZlbmxldml0aGFuLmNvbS9hcmNoaXZlcy9jcm9zcy1icm93c2VyLXNwbGl0XG4gICAgLy8gSSd2ZSB0ZXN0ZWQgaW4gbWFueSBicm93c2VycyBhbmQgdGhpcyBzZWVtcyB0byBjb3ZlciB0aGUgZGV2aWFudCBvbmVzOlxuICAgIC8vICAgICdhYicuc3BsaXQoLyg/OmFiKSovKSBzaG91bGQgYmUgW1wiXCIsIFwiXCJdLCBub3QgW1wiXCJdXG4gICAgLy8gICAgJy4nLnNwbGl0KC8oLj8pKC4/KS8pIHNob3VsZCBiZSBbXCJcIiwgXCIuXCIsIFwiXCIsIFwiXCJdLCBub3QgW1wiXCIsIFwiXCJdXG4gICAgLy8gICAgJ3Rlc3N0Jy5zcGxpdCgvKHMpKi8pIHNob3VsZCBiZSBbXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIFwic1wiLCBcInRcIl0sIG5vdFxuICAgIC8vICAgICAgIFt1bmRlZmluZWQsIFwidFwiLCB1bmRlZmluZWQsIFwiZVwiLCAuLi5dXG4gICAgLy8gICAgJycuc3BsaXQoLy4/Lykgc2hvdWxkIGJlIFtdLCBub3QgW1wiXCJdXG4gICAgLy8gICAgJy4nLnNwbGl0KC8oKSgpLykgc2hvdWxkIGJlIFtcIi5cIl0sIG5vdCBbXCJcIiwgXCJcIiwgXCIuXCJdXG5cbiAgICBpZiAoXG4gICAgICAgICdhYicuc3BsaXQoLyg/OmFiKSovKS5sZW5ndGggIT09IDIgfHxcbiAgICAgICAgJy4nLnNwbGl0KC8oLj8pKC4/KS8pLmxlbmd0aCAhPT0gNCB8fFxuICAgICAgICAndGVzc3QnLnNwbGl0KC8ocykqLylbMV0gPT09ICd0JyB8fFxuICAgICAgICAndGVzdCcuc3BsaXQoLyg/OikvLCAtMSkubGVuZ3RoICE9PSA0IHx8XG4gICAgICAgICcnLnNwbGl0KC8uPy8pLmxlbmd0aCB8fFxuICAgICAgICAnLicuc3BsaXQoLygpKCkvKS5sZW5ndGggPiAxXG4gICAgKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29tcGxpYW50RXhlY05wY2cgPSB0eXBlb2YgKC8oKT8/LykuZXhlYygnJylbMV0gPT09ICd1bmRlZmluZWQnOyAvLyBOUENHOiBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cFxuICAgICAgICAgICAgdmFyIG1heFNhZmUzMkJpdEludCA9IE1hdGgucG93KDIsIDMyKSAtIDE7XG5cbiAgICAgICAgICAgIFN0cmluZ1Byb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0cmluZyA9IFN0cmluZyh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNlcGFyYXRvciA9PT0gJ3VuZGVmaW5lZCcgJiYgbGltaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICAgICAgICAgICAgaWYgKCFpc1JlZ2V4KHNlcGFyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0clNwbGl0KHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnVuaWNvZGUgPyAndScgOiAnJykgKyAvLyBpbiBFUzZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnN0aWNreSA/ICd5JyA6ICcnKSwgLy8gRmlyZWZveCAzKyBhbmQgRVM2XG4gICAgICAgICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSAwLFxuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBzZXBhcmF0b3JDb3B5ID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoJ14nICsgc2VwYXJhdG9yQ29weS5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogVmFsdWVzIGZvciBgbGltaXRgLCBwZXIgdGhlIHNwZWM6XG4gICAgICAgICAgICAgICAgICogSWYgdW5kZWZpbmVkOiA0Mjk0OTY3Mjk1IC8vIG1heFNhZmUzMkJpdEludFxuICAgICAgICAgICAgICAgICAqIElmIDAsIEluZmluaXR5LCBvciBOYU46IDBcbiAgICAgICAgICAgICAgICAgKiBJZiBwb3NpdGl2ZSBudW1iZXI6IGxpbWl0ID0gTWF0aC5mbG9vcihsaW1pdCk7IGlmIChsaW1pdCA+IDQyOTQ5NjcyOTUpIGxpbWl0IC09IDQyOTQ5NjcyOTY7XG4gICAgICAgICAgICAgICAgICogSWYgbmVnYXRpdmUgbnVtYmVyOiA0Mjk0OTY3Mjk2IC0gTWF0aC5mbG9vcihNYXRoLmFicyhsaW1pdCkpXG4gICAgICAgICAgICAgICAgICogSWYgb3RoZXI6IFR5cGUtY29udmVydCwgdGhlbiB1c2UgdGhlIGFib3ZlIHJ1bGVzXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIHNwbGl0TGltaXQgPSB0eXBlb2YgbGltaXQgPT09ICd1bmRlZmluZWQnID8gbWF4U2FmZTMyQml0SW50IDogRVMuVG9VaW50MzIobGltaXQpO1xuICAgICAgICAgICAgICAgIG1hdGNoID0gc2VwYXJhdG9yQ29weS5leGVjKHN0cmluZyk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGBzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoQ2FsbChvdXRwdXQsIHN0clNsaWNlKHN0cmluZywgbGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFtpXSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheV9wdXNoLmFwcGx5KG91dHB1dCwgYXJyYXlTbGljZShtYXRjaCwgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBzcGxpdExpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcGFyYXRvckNvcHkubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yQ29weS5sYXN0SW5kZXgrKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gc2VwYXJhdG9yQ29weS5leGVjKHN0cmluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3JDb3B5LnRlc3QoJycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoQ2FsbChvdXRwdXQsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2hDYWxsKG91dHB1dCwgc3RyU2xpY2Uoc3RyaW5nLCBsYXN0TGFzdEluZGV4KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQubGVuZ3RoID4gc3BsaXRMaW1pdCA/IGFycmF5U2xpY2Uob3V0cHV0LCAwLCBzcGxpdExpbWl0KSA6IG91dHB1dDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0oKSk7XG5cbiAgICAvLyBbYnVnZml4LCBjaHJvbWVdXG4gICAgLy8gSWYgc2VwYXJhdG9yIGlzIHVuZGVmaW5lZCwgdGhlbiB0aGUgcmVzdWx0IGFycmF5IGNvbnRhaW5zIGp1c3Qgb25lIFN0cmluZyxcbiAgICAvLyB3aGljaCBpcyB0aGUgdGhpcyB2YWx1ZSAoY29udmVydGVkIHRvIGEgU3RyaW5nKS4gSWYgbGltaXQgaXMgbm90IHVuZGVmaW5lZCxcbiAgICAvLyB0aGVuIHRoZSBvdXRwdXQgYXJyYXkgaXMgdHJ1bmNhdGVkIHNvIHRoYXQgaXQgY29udGFpbnMgbm8gbW9yZSB0aGFuIGxpbWl0XG4gICAgLy8gZWxlbWVudHMuXG4gICAgLy8gXCIwXCIuc3BsaXQodW5kZWZpbmVkLCAwKSAtPiBbXVxuICAgIH0gZWxzZSBpZiAoJzAnLnNwbGl0KHZvaWQgMCwgMCkubGVuZ3RoKSB7XG4gICAgICAgIFN0cmluZ1Byb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VwYXJhdG9yID09PSAndW5kZWZpbmVkJyAmJiBsaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHJTcGxpdCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgc3RyX3JlcGxhY2UgPSBTdHJpbmdQcm90b3R5cGUucmVwbGFjZTtcbiAgICB2YXIgcmVwbGFjZVJlcG9ydHNHcm91cHNDb3JyZWN0bHkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ3JvdXBzID0gW107XG4gICAgICAgICd4Jy5yZXBsYWNlKC94KC4pPy9nLCBmdW5jdGlvbiAobWF0Y2gsIGdyb3VwKSB7XG4gICAgICAgICAgICBwdXNoQ2FsbChncm91cHMsIGdyb3VwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBncm91cHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBncm91cHNbMF0gPT09ICd1bmRlZmluZWQnO1xuICAgIH0oKSk7XG5cbiAgICBpZiAoIXJlcGxhY2VSZXBvcnRzR3JvdXBzQ29ycmVjdGx5KSB7XG4gICAgICAgIFN0cmluZ1Byb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgaXNGbiA9IGlzQ2FsbGFibGUocmVwbGFjZVZhbHVlKTtcbiAgICAgICAgICAgIHZhciBoYXNDYXB0dXJpbmdHcm91cHMgPSBpc1JlZ2V4KHNlYXJjaFZhbHVlKSAmJiAoL1xcKVsqP10vKS50ZXN0KHNlYXJjaFZhbHVlLnNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoIWlzRm4gfHwgIWhhc0NhcHR1cmluZ0dyb3Vwcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJfcmVwbGFjZS5jYWxsKHRoaXMsIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZFJlcGxhY2VWYWx1ZSA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsTGFzdEluZGV4ID0gc2VhcmNoVmFsdWUubGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBzZWFyY2hWYWx1ZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IHNlYXJjaFZhbHVlLmV4ZWMobWF0Y2gpIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBzZWFyY2hWYWx1ZS5sYXN0SW5kZXggPSBvcmlnaW5hbExhc3RJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgcHVzaENhbGwoYXJncywgYXJndW1lbnRzW2xlbmd0aCAtIDJdLCBhcmd1bWVudHNbbGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZVZhbHVlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cl9yZXBsYWNlLmNhbGwodGhpcywgc2VhcmNoVmFsdWUsIHdyYXBwZWRSZXBsYWNlVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyLCAzcmQgQi4yLjNcbiAgICAvLyBOb3QgYW4gRUNNQVNjcmlwdCBzdGFuZGFyZCwgYWx0aG91Z2ggRUNNQVNjcmlwdCAzcmQgRWRpdGlvbiBoYXMgYVxuICAgIC8vIG5vbi1ub3JtYXRpdmUgc2VjdGlvbiBzdWdnZXN0aW5nIHVuaWZvcm0gc2VtYW50aWNzIGFuZCBpdCBzaG91bGQgYmVcbiAgICAvLyBub3JtYWxpemVkIGFjcm9zcyBhbGwgYnJvd3NlcnNcbiAgICAvLyBbYnVnZml4LCBJRSBsdCA5XSBJRSA8IDkgc3Vic3RyKCkgd2l0aCBuZWdhdGl2ZSB2YWx1ZSBub3Qgd29ya2luZyBpbiBJRVxuICAgIHZhciBzdHJpbmdfc3Vic3RyID0gU3RyaW5nUHJvdG90eXBlLnN1YnN0cjtcbiAgICB2YXIgaGFzTmVnYXRpdmVTdWJzdHJCdWcgPSAnJy5zdWJzdHIgJiYgJzBiJy5zdWJzdHIoLTEpICE9PSAnYic7XG4gICAgZGVmaW5lUHJvcGVydGllcyhTdHJpbmdQcm90b3R5cGUsIHtcbiAgICAgICAgc3Vic3RyOiBmdW5jdGlvbiBzdWJzdHIoc3RhcnQsIGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRTdGFydCA9IG1heCh0aGlzLmxlbmd0aCArIHN0YXJ0LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdfc3Vic3RyLmNhbGwodGhpcywgbm9ybWFsaXplZFN0YXJ0LCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgfSwgaGFzTmVnYXRpdmVTdWJzdHJCdWcpO1xuXG4gICAgLy8gRVM1IDE1LjUuNC4yMFxuICAgIC8vIHdoaXRlc3BhY2UgZnJvbTogaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS41LjQuMjBcbiAgICB2YXIgd3MgPSAnXFx4MDlcXHgwQVxceDBCXFx4MENcXHgwRFxceDIwXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnICtcbiAgICAgICAgJ1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4JyArXG4gICAgICAgICdcXHUyMDI5XFx1RkVGRic7XG4gICAgdmFyIHplcm9XaWR0aCA9ICdcXHUyMDBiJztcbiAgICB2YXIgd3NSZWdleENoYXJzID0gJ1snICsgd3MgKyAnXSc7XG4gICAgdmFyIHRyaW1CZWdpblJlZ2V4cCA9IG5ldyBSZWdFeHAoJ14nICsgd3NSZWdleENoYXJzICsgd3NSZWdleENoYXJzICsgJyonKTtcbiAgICB2YXIgdHJpbUVuZFJlZ2V4cCA9IG5ldyBSZWdFeHAod3NSZWdleENoYXJzICsgd3NSZWdleENoYXJzICsgJyokJyk7XG4gICAgdmFyIGhhc1RyaW1XaGl0ZXNwYWNlQnVnID0gU3RyaW5nUHJvdG90eXBlLnRyaW0gJiYgKHdzLnRyaW0oKSB8fCAhemVyb1dpZHRoLnRyaW0oKSk7XG4gICAgZGVmaW5lUHJvcGVydGllcyhTdHJpbmdQcm90b3R5cGUsIHtcbiAgICAgICAgLy8gaHR0cDovL2Jsb2cuc3RldmVubGV2aXRoYW4uY29tL2FyY2hpdmVzL2Zhc3Rlci10cmltLWphdmFzY3JpcHRcbiAgICAgICAgLy8gaHR0cDovL3BlcmZlY3Rpb25raWxscy5jb20vd2hpdGVzcGFjZS1kZXZpYXRpb25zL1xuICAgICAgICB0cmltOiBmdW5jdGlvbiB0cmltKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzID09PSAndW5kZWZpbmVkJyB8fCB0aGlzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyB0aGlzICsgJyB0byBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkU3RyaW5nKHRoaXMpLnJlcGxhY2UodHJpbUJlZ2luUmVnZXhwLCAnJykucmVwbGFjZSh0cmltRW5kUmVnZXhwLCAnJyk7XG4gICAgICAgIH1cbiAgICB9LCBoYXNUcmltV2hpdGVzcGFjZUJ1Zyk7XG4gICAgdmFyIHRyaW0gPSBjYWxsLmJpbmQoU3RyaW5nLnByb3RvdHlwZS50cmltKTtcblxuICAgIHZhciBoYXNMYXN0SW5kZXhCdWcgPSBTdHJpbmdQcm90b3R5cGUubGFzdEluZGV4T2YgJiYgJ2FiY+OBguOBhCcubGFzdEluZGV4T2YoJ+OBguOBhCcsIDIpICE9PSAtMTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKFN0cmluZ1Byb3RvdHlwZSwge1xuICAgICAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoU3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FuJ3QgY29udmVydCBcIiArIHRoaXMgKyAnIHRvIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIFMgPSAkU3RyaW5nKHRoaXMpO1xuICAgICAgICAgICAgdmFyIHNlYXJjaFN0ciA9ICRTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICAgICAgICAgIHZhciBudW1Qb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/ICROdW1iZXIoYXJndW1lbnRzWzFdKSA6IE5hTjtcbiAgICAgICAgICAgIHZhciBwb3MgPSBpc0FjdHVhbE5hTihudW1Qb3MpID8gSW5maW5pdHkgOiBFUy5Ub0ludGVnZXIobnVtUG9zKTtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IG1pbihtYXgocG9zLCAwKSwgUy5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIHNlYXJjaExlbiA9IHNlYXJjaFN0ci5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgayA9IHN0YXJ0ICsgc2VhcmNoTGVuO1xuICAgICAgICAgICAgd2hpbGUgKGsgPiAwKSB7XG4gICAgICAgICAgICAgICAgayA9IG1heCgwLCBrIC0gc2VhcmNoTGVuKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBzdHJJbmRleE9mKHN0clNsaWNlKFMsIGssIHN0YXJ0ICsgc2VhcmNoTGVuKSwgc2VhcmNoU3RyKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrICsgaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfSwgaGFzTGFzdEluZGV4QnVnKTtcblxuICAgIHZhciBvcmlnaW5hbExhc3RJbmRleE9mID0gU3RyaW5nUHJvdG90eXBlLmxhc3RJbmRleE9mO1xuICAgIGRlZmluZVByb3BlcnRpZXMoU3RyaW5nUHJvdG90eXBlLCB7XG4gICAgICAgIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hTdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbExhc3RJbmRleE9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9LCBTdHJpbmdQcm90b3R5cGUubGFzdEluZGV4T2YubGVuZ3RoICE9PSAxKTtcblxuICAgIC8vIEVTLTUgMTUuMS4yLjJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSByYWRpeCAqL1xuICAgIGlmIChwYXJzZUludCh3cyArICcwOCcpICE9PSA4IHx8IHBhcnNlSW50KHdzICsgJzB4MTYnKSAhPT0gMjIpIHtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIHJhZGl4ICovXG4gICAgICAgIC8qIGdsb2JhbCBwYXJzZUludDogdHJ1ZSAqL1xuICAgICAgICBwYXJzZUludCA9IChmdW5jdGlvbiAob3JpZ1BhcnNlSW50KSB7XG4gICAgICAgICAgICB2YXIgaGV4UmVnZXggPSAvXltcXC0rXT8wW3hYXS87XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gcGFyc2VJbnQoc3RyLCByYWRpeCkge1xuICAgICAgICAgICAgICAgIHZhciBzdHJpbmcgPSB0cmltKFN0cmluZyhzdHIpKTtcbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdGVkUmFkaXggPSAkTnVtYmVyKHJhZGl4KSB8fCAoaGV4UmVnZXgudGVzdChzdHJpbmcpID8gMTYgOiAxMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdQYXJzZUludChzdHJpbmcsIGRlZmF1bHRlZFJhZGl4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0ocGFyc2VJbnQpKTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2VzNS5naXRodWIuaW8vI3gxNS4xLjIuM1xuICAgIGlmICgxIC8gcGFyc2VGbG9hdCgnLTAnKSAhPT0gLUluZmluaXR5KSB7XG4gICAgICAgIC8qIGdsb2JhbCBwYXJzZUZsb2F0OiB0cnVlICovXG4gICAgICAgIHBhcnNlRmxvYXQgPSAoZnVuY3Rpb24gKG9yaWdQYXJzZUZsb2F0KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gcGFyc2VGbG9hdChzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXRTdHJpbmcgPSB0cmltKFN0cmluZyhzdHJpbmcpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gb3JpZ1BhcnNlRmxvYXQoaW5wdXRTdHJpbmcpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IDAgJiYgc3RyU2xpY2UoaW5wdXRTdHJpbmcsIDAsIDEpID09PSAnLScgPyAtMCA6IHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0ocGFyc2VGbG9hdCkpO1xuICAgIH1cblxuICAgIGlmIChTdHJpbmcobmV3IFJhbmdlRXJyb3IoJ3Rlc3QnKSkgIT09ICdSYW5nZUVycm9yOiB0ZXN0Jykge1xuICAgICAgICB2YXIgZXJyb3JUb1N0cmluZ1NoaW0gPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcyA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiICsgdGhpcyArICcgdG8gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gJ0Vycm9yJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9ICRTdHJpbmcobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbXNnID0gdGhpcy5tZXNzYWdlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtc2cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgbXNnID0gJyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtc2cgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgbXNnID0gJFN0cmluZyhtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbXNnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmFtZSArICc6ICcgKyBtc2c7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGNhbid0IHVzZSBkZWZpbmVQcm9wZXJ0aWVzIGhlcmUgYmVjYXVzZSBvZiB0b1N0cmluZyBlbnVtZXJhdGlvbiBpc3N1ZSBpbiBJRSA8PSA4XG4gICAgICAgIEVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGVycm9yVG9TdHJpbmdTaGltO1xuICAgIH1cblxuICAgIGlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG4gICAgICAgIHZhciBlbnN1cmVOb25FbnVtZXJhYmxlID0gZnVuY3Rpb24gKG9iaiwgcHJvcCkge1xuICAgICAgICAgICAgaWYgKGlzRW51bShvYmosIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKGRlc2MuY29uZmlndXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2MuZW51bWVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCBkZXNjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGVuc3VyZU5vbkVudW1lcmFibGUoRXJyb3IucHJvdG90eXBlLCAnbWVzc2FnZScpO1xuICAgICAgICBpZiAoRXJyb3IucHJvdG90eXBlLm1lc3NhZ2UgIT09ICcnKSB7XG4gICAgICAgICAgICBFcnJvci5wcm90b3R5cGUubWVzc2FnZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZU5vbkVudW1lcmFibGUoRXJyb3IucHJvdG90eXBlLCAnbmFtZScpO1xuICAgIH1cblxuICAgIGlmIChTdHJpbmcoL2EvbWlnKSAhPT0gJy9hL2dpbScpIHtcbiAgICAgICAgdmFyIHJlZ2V4VG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSAnLycgKyB0aGlzLnNvdXJjZSArICcvJztcbiAgICAgICAgICAgIGlmICh0aGlzLmdsb2JhbCkge1xuICAgICAgICAgICAgICAgIHN0ciArPSAnZyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pZ25vcmVDYXNlKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9ICdpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpbGluZSkge1xuICAgICAgICAgICAgICAgIHN0ciArPSAnbSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9O1xuICAgICAgICAvLyBjYW4ndCB1c2UgZGVmaW5lUHJvcGVydGllcyBoZXJlIGJlY2F1c2Ugb2YgdG9TdHJpbmcgZW51bWVyYXRpb24gaXNzdWUgaW4gSUUgPD0gOFxuICAgICAgICBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nID0gcmVnZXhUb1N0cmluZztcbiAgICB9XG59KSk7XG4iLCIvKiFcbiAqIEBvdmVydmlldyBlczYtcHJvbWlzZSAtIGEgdGlueSBpbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlcy9BKy5cbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0IFllaHVkYSBLYXR6LCBUb20gRGFsZSwgU3RlZmFuIFBlbm5lciBhbmQgY29udHJpYnV0b3JzIChDb252ZXJzaW9uIHRvIEVTNiBBUEkgYnkgSmFrZSBBcmNoaWJhbGQpXG4gKiBAbGljZW5zZSAgIExpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG4gKiAgICAgICAgICAgIFNlZSBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vc3RlZmFucGVubmVyL2VzNi1wcm9taXNlL21hc3Rlci9MSUNFTlNFXG4gKiBAdmVyc2lvbiAgIDMuMy4xXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsLkVTNlByb21pc2UgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG9iamVjdE9yRnVuY3Rpb24oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG59XG5cbnZhciBfaXNBcnJheSA9IHVuZGVmaW5lZDtcbmlmICghQXJyYXkuaXNBcnJheSkge1xuICBfaXNBcnJheSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcbn0gZWxzZSB7XG4gIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbn1cblxudmFyIGlzQXJyYXkgPSBfaXNBcnJheTtcblxudmFyIGxlbiA9IDA7XG52YXIgdmVydHhOZXh0ID0gdW5kZWZpbmVkO1xudmFyIGN1c3RvbVNjaGVkdWxlckZuID0gdW5kZWZpbmVkO1xuXG52YXIgYXNhcCA9IGZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGFyZykge1xuICBxdWV1ZVtsZW5dID0gY2FsbGJhY2s7XG4gIHF1ZXVlW2xlbiArIDFdID0gYXJnO1xuICBsZW4gKz0gMjtcbiAgaWYgKGxlbiA9PT0gMikge1xuICAgIC8vIElmIGxlbiBpcyAyLCB0aGF0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byBzY2hlZHVsZSBhbiBhc3luYyBmbHVzaC5cbiAgICAvLyBJZiBhZGRpdGlvbmFsIGNhbGxiYWNrcyBhcmUgcXVldWVkIGJlZm9yZSB0aGUgcXVldWUgaXMgZmx1c2hlZCwgdGhleVxuICAgIC8vIHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IHRoaXMgZmx1c2ggdGhhdCB3ZSBhcmUgc2NoZWR1bGluZy5cbiAgICBpZiAoY3VzdG9tU2NoZWR1bGVyRm4pIHtcbiAgICAgIGN1c3RvbVNjaGVkdWxlckZuKGZsdXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVGbHVzaCgpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2NoZWR1bGVyKHNjaGVkdWxlRm4pIHtcbiAgY3VzdG9tU2NoZWR1bGVyRm4gPSBzY2hlZHVsZUZuO1xufVxuXG5mdW5jdGlvbiBzZXRBc2FwKGFzYXBGbikge1xuICBhc2FwID0gYXNhcEZuO1xufVxuXG52YXIgYnJvd3NlcldpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdW5kZWZpbmVkO1xudmFyIGJyb3dzZXJHbG9iYWwgPSBicm93c2VyV2luZG93IHx8IHt9O1xudmFyIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gYnJvd3Nlckdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGJyb3dzZXJHbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBpc05vZGUgPSB0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICh7fSkudG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuXG4vLyB0ZXN0IGZvciB3ZWIgd29ya2VyIGJ1dCBub3QgaW4gSUUxMFxudmFyIGlzV29ya2VyID0gdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJztcblxuLy8gbm9kZVxuZnVuY3Rpb24gdXNlTmV4dFRpY2soKSB7XG4gIC8vIG5vZGUgdmVyc2lvbiAwLjEwLnggZGlzcGxheXMgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHdoZW4gbmV4dFRpY2sgaXMgdXNlZCByZWN1cnNpdmVseVxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N1am9qcy93aGVuL2lzc3Vlcy80MTAgZm9yIGRldGFpbHNcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gIH07XG59XG5cbi8vIHZlcnR4XG5mdW5jdGlvbiB1c2VWZXJ0eFRpbWVyKCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZlcnR4TmV4dChmbHVzaCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZU11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gIHZhciBpdGVyYXRpb25zID0gMDtcbiAgdmFyIG9ic2VydmVyID0gbmV3IEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKGZsdXNoKTtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gIG9ic2VydmVyLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgbm9kZS5kYXRhID0gaXRlcmF0aW9ucyA9ICsraXRlcmF0aW9ucyAlIDI7XG4gIH07XG59XG5cbi8vIHdlYiB3b3JrZXJcbmZ1bmN0aW9uIHVzZU1lc3NhZ2VDaGFubmVsKCkge1xuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VTZXRUaW1lb3V0KCkge1xuICAvLyBTdG9yZSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBzbyBlczYtcHJvbWlzZSB3aWxsIGJlIHVuYWZmZWN0ZWQgYnlcbiAgLy8gb3RoZXIgY29kZSBtb2RpZnlpbmcgc2V0VGltZW91dCAobGlrZSBzaW5vbi51c2VGYWtlVGltZXJzKCkpXG4gIHZhciBnbG9iYWxTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2xvYmFsU2V0VGltZW91dChmbHVzaCwgMSk7XG4gIH07XG59XG5cbnZhciBxdWV1ZSA9IG5ldyBBcnJheSgxMDAwKTtcbmZ1bmN0aW9uIGZsdXNoKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gcXVldWVbaV07XG4gICAgdmFyIGFyZyA9IHF1ZXVlW2kgKyAxXTtcblxuICAgIGNhbGxiYWNrKGFyZyk7XG5cbiAgICBxdWV1ZVtpXSA9IHVuZGVmaW5lZDtcbiAgICBxdWV1ZVtpICsgMV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBhdHRlbXB0VmVydHgoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHIgPSByZXF1aXJlO1xuICAgIHZhciB2ZXJ0eCA9IHIoJ3ZlcnR4Jyk7XG4gICAgdmVydHhOZXh0ID0gdmVydHgucnVuT25Mb29wIHx8IHZlcnR4LnJ1bk9uQ29udGV4dDtcbiAgICByZXR1cm4gdXNlVmVydHhUaW1lcigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbiAgfVxufVxuXG52YXIgc2NoZWR1bGVGbHVzaCA9IHVuZGVmaW5lZDtcbi8vIERlY2lkZSB3aGF0IGFzeW5jIG1ldGhvZCB0byB1c2UgdG8gdHJpZ2dlcmluZyBwcm9jZXNzaW5nIG9mIHF1ZXVlZCBjYWxsYmFja3M6XG5pZiAoaXNOb2RlKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VOZXh0VGljaygpO1xufSBlbHNlIGlmIChCcm93c2VyTXV0YXRpb25PYnNlcnZlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTXV0YXRpb25PYnNlcnZlcigpO1xufSBlbHNlIGlmIChpc1dvcmtlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTWVzc2FnZUNoYW5uZWwoKTtcbn0gZWxzZSBpZiAoYnJvd3NlcldpbmRvdyA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSBhdHRlbXB0VmVydHgoKTtcbn0gZWxzZSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VTZXRUaW1lb3V0KCk7XG59XG5cbmZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgdmFyIF9hcmd1bWVudHMgPSBhcmd1bWVudHM7XG5cbiAgdmFyIHBhcmVudCA9IHRoaXM7XG5cbiAgdmFyIGNoaWxkID0gbmV3IHRoaXMuY29uc3RydWN0b3Iobm9vcCk7XG5cbiAgaWYgKGNoaWxkW1BST01JU0VfSURdID09PSB1bmRlZmluZWQpIHtcbiAgICBtYWtlUHJvbWlzZShjaGlsZCk7XG4gIH1cblxuICB2YXIgX3N0YXRlID0gcGFyZW50Ll9zdGF0ZTtcblxuICBpZiAoX3N0YXRlKSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjYWxsYmFjayA9IF9hcmd1bWVudHNbX3N0YXRlIC0gMV07XG4gICAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGludm9rZUNhbGxiYWNrKF9zdGF0ZSwgY2hpbGQsIGNhbGxiYWNrLCBwYXJlbnQuX3Jlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KSgpO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbik7XG4gIH1cblxuICByZXR1cm4gY2hpbGQ7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZXNvbHZlYCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIHJlc29sdmVkIHdpdGggdGhlXG4gIHBhc3NlZCBgdmFsdWVgLiBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVzb2x2ZSgxKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoMSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZXNvbHZlXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZXNvbHZlZCB3aXRoXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgZnVsZmlsbGVkIHdpdGggdGhlIGdpdmVuXG4gIGB2YWx1ZWBcbiovXG5mdW5jdGlvbiByZXNvbHZlKG9iamVjdCkge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gIGlmIChvYmplY3QgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0LmNvbnN0cnVjdG9yID09PSBDb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcbiAgX3Jlc29sdmUocHJvbWlzZSwgb2JqZWN0KTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbnZhciBQUk9NSVNFX0lEID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDE2KTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBQRU5ESU5HID0gdm9pZCAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xuXG52YXIgR0VUX1RIRU5fRVJST1IgPSBuZXcgRXJyb3JPYmplY3QoKTtcblxuZnVuY3Rpb24gc2VsZkZ1bGZpbGxtZW50KCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIllvdSBjYW5ub3QgcmVzb2x2ZSBhIHByb21pc2Ugd2l0aCBpdHNlbGZcIik7XG59XG5cbmZ1bmN0aW9uIGNhbm5vdFJldHVybk93bigpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGF0IHNhbWUgcHJvbWlzZS4nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGhlbihwcm9taXNlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBHRVRfVEhFTl9FUlJPUi5lcnJvciA9IGVycm9yO1xuICAgIHJldHVybiBHRVRfVEhFTl9FUlJPUjtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlUaGVuKHRoZW4sIHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpIHtcbiAgdHJ5IHtcbiAgICB0aGVuLmNhbGwodmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUsIHRoZW4pIHtcbiAgYXNhcChmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgIHZhciBzZWFsZWQgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3IgPSB0cnlUaGVuKHRoZW4sIHRoZW5hYmxlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmIChzZWFsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgIGlmICh0aGVuYWJsZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgX3Jlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuXG4gICAgICBfcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSwgJ1NldHRsZTogJyArIChwcm9taXNlLl9sYWJlbCB8fCAnIHVua25vd24gcHJvbWlzZScpKTtcblxuICAgIGlmICghc2VhbGVkICYmIGVycm9yKSB7XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgX3JlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgfVxuICB9LCBwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUpIHtcbiAgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gRlVMRklMTEVEKSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgfSBlbHNlIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgX3JlamVjdChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBzdWJzY3JpYmUodGhlbmFibGUsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gX3Jlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJldHVybiBfcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuJCQpIHtcbiAgaWYgKG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IgPT09IHByb21pc2UuY29uc3RydWN0b3IgJiYgdGhlbiQkID09PSB0aGVuICYmIG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IucmVzb2x2ZSA9PT0gcmVzb2x2ZSkge1xuICAgIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0aGVuJCQgPT09IEdFVF9USEVOX0VSUk9SKSB7XG4gICAgICBfcmVqZWN0KHByb21pc2UsIEdFVF9USEVOX0VSUk9SLmVycm9yKTtcbiAgICB9IGVsc2UgaWYgKHRoZW4kJCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih0aGVuJCQpKSB7XG4gICAgICBoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX3Jlc29sdmUocHJvbWlzZSwgdmFsdWUpIHtcbiAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgX3JlamVjdChwcm9taXNlLCBzZWxmRnVsZmlsbG1lbnQoKSk7XG4gIH0gZWxzZSBpZiAob2JqZWN0T3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlLCBnZXRUaGVuKHZhbHVlKSk7XG4gIH0gZWxzZSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG4gIGlmIChwcm9taXNlLl9vbmVycm9yKSB7XG4gICAgcHJvbWlzZS5fb25lcnJvcihwcm9taXNlLl9yZXN1bHQpO1xuICB9XG5cbiAgcHVibGlzaChwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gZnVsZmlsbChwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm9taXNlLl9yZXN1bHQgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fc3RhdGUgPSBGVUxGSUxMRUQ7XG5cbiAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgIGFzYXAocHVibGlzaCwgcHJvbWlzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3JlamVjdChwcm9taXNlLCByZWFzb24pIHtcbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHByb21pc2UuX3N0YXRlID0gUkVKRUNURUQ7XG4gIHByb21pc2UuX3Jlc3VsdCA9IHJlYXNvbjtcblxuICBhc2FwKHB1Ymxpc2hSZWplY3Rpb24sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgdmFyIF9zdWJzY3JpYmVycyA9IHBhcmVudC5fc3Vic2NyaWJlcnM7XG4gIHZhciBsZW5ndGggPSBfc3Vic2NyaWJlcnMubGVuZ3RoO1xuXG4gIHBhcmVudC5fb25lcnJvciA9IG51bGw7XG5cbiAgX3N1YnNjcmliZXJzW2xlbmd0aF0gPSBjaGlsZDtcbiAgX3N1YnNjcmliZXJzW2xlbmd0aCArIEZVTEZJTExFRF0gPSBvbkZ1bGZpbGxtZW50O1xuICBfc3Vic2NyaWJlcnNbbGVuZ3RoICsgUkVKRUNURURdID0gb25SZWplY3Rpb247XG5cbiAgaWYgKGxlbmd0aCA9PT0gMCAmJiBwYXJlbnQuX3N0YXRlKSB7XG4gICAgYXNhcChwdWJsaXNoLCBwYXJlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2gocHJvbWlzZSkge1xuICB2YXIgc3Vic2NyaWJlcnMgPSBwcm9taXNlLl9zdWJzY3JpYmVycztcbiAgdmFyIHNldHRsZWQgPSBwcm9taXNlLl9zdGF0ZTtcblxuICBpZiAoc3Vic2NyaWJlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNoaWxkID0gdW5kZWZpbmVkLFxuICAgICAgY2FsbGJhY2sgPSB1bmRlZmluZWQsXG4gICAgICBkZXRhaWwgPSBwcm9taXNlLl9yZXN1bHQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkgKz0gMykge1xuICAgIGNoaWxkID0gc3Vic2NyaWJlcnNbaV07XG4gICAgY2FsbGJhY2sgPSBzdWJzY3JpYmVyc1tpICsgc2V0dGxlZF07XG5cbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIGNoaWxkLCBjYWxsYmFjaywgZGV0YWlsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soZGV0YWlsKTtcbiAgICB9XG4gIH1cblxuICBwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggPSAwO1xufVxuXG5mdW5jdGlvbiBFcnJvck9iamVjdCgpIHtcbiAgdGhpcy5lcnJvciA9IG51bGw7XG59XG5cbnZhciBUUllfQ0FUQ0hfRVJST1IgPSBuZXcgRXJyb3JPYmplY3QoKTtcblxuZnVuY3Rpb24gdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCkge1xuICB0cnkge1xuICAgIHJldHVybiBjYWxsYmFjayhkZXRhaWwpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgVFJZX0NBVENIX0VSUk9SLmVycm9yID0gZTtcbiAgICByZXR1cm4gVFJZX0NBVENIX0VSUk9SO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIHByb21pc2UsIGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgdmFyIGhhc0NhbGxiYWNrID0gaXNGdW5jdGlvbihjYWxsYmFjayksXG4gICAgICB2YWx1ZSA9IHVuZGVmaW5lZCxcbiAgICAgIGVycm9yID0gdW5kZWZpbmVkLFxuICAgICAgc3VjY2VlZGVkID0gdW5kZWZpbmVkLFxuICAgICAgZmFpbGVkID0gdW5kZWZpbmVkO1xuXG4gIGlmIChoYXNDYWxsYmFjaykge1xuICAgIHZhbHVlID0gdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCk7XG5cbiAgICBpZiAodmFsdWUgPT09IFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgIGVycm9yID0gdmFsdWUuZXJyb3I7XG4gICAgICB2YWx1ZSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICBfcmVqZWN0KHByb21pc2UsIGNhbm5vdFJldHVybk93bigpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBkZXRhaWw7XG4gICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIC8vIG5vb3BcbiAgfSBlbHNlIGlmIChoYXNDYWxsYmFjayAmJiBzdWNjZWVkZWQpIHtcbiAgICAgIF9yZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGZhaWxlZCkge1xuICAgICAgX3JlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBGVUxGSUxMRUQpIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gUkVKRUNURUQpIHtcbiAgICAgIF9yZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZVByb21pc2UocHJvbWlzZSwgcmVzb2x2ZXIpIHtcbiAgdHJ5IHtcbiAgICByZXNvbHZlcihmdW5jdGlvbiByZXNvbHZlUHJvbWlzZSh2YWx1ZSkge1xuICAgICAgX3Jlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIHJlamVjdFByb21pc2UocmVhc29uKSB7XG4gICAgICBfcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBfcmVqZWN0KHByb21pc2UsIGUpO1xuICB9XG59XG5cbnZhciBpZCA9IDA7XG5mdW5jdGlvbiBuZXh0SWQoKSB7XG4gIHJldHVybiBpZCsrO1xufVxuXG5mdW5jdGlvbiBtYWtlUHJvbWlzZShwcm9taXNlKSB7XG4gIHByb21pc2VbUFJPTUlTRV9JRF0gPSBpZCsrO1xuICBwcm9taXNlLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gdW5kZWZpbmVkO1xuICBwcm9taXNlLl9zdWJzY3JpYmVycyA9IFtdO1xufVxuXG5mdW5jdGlvbiBFbnVtZXJhdG9yKENvbnN0cnVjdG9yLCBpbnB1dCkge1xuICB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcblxuICBpZiAoIXRoaXMucHJvbWlzZVtQUk9NSVNFX0lEXSkge1xuICAgIG1ha2VQcm9taXNlKHRoaXMucHJvbWlzZSk7XG4gIH1cblxuICBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuICAgIHRoaXMubGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgIHRoaXMuX3JlbWFpbmluZyA9IGlucHV0Lmxlbmd0aDtcblxuICAgIHRoaXMuX3Jlc3VsdCA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDA7XG4gICAgICB0aGlzLl9lbnVtZXJhdGUoKTtcbiAgICAgIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIF9yZWplY3QodGhpcy5wcm9taXNlLCB2YWxpZGF0aW9uRXJyb3IoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICByZXR1cm4gbmV3IEVycm9yKCdBcnJheSBNZXRob2RzIG11c3QgYmUgcHJvdmlkZWQgYW4gQXJyYXknKTtcbn07XG5cbkVudW1lcmF0b3IucHJvdG90eXBlLl9lbnVtZXJhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgdmFyIF9pbnB1dCA9IHRoaXMuX2lucHV0O1xuXG4gIGZvciAodmFyIGkgPSAwOyB0aGlzLl9zdGF0ZSA9PT0gUEVORElORyAmJiBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLl9lYWNoRW50cnkoX2lucHV0W2ldLCBpKTtcbiAgfVxufTtcblxuRW51bWVyYXRvci5wcm90b3R5cGUuX2VhY2hFbnRyeSA9IGZ1bmN0aW9uIChlbnRyeSwgaSkge1xuICB2YXIgYyA9IHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3I7XG4gIHZhciByZXNvbHZlJCQgPSBjLnJlc29sdmU7XG5cbiAgaWYgKHJlc29sdmUkJCA9PT0gcmVzb2x2ZSkge1xuICAgIHZhciBfdGhlbiA9IGdldFRoZW4oZW50cnkpO1xuXG4gICAgaWYgKF90aGVuID09PSB0aGVuICYmIGVudHJ5Ll9zdGF0ZSAhPT0gUEVORElORykge1xuICAgICAgdGhpcy5fc2V0dGxlZEF0KGVudHJ5Ll9zdGF0ZSwgaSwgZW50cnkuX3Jlc3VsdCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgX3RoZW4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuICAgICAgdGhpcy5fcmVzdWx0W2ldID0gZW50cnk7XG4gICAgfSBlbHNlIGlmIChjID09PSBQcm9taXNlKSB7XG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBjKG5vb3ApO1xuICAgICAgaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBlbnRyeSwgX3RoZW4pO1xuICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KHByb21pc2UsIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl93aWxsU2V0dGxlQXQobmV3IGMoZnVuY3Rpb24gKHJlc29sdmUkJCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZSQkKGVudHJ5KTtcbiAgICAgIH0pLCBpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fd2lsbFNldHRsZUF0KHJlc29sdmUkJChlbnRyeSksIGkpO1xuICB9XG59O1xuXG5FbnVtZXJhdG9yLnByb3RvdHlwZS5fc2V0dGxlZEF0ID0gZnVuY3Rpb24gKHN0YXRlLCBpLCB2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcblxuICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IFBFTkRJTkcpIHtcbiAgICB0aGlzLl9yZW1haW5pbmctLTtcblxuICAgIGlmIChzdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICAgIF9yZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXN1bHRbaV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICB9XG59O1xuXG5FbnVtZXJhdG9yLnByb3RvdHlwZS5fd2lsbFNldHRsZUF0ID0gZnVuY3Rpb24gKHByb21pc2UsIGkpIHtcbiAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXG4gIHN1YnNjcmliZShwcm9taXNlLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoRlVMRklMTEVELCBpLCB2YWx1ZSk7XG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICByZXR1cm4gZW51bWVyYXRvci5fc2V0dGxlZEF0KFJFSkVDVEVELCBpLCByZWFzb24pO1xuICB9KTtcbn07XG5cbi8qKlxuICBgUHJvbWlzZS5hbGxgIGFjY2VwdHMgYW4gYXJyYXkgb2YgcHJvbWlzZXMsIGFuZCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2hcbiAgaXMgZnVsZmlsbGVkIHdpdGggYW4gYXJyYXkgb2YgZnVsZmlsbG1lbnQgdmFsdWVzIGZvciB0aGUgcGFzc2VkIHByb21pc2VzLCBvclxuICByZWplY3RlZCB3aXRoIHRoZSByZWFzb24gb2YgdGhlIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIGJlIHJlamVjdGVkLiBJdCBjYXN0cyBhbGxcbiAgZWxlbWVudHMgb2YgdGhlIHBhc3NlZCBpdGVyYWJsZSB0byBwcm9taXNlcyBhcyBpdCBydW5zIHRoaXMgYWxnb3JpdGhtLlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICBsZXQgcHJvbWlzZTIgPSByZXNvbHZlKDIpO1xuICBsZXQgcHJvbWlzZTMgPSByZXNvbHZlKDMpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gVGhlIGFycmF5IGhlcmUgd291bGQgYmUgWyAxLCAyLCAzIF07XG4gIH0pO1xuICBgYGBcblxuICBJZiBhbnkgb2YgdGhlIGBwcm9taXNlc2AgZ2l2ZW4gdG8gYGFsbGAgYXJlIHJlamVjdGVkLCB0aGUgZmlyc3QgcHJvbWlzZVxuICB0aGF0IGlzIHJlamVjdGVkIHdpbGwgYmUgZ2l2ZW4gYXMgYW4gYXJndW1lbnQgdG8gdGhlIHJldHVybmVkIHByb21pc2VzJ3NcbiAgcmVqZWN0aW9uIGhhbmRsZXIuIEZvciBleGFtcGxlOlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICBsZXQgcHJvbWlzZTIgPSByZWplY3QobmV3IEVycm9yKFwiMlwiKSk7XG4gIGxldCBwcm9taXNlMyA9IHJlamVjdChuZXcgRXJyb3IoXCIzXCIpKTtcbiAgbGV0IHByb21pc2VzID0gWyBwcm9taXNlMSwgcHJvbWlzZTIsIHByb21pc2UzIF07XG5cbiAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zIGJlY2F1c2UgdGhlcmUgYXJlIHJlamVjdGVkIHByb21pc2VzIVxuICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgIC8vIGVycm9yLm1lc3NhZ2UgPT09IFwiMlwiXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIGFsbFxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IGVudHJpZXMgYXJyYXkgb2YgcHJvbWlzZXNcbiAgQHBhcmFtIHtTdHJpbmd9IGxhYmVsIG9wdGlvbmFsIHN0cmluZyBmb3IgbGFiZWxpbmcgdGhlIHByb21pc2UuXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIGFsbCBgcHJvbWlzZXNgIGhhdmUgYmVlblxuICBmdWxmaWxsZWQsIG9yIHJlamVjdGVkIGlmIGFueSBvZiB0aGVtIGJlY29tZSByZWplY3RlZC5cbiAgQHN0YXRpY1xuKi9cbmZ1bmN0aW9uIGFsbChlbnRyaWVzKSB7XG4gIHJldHVybiBuZXcgRW51bWVyYXRvcih0aGlzLCBlbnRyaWVzKS5wcm9taXNlO1xufVxuXG4vKipcbiAgYFByb21pc2UucmFjZWAgcmV0dXJucyBhIG5ldyBwcm9taXNlIHdoaWNoIGlzIHNldHRsZWQgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZVxuICBmaXJzdCBwYXNzZWQgcHJvbWlzZSB0byBzZXR0bGUuXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAxJyk7XG4gICAgfSwgMjAwKTtcbiAgfSk7XG5cbiAgbGV0IHByb21pc2UyID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDInKTtcbiAgICB9LCAxMDApO1xuICB9KTtcblxuICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyByZXN1bHQgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgaXQgd2FzIHJlc29sdmVkIGJlZm9yZSBwcm9taXNlMVxuICAgIC8vIHdhcyByZXNvbHZlZC5cbiAgfSk7XG4gIGBgYFxuXG4gIGBQcm9taXNlLnJhY2VgIGlzIGRldGVybWluaXN0aWMgaW4gdGhhdCBvbmx5IHRoZSBzdGF0ZSBvZiB0aGUgZmlyc3RcbiAgc2V0dGxlZCBwcm9taXNlIG1hdHRlcnMuIEZvciBleGFtcGxlLCBldmVuIGlmIG90aGVyIHByb21pc2VzIGdpdmVuIHRvIHRoZVxuICBgcHJvbWlzZXNgIGFycmF5IGFyZ3VtZW50IGFyZSByZXNvbHZlZCwgYnV0IHRoZSBmaXJzdCBzZXR0bGVkIHByb21pc2UgaGFzXG4gIGJlY29tZSByZWplY3RlZCBiZWZvcmUgdGhlIG90aGVyIHByb21pc2VzIGJlY2FtZSBmdWxmaWxsZWQsIHRoZSByZXR1cm5lZFxuICBwcm9taXNlIHdpbGwgYmVjb21lIHJlamVjdGVkOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ3Byb21pc2UgMicpKTtcbiAgICB9LCAxMDApO1xuICB9KTtcblxuICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVuc1xuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAncHJvbWlzZSAyJyBiZWNhdXNlIHByb21pc2UgMiBiZWNhbWUgcmVqZWN0ZWQgYmVmb3JlXG4gICAgLy8gcHJvbWlzZSAxIGJlY2FtZSBmdWxmaWxsZWRcbiAgfSk7XG4gIGBgYFxuXG4gIEFuIGV4YW1wbGUgcmVhbC13b3JsZCB1c2UgY2FzZSBpcyBpbXBsZW1lbnRpbmcgdGltZW91dHM6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBQcm9taXNlLnJhY2UoW2FqYXgoJ2Zvby5qc29uJyksIHRpbWVvdXQoNTAwMCldKVxuICBgYGBcblxuICBAbWV0aG9kIHJhY2VcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FycmF5fSBwcm9taXNlcyBhcnJheSBvZiBwcm9taXNlcyB0byBvYnNlcnZlXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHdoaWNoIHNldHRsZXMgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZSBmaXJzdCBwYXNzZWRcbiAgcHJvbWlzZSB0byBzZXR0bGUuXG4qL1xuZnVuY3Rpb24gcmFjZShlbnRyaWVzKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKCFpc0FycmF5KGVudHJpZXMpKSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAoXywgcmVqZWN0KSB7XG4gICAgICByZXR1cm4gcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gcmFjZS4nKSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gZW50cmllcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnJlc29sdmUoZW50cmllc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZWplY3RgIHJldHVybnMgYSBwcm9taXNlIHJlamVjdGVkIHdpdGggdGhlIHBhc3NlZCBgcmVhc29uYC5cbiAgSXQgaXMgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgfSk7XG4gIGBgYFxuXG4gIEluc3RlYWQgb2Ygd3JpdGluZyB0aGUgYWJvdmUsIHlvdXIgY29kZSBub3cgc2ltcGx5IGJlY29tZXMgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdXSE9PUFMnKSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgcmVqZWN0XG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHJlYXNvbiB2YWx1ZSB0aGF0IHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aC5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgZ2l2ZW4gYHJlYXNvbmAuXG4qL1xuZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcbiAgX3JlamVjdChwcm9taXNlLCByZWFzb24pO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gbmVlZHNSZXNvbHZlcigpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xufVxuXG5mdW5jdGlvbiBuZWVkc05ldygpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbn1cblxuLyoqXG4gIFByb21pc2Ugb2JqZWN0cyByZXByZXNlbnQgdGhlIGV2ZW50dWFsIHJlc3VsdCBvZiBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLiBUaGVcbiAgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCwgd2hpY2hcbiAgcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGUgcmVhc29uXG4gIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXG4gIFRlcm1pbm9sb2d5XG4gIC0tLS0tLS0tLS0tXG5cbiAgLSBgcHJvbWlzZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHdpdGggYSBgdGhlbmAgbWV0aG9kIHdob3NlIGJlaGF2aW9yIGNvbmZvcm1zIHRvIHRoaXMgc3BlY2lmaWNhdGlvbi5cbiAgLSBgdGhlbmFibGVgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB0aGF0IGRlZmluZXMgYSBgdGhlbmAgbWV0aG9kLlxuICAtIGB2YWx1ZWAgaXMgYW55IGxlZ2FsIEphdmFTY3JpcHQgdmFsdWUgKGluY2x1ZGluZyB1bmRlZmluZWQsIGEgdGhlbmFibGUsIG9yIGEgcHJvbWlzZSkuXG4gIC0gYGV4Y2VwdGlvbmAgaXMgYSB2YWx1ZSB0aGF0IGlzIHRocm93biB1c2luZyB0aGUgdGhyb3cgc3RhdGVtZW50LlxuICAtIGByZWFzb25gIGlzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2h5IGEgcHJvbWlzZSB3YXMgcmVqZWN0ZWQuXG4gIC0gYHNldHRsZWRgIHRoZSBmaW5hbCByZXN0aW5nIHN0YXRlIG9mIGEgcHJvbWlzZSwgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuXG4gIEEgcHJvbWlzZSBjYW4gYmUgaW4gb25lIG9mIHRocmVlIHN0YXRlczogcGVuZGluZywgZnVsZmlsbGVkLCBvciByZWplY3RlZC5cblxuICBQcm9taXNlcyB0aGF0IGFyZSBmdWxmaWxsZWQgaGF2ZSBhIGZ1bGZpbGxtZW50IHZhbHVlIGFuZCBhcmUgaW4gdGhlIGZ1bGZpbGxlZFxuICBzdGF0ZS4gIFByb21pc2VzIHRoYXQgYXJlIHJlamVjdGVkIGhhdmUgYSByZWplY3Rpb24gcmVhc29uIGFuZCBhcmUgaW4gdGhlXG4gIHJlamVjdGVkIHN0YXRlLiAgQSBmdWxmaWxsbWVudCB2YWx1ZSBpcyBuZXZlciBhIHRoZW5hYmxlLlxuXG4gIFByb21pc2VzIGNhbiBhbHNvIGJlIHNhaWQgdG8gKnJlc29sdmUqIGEgdmFsdWUuICBJZiB0aGlzIHZhbHVlIGlzIGFsc28gYVxuICBwcm9taXNlLCB0aGVuIHRoZSBvcmlnaW5hbCBwcm9taXNlJ3Mgc2V0dGxlZCBzdGF0ZSB3aWxsIG1hdGNoIHRoZSB2YWx1ZSdzXG4gIHNldHRsZWQgc3RhdGUuICBTbyBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2lsbFxuICBpdHNlbGYgcmVqZWN0LCBhbmQgYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCBmdWxmaWxscyB3aWxsXG4gIGl0c2VsZiBmdWxmaWxsLlxuXG5cbiAgQmFzaWMgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLVxuXG4gIGBgYGpzXG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgLy8gb24gc3VjY2Vzc1xuICAgIHJlc29sdmUodmFsdWUpO1xuXG4gICAgLy8gb24gZmFpbHVyZVxuICAgIHJlamVjdChyZWFzb24pO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIEFkdmFuY2VkIFVzYWdlOlxuICAtLS0tLS0tLS0tLS0tLS1cblxuICBQcm9taXNlcyBzaGluZSB3aGVuIGFic3RyYWN0aW5nIGF3YXkgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBzdWNoIGFzXG4gIGBYTUxIdHRwUmVxdWVzdGBzLlxuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGdldEpTT04odXJsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZXI7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICB4aHIuc2VuZCgpO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignZ2V0SlNPTjogYCcgKyB1cmwgKyAnYCBmYWlsZWQgd2l0aCBzdGF0dXM6IFsnICsgdGhpcy5zdGF0dXMgKyAnXScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBnZXRKU09OKCcvcG9zdHMuanNvbicpLnRoZW4oZnVuY3Rpb24oanNvbikge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgVW5saWtlIGNhbGxiYWNrcywgcHJvbWlzZXMgYXJlIGdyZWF0IGNvbXBvc2FibGUgcHJpbWl0aXZlcy5cblxuICBgYGBqc1xuICBQcm9taXNlLmFsbChbXG4gICAgZ2V0SlNPTignL3Bvc3RzJyksXG4gICAgZ2V0SlNPTignL2NvbW1lbnRzJylcbiAgXSkudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuICAgIHZhbHVlc1swXSAvLyA9PiBwb3N0c0pTT05cbiAgICB2YWx1ZXNbMV0gLy8gPT4gY29tbWVudHNKU09OXG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9KTtcbiAgYGBgXG5cbiAgQGNsYXNzIFByb21pc2VcbiAgQHBhcmFtIHtmdW5jdGlvbn0gcmVzb2x2ZXJcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAY29uc3RydWN0b3JcbiovXG5mdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyKSB7XG4gIHRoaXNbUFJPTUlTRV9JRF0gPSBuZXh0SWQoKTtcbiAgdGhpcy5fcmVzdWx0ID0gdGhpcy5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG5cbiAgaWYgKG5vb3AgIT09IHJlc29sdmVyKSB7XG4gICAgdHlwZW9mIHJlc29sdmVyICE9PSAnZnVuY3Rpb24nICYmIG5lZWRzUmVzb2x2ZXIoKTtcbiAgICB0aGlzIGluc3RhbmNlb2YgUHJvbWlzZSA/IGluaXRpYWxpemVQcm9taXNlKHRoaXMsIHJlc29sdmVyKSA6IG5lZWRzTmV3KCk7XG4gIH1cbn1cblxuUHJvbWlzZS5hbGwgPSBhbGw7XG5Qcm9taXNlLnJhY2UgPSByYWNlO1xuUHJvbWlzZS5yZXNvbHZlID0gcmVzb2x2ZTtcblByb21pc2UucmVqZWN0ID0gcmVqZWN0O1xuUHJvbWlzZS5fc2V0U2NoZWR1bGVyID0gc2V0U2NoZWR1bGVyO1xuUHJvbWlzZS5fc2V0QXNhcCA9IHNldEFzYXA7XG5Qcm9taXNlLl9hc2FwID0gYXNhcDtcblxuUHJvbWlzZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQcm9taXNlLFxuXG4gIC8qKlxuICAgIFRoZSBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLFxuICAgIHdoaWNoIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlXG4gICAgcmVhc29uIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcbiAgICAgIC8vIHVzZXIgaXMgYXZhaWxhYmxlXG4gICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIENoYWluaW5nXG4gICAgLS0tLS0tLS1cbiAgXG4gICAgVGhlIHJldHVybiB2YWx1ZSBvZiBgdGhlbmAgaXMgaXRzZWxmIGEgcHJvbWlzZS4gIFRoaXMgc2Vjb25kLCAnZG93bnN0cmVhbSdcbiAgICBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZmlyc3QgcHJvbWlzZSdzIGZ1bGZpbGxtZW50XG4gICAgb3IgcmVqZWN0aW9uIGhhbmRsZXIsIG9yIHJlamVjdGVkIGlmIHRoZSBoYW5kbGVyIHRocm93cyBhbiBleGNlcHRpb24uXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICByZXR1cm4gdXNlci5uYW1lO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgICB9KS50aGVuKGZ1bmN0aW9uICh1c2VyTmFtZSkge1xuICAgICAgLy8gSWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGB1c2VyTmFtZWAgd2lsbCBiZSB0aGUgdXNlcidzIG5hbWUsIG90aGVyd2lzZSBpdFxuICAgICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gICAgfSk7XG4gIFxuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgLy8gaWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGByZWFzb25gIHdpbGwgYmUgJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jy5cbiAgICAgIC8vIElmIGBmaW5kVXNlcmAgcmVqZWN0ZWQsIGByZWFzb25gIHdpbGwgYmUgJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknLlxuICAgIH0pO1xuICAgIGBgYFxuICAgIElmIHRoZSBkb3duc3RyZWFtIHByb21pc2UgZG9lcyBub3Qgc3BlY2lmeSBhIHJlamVjdGlvbiBoYW5kbGVyLCByZWplY3Rpb24gcmVhc29ucyB3aWxsIGJlIHByb3BhZ2F0ZWQgZnVydGhlciBkb3duc3RyZWFtLlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgdGhyb3cgbmV3IFBlZGFnb2dpY2FsRXhjZXB0aW9uKCdVcHN0cmVhbSBlcnJvcicpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAvLyBUaGUgYFBlZGdhZ29jaWFsRXhjZXB0aW9uYCBpcyBwcm9wYWdhdGVkIGFsbCB0aGUgd2F5IGRvd24gdG8gaGVyZVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBBc3NpbWlsYXRpb25cbiAgICAtLS0tLS0tLS0tLS1cbiAgXG4gICAgU29tZXRpbWVzIHRoZSB2YWx1ZSB5b3Ugd2FudCB0byBwcm9wYWdhdGUgdG8gYSBkb3duc3RyZWFtIHByb21pc2UgY2FuIG9ubHkgYmVcbiAgICByZXRyaWV2ZWQgYXN5bmNocm9ub3VzbHkuIFRoaXMgY2FuIGJlIGFjaGlldmVkIGJ5IHJldHVybmluZyBhIHByb21pc2UgaW4gdGhlXG4gICAgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uIGhhbmRsZXIuIFRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCB0aGVuIGJlIHBlbmRpbmdcbiAgICB1bnRpbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBzZXR0bGVkLiBUaGlzIGlzIGNhbGxlZCAqYXNzaW1pbGF0aW9uKi5cbiAgXG4gICAgYGBganNcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgICAgLy8gVGhlIHVzZXIncyBjb21tZW50cyBhcmUgbm93IGF2YWlsYWJsZVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBJZiB0aGUgYXNzaW1saWF0ZWQgcHJvbWlzZSByZWplY3RzLCB0aGVuIHRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCBhbHNvIHJlamVjdC5cbiAgXG4gICAgYGBganNcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCBmdWxmaWxscywgd2UnbGwgaGF2ZSB0aGUgdmFsdWUgaGVyZVxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgcmVqZWN0cywgd2UnbGwgaGF2ZSB0aGUgcmVhc29uIGhlcmVcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgU2ltcGxlIEV4YW1wbGVcbiAgICAtLS0tLS0tLS0tLS0tLVxuICBcbiAgICBTeW5jaHJvbm91cyBFeGFtcGxlXG4gIFxuICAgIGBgYGphdmFzY3JpcHRcbiAgICBsZXQgcmVzdWx0O1xuICBcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gZmluZFJlc3VsdCgpO1xuICAgICAgLy8gc3VjY2Vzc1xuICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAvLyBmYWlsdXJlXG4gICAgfVxuICAgIGBgYFxuICBcbiAgICBFcnJiYWNrIEV4YW1wbGVcbiAgXG4gICAgYGBganNcbiAgICBmaW5kUmVzdWx0KGZ1bmN0aW9uKHJlc3VsdCwgZXJyKXtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgfVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBQcm9taXNlIEV4YW1wbGU7XG4gIFxuICAgIGBgYGphdmFzY3JpcHRcbiAgICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgLy8gc3VjY2Vzc1xuICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAvLyBmYWlsdXJlXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEFkdmFuY2VkIEV4YW1wbGVcbiAgICAtLS0tLS0tLS0tLS0tLVxuICBcbiAgICBTeW5jaHJvbm91cyBFeGFtcGxlXG4gIFxuICAgIGBgYGphdmFzY3JpcHRcbiAgICBsZXQgYXV0aG9yLCBib29rcztcbiAgXG4gICAgdHJ5IHtcbiAgICAgIGF1dGhvciA9IGZpbmRBdXRob3IoKTtcbiAgICAgIGJvb2tzICA9IGZpbmRCb29rc0J5QXV0aG9yKGF1dGhvcik7XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9XG4gICAgYGBgXG4gIFxuICAgIEVycmJhY2sgRXhhbXBsZVxuICBcbiAgICBgYGBqc1xuICBcbiAgICBmdW5jdGlvbiBmb3VuZEJvb2tzKGJvb2tzKSB7XG4gIFxuICAgIH1cbiAgXG4gICAgZnVuY3Rpb24gZmFpbHVyZShyZWFzb24pIHtcbiAgXG4gICAgfVxuICBcbiAgICBmaW5kQXV0aG9yKGZ1bmN0aW9uKGF1dGhvciwgZXJyKXtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZpbmRCb29va3NCeUF1dGhvcihhdXRob3IsIGZ1bmN0aW9uKGJvb2tzLCBlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3VuZEJvb2tzKGJvb2tzKTtcbiAgICAgICAgICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlKHJlYXNvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIFByb21pc2UgRXhhbXBsZTtcbiAgXG4gICAgYGBgamF2YXNjcmlwdFxuICAgIGZpbmRBdXRob3IoKS5cbiAgICAgIHRoZW4oZmluZEJvb2tzQnlBdXRob3IpLlxuICAgICAgdGhlbihmdW5jdGlvbihib29rcyl7XG4gICAgICAgIC8vIGZvdW5kIGJvb2tzXG4gICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEBtZXRob2QgdGhlblxuICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uRnVsZmlsbGVkXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3RlZFxuICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuICB0aGVuOiB0aGVuLFxuXG4gIC8qKlxuICAgIGBjYXRjaGAgaXMgc2ltcGx5IHN1Z2FyIGZvciBgdGhlbih1bmRlZmluZWQsIG9uUmVqZWN0aW9uKWAgd2hpY2ggbWFrZXMgaXQgdGhlIHNhbWVcbiAgICBhcyB0aGUgY2F0Y2ggYmxvY2sgb2YgYSB0cnkvY2F0Y2ggc3RhdGVtZW50LlxuICBcbiAgICBgYGBqc1xuICAgIGZ1bmN0aW9uIGZpbmRBdXRob3IoKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY291bGRuJ3QgZmluZCB0aGF0IGF1dGhvcicpO1xuICAgIH1cbiAgXG4gICAgLy8gc3luY2hyb25vdXNcbiAgICB0cnkge1xuICAgICAgZmluZEF1dGhvcigpO1xuICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgIH1cbiAgXG4gICAgLy8gYXN5bmMgd2l0aCBwcm9taXNlc1xuICAgIGZpbmRBdXRob3IoKVsnY2F0Y2gnXShmdW5jdGlvbihyZWFzb24pe1xuICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQG1ldGhvZCBjYXRjaFxuICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0aW9uXG4gICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG4gICdjYXRjaCc6IGZ1bmN0aW9uIF9jYXRjaChvblJlamVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBwb2x5ZmlsbCgpIHtcbiAgICB2YXIgbG9jYWwgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbG9jYWwgPSBnbG9iYWw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbG9jYWwgPSBzZWxmO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2NhbCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9seWZpbGwgZmFpbGVkIGJlY2F1c2UgZ2xvYmFsIG9iamVjdCBpcyB1bmF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgUCA9IGxvY2FsLlByb21pc2U7XG5cbiAgICBpZiAoUCkge1xuICAgICAgICB2YXIgcHJvbWlzZVRvU3RyaW5nID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb21pc2VUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQLnJlc29sdmUoKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIHNpbGVudGx5IGlnbm9yZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9taXNlVG9TdHJpbmcgPT09ICdbb2JqZWN0IFByb21pc2VdJyAmJiAhUC5jYXN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsb2NhbC5Qcm9taXNlID0gUHJvbWlzZTtcbn1cblxucG9seWZpbGwoKTtcbi8vIFN0cmFuZ2UgY29tcGF0Li5cblByb21pc2UucG9seWZpbGwgPSBwb2x5ZmlsbDtcblByb21pc2UuUHJvbWlzZSA9IFByb21pc2U7XG5cbnJldHVybiBQcm9taXNlO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXM2LXByb21pc2UubWFwIiwiJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgcHJvbWlzZUV4dGVuc2lvbnNfMSA9IHJlcXVpcmUoXCIuLy4uL2hlbHBlcnMvcHJvbWlzZUV4dGVuc2lvbnNcIik7XHJcbnZhciBhY3Rpdml0eU1hbmFnZW1lbnRBUElfMSA9IHJlcXVpcmUoXCIuL2FjdGl2aXR5TWFuYWdlbWVudEFQSVwiKTtcclxudmFyIGFjdGl2aXR5QUdNXzEgPSByZXF1aXJlKFwiLi4vY29yZS9hY3Rpdml0eUFHTVwiKTtcclxudmFyIEFjdGl2aXR5QVBJID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFjdGl2aXR5QVBJKG1hbmFnZXIsIG15KSB7XHJcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gXCIyLjQuMVwiO1xyXG4gICAgICAgIHRoaXMuX19tZ3IgPSBtYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMuX215ID0gbXk7XHJcbiAgICAgICAgdGhpcy5hbGwgPSBuZXcgYWN0aXZpdHlNYW5hZ2VtZW50QVBJXzEuQWN0aXZpdHlNYW5hZ2VtZW50QVBJKG1hbmFnZXIsIG15KTtcclxuICAgIH1cclxuICAgIEFjdGl2aXR5QVBJLnByb3RvdHlwZS5yZWFkeSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9fbWdyLnJlYWR5KClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMpO1xyXG4gICAgICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2VFeHRlbnNpb25zXzEubm9kZWlmeShwcm9taXNlLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5QVBJLnByb3RvdHlwZSwgXCJteVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9teTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eUFQSS5wcm90b3R5cGUsIFwiYXdhcmVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbXkud2luZG93ICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHlBUEkucHJvdG90eXBlLCBcImluQWN0aXZpdHlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hd2FyZSAmJiB0aGlzLl9teS5hY3Rpdml0eSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5QVBJLnByb3RvdHlwZSwgXCJhZ21cIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuYXdhcmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLmluQWN0aXZpdHkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYWN0aXZpdHlBR01fMS5BY3Rpdml0eUFHTShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbXkuYWN0aXZpdHkuYWdtO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIEFjdGl2aXR5QVBJO1xyXG59KCkpO1xyXG5leHBvcnRzLkFjdGl2aXR5QVBJID0gQWN0aXZpdHlBUEk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGl2aXR5QVBJLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLy4uL2hlbHBlcnMvdXRpbFwiKTtcclxudmFyIEFjdGl2aXR5TWFuYWdlbWVudEFQSSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBY3Rpdml0eU1hbmFnZW1lbnRBUEkobWFuYWdlciwgbXkpIHtcclxuICAgICAgICB0aGlzLl9tID0gbWFuYWdlcjtcclxuICAgICAgICB0aGlzLl9teSA9IG15O1xyXG4gICAgICAgIHRoaXMuYWN0aXZpdHlUeXBlcyA9IHtcclxuICAgICAgICAgICAgZ2V0OiB0aGlzLl9nZXRBY3Rpdml0eVR5cGVzV3JhcHBlci5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICByZWdpc3RlcjogdGhpcy5fbS5yZWdpc3RlckFjdGl2aXR5VHlwZS5iaW5kKHRoaXMuX20pLFxyXG4gICAgICAgICAgICB1bnJlZ2lzdGVyOiB0aGlzLl9tLnVucmVnaXN0ZXJBY3Rpdml0eVR5cGUuYmluZCh0aGlzLl9tKSxcclxuICAgICAgICAgICAgc3Vic2NyaWJlOiB0aGlzLl9tLnN1YnNjcmliZUFjdGl2aXR5VHlwZUV2ZW50cy5iaW5kKHRoaXMuX20pLFxyXG4gICAgICAgICAgICB1bnN1YnNjcmliZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBpbml0aWF0ZTogdGhpcy5fbS5pbml0aWF0ZS5iaW5kKHRoaXMuX20pXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLndpbmRvd1R5cGVzID0ge1xyXG4gICAgICAgICAgICBnZXQ6IHRoaXMuX2dldFdpbmRvd1R5cGVzV3JhcHBlci5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICByZWdpc3RlckZhY3Rvcnk6IHRoaXMuX20ucmVnaXN0ZXJXaW5kb3dGYWN0b3J5LmJpbmQodGhpcy5fbSksXHJcbiAgICAgICAgICAgIHVucmVnaXN0ZXJGYWN0b3J5OiB0aGlzLl9tLnVucmVnaXN0ZXJXaW5kb3dGYWN0b3J5LmJpbmQodGhpcy5fbSksXHJcbiAgICAgICAgICAgIHN1YnNjcmliZTogdGhpcy5fbS5zdWJzY3JpYmVXaW5kb3dUeXBlRXZlbnRzLmJpbmQodGhpcy5fbSksXHJcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlOiB1bmRlZmluZWRcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMud2luZG93cyA9IHtcclxuICAgICAgICAgICAgZ2V0OiB0aGlzLl9tLmdldFdpbmRvd3MuYmluZCh0aGlzLl9tKSxcclxuICAgICAgICAgICAgc3Vic2NyaWJlOiB0aGlzLl9tLnN1YnNjcmliZVdpbmRvd0V2ZW50cy5iaW5kKHRoaXMuX20pLFxyXG4gICAgICAgICAgICBhbm5vdW5jZTogdGhpcy5fbS5hbm5vdW5jZVdpbmRvdy5iaW5kKHRoaXMuX20pLFxyXG4gICAgICAgICAgICB1bnN1YnNjcmliZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBjcmVhdGU6IHRoaXMuX20uY3JlYXRlV2luZG93LmJpbmQodGhpcy5fbSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VzID0ge1xyXG4gICAgICAgICAgICBnZXQ6IHRoaXMuX20uZ2V0QWN0aXZpdGllcy5iaW5kKHRoaXMuX20pLFxyXG4gICAgICAgICAgICBzdWJzY3JpYmU6IHRoaXMuX20uc3Vic2NyaWJlQWN0aXZpdHlFdmVudHMuYmluZCh0aGlzLl9tKSxcclxuICAgICAgICAgICAgdW5zdWJzY3JpYmU6IHVuZGVmaW5lZFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBBY3Rpdml0eU1hbmFnZW1lbnRBUEkucHJvdG90eXBlLl9nZXRBY3Rpdml0eVR5cGVzV3JhcHBlciA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQobmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX20uZ2V0QWN0aXZpdHlUeXBlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fbS5nZXRBY3Rpdml0eVR5cGUobmFtZSk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VtZW50QVBJLnByb3RvdHlwZS5fZ2V0V2luZG93VHlwZXNXcmFwcGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChuYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbS5nZXRXaW5kb3dUeXBlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fbS5nZXRXaW5kb3dUeXBlKG5hbWUpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBY3Rpdml0eU1hbmFnZW1lbnRBUEk7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQWN0aXZpdHlNYW5hZ2VtZW50QVBJID0gQWN0aXZpdHlNYW5hZ2VtZW50QVBJO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpdml0eU1hbmFnZW1lbnRBUEkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCIuLy4uL2hlbHBlcnMvbG9nZ2VyXCIpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLy4uL2hlbHBlcnMvdXRpbFwiKTtcclxudmFyIEFjdGl2aXR5TXkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQWN0aXZpdHlNeShtYW5hZ2VyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl9teUFjdGl2aXR5Sm9pbmVkQ2FsbGJhY2tzID0gW107XHJcbiAgICAgICAgdGhpcy5fbXlBY3Rpdml0eVJlbW92ZWRDYWxsYmFja3MgPSBbXTtcclxuICAgICAgICB0aGlzLl9teUNvbnRleHRVcGRhdGVDYWxsYmFja3MgPSBbXTtcclxuICAgICAgICB0aGlzLl9sb2dnZXIgPSBsb2dnZXJfMS5Mb2dnZXIuR2V0KHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX20gPSBtYW5hZ2VyO1xyXG4gICAgICAgIG1hbmFnZXIucmVhZHkoKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYW0pIHtcclxuICAgICAgICAgICAgYW0uc3Vic2NyaWJlQWN0aXZpdHlDb250ZXh0Q2hhbmdlZChfdGhpcy5fc3Vic2NyaWJlTXlDb250ZXh0Q2hhbmdlZC5iaW5kKF90aGlzKSk7XHJcbiAgICAgICAgICAgIGFtLnN1YnNjcmliZVdpbmRvd0V2ZW50cyhfdGhpcy5fc3Vic2NyaWJlTXlXaW5kb3dFdmVudC5iaW5kKF90aGlzKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHlNeS5wcm90b3R5cGUsIFwid2luZG93XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwodGhpcy5fdykpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhbm5vdW5jZWRXaW5kb3dzID0gdGhpcy5fbS5hbm5vdW5jZWRXaW5kb3dzO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFubm91bmNlZFdpbmRvd3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3cgPSBhbm5vdW5jZWRXaW5kb3dzWzBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5TXkucHJvdG90eXBlLCBcImFjdGl2aXR5XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG15V2luID0gdGhpcy53aW5kb3c7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKG15V2luKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbXlXaW4uYWN0aXZpdHk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBBY3Rpdml0eU15LnByb3RvdHlwZS5jcmVhdGVXaW5kb3cgPSBmdW5jdGlvbiAod2luZG93VHlwZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tLmNyZWF0ZVdpbmRvdyh0aGlzLmFjdGl2aXR5LCB3aW5kb3dUeXBlKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU15LnByb3RvdHlwZS5jcmVhdGVTdGFja2VkV2luZG93cyA9IGZ1bmN0aW9uICh3aW5kb3dUeXBlcywgdGltZW91dCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tLmNyZWF0ZVN0YWNrZWRXaW5kb3dzKHRoaXMuYWN0aXZpdHksIHdpbmRvd1R5cGVzLCB0aW1lb3V0KTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHlNeS5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhY3Rpdml0eSA9IHRoaXMuYWN0aXZpdHk7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKGFjdGl2aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhY3Rpdml0eS5jb250ZXh0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQWN0aXZpdHlNeS5wcm90b3R5cGUub25BY3Rpdml0eUpvaW5lZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuX215QWN0aXZpdHlKb2luZWRDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgdmFyIG15V2luID0gdGhpcy53aW5kb3c7XHJcbiAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKG15V2luKSAmJiAhdXRpbC5pc1VuZGVmaW5lZE9yTnVsbChteVdpbi5hY3Rpdml0eSkpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2sobXlXaW4uYWN0aXZpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU15LnByb3RvdHlwZS5vbkFjdGl2aXR5TGVmdCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuX215QWN0aXZpdHlSZW1vdmVkQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TXkucHJvdG90eXBlLm9uQ29udGV4dENoYW5nZWQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLl9teUNvbnRleHRVcGRhdGVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgdmFyIG15V2luID0gdGhpcy53aW5kb3c7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwobXlXaW4pKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFjdGl2aXR5ID0gbXlXaW4uYWN0aXZpdHk7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwoYWN0aXZpdHkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FsbGJhY2soYWN0aXZpdHkuY29udGV4dCwgYWN0aXZpdHkuY29udGV4dCwgW10sIGFjdGl2aXR5KTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU15LnByb3RvdHlwZS5fc3Vic2NyaWJlTXlDb250ZXh0Q2hhbmdlZCA9IGZ1bmN0aW9uIChhY3Rpdml0eSwgY29udGV4dCwgZGVsdGEsIHJlbW92ZWQpIHtcclxuICAgICAgICB2YXIgbXlXaW4gPSB0aGlzLndpbmRvdztcclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbChteVdpbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbXlBY3Rpdml0eSA9IG15V2luLmFjdGl2aXR5O1xyXG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKG15QWN0aXZpdHkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFjdGl2aXR5LmlkICE9PSBteUFjdGl2aXR5LmlkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbm90aWZ5TXlDb250ZXh0Q2hhbmdlZChhY3Rpdml0eSwgY29udGV4dCwgZGVsdGEsIHJlbW92ZWQpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TXkucHJvdG90eXBlLl9zdWJzY3JpYmVNeVdpbmRvd0V2ZW50ID0gZnVuY3Rpb24gKGFjdGl2aXR5LCB3aW5kb3csIGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwodGhpcy53aW5kb3cpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMud2luZG93LmlkICE9PSB3aW5kb3cuaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXZlbnQgPT09IFwiam9pbmVkXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5fbm90aWZ5T25Kb2luZWQoYWN0aXZpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fbm90aWZ5TXlXaW5kb3dFdmVudChhY3Rpdml0eSwgdGhpcy5fbXlBY3Rpdml0eVJlbW92ZWRDYWxsYmFja3MpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU15LnByb3RvdHlwZS5fbm90aWZ5TXlXaW5kb3dFdmVudCA9IGZ1bmN0aW9uIChhY3Rpdml0eSwgY2FsbGJhY2tTdG9yZSkge1xyXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBjYWxsYmFja1N0b3JlLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGNhbGxiYWNrU3RvcmVbaW5kZXhdO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudChhY3Rpdml0eSwgZXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybignZXJyb3IgaW4gdXNlciBjYWxsYmFjayAnICsgZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNeS5wcm90b3R5cGUuX25vdGlmeU15Q29udGV4dENoYW5nZWQgPSBmdW5jdGlvbiAoYWN0aXZpdHksIGNvbnRleHQsIGRlbHRhLCByZW1vdmVkKSB7XHJcbiAgICAgICAgZGVsdGEgPSBkZWx0YSB8fCB7fTtcclxuICAgICAgICByZW1vdmVkID0gcmVtb3ZlZCB8fCBbXTtcclxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fbXlDb250ZXh0VXBkYXRlQ2FsbGJhY2tzLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuX215Q29udGV4dFVwZGF0ZUNhbGxiYWNrc1tpbmRleF07XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50KGNvbnRleHQsIGRlbHRhLCByZW1vdmVkLCBhY3Rpdml0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKCdlcnJvciBpbiB1c2VyIGNhbGxiYWNrICcgKyBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU15LnByb3RvdHlwZS5fbm90aWZ5T25Kb2luZWQgPSBmdW5jdGlvbiAoYWN0aXZpdHkpIHtcclxuICAgICAgICB0aGlzLl9ub3RpZnlNeVdpbmRvd0V2ZW50KGFjdGl2aXR5LCB0aGlzLl9teUFjdGl2aXR5Sm9pbmVkQ2FsbGJhY2tzKTtcclxuICAgICAgICB0aGlzLl9ub3RpZnlNeUNvbnRleHRDaGFuZ2VkKGFjdGl2aXR5LCBhY3Rpdml0eS5jb250ZXh0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQWN0aXZpdHlNeTtcclxufSgpKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzWydkZWZhdWx0J109IEFjdGl2aXR5TXk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGl2aXR5TXlBUEkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBBY3Rpdml0eUNvbmZpZyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBY3Rpdml0eUNvbmZpZygpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBBY3Rpdml0eUNvbmZpZztcclxufSgpKTtcclxuZXhwb3J0cy5BY3Rpdml0eUNvbmZpZyA9IEFjdGl2aXR5Q29uZmlnO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpdml0eUNvbmZpZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxucmVxdWlyZShcImVzNi1wcm9taXNlXCIpO1xyXG52YXIgaGNCcmlkZ2VfMSA9IHJlcXVpcmUoXCIuL2JyaWRnZXMvaGNCcmlkZ2VcIik7XHJcbnZhciBhY3Rpdml0eU1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL2NvcmUvYWN0aXZpdHlNYW5hZ2VyXCIpO1xyXG52YXIgYWN0aXZpdHlNeUFQSV8xID0gcmVxdWlyZShcIi4vQVBJL2FjdGl2aXR5TXlBUElcIik7XHJcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvbG9nZ2VyXCIpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvdXRpbFwiKTtcclxudmFyIGFjdGl2aXR5Q29uZmlnXzEgPSByZXF1aXJlKFwiLi9hY3Rpdml0eUNvbmZpZ1wiKTtcclxudmFyIGFjdGl2aXR5QVBJXzEgPSByZXF1aXJlKFwiLi9BUEkvYWN0aXZpdHlBUElcIik7XHJcbnZhciBhY3Rpdml0eUFHTV8xID0gcmVxdWlyZShcIi4vY29yZS9hY3Rpdml0eUFHTVwiKTtcclxudmFyIGFjdGl2aXR5ID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgY29uZmlnID0gY29uZmlnIHx8IG5ldyBhY3Rpdml0eUNvbmZpZ18xLkFjdGl2aXR5Q29uZmlnO1xyXG4gICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkKGNvbmZpZy5sb2dMZXZlbCkpIHtcclxuICAgICAgICBsb2dnZXJfMS5Mb2dnZXIuTGV2ZWwgPSBjb25maWcubG9nTGV2ZWw7XHJcbiAgICB9XHJcbiAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwoY29uZmlnLmxvZ2dlcikpIHtcclxuICAgICAgICBsb2dnZXJfMS5Mb2dnZXIuR2x1ZUxvZ2dlciA9IGNvbmZpZy5sb2dnZXI7XHJcbiAgICB9XHJcbiAgICB2YXIgYnJpZGdlO1xyXG4gICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkKHdpbmRvdy5odG1sQ29udGFpbmVyKSkge1xyXG4gICAgICAgIGJyaWRnZSA9IG5ldyBoY0JyaWRnZV8xWydkZWZhdWx0J10oKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFjdGl2aXR5IG5vdCBzdXBwb3J0ZWQgaW4gaW4gYnJvd3NlclwiKTtcclxuICAgIH1cclxuICAgIGlmICghYnJpZGdlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBicmlkZ2UgdG8gbmF0aXZlIGFjdGl2aXR5IGlzIG5lZWRlZCB0byBjcmVhdGUgYWN0aXZpdHkgbGliLlwiKTtcclxuICAgIH1cclxuICAgIGFjdGl2aXR5QUdNXzEuQWN0aXZpdHlBR00uQUdNID0gY29uZmlnLmFnbTtcclxuICAgIHZhciBhY3Rpdml0eU1hbmFnZXIgPSBuZXcgYWN0aXZpdHlNYW5hZ2VyXzFbJ2RlZmF1bHQnXShicmlkZ2UsICFjb25maWcuZGlzYWJsZUF1dG9Bbm5vdW5jZSk7XHJcbiAgICB2YXIgbXkgPSBuZXcgYWN0aXZpdHlNeUFQSV8xWydkZWZhdWx0J10oYWN0aXZpdHlNYW5hZ2VyKTtcclxuICAgIHJldHVybiBuZXcgYWN0aXZpdHlBUElfMS5BY3Rpdml0eUFQSShhY3Rpdml0eU1hbmFnZXIsIG15KTtcclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBhY3Rpdml0eTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0aXZpdHlNb2R1bGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBlbnRpdHlFdmVudF8xID0gcmVxdWlyZShcIi4uL2NvbnRyYWN0cy9lbnRpdHlFdmVudFwiKTtcclxudmFyIGFjdGl2aXR5U3RhdHVzXzEgPSByZXF1aXJlKFwiLi4vY29udHJhY3RzL2FjdGl2aXR5U3RhdHVzXCIpO1xyXG52YXIgYWN0aXZpdHlUeXBlXzEgPSByZXF1aXJlKFwiLi4vZW50aXRpZXMvYWN0aXZpdHlUeXBlXCIpO1xyXG52YXIgd2luZG93VHlwZV8xID0gcmVxdWlyZShcIi4uL2VudGl0aWVzL3dpbmRvd1R5cGVcIik7XHJcbnZhciBhY3Rpdml0eV8xID0gcmVxdWlyZShcIi4uL2VudGl0aWVzL2FjdGl2aXR5XCIpO1xyXG52YXIgYWN0aXZpdHlXaW5kb3dfMSA9IHJlcXVpcmUoXCIuLi9lbnRpdGllcy9hY3Rpdml0eVdpbmRvd1wiKTtcclxudmFyIHByb3h5V2luZG93RmFjdG9yeV8xID0gcmVxdWlyZShcIi4uL2NvcmUvcHJveHlXaW5kb3dGYWN0b3J5XCIpO1xyXG52YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9sb2dnZXJcIik7XHJcbnZhciBlbnRpdHlFdmVudF8yID0gcmVxdWlyZShcIi4uL2NvbnRyYWN0cy9lbnRpdHlFdmVudFwiKTtcclxudmFyIHJlYWR5TWFya2VyXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9yZWFkeU1hcmtlclwiKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vaGVscGVycy91dGlsXCIpO1xyXG52YXIgZW50aXR5RXZlbnRfMyA9IHJlcXVpcmUoXCIuLi9jb250cmFjdHMvZW50aXR5RXZlbnRcIik7XHJcbnZhciBIQ0JyaWRnZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIQ0JyaWRnZShhZ20pIHtcclxuICAgICAgICB0aGlzLl9hY3Rpdml0eVR5cGVFbnRpdHlOYW1lID0gXCJhY3Rpdml0eVR5cGVcIjtcclxuICAgICAgICB0aGlzLl93aW5kb3dUeXBlRW50aXR5TmFtZSA9IFwid2luZG93VHlwZVwiO1xyXG4gICAgICAgIHRoaXMuX2FjdGl2aXR5RW50aXR5TmFtZSA9IFwiYWN0aXZpdHlcIjtcclxuICAgICAgICB0aGlzLl93aW5kb3dFbnRpdHlOYW1lID0gXCJhY3Rpdml0eVdpbmRvd1wiO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IGxvZ2dlcl8xLkxvZ2dlci5HZXQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fbGFzdFNlcSA9IDA7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRRdWV1ZSA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2FjdGl2aXR5VHlwZUNhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3dpbmRvd1R5cGVDYWxsYmFja3MgPSBbXTtcclxuICAgICAgICB0aGlzLl9hY3Rpdml0eUNhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3dpbmRvd0NhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2FnbSA9IGFnbTtcclxuICAgIH1cclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fcmVhZHlNYXJrZXIgPSBuZXcgcmVhZHlNYXJrZXJfMS5SZWFkeU1hcmtlcihcIkhDIEJyaWRnZVwiLCAxKTtcclxuICAgICAgICB0aGlzLl9odG1sQ29udGFpbmVyID0gd2luZG93Lmh0bWxDb250YWluZXIuYWN0aXZpdHlGYWNhZGU7XHJcbiAgICAgICAgdGhpcy5faHRtbENvbnRhaW5lci5pbml0KHRoaXMuX2FnbSA/IHRoaXMuX2FnbS5pbnN0YW5jZSA6IHVuZGVmaW5lZCwgdGhpcy5faGNFdmVudEhhbmRsZXIuYmluZCh0aGlzKSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5fcmVhZHlNYXJrZXIuc2lnbmFsKFwiSW5pdCBkb25lIGZyb20gSENcIik7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9yZWFkeU1hcmtlci5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLnJlYWR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuX3JlYWR5TWFya2VyLnNldENhbGxiYWNrKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShfdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmVycm9yKFwiRXJyb3IgaW5pdGlhbGl6aW5nIEhDIGJyaWRnZSAtIFwiICsgZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoX3RoaXMuX3JlYWR5TWFya2VyLmdldEVycm9yKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuX2hjRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50SnNvbikge1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci50cmFjZShldmVudEpzb24pO1xyXG4gICAgICAgIHZhciBldmVudCA9IEpTT04ucGFyc2UoZXZlbnRKc29uKTtcclxuICAgICAgICB0aGlzLl9wcm9jZXNzRXZlbnRCeVNlcShldmVudCk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLl9wcm9jZXNzRXZlbnRCeVNlcSA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIHZhciBzZXEgPSBldmVudC5zZXF1ZW5jZTtcclxuICAgICAgICBpZiAoc2VxID09PSB0aGlzLl9sYXN0U2VxICsgMSkge1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0U2VxKys7XHJcbiAgICAgICAgICAgIHZhciBuZXh0RXZlbnQgPSB0aGlzLl9ldmVudFF1ZXVlW3NlcSArIDFdO1xyXG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWQobmV4dEV2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwicmVwbGF5aW5nIG1lc3NhZ2UgbnVtYmVyIFwiICsgc2VxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NFdmVudEJ5U2VxKG5leHRFdmVudCk7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRRdWV1ZVtzZXEgKyAxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRRdWV1ZVtzZXFdID0gZXZlbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcIkdvdCBvdXQgb2Ygb3JkZXIgZXZlbnQgd2l0aCBudW1iZXIgXCIgKyBzZXEgKyBcIi4gV2lsbCB3YWl0IGZvciBwcmV2aW91cyBldmVudChzKSBiZWZvcmUgcmVwbGF5aW5nLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLl9wcm9jZXNzRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICB2YXIgZW50aXR5VHlwZSA9IGV2ZW50LmVudGl0eVR5cGU7XHJcbiAgICAgICAgdmFyIGV2ZW50Q29udGV4dCA9IHRoaXMuX2NvbnZlcnRDb250ZXh0KGV2ZW50LmNvbnRleHQpO1xyXG4gICAgICAgIHZhciBlbnRpdHk7XHJcbiAgICAgICAgc3dpdGNoIChlbnRpdHlUeXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgdGhpcy5fYWN0aXZpdHlUeXBlRW50aXR5TmFtZTpcclxuICAgICAgICAgICAgICAgIGVudGl0eSA9IEhDQnJpZGdlLl9oY1RvSnNBY3Rpdml0eVR5cGUoZXZlbnQuZW50aXR5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3B1Ymxpc2hBY3Rpdml0eVR5cGVTdGF0dXNDaGFuZ2UoZW50aXR5LCBldmVudENvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgdGhpcy5fd2luZG93VHlwZUVudGl0eU5hbWU6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkgPSB0aGlzLl9oY1RvSnNXaW5kb3dUeXBlKGV2ZW50LmVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wdWJsaXNoV2luZG93VHlwZVN0YXR1c0NoYW5nZShlbnRpdHksIGV2ZW50Q29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSB0aGlzLl9hY3Rpdml0eUVudGl0eU5hbWU6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkgPSB0aGlzLl9oY1RvSnNBY3Rpdml0eShldmVudC5lbnRpdHkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHVibGlzaEFjdGl2aXR5U3RhdHVzQ2hhbmdlKGVudGl0eSwgZXZlbnRDb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIHRoaXMuX3dpbmRvd0VudGl0eU5hbWU6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkgPSBIQ0JyaWRnZS5faGNUb0pzV2luZG93KGV2ZW50LmVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wdWJsaXNoQWN0aXZpdHlXaW5kb3dFdmVudChlbnRpdHksIGV2ZW50Q29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLl9jb252ZXJ0Q29udGV4dCA9IGZ1bmN0aW9uIChoY0NvbnRleHQpIHtcclxuICAgICAgICBpZiAoaGNDb250ZXh0LnR5cGUgPT09IGVudGl0eUV2ZW50XzEuRW50aXR5RXZlbnRUeXBlLlN0YXR1c0NoYW5nZSkge1xyXG4gICAgICAgICAgICB2YXIgb2xkU3RhdHVzID0gbmV3IGFjdGl2aXR5U3RhdHVzXzEuQWN0aXZpdHlTdGF0dXMoaGNDb250ZXh0Lm9sZFN0YXR1cy5zdGF0ZSwgaGNDb250ZXh0Lm9sZFN0YXR1cy5zdGF0dXNNZXNzYWdlLCBoY0NvbnRleHQub2xkU3RhdHVzLnN0YXR1c1RpbWUpO1xyXG4gICAgICAgICAgICB2YXIgbmV3U3RhdHVzID0gbmV3IGFjdGl2aXR5U3RhdHVzXzEuQWN0aXZpdHlTdGF0dXMoaGNDb250ZXh0Lm5ld1N0YXR1cy5zdGF0ZSwgaGNDb250ZXh0Lm5ld1N0YXR1cy5zdGF0dXNNZXNzYWdlLCBoY0NvbnRleHQubmV3U3RhdHVzLnN0YXR1c1RpbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGVudGl0eUV2ZW50XzEuRW50aXR5U3RhdHVzQ2hhbmdlRXZlbnRDb250ZXh0KG5ld1N0YXR1cywgb2xkU3RhdHVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaGNDb250ZXh0LnR5cGUgPT09IGVudGl0eUV2ZW50XzEuRW50aXR5RXZlbnRUeXBlLkFjdGl2aXR5V2luZG93RXZlbnQpIHtcclxuICAgICAgICAgICAgdmFyIGFjdCA9IHRoaXMuX2hjVG9Kc0FjdGl2aXR5KGhjQ29udGV4dC5hY3Rpdml0eSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgZW50aXR5RXZlbnRfMS5FbnRpdHlBY3Rpdml0eVdpbmRvd0V2ZW50Q29udGV4dChhY3QsIGhjQ29udGV4dC5ldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhjQ29udGV4dC50eXBlID09PSBlbnRpdHlFdmVudF8xLkVudGl0eUV2ZW50VHlwZS5BY3Rpdml0eUNvbnRleHRDaGFuZ2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBlbnRpdHlFdmVudF8zLkFjdGl2aXR5Q29udGV4dENoYW5nZWRDb250ZXh0KGhjQ29udGV4dC5uZXdDb250ZXh0LCBoY0NvbnRleHQudXBkYXRlZCwgaGNDb250ZXh0LnJlbW92ZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IGVudGl0eUV2ZW50XzEuRW50aXR5RXZlbnRDb250ZXh0KGhjQ29udGV4dC50eXBlKTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5faGNUb0pzV2luZG93ID0gZnVuY3Rpb24gKGhjV2luZG93KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBhY3Rpdml0eVdpbmRvd18xWydkZWZhdWx0J10oaGNXaW5kb3cuaWQsIGhjV2luZG93Lm5hbWUsIGhjV2luZG93LnR5cGUsIGhjV2luZG93LmFjdGl2aXR5SWQsIGhjV2luZG93Lmluc3RhbmNlLCBoY1dpbmRvdy5pc0luZGVwZW5kZW50KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuX2hjVG9Kc0FjdGl2aXR5ID0gZnVuY3Rpb24gKGhjQWN0KSB7XHJcbiAgICAgICAgdmFyIHdpbmRvdyA9IGhjQWN0Lm93bmVyID8gSENCcmlkZ2UuX2hjVG9Kc1dpbmRvdyhoY0FjdC5vd25lcikgOiBudWxsO1xyXG4gICAgICAgIHZhciB3aW5kb3dJZCA9IHdpbmRvdyA/IHdpbmRvdy5pZCA6IG51bGw7XHJcbiAgICAgICAgdmFyIHN0YXR1cyA9IG5ldyBhY3Rpdml0eVN0YXR1c18xLkFjdGl2aXR5U3RhdHVzKGhjQWN0LnN0YXR1cy5zdGF0ZSwgaGNBY3Quc3RhdHVzLnN0YXR1c01lc3NhZ2UsIGhjQWN0LnN0YXR1cy5zdGF0dXNUaW1lKTtcclxuICAgICAgICB2YXIgY29udGV4dCA9IEpTT04ucGFyc2UoaGNBY3QuY29udGV4dCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBhY3Rpdml0eV8xWydkZWZhdWx0J10oaGNBY3QuaWQsIGhjQWN0LnR5cGUubmFtZSwgc3RhdHVzLCBjb250ZXh0LCB3aW5kb3dJZCk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UuX2hjVG9Kc0FjdGl2aXR5VHlwZSA9IGZ1bmN0aW9uIChoY0FjdFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IGFjdGl2aXR5VHlwZV8xWydkZWZhdWx0J10oaGNBY3RUeXBlLm5hbWUsIGhjQWN0VHlwZS5vd25lcldpbmRvd1R5cGUsIGhjQWN0VHlwZS5oZWxwZXJXaW5kb3dUeXBlcywgaGNBY3RUeXBlLmRlc2NyaXB0aW9uKTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuX2hjVG9Kc1dpbmRvd1R5cGUgPSBmdW5jdGlvbiAoaGNXaW5UeXBlKSB7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQoaGNXaW5UeXBlLmZhY3RvcmllcykpIHtcclxuICAgICAgICAgICAgaGNXaW5UeXBlLmZhY3RvcmllcyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZmFjdG9yaWVzID0gaGNXaW5UeXBlLmZhY3Rvcmllcy5tYXAoZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEhDQnJpZGdlLl9oY1RvSnNXaW5kb3dUeXBlRmFjdG9yeShmKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IHdpbmRvd1R5cGVfMVsnZGVmYXVsdCddKGhjV2luVHlwZS5uYW1lLCBmYWN0b3JpZXMpO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLl9oY1RvSnNXaW5kb3dUeXBlRmFjdG9yeSA9IGZ1bmN0aW9uIChoY1dpblR5cGVGYWN0b3J5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBwcm94eVdpbmRvd0ZhY3RvcnlfMS5Qcm94eVdpbmRvd0ZhY3RvcnkoaGNXaW5UeXBlRmFjdG9yeS5kZXNjcmlwdGlvbik7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UuX2dldFVSTFBhcmFtZXRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCgobmV3IFJlZ0V4cCgnWz98Jl0nICsgbmFtZSArICc9JyArICcoW14mO10rPykoJnwjfDt8JCknKS5leGVjKGxvY2F0aW9uLnNlYXJjaCkgfHwgWywgXCJcIl0pWzFdLnJlcGxhY2UoL1xcKy9nLCAnJTIwJykpIHx8IG51bGw7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLmdldEFjdGl2aXR5VHlwZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5faHRtbENvbnRhaW5lci5nZXRBY3Rpdml0eVR5cGVzKGZ1bmN0aW9uIChpbmZvcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGluZm9zLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmZvID0gaW5mb3NbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdBY3Rpdml0eVR5cGUgPSBIQ0JyaWRnZS5faGNUb0pzQWN0aXZpdHlUeXBlKGluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld0FjdGl2aXR5VHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLnJlZ2lzdGVyQWN0aXZpdHlUeXBlID0gZnVuY3Rpb24gKGFjdGl2aXR5VHlwZU5hbWUsIG93bmVyV2luZG93LCBoZWxwZXJXaW5kb3dzLCBsYXlvdXRDb25maWcsIGRlc2NyaXB0aW9uKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBpZiAoaGVscGVyV2luZG93cyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBoZWxwZXJXaW5kb3dzID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IGFjdGl2aXR5VHlwZU5hbWUsXHJcbiAgICAgICAgICAgICAgICBvd25lcldpbmRvd1R5cGU6IG93bmVyV2luZG93LFxyXG4gICAgICAgICAgICAgICAgaGVscGVyV2luZG93VHlwZXM6IGhlbHBlcldpbmRvd3MsXHJcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXHJcbiAgICAgICAgICAgICAgICBsYXlvdXRDb25maWc6IEpTT04uc3RyaW5naWZ5KGxheW91dENvbmZpZylcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgX3RoaXMuX2h0bWxDb250YWluZXIucmVnaXN0ZXJBY3Rpdml0eVR5cGUoSlNPTi5zdHJpbmdpZnkoY29uZmlnKSwgZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdBY3Rpdml0eVR5cGUgPSBIQ0JyaWRnZS5faGNUb0pzQWN0aXZpdHlUeXBlKGluZm8pO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShuZXdBY3Rpdml0eVR5cGUpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS51bnJlZ2lzdGVyQWN0aXZpdHlUeXBlID0gZnVuY3Rpb24gKGFjdGl2aXR5VHlwZU5hbWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9odG1sQ29udGFpbmVyLnVucmVnaXN0ZXJBY3Rpdml0eVR5cGUoYWN0aXZpdHlUeXBlTmFtZSwgZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLmdldFdpbmRvd1R5cGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2h0bWxDb250YWluZXIuZ2V0V2luZG93VHlwZXMoZnVuY3Rpb24gKGluZm9zKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgaW5mb3MubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZm8gPSBpbmZvc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1dpbmRvd1R5cGUgPSBfdGhpcy5faGNUb0pzV2luZG93VHlwZShpbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdXaW5kb3dUeXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUucmVnaXN0ZXJXaW5kb3dGYWN0b3J5ID0gZnVuY3Rpb24gKHdpbmRvd1R5cGVOYW1lLCBmYWN0b3J5KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh3aW5kb3dUeXBlTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChcIndpbmRvd1R5cGVOYW1lIHNob3VsZCBiZSBwcm92aWRlZFwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5faHRtbENvbnRhaW5lci5yZWdpc3RlcldpbmRvd0ZhY3Rvcnkod2luZG93VHlwZU5hbWUsIGZhY3RvcnkuY3JlYXRlLmJpbmQoZmFjdG9yeSksIGZ1bmN0aW9uIChpbmZvKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5pbml0aWF0ZUFjdGl2aXR5ID0gZnVuY3Rpb24gKGFjdGl2aXR5VHlwZSwgY29udGV4dCwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKGFjdGl2aXR5VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChcIndpbmRvd1R5cGVOYW1lIHNob3VsZCBiZSBwcm92aWRlZFwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbChjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLl9odG1sQ29udGFpbmVyLmluaXRpYXRlKGFjdGl2aXR5VHlwZSwgSlNPTi5zdHJpbmdpZnkoY29udGV4dCksIGZ1bmN0aW9uIChhY3Rpdml0eUlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKGFjdGl2aXR5SWQpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5nZXRBbm5vdW5jZW1lbnRJbmZvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBoYyA9IHdpbmRvdy5odG1sQ29udGFpbmVyO1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gaGMuZ2V0Q29udGV4dCgpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB7IGFjdGl2aXR5V2luZG93SWQ6IFwiXCIsIGFjdGl2aXR5V2luZG93VHlwZTogXCJcIiwgYWN0aXZpdHlXaW5kb3dJbmRlcGVuZGVudDogZmFsc2UsIGFjdGl2aXR5V2luZG93TmFtZTogXCJcIiB9O1xyXG4gICAgICAgIHJlc3VsdC5hY3Rpdml0eVdpbmRvd1R5cGUgPSBjb250ZXh0LmFjdGl2aXR5V2luZG93VHlwZTtcclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChyZXN1bHQuYWN0aXZpdHlXaW5kb3dUeXBlKSkge1xyXG4gICAgICAgICAgICByZXN1bHQuYWN0aXZpdHlXaW5kb3dUeXBlID0gSENCcmlkZ2UuX2dldFVSTFBhcmFtZXRlcihcImFjdGl2aXR5V2luZG93VHlwZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LmFjdGl2aXR5V2luZG93SWQgPSBjb250ZXh0LmFjdGl2aXR5V2luZG93SWQ7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQocmVzdWx0LmFjdGl2aXR5V2luZG93SWQpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5hY3Rpdml0eVdpbmRvd0lkID0gSENCcmlkZ2UuX2dldFVSTFBhcmFtZXRlcihcImFjdGl2aXR5V2luZG93SWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC5hY3Rpdml0eVdpbmRvd0luZGVwZW5kZW50ID0gY29udGV4dC5hY3Rpdml0eVdpbmRvd0luZGVwZW5kZW50O1xyXG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKHJlc3VsdC5hY3Rpdml0eVdpbmRvd0luZGVwZW5kZW50KSkge1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQuYWN0aXZpdHlXaW5kb3dOYW1lID0gY29udGV4dC5hY3Rpdml0eVdpbmRvd05hbWU7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQocmVzdWx0LmFjdGl2aXR5V2luZG93TmFtZSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmFjdGl2aXR5V2luZG93TmFtZSA9IEhDQnJpZGdlLl9nZXRVUkxQYXJhbWV0ZXIoXCJhY3Rpdml0eVdpbmRvd05hbWVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLmFubm91bmNlV2luZG93ID0gZnVuY3Rpb24gKHdpbmRvd1R5cGUsIGFjdGl2aXR5V2luZG93SWQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKHdpbmRvd1R5cGUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbiBub3QgZGV0ZXJtaW5lIHdpbmRvdyB0eXBlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZCh3aW5kb3dUeXBlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW4gbm90IGRldGVybWluZSB3aW5kb3cgYWN0aXZpdHlXaW5kb3dJZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faHRtbENvbnRhaW5lci5hbm5vdW5jZVdpbmRvdyh3aW5kb3dUeXBlLCBhY3Rpdml0eVdpbmRvd0lkLCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5lcnJvcihcIkVycm9yIGFubm91bmNpbmcgYWN0aXZpdHkgd2luZG93IHdpdGggaWQgJ1wiICsgYWN0aXZpdHlXaW5kb3dJZCArIFwiJy4gXCIgKyBlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLmdldEFjdGl2aXRpZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLnRyYWNlKFwiRXhlY3V0aW5nIGdldEFjdGl2aXRpZXMoKVwiKTtcclxuICAgICAgICAgICAgX3RoaXMuX2h0bWxDb250YWluZXIuZ2V0QWN0aXZpdGllcyhmdW5jdGlvbiAoYWN0aXZpdGllc1N0cikge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci50cmFjZShcIkdvdCBnZXRBY3Rpdml0aWVzKCkgOlwiICsgYWN0aXZpdGllc1N0cik7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWN0aXZpdGllcyA9IEpTT04ucGFyc2UoYWN0aXZpdGllc1N0cik7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gYWN0aXZpdGllcy5tYXAoZnVuY3Rpb24gKGFjdCkgeyByZXR1cm4gX3RoaXMuX2hjVG9Kc0FjdGl2aXR5KGFjdCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIudHJhY2UoXCJFcnJvciBpbiBnZXRBY3Rpdml0aWVzKCkgOlwiICsgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLnVwZGF0ZUFjdGl2aXR5Q29udGV4dCA9IGZ1bmN0aW9uIChhY3Rpdml0eSwgY29udGV4dCwgZnVsbFJlcGxhY2UsIHJlbW92ZWRLZXlzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChyZW1vdmVkS2V5cykpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZWRLZXlzID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICBmdWxsUmVwbGFjZTogZnVsbFJlcGxhY2UsXHJcbiAgICAgICAgICAgICAgICByZW1vdmVkS2V5czogcmVtb3ZlZEtleXNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgX3RoaXMuX2h0bWxDb250YWluZXIuc2V0QWN0aXZpdHlDb250ZXh0KGFjdGl2aXR5LmlkLCBKU09OLnN0cmluZ2lmeShjb250ZXh0KSwgSlNPTi5zdHJpbmdpZnkob3B0aW9ucyksIGZ1bmN0aW9uIChuZXdDb250ZXh0U3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3Q29udGV4dCA9IEpTT04ucGFyc2UobmV3Q29udGV4dFN0cmluZyk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKG5ld0NvbnRleHQpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIHJlamVjdChlcnJvcik7IH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5nZXRBY3Rpdml0eVdpbmRvd3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5faHRtbENvbnRhaW5lci5nZXRXaW5kb3dzKGZ1bmN0aW9uICh3aW5kb3dzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gd2luZG93cy5tYXAoZnVuY3Rpb24gKHdpbmQpIHsgcmV0dXJuIEhDQnJpZGdlLl9oY1RvSnNXaW5kb3cod2luZCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5zdG9wQWN0aXZpdHkgPSBmdW5jdGlvbiAoYWN0aXZpdHkpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9odG1sQ29udGFpbmVyLnN0b3BBY3Rpdml0eShhY3Rpdml0eS5pZCwgZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS51bnJlZ2lzdGVyV2luZG93RmFjdG9yeSA9IGZ1bmN0aW9uICh3aW5kb3dUeXBlTmFtZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2h0bWxDb250YWluZXIucmVnaXN0ZXJXaW5kb3dGYWN0b3J5KHdpbmRvd1R5cGVOYW1lLCBmdW5jdGlvbiAoaW5mbykge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuY3JlYXRlV2luZG93ID0gZnVuY3Rpb24gKGlkLCB3aW5kb3dEZWZpbml0aW9uKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5faHRtbENvbnRhaW5lci5jcmVhdGVXaW5kb3coaWQsIEpTT04uc3RyaW5naWZ5KHdpbmRvd0RlZmluaXRpb24pLCBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoaWQpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5jcmVhdGVTdGFja2VkV2luZG93cyA9IGZ1bmN0aW9uIChpZCwgd2luZG93RGVmaW5pdGlvbnMsIHRpbWVvdXQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9odG1sQ29udGFpbmVyLmNyZWF0ZVN0YWNrZWRXaW5kb3dzKGlkLCBKU09OLnN0cmluZ2lmeSh3aW5kb3dEZWZpbml0aW9ucyksIHRpbWVvdXQsIGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShpZCk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLm9uQWN0aXZpdHlUeXBlU3RhdHVzQ2hhbmdlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZpdHlUeXBlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5vbldpbmRvd1R5cGVTdGF0dXNDaGFuZ2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLl93aW5kb3dUeXBlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5vbkFjdGl2aXR5U3RhdHVzQ2hhbmdlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZpdHlDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLm9uQWN0aXZpdHlXaW5kb3dDaGFuZ2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLl93aW5kb3dDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLmdldFdpbmRvd0JvdW5kcyA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2h0bWxDb250YWluZXIuZ2V0V2luZG93Qm91bmRzKGlkLCBmdW5jdGlvbiAoYm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKGJvdW5kcyk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuc2V0V2luZG93Qm91bmRzID0gZnVuY3Rpb24gKGlkLCBib3VuZHMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9odG1sQ29udGFpbmVyLnNldFdpbmRvd0JvdW5kcyhpZCwgSlNPTi5zdHJpbmdpZnkoYm91bmRzKSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLnJlZ2lzdGVyV2luZG93ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIGluZGVwZW5kZW50KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5faHRtbENvbnRhaW5lci5yZWdpc3RlcldpbmRvdyh0eXBlLCBuYW1lLCBpbmRlcGVuZGVudCwgZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKGlkKTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuY2xvc2VXaW5kb3cgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9odG1sQ29udGFpbmVyLmNsb3NlV2luZG93KGlkLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuYWN0aXZhdGVXaW5kb3cgPSBmdW5jdGlvbiAoaWQsIGZvY3VzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5faHRtbENvbnRhaW5lci5hY3RpdmF0ZVdpbmRvdyhpZCwgZm9jdXMsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5fcHVibGlzaFN0YXR1c0NoYW5nZSA9IGZ1bmN0aW9uIChlbnRpdHksIGNvbnRleHQsIGNhbGxiYWNrcykge1xyXG4gICAgICAgIHZhciBlbnRpdHlFdmVudCA9IG5ldyBlbnRpdHlFdmVudF8yLkVudGl0eUV2ZW50KGVudGl0eSwgY29udGV4dCk7XHJcbiAgICAgICAgY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGVudGl0eUV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuX3B1Ymxpc2hBY3Rpdml0eVR5cGVTdGF0dXNDaGFuZ2UgPSBmdW5jdGlvbiAoYXQsIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLl9wdWJsaXNoU3RhdHVzQ2hhbmdlKGF0LCBjb250ZXh0LCB0aGlzLl9hY3Rpdml0eVR5cGVDYWxsYmFja3MpO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5fcHVibGlzaFdpbmRvd1R5cGVTdGF0dXNDaGFuZ2UgPSBmdW5jdGlvbiAod3QsIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLl9wdWJsaXNoU3RhdHVzQ2hhbmdlKHd0LCBjb250ZXh0LCB0aGlzLl93aW5kb3dUeXBlQ2FsbGJhY2tzKTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuX3B1Ymxpc2hBY3Rpdml0eVN0YXR1c0NoYW5nZSA9IGZ1bmN0aW9uIChhY3QsIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLl9wdWJsaXNoU3RhdHVzQ2hhbmdlKGFjdCwgY29udGV4dCwgdGhpcy5fYWN0aXZpdHlDYWxsYmFja3MpO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5fcHVibGlzaEFjdGl2aXR5V2luZG93RXZlbnQgPSBmdW5jdGlvbiAodywgY29udGV4dCkge1xyXG4gICAgICAgIHRoaXMuX3B1Ymxpc2hTdGF0dXNDaGFuZ2UodywgY29udGV4dCwgdGhpcy5fd2luZG93Q2FsbGJhY2tzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSENCcmlkZ2U7XHJcbn0oKSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0c1snZGVmYXVsdCddPSBIQ0JyaWRnZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGNCcmlkZ2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBBY3Rpdml0eVN0YXR1cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBY3Rpdml0eVN0YXR1cyhzdGF0ZSwgbWVzc2FnZSwgdGltZSkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgIHRoaXMudGltZSA9IHRpbWU7XHJcbiAgICB9XHJcbiAgICBBY3Rpdml0eVN0YXR1cy5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGU7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlTdGF0dXMucHJvdG90eXBlLmdldE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eVN0YXR1cy5wcm90b3R5cGUuZ2V0VGltZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aW1lO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBY3Rpdml0eVN0YXR1cztcclxufSgpKTtcclxuZXhwb3J0cy5BY3Rpdml0eVN0YXR1cyA9IEFjdGl2aXR5U3RhdHVzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpdml0eVN0YXR1cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIEVudGl0eUV2ZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEVudGl0eUV2ZW50KGVudGl0aXksIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLmVudGl0eSA9IGVudGl0aXk7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgIH1cclxuICAgIHJldHVybiBFbnRpdHlFdmVudDtcclxufSgpKTtcclxuZXhwb3J0cy5FbnRpdHlFdmVudCA9IEVudGl0eUV2ZW50O1xyXG52YXIgRW50aXR5RXZlbnRDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEVudGl0eUV2ZW50Q29udGV4dChldmVudFR5cGUpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSBldmVudFR5cGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRW50aXR5RXZlbnRDb250ZXh0O1xyXG59KCkpO1xyXG5leHBvcnRzLkVudGl0eUV2ZW50Q29udGV4dCA9IEVudGl0eUV2ZW50Q29udGV4dDtcclxudmFyIEVudGl0eVN0YXR1c0NoYW5nZUV2ZW50Q29udGV4dCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRW50aXR5U3RhdHVzQ2hhbmdlRXZlbnRDb250ZXh0LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRW50aXR5U3RhdHVzQ2hhbmdlRXZlbnRDb250ZXh0KG5ld1N0YXR1cywgb2xkU3RhdHVzKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgRW50aXR5RXZlbnRUeXBlLlN0YXR1c0NoYW5nZSk7XHJcbiAgICAgICAgdGhpcy5uZXdTdGF0dXMgPSBuZXdTdGF0dXM7XHJcbiAgICAgICAgdGhpcy5vbGRTdGF0dXMgPSBvbGRTdGF0dXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRW50aXR5U3RhdHVzQ2hhbmdlRXZlbnRDb250ZXh0O1xyXG59KEVudGl0eUV2ZW50Q29udGV4dCkpO1xyXG5leHBvcnRzLkVudGl0eVN0YXR1c0NoYW5nZUV2ZW50Q29udGV4dCA9IEVudGl0eVN0YXR1c0NoYW5nZUV2ZW50Q29udGV4dDtcclxudmFyIEVudGl0eUFjdGl2aXR5V2luZG93RXZlbnRDb250ZXh0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhFbnRpdHlBY3Rpdml0eVdpbmRvd0V2ZW50Q29udGV4dCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEVudGl0eUFjdGl2aXR5V2luZG93RXZlbnRDb250ZXh0KGFjdGl2aXR5LCBldmVudCkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIEVudGl0eUV2ZW50VHlwZS5BY3Rpdml0eVdpbmRvd0V2ZW50KTtcclxuICAgICAgICB0aGlzLmFjdGl2aXR5ID0gYWN0aXZpdHk7XHJcbiAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEVudGl0eUFjdGl2aXR5V2luZG93RXZlbnRDb250ZXh0O1xyXG59KEVudGl0eUV2ZW50Q29udGV4dCkpO1xyXG5leHBvcnRzLkVudGl0eUFjdGl2aXR5V2luZG93RXZlbnRDb250ZXh0ID0gRW50aXR5QWN0aXZpdHlXaW5kb3dFdmVudENvbnRleHQ7XHJcbnZhciBBY3Rpdml0eUNvbnRleHRDaGFuZ2VkQ29udGV4dCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQWN0aXZpdHlDb250ZXh0Q2hhbmdlZENvbnRleHQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBY3Rpdml0eUNvbnRleHRDaGFuZ2VkQ29udGV4dChjb250ZXh0LCB1cGRhdGVkLCByZW1vdmVkKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgRW50aXR5RXZlbnRUeXBlLkFjdGl2aXR5Q29udGV4dENoYW5nZSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVkID0gdXBkYXRlZDtcclxuICAgICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IEpTT04ucGFyc2UoY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQWN0aXZpdHlDb250ZXh0Q2hhbmdlZENvbnRleHQ7XHJcbn0oRW50aXR5RXZlbnRDb250ZXh0KSk7XHJcbmV4cG9ydHMuQWN0aXZpdHlDb250ZXh0Q2hhbmdlZENvbnRleHQgPSBBY3Rpdml0eUNvbnRleHRDaGFuZ2VkQ29udGV4dDtcclxudmFyIEVudGl0eUV2ZW50VHlwZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFbnRpdHlFdmVudFR5cGUoKSB7XHJcbiAgICB9XHJcbiAgICBFbnRpdHlFdmVudFR5cGUuQWRkZWQgPSBcImFkZGVkXCI7XHJcbiAgICBFbnRpdHlFdmVudFR5cGUuUmVtb3ZlZCA9IFwicmVtb3ZlZFwiO1xyXG4gICAgRW50aXR5RXZlbnRUeXBlLlVwZGF0ZWQgPSBcInVwZGF0ZWRcIjtcclxuICAgIEVudGl0eUV2ZW50VHlwZS5GYWN0b3J5UmVnaXN0ZXJlZCA9IFwiZmFjdG9yeVJlZ2lzdGVyZWRcIjtcclxuICAgIEVudGl0eUV2ZW50VHlwZS5GYWN0b3J5VW5yZWdpc3RlcmVkID0gXCJmYWN0b3J5VW5yZWdpc3RlcmVkXCI7XHJcbiAgICBFbnRpdHlFdmVudFR5cGUuU3RhdHVzQ2hhbmdlID0gXCJzdGF0dXNDaGFuZ2VcIjtcclxuICAgIEVudGl0eUV2ZW50VHlwZS5BY3Rpdml0eUNvbnRleHRDaGFuZ2UgPSBcImFjdGl2aXR5Q29udGV4dFVwZGF0ZVwiO1xyXG4gICAgRW50aXR5RXZlbnRUeXBlLkFjdGl2aXR5V2luZG93RXZlbnQgPSBcImFjdGl2aXR5V2luZG93RXZlbnRcIjtcclxuICAgIHJldHVybiBFbnRpdHlFdmVudFR5cGU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuRW50aXR5RXZlbnRUeXBlID0gRW50aXR5RXZlbnRUeXBlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnRpdHlFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vaGVscGVycy91dGlsXCIpO1xyXG52YXIgQWN0aXZpdHlBR00gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQWN0aXZpdHlBR00oYWN0aXZpdHkpIHtcclxuICAgICAgICB0aGlzLl9hY3Rpdml0eSA9IGFjdGl2aXR5O1xyXG4gICAgfVxyXG4gICAgQWN0aXZpdHlBR00ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGRlZmluaXRpb24sIGhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVIYXNBZ20oKTtcclxuICAgICAgICBBY3Rpdml0eUFHTS5BR00ucmVnaXN0ZXIoZGVmaW5pdGlvbiwgaGFuZGxlcik7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlBR00ucHJvdG90eXBlLnNlcnZlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlSGFzQWdtKCk7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwodGhpcy5fYWN0aXZpdHkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2aXR5LndpbmRvd3MubWFwKGZ1bmN0aW9uICh3KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3Lmluc3RhbmNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5QUdNLnByb3RvdHlwZS5tZXRob2RzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUhhc0FnbSgpO1xyXG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHRoaXMuX2FjdGl2aXR5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB3aW5kb3dzID0gdGhpcy5fYWN0aXZpdHkud2luZG93cztcclxuICAgICAgICB2YXIgbWV0aG9kTmFtZXMgPSBbXTtcclxuICAgICAgICB2YXIgbWV0aG9kcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB3aW5kb3dzLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICB2YXIgd2luZG93XzEgPSB3aW5kb3dzW2luZGV4XTtcclxuICAgICAgICAgICAgdmFyIHdpbmRvd01ldGhvZHMgPSB0aGlzLm1ldGhvZHNGb3JXaW5kb3cod2luZG93XzEpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBtZXRob2RJbmRleCA9IDA7IG1ldGhvZEluZGV4IDwgd2luZG93TWV0aG9kcy5sZW5ndGg7IG1ldGhvZEluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50V2luZG93TWV0aG9kID0gd2luZG93TWV0aG9kc1ttZXRob2RJbmRleF07XHJcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kTmFtZXMuaW5kZXhPZihjdXJyZW50V2luZG93TWV0aG9kLm5hbWUpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZE5hbWVzLnB1c2goY3VycmVudFdpbmRvd01ldGhvZC5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2RzLnB1c2goY3VycmVudFdpbmRvd01ldGhvZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1ldGhvZHM7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlBR00ucHJvdG90eXBlLm1ldGhvZHNGb3JXaW5kb3cgPSBmdW5jdGlvbiAod2luZG93KSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlSGFzQWdtKCk7XHJcbiAgICAgICAgaWYgKCF3aW5kb3cuaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQWN0aXZpdHlBR00uQUdNLm1ldGhvZHNGb3JJbnN0YW5jZSh3aW5kb3cuaW5zdGFuY2UpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5QUdNLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgYXJnLCB0YXJnZXQsIG9wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlSGFzQWdtKCk7XHJcbiAgICAgICAgdmFyIGFjdGl2aXR5U2VydmVycyA9IHRoaXMuc2VydmVycygpO1xyXG4gICAgICAgIHZhciBzZXJ2ZXJzVG9JbnZva2VBZ2FpbnN0ID0gW107XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICB0YXJnZXQgPSBcImFjdGl2aXR5LmFsbFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodXRpbC5pc1N0cmluZyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IFwiYWN0aXZpdHkuYWxsXCIpIHtcclxuICAgICAgICAgICAgICAgIHNlcnZlcnNUb0ludm9rZUFnYWluc3QgPSBhY3Rpdml0eVNlcnZlcnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0ID09PSBcImFjdGl2aXR5LmJlc3RcIikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvdGVudGlhbFRhcmdldHMgPSBhY3Rpdml0eVNlcnZlcnMuZmlsdGVyKGZ1bmN0aW9uIChzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kcyA9IEFjdGl2aXR5QUdNLkFHTS5tZXRob2RzRm9ySW5zdGFuY2Uoc2VydmVyKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kcy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0ubmFtZSA9PT0gbWV0aG9kTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB9KS5sZW5ndGggPiAwO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocG90ZW50aWFsVGFyZ2V0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyc1RvSW52b2tlQWdhaW5zdCA9IFtwb3RlbnRpYWxUYXJnZXRzWzBdXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0YXJnZXQgPT09IFwiYWxsXCIgfHwgdGFyZ2V0ID09PSBcImJlc3RcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEFjdGl2aXR5QUdNLkFHTS5pbnZva2UobWV0aG9kTmFtZSwgYXJnLCB0YXJnZXQsIG9wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW52b2tlIHRhcmdldCBcIiArIHRhcmdldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodXRpbC5pc0FycmF5KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldC5sZW5ndGggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0RWxlbSA9IHRhcmdldFswXTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0FnbUluc3RhbmNlKGZpcnN0RWxlbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJzVG9JbnZva2VBZ2FpbnN0ID0gdGFyZ2V0Lm1hcChmdW5jdGlvbiAoaW5zdGFuY2UpIHsgcmV0dXJuIGluc3RhbmNlOyB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzQWN0aXZpdHlXaW5kb3coZmlyc3RFbGVtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlcnNUb0ludm9rZUFnYWluc3QgPSB0YXJnZXQubWFwKGZ1bmN0aW9uICh3aW4pIHsgcmV0dXJuIHdpbi5pbnN0YW5jZTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHRhcmdldCBvYmplY3RcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0FnbUluc3RhbmNlKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIHNlcnZlcnNUb0ludm9rZUFnYWluc3QgPSBbdGFyZ2V0XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9pc0FjdGl2aXR5V2luZG93KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIHNlcnZlcnNUb0ludm9rZUFnYWluc3QgPSBbdGFyZ2V0Lmluc3RhbmNlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdGFyZ2V0IG9iamVjdFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQWN0aXZpdHlBR00uQUdNLmludm9rZShtZXRob2ROYW1lLCBhcmcsIHNlcnZlcnNUb0ludm9rZUFnYWluc3QsIG9wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eUFHTS5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlSGFzQWdtKCk7XHJcbiAgICAgICAgcmV0dXJuIEFjdGl2aXR5QUdNLkFHTS51bnJlZ2lzdGVyKGRlZmluaXRpb24pO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5QUdNLnByb3RvdHlwZS5jcmVhdGVTdHJlYW0gPSBmdW5jdGlvbiAobWV0aG9kRGVmaW5pdGlvbiwgc3Vic2NyaWJlckFkZGVkSGFuZGxlciwgc3Vic2NyaWJlclJlbW92ZWRGdW5jdGlvbikge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUhhc0FnbSgpO1xyXG4gICAgICAgIEFjdGl2aXR5QUdNLkFHTS5jcmVhdGVTdHJlYW0obWV0aG9kRGVmaW5pdGlvbiwgc3Vic2NyaWJlckFkZGVkSGFuZGxlciwgc3Vic2NyaWJlclJlbW92ZWRGdW5jdGlvbik7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlBR00ucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChtZXRob2REZWZpbml0aW9uLCBwYXJhbWV0ZXJzLCB0YXJnZXQpIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVIYXNBZ20oKTtcclxuICAgICAgICB2YXIgc2VydmVycyA9IHRoaXMuc2VydmVycygpO1xyXG4gICAgICAgIHJldHVybiBBY3Rpdml0eUFHTS5BR00uc3Vic2NyaWJlKG1ldGhvZERlZmluaXRpb24sIHBhcmFtZXRlcnMsIHNlcnZlcnMpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5QUdNLnByb3RvdHlwZS5fZW5zdXJlSGFzQWdtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKEFjdGl2aXR5QUdNLkFHTSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWdtIHNob3VsZCBiZSBjb25maWd1cmVkIHRvIGJlIHVzZWQgaW4gYWN0aXZpdHlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5QUdNLnByb3RvdHlwZS5faXNBZ21JbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICByZXR1cm4gb2JqLmFwcGxpY2F0aW9uICE9IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eUFHTS5wcm90b3R5cGUuX2lzQWN0aXZpdHlXaW5kb3cgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iai5pbnN0YW5jZSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBY3Rpdml0eUFHTTtcclxufSgpKTtcclxuZXhwb3J0cy5BY3Rpdml0eUFHTSA9IEFjdGl2aXR5QUdNO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpdml0eUFHTS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIGVudGl0eUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vY29udHJhY3RzL2VudGl0eUV2ZW50XCIpO1xyXG52YXIgYWN0aXZpdHlUeXBlXzEgPSByZXF1aXJlKFwiLi4vZW50aXRpZXMvYWN0aXZpdHlUeXBlXCIpO1xyXG52YXIgcHJvbWlzZUV4dGVuc2lvbnNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3Byb21pc2VFeHRlbnNpb25zXCIpO1xyXG52YXIgcmVhZHlNYXJrZXJfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3JlYWR5TWFya2VyXCIpO1xyXG52YXIgZW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2VudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uXCIpO1xyXG52YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9sb2dnZXJcIik7XHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdXRpbFwiKTtcclxudmFyIGxvY2FsV2luZG93RmFjdG9yeV8xID0gcmVxdWlyZShcIi4vbG9jYWxXaW5kb3dGYWN0b3J5XCIpO1xyXG52YXIgQWN0aXZpdHlNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFjdGl2aXR5TWFuYWdlcihicmlkZ2UsIGF1dG9Bbm5vdW5jZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gbG9nZ2VyXzEuTG9nZ2VyLkdldCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9hbm5vdW5jZWRXaW5kb3dzID0gW107XHJcbiAgICAgICAgdGhpcy5fYnJpZGdlID0gYnJpZGdlO1xyXG4gICAgICAgIHRoaXMuX2FjdGl2aXR5VHlwZXMgPSBuZXcgZW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb25fMS5FbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbihmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuX2dyYWJFbnRpdHkoZSk7IH0pO1xyXG4gICAgICAgIHRoaXMuX3dpbmRvd1R5cGVzID0gbmV3IGVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uXzEuRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24oZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLl9ncmFiRW50aXR5KGUpOyB9KTtcclxuICAgICAgICB0aGlzLl9hY3Rpdml0aWVzID0gbmV3IGVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uXzEuRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24oZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLl9ncmFiRW50aXR5KGUpOyB9KTtcclxuICAgICAgICB0aGlzLl93aW5kb3dzID0gbmV3IGVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uXzEuRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24oZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLl9ncmFiRW50aXR5KGUpOyB9KTtcclxuICAgICAgICB0aGlzLl9kYXRhUmVhZHlNYXJrZXIgPSBuZXcgcmVhZHlNYXJrZXJfMS5SZWFkeU1hcmtlcihcIkFjdGl2aXR5IE1hbmFnZXIgRGF0YVwiLCBbXCJHZXRBY3Rpdml0eVR5cGVzXCIsIFwiR2V0V2luZG93VHlwZXNcIiwgXCJHZXRBY3Rpdml0aWVzXCIsIFwiR2V0V2luZG93c1wiXS5sZW5ndGgpO1xyXG4gICAgICAgIGlmIChhdXRvQW5ub3VuY2UpIHtcclxuICAgICAgICAgICAgdmFyIGFubm91bmNlTWFrZXIgPSBuZXcgcmVhZHlNYXJrZXJfMS5SZWFkeU1hcmtlcihcIkFjdGl2aXR5IE1hbmFnZXIgQW5ub3VuY2VcIiwgW1wiQW5ub3VuY2VtZW50XCJdLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5TWFya2VyID0gYW5ub3VuY2VNYWtlcjtcclxuICAgICAgICAgICAgdGhpcy5fZGF0YVJlYWR5TWFya2VyLnNldENhbGxiYWNrKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVhZHlNYXJrZXIuZXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoXCJBdXRvIGFubm91bmNpbmcgd2luZG93XCIpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYW5ub3VuY2VXaW5kb3coKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Fubm91bmNlZFdpbmRvd3MucHVzaCh3KTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVhZHlNYXJrZXIuc2lnbmFsKFwiU3VjY2Vzc2Z1bGx5IGFubm91bmNlZCB3aW5kb3cgd2l0aCBpZCAnXCIgKyB3LmlkICsgXCInXCIpO1xyXG4gICAgICAgICAgICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoXCJXaWxsIG5vdCBhbm5vdW5jZSB3aW5kb3cgLSBcIiArIGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlYWR5TWFya2VyLnNpZ25hbCgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVhZHlNYXJrZXIgPSB0aGlzLl9kYXRhUmVhZHlNYXJrZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2JyaWRnZS5pbml0KCk7XHJcbiAgICAgICAgdGhpcy5fYnJpZGdlXHJcbiAgICAgICAgICAgIC5yZWFkeSgpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChhdykge1xyXG4gICAgICAgICAgICBfdGhpcy5fc3Vic2NyaWJlRm9yRGF0YSgpO1xyXG4gICAgICAgIH0pWydjYXRjaCddKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZSwgXCJhbm5vdW5jZWRXaW5kb3dzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Fubm91bmNlZFdpbmRvd3M7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBhbGxvd2VkXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5yZWFkeSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9yZWFkeU1hcmtlci5zZXRDYWxsYmFjayhmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KF90aGlzLl9yZWFkeU1hcmtlci5nZXRFcnJvcigpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2VFeHRlbnNpb25zXzEubm9kZWlmeShwcm9taXNlLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5nZXRBY3Rpdml0eVR5cGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hY3Rpdml0eVR5cGVzLmdldCgpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuZ2V0QWN0aXZpdHlUeXBlID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZpdHlUeXBlcy5nZXRCeU5hbWUobmFtZSk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5yZWdpc3RlckFjdGl2aXR5VHlwZSA9IGZ1bmN0aW9uIChhY3Rpdml0eVR5cGVOYW1lLCBvd25lcldpbmRvd1R5cGUsIGhlbHBlcldpbmRvd1R5cGVzLCBsYXlvdXRDb25maWcsIGRlc2NyaXB0aW9uLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKGFjdGl2aXR5VHlwZU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoXCJhY3Rpdml0eVR5cGVOYW1lIGFyZ3VtZW50IGNhbiBub3QgYmUgdW5kZWZpbmVkXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1N0cmluZyhhY3Rpdml0eVR5cGVOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KFwiYWN0aXZpdHlUeXBlTmFtZSBzaG91bGQgYmUgc3RyaW5nXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhY3RUeXBlID0gX3RoaXMuZ2V0QWN0aXZpdHlUeXBlKGFjdGl2aXR5VHlwZU5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwoYWN0VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChcIkFjdGl2aXR5IHR5cGUgJ1wiICsgYWN0aXZpdHlUeXBlTmFtZSArIFwiJyBhbHJlYWR5IGV4aXN0c1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgb3duZXJEZWZpbml0aW9uO1xyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChvd25lcldpbmRvd1R5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoXCJPd25lciB3aW5kb3cgdHlwZSBjYW4gbm90IGJlIHVuZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1N0cmluZyhvd25lcldpbmRvd1R5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICBvd25lckRlZmluaXRpb24gPSB7IHR5cGU6IG93bmVyV2luZG93VHlwZSwgbmFtZTogXCJcIiwgaXNJbmRlcGVuZGVudDogZmFsc2UsIGFyZ3VtZW50czoge30gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG93bmVyRGVmaW5pdGlvbiA9IG93bmVyV2luZG93VHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaGVscGVyRGVmaW5pdGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkKGhlbHBlcldpbmRvd1R5cGVzKSAmJiB1dGlsLmlzQXJyYXkoaGVscGVyV2luZG93VHlwZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCBpbiBoZWxwZXJXaW5kb3dUeXBlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gaGVscGVyV2luZG93VHlwZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzU3RyaW5nKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWZpbml0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogaXRlbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0luZGVwZW5kZW50OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVRvOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVEaXJlY3Rpb246IFwiXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dTdHlsZUF0dHJpYnV0ZXM6IHt9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlckRlZmluaXRpb25zLnB1c2goZGVmaW5pdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXJEZWZpbml0aW9ucy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5fYnJpZGdlXHJcbiAgICAgICAgICAgICAgICAucmVnaXN0ZXJBY3Rpdml0eVR5cGUoYWN0aXZpdHlUeXBlTmFtZSwgb3duZXJEZWZpbml0aW9uLCBoZWxwZXJEZWZpbml0aW9ucywgbGF5b3V0Q29uZmlnLCBkZXNjcmlwdGlvbilcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChhY3Rpdml0eVR5cGUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9ncmFiRW50aXR5KGFjdGl2aXR5VHlwZSk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKGFjdGl2aXR5VHlwZSk7XHJcbiAgICAgICAgICAgIH0pWydjYXRjaCddKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2VFeHRlbnNpb25zXzEubm9kZWlmeShwcm9taXNlLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS51bnJlZ2lzdGVyQWN0aXZpdHlUeXBlID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIGFjdFR5cGUgPSBfdGhpcy5nZXRBY3Rpdml0eVR5cGUodHlwZSk7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKGFjdFR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoXCJBY3Rpdml0eSB0eXBlICdcIiArIHR5cGUgKyBcIicgZG9lcyBub3QgZXhpc3RzXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fYnJpZGdlLnVucmVnaXN0ZXJBY3Rpdml0eVR5cGUodHlwZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2VFeHRlbnNpb25zXzEubm9kZWlmeShwcm9taXNlLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5pbml0aWF0ZSA9IGZ1bmN0aW9uIChhY3Rpdml0eVR5cGUsIGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIGFjdFR5cGUgPSBfdGhpcy5nZXRBY3Rpdml0eVR5cGUoYWN0aXZpdHlUeXBlKTtcclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQoYWN0VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChcIkFjdGl2aXR5IHR5cGUgJ1wiICsgYWN0aXZpdHlUeXBlICsgXCInIGRvZXMgbm90IGV4aXN0c1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5fYnJpZGdlXHJcbiAgICAgICAgICAgICAgICAuaW5pdGlhdGVBY3Rpdml0eShhY3Rpdml0eVR5cGUsIGNvbnRleHQpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYWN0SWQpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9hY3Rpdml0aWVzXHJcbiAgICAgICAgICAgICAgICAgICAgLmdldE9yV2FpdChhY3RJZClcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShhY3QpO1xyXG4gICAgICAgICAgICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycikgeyByZXR1cm4gcmVqZWN0KGVycik7IH0pO1xyXG4gICAgICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2VFeHRlbnNpb25zXzEubm9kZWlmeShwcm9taXNlLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5zdWJzY3JpYmVBY3Rpdml0eVR5cGVFdmVudHMgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMuX2FjdGl2aXR5VHlwZXMuc3Vic2NyaWJlKGZ1bmN0aW9uIChhdCwgY29udGV4dCkge1xyXG4gICAgICAgICAgICBoYW5kbGVyKGF0LCBjb250ZXh0LnR5cGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuZ2V0V2luZG93VHlwZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpbmRvd1R5cGVzLmdldCgpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuZ2V0V2luZG93VHlwZSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpbmRvd1R5cGVzLmdldEJ5TmFtZShuYW1lKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLnJlZ2lzdGVyV2luZG93RmFjdG9yeSA9IGZ1bmN0aW9uICh3aW5kb3dUeXBlLCBmYWN0b3J5TWV0aG9kLCBkZXNjcmlwdGlvbiwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh3aW5kb3dUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KFwibm8gd2luZG93VHlwZSBzcGVjaWZpZWRcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNPYmplY3Qod2luZG93VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvd1R5cGUgPSB3aW5kb3dUeXBlLmdldE5hbWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghdXRpbC5pc1N0cmluZyh3aW5kb3dUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KFwid2luZG93VHlwZSBzaG91bGQgYmUgc3RyaW5nIG9yIG9iamVjdCB0aGF0IGhhcyBnZXROYW1lIG1ldGhvZFwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZmFjdG9yeSA9IG5ldyBsb2NhbFdpbmRvd0ZhY3RvcnlfMS5Mb2NhbFdpbmRvd0ZhY3RvcnkoZmFjdG9yeU1ldGhvZCwgZGVzY3JpcHRpb24pO1xyXG4gICAgICAgICAgICBfdGhpcy5fYnJpZGdlXHJcbiAgICAgICAgICAgICAgICAucmVnaXN0ZXJXaW5kb3dGYWN0b3J5KHdpbmRvd1R5cGUsIGZhY3RvcnkpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh2KTtcclxuICAgICAgICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlRXh0ZW5zaW9uc18xLm5vZGVpZnkocHJvbWlzZSwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUudW5yZWdpc3RlcldpbmRvd0ZhY3RvcnkgPSBmdW5jdGlvbiAod2luZG93VHlwZSwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh3aW5kb3dUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KFwibm8gd2luZG93VHlwZSBzcGVjaWZpZWRcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzU3RyaW5nKHdpbmRvd1R5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoXCJ3aW5kb3dUeXBlIHNob3VsZCBiZSBhIHN0cmluZ1wiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5fYnJpZGdlXHJcbiAgICAgICAgICAgICAgICAudW5yZWdpc3RlcldpbmRvd0ZhY3Rvcnkod2luZG93VHlwZSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHYpO1xyXG4gICAgICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2VFeHRlbnNpb25zXzEubm9kZWlmeShwcm9taXNlLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5nZXRBY3Rpdml0aWVzID0gZnVuY3Rpb24gKGFjdGl2aXR5VHlwZSkge1xyXG4gICAgICAgIHZhciBhY3QgPSB0aGlzLl9hY3Rpdml0aWVzLmdldCgpO1xyXG4gICAgICAgIGlmICghYWN0aXZpdHlUeXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0eXBlcyA9IGFjdGl2aXR5VHlwZTtcclxuICAgICAgICBpZiAodXRpbC5pc1N0cmluZyhhY3Rpdml0eVR5cGUpKSB7XHJcbiAgICAgICAgICAgIHR5cGVzID0gW2FjdGl2aXR5VHlwZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFjdGl2aXR5VHlwZSBpbnN0YW5jZW9mIGFjdGl2aXR5VHlwZV8xWydkZWZhdWx0J10pIHtcclxuICAgICAgICAgICAgdHlwZXMgPSBbYWN0aXZpdHlUeXBlLm5hbWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhY3Rpdml0eVR5cGUgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBhcmd1bWVudCAnYWN0aXZpdHlUeXBlJyA9IFwiICsgYWN0aXZpdHlUeXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFjdC5maWx0ZXIoZnVuY3Rpb24gKGFjdCkge1xyXG4gICAgICAgICAgICB2YXIgdHlwZSA9IGFjdC50eXBlO1xyXG4gICAgICAgICAgICByZXR1cm4gdXRpbC5zb21lKHR5cGVzLCBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGUuaWQgPT0gdC5pZDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5nZXRBY3Rpdml0eUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZpdGllcy5nZXRCeU5hbWUoaWQpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuYW5ub3VuY2VXaW5kb3cgPSBmdW5jdGlvbiAoYWN0aXZpdHlXaW5kb3dJZCwgd2luZG93VHlwZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBhbm5vdW5jZW1lbnRJbmZvID0gX3RoaXMuX2JyaWRnZS5nZXRBbm5vdW5jZW1lbnRJbmZvKCk7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKGFjdGl2aXR5V2luZG93SWQpKSB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpdml0eVdpbmRvd0lkID0gYW5ub3VuY2VtZW50SW5mby5hY3Rpdml0eVdpbmRvd0lkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKHdpbmRvd1R5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3dUeXBlID0gYW5ub3VuY2VtZW50SW5mby5hY3Rpdml0eVdpbmRvd1R5cGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwod2luZG93VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYW5ub3VuY2UgLSB1bmtub3duIHdpbmRvd1R5cGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwoYWN0aXZpdHlXaW5kb3dJZCkpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoXCJSZWdpc3RlcmluZyB3aW5kb3cgd2l0aCB0eXBlOidcIiArIHdpbmRvd1R5cGUgKyBcIicsIG5hbWU6J1wiICsgYW5ub3VuY2VtZW50SW5mby5hY3Rpdml0eVdpbmRvd05hbWUgKyBcIicsIGluZC46J1wiICsgYW5ub3VuY2VtZW50SW5mby5hY3Rpdml0eVdpbmRvd0luZGVwZW5kZW50ICsgXCInXCIpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2JyaWRnZS5yZWdpc3RlcldpbmRvdyh3aW5kb3dUeXBlLCBhbm5vdW5jZW1lbnRJbmZvLmFjdGl2aXR5V2luZG93TmFtZSwgYW5ub3VuY2VtZW50SW5mby5hY3Rpdml0eVdpbmRvd0luZGVwZW5kZW50KVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKF90aGlzLl93aW5kb3dzLmdldE9yV2FpdC5iaW5kKF90aGlzLl93aW5kb3dzKSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodyk7XHJcbiAgICAgICAgICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5lcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmRlYnVnKFwiQW5ub3VuY2luZyB3aW5kb3cgd2l0aCBpZCAnXCIgKyBhY3Rpdml0eVdpbmRvd0lkICsgXCInIGFuZCB0eXBlICdcIiArIHdpbmRvd1R5cGUgKyBcIidcIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFdpbmRvdyA9IF90aGlzLl93aW5kb3dzLmdldEJ5TmFtZShhY3Rpdml0eVdpbmRvd0lkKTtcclxuICAgICAgICAgICAgICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZE9yTnVsbChjdXJyZW50V2luZG93KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoXCJXaW5kb3cgd2l0aCBpZCAnXCIgKyBhY3Rpdml0eVdpbmRvd0lkICsgXCInIGFscmVhZHkgYW5ub3VuY2VkIC0gcmV1c2luZyB0aGUgd2luZG93XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY3VycmVudFdpbmRvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHdpbmRvd0V2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChhLCB3LCBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2aXR5V2luZG93SWQgPT09IHcuaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgPT09IFwiam9pbmVkXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3Rpdml0eSA9IHcuYWN0aXZpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChhY3Rpdml0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoXCJVTkRFRklORUQgQUNUSVZJVFlcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLnRyYWNlKFwiR290IGpvaW5lZCBldmVudCBmb3IgaWQgJ1wiICsgYWN0aXZpdHlXaW5kb3dJZCArIFwiJ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51bnN1YnNjcmliZVdpbmRvd0V2ZW50cyh3aW5kb3dFdmVudEhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnN1YnNjcmliZVdpbmRvd0V2ZW50cyh3aW5kb3dFdmVudEhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci50cmFjZShcIldhaXRpbmcgZm9yIGpvaW5lZCBldmVudCBmb3IgaWQgJ1wiICsgYWN0aXZpdHlXaW5kb3dJZCArIFwiJ1wiKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9icmlkZ2UuYW5ub3VuY2VXaW5kb3cod2luZG93VHlwZSwgYWN0aXZpdHlXaW5kb3dJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLnN1YnNjcmliZVdpbmRvd1R5cGVFdmVudHMgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMuX3dpbmRvd1R5cGVzLnN1YnNjcmliZShmdW5jdGlvbiAod3QsIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgaGFuZGxlcih3dCwgY29udGV4dC50eXBlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLnN1YnNjcmliZUFjdGl2aXR5RXZlbnRzID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLl9hY3Rpdml0aWVzLnN1YnNjcmliZShmdW5jdGlvbiAoYWN0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0LnR5cGUgPT09IGVudGl0eUV2ZW50XzEuRW50aXR5RXZlbnRUeXBlLlN0YXR1c0NoYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlcihhY3QsIHAubmV3U3RhdHVzLCBwLm9sZFN0YXR1cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLnN1YnNjcmliZVdpbmRvd0V2ZW50cyA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5fd2luZG93cy5zdWJzY3JpYmUoZnVuY3Rpb24gKHdpbmRvdywgY29udGV4dCkge1xyXG4gICAgICAgICAgICBpZiAoY29udGV4dC50eXBlID09PSBlbnRpdHlFdmVudF8xLkVudGl0eUV2ZW50VHlwZS5BY3Rpdml0eVdpbmRvd0V2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyKHdpbmRvdy5hY3Rpdml0eSwgd2luZG93LCBwLmV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjb250ZXh0LnR5cGUgPT09ICdyZW1vdmVkJykge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlcih3aW5kb3cuYWN0aXZpdHksIHdpbmRvdywgY29udGV4dC50eXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUudW5zdWJzY3JpYmVXaW5kb3dFdmVudHMgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuY3JlYXRlV2luZG93ID0gZnVuY3Rpb24gKGFjdGl2aXR5LCB3aW5kb3dUeXBlLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKGFjdGl2aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KFwiYWN0aXZpdHkgaXMgdW5kZWZpbmVkXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHdpbmRvd1R5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoXCJ3aW5kb3dUeXBlIGlzIHVuZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgd2luZG93RGVmaW5pdGlvbjtcclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcod2luZG93VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvd0RlZmluaXRpb24gPSB7IHR5cGU6IHdpbmRvd1R5cGUsIG5hbWU6IFwiXCIsIGlzSW5kZXBlbmRlbnQ6IGZhbHNlLCBhcmd1bWVudHM6IHt9IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3dEZWZpbml0aW9uID0gd2luZG93VHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVsYXRpdmVUb1dpbmRvdztcclxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHdpbmRvd0RlZmluaXRpb24ucmVsYXRpdmVUbykpIHtcclxuICAgICAgICAgICAgICAgIHJlbGF0aXZlVG9XaW5kb3cgPSB3aW5kb3dEZWZpbml0aW9uLnJlbGF0aXZlVG87XHJcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZVRvV2luZG93KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3aW5kb3dzID0gX3RoaXMuZ2V0V2luZG93cyh7IHR5cGU6IHJlbGF0aXZlVG9XaW5kb3cgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHdpbmRvd3MpICYmIHdpbmRvd3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dEZWZpbml0aW9uLnJlbGF0aXZlVG8gPSB3aW5kb3dzWzBdLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHJlbGF0aXZlVG9XaW5kb3cudHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2luZG93cyA9IF90aGlzLmdldFdpbmRvd3MoeyB0eXBlOiByZWxhdGl2ZVRvV2luZG93LnR5cGUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHdpbmRvd3MpICYmIHdpbmRvd3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dEZWZpbml0aW9uLnJlbGF0aXZlVG8gPSB3aW5kb3dzWzBdLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHJlbGF0aXZlVG9XaW5kb3cud2luZG93SWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93RGVmaW5pdGlvbi5yZWxhdGl2ZVRvID0gcmVsYXRpdmVUb1dpbmRvdy53aW5kb3dJZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5fYnJpZGdlLmNyZWF0ZVdpbmRvdyhhY3Rpdml0eS5pZCwgd2luZG93RGVmaW5pdGlvbilcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh3aWQpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoXCJXaW5kb3cgY3JlYXRlZCwgd2FpdGluZyBmb3Igd2luZG93IGVudGl0eSB3aXRoIGlkIFwiICsgd2lkKTtcclxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKHdpbmRvdywgY29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuaWQgPT09IHdpZCAmJiB3aW5kb3cuYWN0aXZpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiR290IGVudGl0eSB3aW5kb3cgd2l0aCBpZCBcIiArIHdpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUod2luZG93KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2luZG93cy51bnN1YnNjcmliZShoYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LmJpbmQoX3RoaXMpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3dpbmRvd3Muc3Vic2NyaWJlKGhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2VFeHRlbnNpb25zXzEubm9kZWlmeShwcm9taXNlLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVTdGFja2VkV2luZG93cyA9IGZ1bmN0aW9uIChhY3Rpdml0eSwgcmVsYXRpdmVXaW5kb3dUeXBlcywgdGltZW91dCwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbChhY3Rpdml0eSkpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChcImFjdGl2aXR5IGlzIHVuZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbChyZWxhdGl2ZVdpbmRvd1R5cGVzKSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KFwicmVsYXRpdmVXaW5kb3dUeXBlcyBpcyB1bmRlZmluZWRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlbGF0aXZlV2luZG93VHlwZXMpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoXCJyZWxhdGl2ZVdpbmRvd1R5cGVzIGhhcyB0byBiZSBhcnJheVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh0aW1lb3V0KSkge1xyXG4gICAgICAgICAgICAgICAgdGltZW91dCA9IDIwMDAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZVdpbmRvd3MgPSBbXTtcclxuICAgICAgICAgICAgcmVsYXRpdmVXaW5kb3dUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgd2luZG93RGVmaW5pdGlvbjtcclxuICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzU3RyaW5nKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93RGVmaW5pdGlvbiA9IHsgdHlwZTogZWxlbWVudCwgbmFtZTogXCJcIiwgaXNJbmRlcGVuZGVudDogZmFsc2UsIGFyZ3VtZW50czoge30gfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0RlZmluaXRpb24gPSBlbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHJlbGF0aXZlVG9XaW5kb3c7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwod2luZG93RGVmaW5pdGlvbi5yZWxhdGl2ZVRvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlVG9XaW5kb3cgPSB3aW5kb3dEZWZpbml0aW9uLnJlbGF0aXZlVG87XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHJlbGF0aXZlVG9XaW5kb3cudHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93RGVmaW5pdGlvbi5yZWxhdGl2ZVRvID0gcmVsYXRpdmVUb1dpbmRvdy50eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghdXRpbC5pc1VuZGVmaW5lZE9yTnVsbChyZWxhdGl2ZVRvV2luZG93LndpbmRvd0lkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2luZG93cyA9IF90aGlzLmdldFdpbmRvd3MoeyBpZDogcmVsYXRpdmVUb1dpbmRvdy53aW5kb3dJZCB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHdpbmRvd3MpICYmIHdpbmRvd3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93RGVmaW5pdGlvbi5yZWxhdGl2ZVRvID0gd2luZG93c1swXS50eXBlLm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dEZWZpbml0aW9uLnVzZUV4aXN0aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlbGF0aXZlV2luZG93cy5wdXNoKHdpbmRvd0RlZmluaXRpb24pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgX3RoaXMuX2JyaWRnZS5jcmVhdGVTdGFja2VkV2luZG93cyhhY3Rpdml0eS5pZCwgcmVsYXRpdmVXaW5kb3dzLCB0aW1lb3V0KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHdpZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2aXR5V2luZG93cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFscmVhZHlDcmVhdGVkID0gW107XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uICh3aW5kb3csIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAod2lkLmluZGV4T2Yod2luZG93LmlkKSA+PSAwICYmIGFscmVhZHlDcmVhdGVkLmluZGV4T2Yod2luZG93LmlkKSA8IDAgJiYgd2luZG93LmFjdGl2aXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcIkdvdCBlbnRpdHkgd2luZG93IHdpdGggaWQgXCIgKyB3aWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpdml0eVdpbmRvd3MucHVzaCh3aW5kb3cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHJlYWR5Q3JlYXRlZC5wdXNoKHdpbmRvdy5pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpdml0eVdpbmRvd3MubGVuZ3RoID09IHdpZC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYWN0aXZpdHlXaW5kb3dzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3dpbmRvd3MudW5zdWJzY3JpYmUoaGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LmJpbmQoX3RoaXMpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3dpbmRvd3Muc3Vic2NyaWJlKGhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2VFeHRlbnNpb25zXzEubm9kZWlmeShwcm9taXNlLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5qb2luV2luZG93VG9BY3Rpdml0eSA9IGZ1bmN0aW9uIChhY3Rpdml0eSwgd2luZG93LCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5sZWF2ZVdpbmRvd0Zyb21BY3Rpdml0eSA9IGZ1bmN0aW9uIChhY3Rpdml0eSwgd2luZG93LCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5zZXRBY3Rpdml0eUNvbnRleHQgPSBmdW5jdGlvbiAoYWN0aXZpdHksIGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwoYWN0aXZpdHkpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoXCJhY3Rpdml0eSBjYW4gbm90IGJlIG51bGxcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuX2JyaWRnZVxyXG4gICAgICAgICAgICAgICAgLnVwZGF0ZUFjdGl2aXR5Q29udGV4dChhY3Rpdml0eSwgY29udGV4dCwgdHJ1ZSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUob2JqKTtcclxuICAgICAgICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlRXh0ZW5zaW9uc18xLm5vZGVpZnkocHJvbWlzZSwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUudXBkYXRlQWN0aXZpdHlDb250ZXh0ID0gZnVuY3Rpb24gKGFjdGl2aXR5LCBjb250ZXh0LCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKGFjdGl2aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KFwiYWN0aXZpdHkgY2FuIG5vdCBiZSBudWxsXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByZW1vdmVkS2V5cyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gY29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBjb250ZXh0W2tleV0gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkS2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuX2JyaWRnZVxyXG4gICAgICAgICAgICAgICAgLnVwZGF0ZUFjdGl2aXR5Q29udGV4dChhY3Rpdml0eSwgY29udGV4dCwgZmFsc2UsIHJlbW92ZWRLZXlzKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShvYmopO1xyXG4gICAgICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2VFeHRlbnNpb25zXzEubm9kZWlmeShwcm9taXNlLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5zdWJzY3JpYmVBY3Rpdml0eUNvbnRleHRDaGFuZ2VkID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLl9hY3Rpdml0aWVzLnN1YnNjcmliZShmdW5jdGlvbiAoYWN0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0LnR5cGUgPT09IGVudGl0eUV2ZW50XzEuRW50aXR5RXZlbnRUeXBlLkFjdGl2aXR5Q29udGV4dENoYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZUNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlcihhY3QsIHVwZGF0ZUNvbnRleHQuY29udGV4dCwgdXBkYXRlQ29udGV4dC51cGRhdGVkLCB1cGRhdGVDb250ZXh0LnJlbW92ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5zdG9wQWN0aXZpdHkgPSBmdW5jdGlvbiAoYWN0aXZpdHksIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9icmlkZ2Uuc3RvcEFjdGl2aXR5KGFjdGl2aXR5KTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZUV4dGVuc2lvbnNfMS5ub2RlaWZ5KHByb21pc2UsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLmdldFdpbmRvd3MgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQoZmlsdGVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2luZG93cy5nZXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkKGZpbHRlci5pZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLl93aW5kb3dzLmdldEJ5TmFtZShmaWx0ZXIuaWQpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFsbFdpbmRvd3MgPSB0aGlzLl93aW5kb3dzLmdldCgpO1xyXG4gICAgICAgIHJldHVybiBhbGxXaW5kb3dzLmZpbHRlcihmdW5jdGlvbiAodykge1xyXG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWQoZmlsdGVyLnR5cGUpICYmIHcudHlwZS5pZCAhPT0gZmlsdGVyLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWQoZmlsdGVyLm5hbWUpICYmIHcubmFtZSAhPT0gZmlsdGVyLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWQoZmlsdGVyLmFjdGl2aXR5SWQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh3LmFjdGl2aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh3LmFjdGl2aXR5LmlkICE9PSBmaWx0ZXIuYWN0aXZpdHlJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLl9ncmFiRW50aXR5ID0gZnVuY3Rpb24gKGVudGl0eSkge1xyXG4gICAgICAgIGVudGl0eS5tYW5hZ2VyID0gdGhpcztcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLl9zdWJzY3JpYmVGb3JEYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiU3RhcnQgZ2V0dGluZyBpbml0aWFsIGRhdGEuLi5cIik7XHJcbiAgICAgICAgdGhpcy5fYnJpZGdlLm9uQWN0aXZpdHlUeXBlU3RhdHVzQ2hhbmdlKGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICBfdGhpcy5fYWN0aXZpdHlUeXBlcy5wcm9jZXNzKGV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9icmlkZ2UuZ2V0QWN0aXZpdHlUeXBlcygpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChhdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5fYWN0aXZpdHlUeXBlcy5hZGQoYXQpO1xyXG4gICAgICAgICAgICBfdGhpcy5fZGF0YVJlYWR5TWFya2VyLnNpZ25hbChcIkdvdCBhY3QgdHlwZXNcIik7XHJcbiAgICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICBfdGhpcy5fZGF0YVJlYWR5TWFya2VyLmVycm9yKFwiQ2FuIG5vdCBpbml0aWFsaXplIEFjdGl2aXR5TWFuYWdlciAtIGVycm9yIGdldHRpbmcgYWN0aXZpdHkgdHlwZXMgLVwiICsgZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2JyaWRnZS5vbldpbmRvd1R5cGVTdGF0dXNDaGFuZ2UoZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl93aW5kb3dUeXBlcy5wcm9jZXNzKGV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9icmlkZ2UuZ2V0V2luZG93VHlwZXMoKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAod3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuX3dpbmRvd1R5cGVzLmFkZCh3dCk7XHJcbiAgICAgICAgICAgIF90aGlzLl9kYXRhUmVhZHlNYXJrZXIuc2lnbmFsKFwiR290IHdpbmRvdyB0eXBlc1wiKTtcclxuICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgIF90aGlzLl9kYXRhUmVhZHlNYXJrZXIuZXJyb3IoXCJDYW4gbm90IGluaXRpYWxpemUgQWN0aXZpdHlNYW5hZ2VyIC0gZXJyb3IgZ2V0dGluZyB3aW5kb3cgdHlwZXMgIFwiICsgZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2JyaWRnZS5vbkFjdGl2aXR5U3RhdHVzQ2hhbmdlKGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICBfdGhpcy5fYWN0aXZpdGllcy5wcm9jZXNzKGV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9icmlkZ2UuZ2V0QWN0aXZpdGllcygpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChhYykge1xyXG4gICAgICAgICAgICBfdGhpcy5fYWN0aXZpdGllcy5hZGQoYWMpO1xyXG4gICAgICAgICAgICBfdGhpcy5fZGF0YVJlYWR5TWFya2VyLnNpZ25hbChcIkdvdCBhY3Rpdml0aWVzXCIpO1xyXG4gICAgICAgIH0pWydjYXRjaCddKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgX3RoaXMuX2RhdGFSZWFkeU1hcmtlci5lcnJvcihcIkNhbiBub3QgaW5pdGlhbGl6ZSBBY3Rpdml0eU1hbmFnZXIgLSBlcnJvciBnZXR0aW5nIGFjdGl2aXR5IGluc3RhbmNlcyAtXCIgKyBlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fYnJpZGdlLm9uQWN0aXZpdHlXaW5kb3dDaGFuZ2UoZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl93aW5kb3dzLnByb2Nlc3MoZXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2JyaWRnZS5nZXRBY3Rpdml0eVdpbmRvd3MoKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYXcpIHtcclxuICAgICAgICAgICAgX3RoaXMuX3dpbmRvd3MuYWRkKGF3KTtcclxuICAgICAgICAgICAgX3RoaXMuX2RhdGFSZWFkeU1hcmtlci5zaWduYWwoXCJHb3Qgd2luZG93c1wiKTtcclxuICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgIF90aGlzLl9kYXRhUmVhZHlNYXJrZXIuZXJyb3IoXCJDYW4gbm90IGluaXRpYWxpemUgQWN0aXZpdHlNYW5hZ2VyIC0gZXJyb3IgZ2V0dGluZyBhY3Rpdml0eSB3aW5kb3dzIC1cIiArIGVycm9yKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLmdldFdpbmRvd0JvdW5kcyA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9icmlkZ2UuZ2V0V2luZG93Qm91bmRzKGlkKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLnNldFdpbmRvd0JvdW5kcyA9IGZ1bmN0aW9uIChpZCwgYm91bmRzLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9icmlkZ2Uuc2V0V2luZG93Qm91bmRzKGlkLCBib3VuZHMpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKCk7IH0pWydjYXRjaCddKGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHJlamVjdChlcnIpOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZUV4dGVuc2lvbnNfMS5ub2RlaWZ5KHByb21pc2UsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLmNsb3NlV2luZG93ID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JyaWRnZS5jbG9zZVdpbmRvdyhpZCk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5hY3RpdmF0ZVdpbmRvdyA9IGZ1bmN0aW9uIChpZCwgZm9jdXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYnJpZGdlLmFjdGl2YXRlV2luZG93KGlkLCBmb2N1cyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFjdGl2aXR5TWFuYWdlcjtcclxufSgpKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzWydkZWZhdWx0J109IEFjdGl2aXR5TWFuYWdlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0aXZpdHlNYW5hZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgTG9jYWxXaW5kb3dGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExvY2FsV2luZG93RmFjdG9yeShjcmVhdGVGdW5jdGlvbiwgZGVzY3JpcHRpb24pIHtcclxuICAgICAgICB0aGlzLl9jcmVhdGVGdW5jdGlvbiA9IGNyZWF0ZUZ1bmN0aW9uO1xyXG4gICAgICAgIHRoaXMuX2Rlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XHJcbiAgICB9XHJcbiAgICBMb2NhbFdpbmRvd0ZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChhY3Rpdml0eVdpbmRvd0lkLCBjb250ZXh0LCBsYXlvdXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlRnVuY3Rpb24oYWN0aXZpdHlXaW5kb3dJZCwgY29udGV4dCwgbGF5b3V0KTtcclxuICAgIH07XHJcbiAgICBMb2NhbFdpbmRvd0ZhY3RvcnkucHJvdG90eXBlLmRlc2NyaXB0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZXNjcmlwdGlvbjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTG9jYWxXaW5kb3dGYWN0b3J5O1xyXG59KCkpO1xyXG5leHBvcnRzLkxvY2FsV2luZG93RmFjdG9yeSA9IExvY2FsV2luZG93RmFjdG9yeTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxXaW5kb3dGYWN0b3J5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgUHJveHlXaW5kb3dGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFByb3h5V2luZG93RmFjdG9yeShkZXNjcmlwdGlvbikge1xyXG4gICAgICAgIHRoaXMuX2Rlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XHJcbiAgICB9XHJcbiAgICBQcm94eVdpbmRvd0ZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChhY3Rpdml0eVdpbmRvd0lkLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBQcm94eVdpbmRvd0ZhY3RvcnkucHJvdG90eXBlLmRlc2NyaXB0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZXNjcmlwdGlvbjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUHJveHlXaW5kb3dGYWN0b3J5O1xyXG59KCkpO1xyXG5leHBvcnRzLlByb3h5V2luZG93RmFjdG9yeSA9IFByb3h5V2luZG93RmFjdG9yeTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJveHlXaW5kb3dGYWN0b3J5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgYWN0aXZpdHlFbnRpdHlfMSA9IHJlcXVpcmUoXCIuL2FjdGl2aXR5RW50aXR5XCIpO1xyXG52YXIgYWN0aXZpdHlBR01fMSA9IHJlcXVpcmUoXCIuLi9jb3JlL2FjdGl2aXR5QUdNXCIpO1xyXG52YXIgQWN0aXZpdHkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFjdGl2aXR5LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQWN0aXZpdHkoaWQsIGFjdFR5cGUsIHN0YXR1cywgY29udGV4dCwgb3duZXJJZCkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGlkKTtcclxuICAgICAgICB0aGlzLl9pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMuX2FjdFR5cGUgPSBhY3RUeXBlO1xyXG4gICAgICAgIHRoaXMuX3N0YXR1cyA9IHN0YXR1cztcclxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB0aGlzLl9vd25lcklkID0gb3duZXJJZDtcclxuICAgICAgICB0aGlzLl9hZ20gPSBuZXcgYWN0aXZpdHlBR01fMS5BY3Rpdml0eUFHTSh0aGlzKTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eS5wcm90b3R5cGUsIFwidHlwZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hbmFnZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0QWN0aXZpdHlUeXBlKHRoaXMuX2FjdFR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHkucHJvdG90eXBlLCBcImNvbnRleHRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eS5wcm90b3R5cGUsIFwic3RhdHVzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXR1cztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eS5wcm90b3R5cGUsIFwib3duZXJcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX293bmVySWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0V2luZG93cyh7IGlkOiB0aGlzLl9vd25lcklkIH0pWzBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5LnByb3RvdHlwZSwgXCJ3aW5kb3dzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5nZXRXaW5kb3dzKHsgYWN0aXZpdHlJZDogdGhpcy5faWQgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHkucHJvdG90eXBlLCBcImFnbVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZ207XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uICh3aW5kb3csIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5qb2luV2luZG93VG9BY3Rpdml0eSh0aGlzLCB3aW5kb3csIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuY3JlYXRlV2luZG93ID0gZnVuY3Rpb24gKHdpbmRvd1R5cGUsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5jcmVhdGVXaW5kb3codGhpcywgd2luZG93VHlwZSwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5jcmVhdGVTdGFja2VkV2luZG93cyA9IGZ1bmN0aW9uICh3aW5kb3dUeXBlcywgdGltZW91dCwgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmNyZWF0ZVN0YWNrZWRXaW5kb3dzKHRoaXMsIHdpbmRvd1R5cGVzLCB0aW1lb3V0LCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLmxlYXZlID0gZnVuY3Rpb24gKHdpbmRvdywgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmxlYXZlV2luZG93RnJvbUFjdGl2aXR5KHRoaXMsIHdpbmRvdywgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5nZXRXaW5kb3dzQnlUeXBlID0gZnVuY3Rpb24gKHdpbmRvd1R5cGUpIHtcclxuICAgICAgICB2YXIgZmlsdGVyID0geyBhY3Rpdml0eUlkOiB0aGlzLl9pZCwgdHlwZTogd2luZG93VHlwZSB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0V2luZG93cyhmaWx0ZXIpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zZXRDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5zZXRBY3Rpdml0eUNvbnRleHQodGhpcywgY29udGV4dCwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci51cGRhdGVBY3Rpdml0eUNvbnRleHQodGhpcywgY29udGV4dCwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5vblN0YXR1c0NoYW5nZSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLm1hbmFnZXIuc3Vic2NyaWJlQWN0aXZpdHlFdmVudHMoZnVuY3Rpb24gKGEsIG5zLCBvcykge1xyXG4gICAgICAgICAgICBpZiAoYS5pZCA9PT0gX3RoaXMuaWQpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIoYSwgbnMsIG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5vbldpbmRvd0V2ZW50ID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMubWFuYWdlci5zdWJzY3JpYmVXaW5kb3dFdmVudHMoZnVuY3Rpb24gKGEsIHcsIGUpIHtcclxuICAgICAgICAgICAgaWYgKGEuaWQgPT09IF90aGlzLmlkKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyKGEsIHcsIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLm9uQ29udGV4dENoYW5nZWQgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnN1YnNjcmliZUFjdGl2aXR5Q29udGV4dENoYW5nZWQoZnVuY3Rpb24gKGFjdCwgY29udGV4dCwgZGVsdGEsIHJlbW92ZWQpIHtcclxuICAgICAgICAgICAgaWYgKGFjdC5pZCA9PT0gX3RoaXMuaWQpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIoY29udGV4dCwgZGVsdGEsIHJlbW92ZWQsIGFjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBoYW5kbGVyKHRoaXMuY29udGV4dCwgdGhpcy5jb250ZXh0LCBbXSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7IH1cclxuICAgIH07XHJcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLm1hbmFnZXIuc3RvcEFjdGl2aXR5KHRoaXMpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS51cGRhdGVDb3JlID0gZnVuY3Rpb24gKGFjdGl2aXR5KSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGVDb3JlLmNhbGwodGhpcywgYWN0aXZpdHkpO1xyXG4gICAgICAgIHRoaXMuX2FjdFR5cGUgPSBhY3Rpdml0eS5fYWN0VHlwZTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gYWN0aXZpdHkuX2NvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5fc3RhdHVzID0gYWN0aXZpdHkuX3N0YXR1cztcclxuICAgICAgICB0aGlzLl9vd25lcklkID0gYWN0aXZpdHkuX293bmVySWQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFjdGl2aXR5O1xyXG59KGFjdGl2aXR5RW50aXR5XzFbJ2RlZmF1bHQnXSkpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHNbJ2RlZmF1bHQnXT0gQWN0aXZpdHk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFjdGl2aXR5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgQWN0aXZpdHlFbnRpdHkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQWN0aXZpdHlFbnRpdHkoaWQpIHtcclxuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2lkID0gaWQ7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHlFbnRpdHkucHJvdG90eXBlLCBcImlkXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQWN0aXZpdHlFbnRpdHkucHJvdG90eXBlLm9uVXBkYXRlZCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChoYW5kbGVyKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eUVudGl0eS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyLl9pZCAhPSB0aGlzLl9pZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkNhbiBub3QgdXBkYXRlIGZyb20gZW50aXR5IHdpdGggZGlmZmVyZW50IGlkLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVDb3JlKG90aGVyKTtcclxuICAgICAgICB0aGlzLm5vdGlmeSgpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5RW50aXR5LnByb3RvdHlwZS51cGRhdGVDb3JlID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlFbnRpdHkucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5saXN0ZW5lcnMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMubGlzdGVuZXJzW2luZGV4XTtcclxuICAgICAgICAgICAgbGlzdGVuZXIodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBBY3Rpdml0eUVudGl0eTtcclxufSgpKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzWydkZWZhdWx0J109IEFjdGl2aXR5RW50aXR5O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpdml0eUVudGl0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIGFjdGl2aXR5RW50aXR5XzEgPSByZXF1aXJlKFwiLi9hY3Rpdml0eUVudGl0eVwiKTtcclxudmFyIEFjdGl2aXR5VHlwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQWN0aXZpdHlUeXBlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQWN0aXZpdHlUeXBlKG5hbWUsIG93bmVyV2luZG93LCBoZWxwZXJXaW5kb3dzLCBkZXNjcmlwdGlvbikge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpO1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuX2Rlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XHJcbiAgICAgICAgdGhpcy5fb3duZXJXaW5kb3cgPSBvd25lcldpbmRvdztcclxuICAgICAgICB0aGlzLl9oZWxwZXJXaW5kb3dzID0gaGVscGVyV2luZG93cyB8fCBbXTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eVR5cGUucHJvdG90eXBlLCBcIm5hbWVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eVR5cGUucHJvdG90eXBlLCBcImRlc2NyaXB0aW9uXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rlc2NyaXB0aW9uO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5VHlwZS5wcm90b3R5cGUsIFwiaGVscGVyV2luZG93c1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWxwZXJXaW5kb3dzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5VHlwZS5wcm90b3R5cGUsIFwib3duZXJXaW5kb3dcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3duZXJXaW5kb3c7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBBY3Rpdml0eVR5cGUucHJvdG90eXBlLnN1YnNjcmliZUFjdGl2aXR5U3RhdHVzQ2hhbmdlID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5VHlwZS5wcm90b3R5cGUuaW5pdGlhdGUgPSBmdW5jdGlvbiAoY29udGV4dCwgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmluaXRpYXRlKHRoaXMuX25hbWUsIGNvbnRleHQsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eVR5cGUucHJvdG90eXBlLnVwZGF0ZUNvcmUgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlQ29yZS5jYWxsKHRoaXMsIHR5cGUpO1xyXG4gICAgICAgIHRoaXMuX2Rlc2NyaXB0aW9uID0gdHlwZS5fZGVzY3JpcHRpb247XHJcbiAgICAgICAgdGhpcy5fb3duZXJXaW5kb3cgPSB0eXBlLl9vd25lcldpbmRvdztcclxuICAgICAgICB0aGlzLl9oZWxwZXJXaW5kb3dzID0gdHlwZS5faGVscGVyV2luZG93cztcclxuICAgIH07XHJcbiAgICByZXR1cm4gQWN0aXZpdHlUeXBlO1xyXG59KGFjdGl2aXR5RW50aXR5XzFbJ2RlZmF1bHQnXSkpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHNbJ2RlZmF1bHQnXT0gQWN0aXZpdHlUeXBlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpdml0eVR5cGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBhY3Rpdml0eUVudGl0eV8xID0gcmVxdWlyZShcIi4vYWN0aXZpdHlFbnRpdHlcIik7XHJcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2xvZ2dlclwiKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vaGVscGVycy91dGlsXCIpO1xyXG52YXIgQWN0aXZpdHlXaW5kb3cgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFjdGl2aXR5V2luZG93LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQWN0aXZpdHlXaW5kb3coaWQsIG5hbWUsIHR5cGUsIGFjdGl2aXR5SWQsIGluc3RhbmNlLCBpc0luZGVwZW5kZW50KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgaWQpO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IGxvZ2dlcl8xLkxvZ2dlci5HZXQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZpdHlJZCA9IGFjdGl2aXR5SWQ7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgICAgICB0aGlzLl9pc0luZGVwZW5kZW50ID0gaXNJbmRlcGVuZGVudDtcclxuICAgIH1cclxuICAgIEFjdGl2aXR5V2luZG93LnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5nZXRXaW5kb3dCb3VuZHModGhpcy5pZCk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5V2luZG93LnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHlXaW5kb3cucHJvdG90eXBlLCBcImlzSW5kZXBlbmRlbnRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNJbmRlcGVuZGVudDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eVdpbmRvdy5wcm90b3R5cGUsIFwidHlwZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hbmFnZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0V2luZG93VHlwZSh0aGlzLl90eXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5V2luZG93LnByb3RvdHlwZSwgXCJhY3Rpdml0eVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKHRoaXMuX2FjdGl2aXR5SWQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0QWN0aXZpdHlCeUlkKHRoaXMuX2FjdGl2aXR5SWQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5V2luZG93LnByb3RvdHlwZSwgXCJpc093bmVyXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFjdCA9IHRoaXMuYWN0aXZpdHk7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKGFjdCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYWN0Lm93bmVyLmlkID09PSB0aGlzLmlkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQWN0aXZpdHlXaW5kb3cucHJvdG90eXBlLnNldFZpc2libGUgPSBmdW5jdGlvbiAoaXNWaXNpYmxlLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlXaW5kb3cucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKGZvY3VzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5hY3RpdmF0ZVdpbmRvdyh0aGlzLmlkLCBmb2N1cyk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlXaW5kb3cucHJvdG90eXBlLnNldFRpdGxlID0gZnVuY3Rpb24gKHRpdGxlLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlXaW5kb3cucHJvdG90eXBlLnNldEJvdW5kcyA9IGZ1bmN0aW9uIChib3VuZHMsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5zZXRXaW5kb3dCb3VuZHModGhpcy5pZCwgYm91bmRzLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlXaW5kb3cucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlXaW5kb3cucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuY2xvc2VXaW5kb3codGhpcy5pZCk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5V2luZG93LnByb3RvdHlwZSwgXCJpbnN0YW5jZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEFjdGl2aXR5V2luZG93LnByb3RvdHlwZS5vbkFjdGl2aXR5Sm9pbmVkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlRm9yQWN0aXZpdHlXaW5kb3dFdmVudChcImpvaW5lZFwiLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlXaW5kb3cucHJvdG90eXBlLm9uQWN0aXZpdHlSZW1vdmVkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlRm9yQWN0aXZpdHlXaW5kb3dFdmVudChcInJlbW92ZWRcIiwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5V2luZG93LnByb3RvdHlwZS51cGRhdGVDb3JlID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZpdHlJZCA9IG90aGVyLl9hY3Rpdml0eUlkO1xyXG4gICAgICAgIHRoaXMuX2lzSW5kZXBlbmRlbnQgPSBvdGhlci5faXNJbmRlcGVuZGVudDtcclxuICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwob3RoZXIuX2luc3RhbmNlKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG90aGVyLl9pbnN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlXaW5kb3cucHJvdG90eXBlLl9zdWJzY3JpYmVGb3JBY3Rpdml0eVdpbmRvd0V2ZW50ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMubWFuYWdlci5zdWJzY3JpYmVXaW5kb3dFdmVudHMoZnVuY3Rpb24gKGFjdGl2aXR5LCB3aW5kb3csIGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cuaWQgIT09IF90aGlzLmlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGV2ZW50ID09PSBldmVudE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGFjdGl2aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBY3Rpdml0eVdpbmRvdztcclxufShhY3Rpdml0eUVudGl0eV8xWydkZWZhdWx0J10pKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzWydkZWZhdWx0J109IEFjdGl2aXR5V2luZG93O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpdml0eVdpbmRvdy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIGFjdGl2aXR5RW50aXR5XzEgPSByZXF1aXJlKFwiLi9hY3Rpdml0eUVudGl0eVwiKTtcclxudmFyIFdpbmRvd1R5cGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFdpbmRvd1R5cGUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBXaW5kb3dUeXBlKG5hbWUsIGZhY3Rvcmllcykge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpO1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuX2ZhY3RvcmllcyA9IGZhY3RvcmllcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXaW5kb3dUeXBlLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2luZG93VHlwZS5wcm90b3R5cGUsIFwiZmFjdG9yaWVzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZhY3RvcmllcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXaW5kb3dUeXBlLnByb3RvdHlwZSwgXCJ3aW5kb3dzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5nZXRXaW5kb3dzKHsgdHlwZTogdGhpcy5fbmFtZSB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFdpbmRvd1R5cGUucHJvdG90eXBlLnJlZ2lzdGVyRmFjdG9yeSA9IGZ1bmN0aW9uIChmYWN0b3J5LCBmYWN0b3J5TWV0aG9kLCBkZXNjcmlwdGlvbiwgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLnJlZ2lzdGVyV2luZG93RmFjdG9yeSh0aGlzLCBmYWN0b3J5TWV0aG9kLCBkZXNjcmlwdGlvbik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFdpbmRvd1R5cGU7XHJcbn0oYWN0aXZpdHlFbnRpdHlfMVsnZGVmYXVsdCddKSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0c1snZGVmYXVsdCddPSBXaW5kb3dUeXBlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5kb3dUeXBlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgZW50aXR5RXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9jb250cmFjdHMvZW50aXR5RXZlbnRcIik7XHJcbnZhciBFbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbihwcm9jZXNzTmV3KSB7XHJcbiAgICAgICAgdGhpcy5faXRlbXMgPSB7fTtcclxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcclxuICAgICAgICB0aGlzLl9wcm9jZXNzTmV3ID0gcHJvY2Vzc05ldztcclxuICAgIH1cclxuICAgIEVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uLnByb3RvdHlwZS5hZGRPbmUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHRoaXMuYWRkKFtpdGVtXSk7XHJcbiAgICB9O1xyXG4gICAgRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChpdGVtcykge1xyXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBpdGVtcy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBpdGVtc1tpbmRleF07XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2VzcyhuZXcgZW50aXR5RXZlbnRfMS5FbnRpdHlFdmVudChlbGVtZW50LCBuZXcgZW50aXR5RXZlbnRfMS5FbnRpdHlFdmVudENvbnRleHQoZW50aXR5RXZlbnRfMS5FbnRpdHlFdmVudFR5cGUuQWRkZWQpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0O1xyXG4gICAgICAgIHZhciB0eXBlID0gY29udGV4dC50eXBlO1xyXG4gICAgICAgIHZhciBlbnRpdHkgPSBldmVudC5lbnRpdHk7XHJcbiAgICAgICAgdmFyIGludGVybmFsRW50aXR5ID0gdGhpcy5fdXBkYXRlSW50ZXJuYWxDb2xsZWN0aW9ucyhlbnRpdHksIHR5cGUpO1xyXG4gICAgICAgIHRoaXMuX25vdGlmeUxpc3RlbmVycyhpbnRlcm5hbEVudGl0eSwgY29udGV4dCk7XHJcbiAgICB9O1xyXG4gICAgRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuX2l0ZW1zKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pdGVtcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuX2l0ZW1zW2tleV07XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIEVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXRCeU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9pdGVtcykge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faXRlbXNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIEVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXRPcldhaXQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgIHZhciBlbnRpdHlBZGRlZEhhbmRsZXIgPSBmdW5jdGlvbiAoZW50aXR5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW50aXR5LmlkICE9PSBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShlbnRpdHkpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudW5zdWJzY3JpYmUoZW50aXR5QWRkZWRIYW5kbGVyKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgX3RoaXMuc3Vic2NyaWJlKGVudGl0eUFkZGVkSGFuZGxlcik7XHJcbiAgICAgICAgICAgIHZhciB3aW5kb3cgPSBfdGhpcy5nZXRCeU5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUod2luZG93KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGhhbmRsZXIpO1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9pdGVtcykge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuX2l0ZW1zW2tleV07XHJcbiAgICAgICAgICAgIGhhbmRsZXIoZWxlbWVudCwgbmV3IGVudGl0eUV2ZW50XzEuRW50aXR5RXZlbnRDb250ZXh0KGVudGl0eUV2ZW50XzEuRW50aXR5RXZlbnRUeXBlLkFkZGVkLnRvU3RyaW5nKCkpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9saXN0ZW5lcnMuaW5kZXhPZihoYW5kbGVyKTtcclxuICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uLnByb3RvdHlwZS5fbm90aWZ5TGlzdGVuZXJzID0gZnVuY3Rpb24gKGVudGl0eSwgY29udGV4dCkge1xyXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMuX2xpc3RlbmVyc1tpbmRleF07XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcihlbnRpdHksIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24ucHJvdG90eXBlLl91cGRhdGVJbnRlcm5hbENvbGxlY3Rpb25zID0gZnVuY3Rpb24gKGVudGl0eSwgdHlwZSkge1xyXG4gICAgICAgIGlmICh0eXBlID09PSBlbnRpdHlFdmVudF8xLkVudGl0eUV2ZW50VHlwZS5SZW1vdmVkKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pdGVtc1tlbnRpdHkuaWRdO1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzTmV3KGVudGl0eSk7XHJcbiAgICAgICAgICAgIHJldHVybiBlbnRpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gZW50aXR5LmlkO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2l0ZW1zLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NOZXcoZW50aXR5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1zW2VudGl0eS5pZF0gPSBlbnRpdHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pdGVtc1tlbnRpdHkuaWRdLnVwZGF0ZShlbnRpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtc1tlbnRpdHkuaWRdO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbjtcclxufSgpKTtcclxuZXhwb3J0cy5FbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbiA9IEVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xyXG52YXIgTG9nTGV2ZWwgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTG9nTGV2ZWwoKSB7XHJcbiAgICB9XHJcbiAgICBMb2dMZXZlbC5UcmFjZSA9IFwidHJhY2VcIjtcclxuICAgIExvZ0xldmVsLkRlYnVnID0gXCJkZWJ1Z1wiO1xyXG4gICAgTG9nTGV2ZWwuSW5mbyA9IFwiaW5mb1wiO1xyXG4gICAgTG9nTGV2ZWwuV2FybiA9IFwid2FyblwiO1xyXG4gICAgTG9nTGV2ZWwuRXJyb3IgPSBcImVycm9yXCI7XHJcbiAgICByZXR1cm4gTG9nTGV2ZWw7XHJcbn0oKSk7XHJcbmV4cG9ydHMuTG9nTGV2ZWwgPSBMb2dMZXZlbDtcclxudmFyIExvZ2dlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMb2dnZXIobmFtZSkge1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xyXG4gICAgICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZE9yTnVsbChMb2dnZXIuR2x1ZUxvZ2dlcikpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2x1ZUxvZ2dlciA9IExvZ2dlci5HbHVlTG9nZ2VyLnN1YkxvZ2dlcihuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBMb2dnZXIuR2V0TmFtZWQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTG9nZ2VyKG5hbWUpO1xyXG4gICAgfTtcclxuICAgIExvZ2dlci5HZXQgPSBmdW5jdGlvbiAob3duZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExvZ2dlcihMb2dnZXIuR2V0VHlwZU5hbWUob3duZXIpKTtcclxuICAgIH07XHJcbiAgICBMb2dnZXIucHJvdG90eXBlLnRyYWNlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwodGhpcy5fZ2x1ZUxvZ2dlcikpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2x1ZUxvZ2dlci50cmFjZShtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChMb2dnZXIuTGV2ZWwgPT09IExvZ0xldmVsLlRyYWNlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8odGhpcy5fZ2V0TWVzc2FnZShtZXNzYWdlLCBMb2dMZXZlbC5UcmFjZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExvZ2dlci5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh0aGlzLl9nbHVlTG9nZ2VyKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9nbHVlTG9nZ2VyLmRlYnVnKG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKExvZ2dlci5MZXZlbCA9PT0gTG9nTGV2ZWwuRGVidWcgfHxcclxuICAgICAgICAgICAgICAgIExvZ2dlci5MZXZlbCA9PT0gTG9nTGV2ZWwuVHJhY2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyh0aGlzLl9nZXRNZXNzYWdlKG1lc3NhZ2UsIExvZ0xldmVsLkRlYnVnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTG9nZ2VyLnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwodGhpcy5fZ2x1ZUxvZ2dlcikpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2x1ZUxvZ2dlci5pbmZvKG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKExvZ2dlci5MZXZlbCA9PT0gTG9nTGV2ZWwuRGVidWcgfHxcclxuICAgICAgICAgICAgICAgIExvZ2dlci5MZXZlbCA9PT0gTG9nTGV2ZWwuVHJhY2UgfHxcclxuICAgICAgICAgICAgICAgIExvZ2dlci5MZXZlbCA9PT0gTG9nTGV2ZWwuSW5mbykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKHRoaXMuX2dldE1lc3NhZ2UobWVzc2FnZSwgTG9nTGV2ZWwuSW5mbykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExvZ2dlci5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHRoaXMuX2dsdWVMb2dnZXIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsdWVMb2dnZXIud2FybihtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChMb2dnZXIuTGV2ZWwgPT09IExvZ0xldmVsLkRlYnVnIHx8XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIuTGV2ZWwgPT09IExvZ0xldmVsLlRyYWNlIHx8XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIuTGV2ZWwgPT09IExvZ0xldmVsLkluZm8gfHxcclxuICAgICAgICAgICAgICAgIExvZ2dlci5MZXZlbCA9PT0gTG9nTGV2ZWwuV2Fybikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKHRoaXMuX2dldE1lc3NhZ2UobWVzc2FnZSwgTG9nTGV2ZWwuSW5mbykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExvZ2dlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh0aGlzLl9nbHVlTG9nZ2VyKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9nbHVlTG9nZ2VyLmVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcih0aGlzLl9nZXRNZXNzYWdlKG1lc3NhZ2UsIExvZ0xldmVsLkVycm9yKSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTG9nZ2VyLnByb3RvdHlwZS5fZ2V0TWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBsZXZlbCkge1xyXG4gICAgICAgIHJldHVybiBcIltcIiArIGxldmVsICsgXCJdIFwiICsgdGhpcy5fbmFtZSArIFwiIC0gXCIgKyBtZXNzYWdlO1xyXG4gICAgfTtcclxuICAgIExvZ2dlci5HZXRUeXBlTmFtZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcclxuICAgICAgICB2YXIgZnVuY05hbWVSZWdleCA9IC9mdW5jdGlvbiAoLnsxLH0pXFwoLztcclxuICAgICAgICB2YXIgcmVzdWx0cyA9IChmdW5jTmFtZVJlZ2V4KS5leGVjKG9iamVjdC5jb25zdHJ1Y3Rvci50b1N0cmluZygpKTtcclxuICAgICAgICByZXR1cm4gKHJlc3VsdHMgJiYgcmVzdWx0cy5sZW5ndGggPiAxKSA/IHJlc3VsdHNbMV0gOiBcIlwiO1xyXG4gICAgfTtcclxuICAgIExvZ2dlci5MZXZlbCA9IExvZ0xldmVsLkluZm87XHJcbiAgICByZXR1cm4gTG9nZ2VyO1xyXG59KCkpO1xyXG5leHBvcnRzLkxvZ2dlciA9IExvZ2dlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3V0aWxcIik7XHJcbnZhciBuZXh0VGljayA9IGZ1bmN0aW9uIChjYikgeyBzZXRUaW1lb3V0KGNiLCAwKTsgfTtcclxuZnVuY3Rpb24gbm9kZWlmeShwcm9taXNlLCBjYWxsYmFjaykge1xyXG4gICAgaWYgKCF1dGlsLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9XHJcbiAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3ApIHtcclxuICAgICAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3ApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBudWxsKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMubm9kZWlmeSA9IG5vZGVpZnk7XHJcbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvbWlzZUV4dGVuc2lvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCIuL2xvZ2dlclwiKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vaGVscGVycy91dGlsXCIpO1xyXG52YXIgUmVhZHlNYXJrZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVhZHlNYXJrZXIobmFtZSwgc2lnbmFsc1RvV2FpdCkge1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IGxvZ2dlcl8xLkxvZ2dlci5HZXROYW1lZChcIlJlYWR5TWFya2VyIFtcIiArIG5hbWUgKyBcIl1cIik7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiSW5pdGlhbGl6aW5nIHJlYWR5IG1hcmtlciBmb3IgJ1wiICsgbmFtZSArIFwiJyB3aXRoIFwiICsgc2lnbmFsc1RvV2FpdCArIFwiIHNpZ25hbHMgdG8gd2FpdFwiKTtcclxuICAgICAgICBpZiAoc2lnbmFsc1RvV2FpdCA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2lnbmFsIG51bWJlci4gU2hvdWxkIGJlID4gMFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc2lnbmFscyA9IHNpZ25hbHNUb1dhaXQ7XHJcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gW107XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XHJcbiAgICB9XHJcbiAgICBSZWFkeU1hcmtlci5wcm90b3R5cGUuc2V0Q2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAodGhpcy5pc1NldCgpKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc0Vycm9yKCkpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5fZXJyb3IpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICBSZWFkeU1hcmtlci5wcm90b3R5cGUuc2lnbmFsID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoXCJTaWduYWxlZCAtIFwiICsgbWVzc2FnZSArIFwiIC0gc2lnbmFscyBsZWZ0IFwiICsgKHRoaXMuX3NpZ25hbHMgLSAxKSk7XHJcbiAgICAgICAgdGhpcy5fc2lnbmFscy0tO1xyXG4gICAgICAgIGlmICh0aGlzLl9zaWduYWxzIDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiByZWFkeSBtYXJrZXIgJ1wiICsgdGhpcy5fbmFtZSArIFwiIC0gc2lnbmFscyBhcmUgXCIgKyB0aGlzLl9zaWduYWxzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNTZXQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSZWFkeU1hcmtlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xyXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChlcnJvckNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFJlYWR5TWFya2VyLnByb3RvdHlwZS5pc1NldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0Vycm9yKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fc2lnbmFscyA9PT0gMDtcclxuICAgIH07XHJcbiAgICBSZWFkeU1hcmtlci5wcm90b3R5cGUuaXNFcnJvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gIXV0aWwuaXNVbmRlZmluZWQodGhpcy5fZXJyb3IpO1xyXG4gICAgfTtcclxuICAgIFJlYWR5TWFya2VyLnByb3RvdHlwZS5nZXRFcnJvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlYWR5TWFya2VyO1xyXG59KCkpO1xyXG5leHBvcnRzLlJlYWR5TWFya2VyID0gUmVhZHlNYXJrZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWR5TWFya2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcclxuICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcclxufVxyXG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XHJcbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xyXG59XHJcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcclxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xyXG59XHJcbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcclxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XHJcbn1cclxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcclxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XHJcbn1cclxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xyXG5mdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbChhcmcpIHtcclxuICAgIHJldHVybiAhYXJnIHx8IHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xyXG59XHJcbmV4cG9ydHMuaXNVbmRlZmluZWRPck51bGwgPSBpc1VuZGVmaW5lZE9yTnVsbDtcclxuZnVuY3Rpb24gaXNFbXB0eShhcmcpIHtcclxuICAgIGZvciAodmFyIHByb3AgaW4gYXJnKSB7XHJcbiAgICAgICAgaWYgKGFyZy5oYXNPd25Qcm9wZXJ0eShwcm9wKSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZXhwb3J0cy5pc0VtcHR5ID0gaXNFbXB0eTtcclxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcclxuICAgIHJldHVybiAhIShhcmcgJiYgYXJnLmNvbnN0cnVjdG9yICYmIGFyZy5jYWxsICYmIGFyZy5hcHBseSk7XHJcbn1cclxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcclxuO1xyXG5mdW5jdGlvbiBzb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcclxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBhcnJheS5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5leHBvcnRzLnNvbWUgPSBzb21lO1xyXG5mdW5jdGlvbiBmaXJzdChhcnJheSwgcHJlZGljYXRlKSB7XHJcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgYXJyYXkubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyYXlbaW5kZXhdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuZXhwb3J0cy5maXJzdCA9IGZpcnN0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCIsIi8qKlxuICogVGhpcyBtb2R1bGUgaGFuZGxlcyBBR00gbWV0aG9kIGludm9jYXRpb25zIC0gdmFsaWRhdGluZyBpbnB1dHMgYW5kIGRlbGVnYXRpbmcgdG8gcHJvdG9jb2xcbiAqL1xudmFyIHJhbmRvbSA9IHJlcXVpcmUoJy4vaGVscGVycy9yYW5kb20nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocHJvdG9jb2wpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKiogU3RvcmUgcGVuZGluZyBjYWxsYmFjayAqKi9cbiAgICB2YXIgcGVuZGluZ0NhbGxiYWNrcyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBhbiBBR00gbWV0aG9kIHRvIGEgc2luZ2xlIEFHTSBzZXJ2ZXIsIGdpdmVuIHZhbGlkIGlucHV0LlxuICAgICAqIEBwYXJhbSBtZXRob2RcbiAgICAgKiBAcGFyYW0gYXJndW1lbnRzT2JqXG4gICAgICogQHBhcmFtIHRhcmdldFxuICAgICAqIEBwYXJhbSBzdHVmZlxuICAgICAqIEBwYXJhbSBzdWNjZXNzXG4gICAgICogQHBhcmFtIGVycm9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJndW1lbnRzT2JqLCB0YXJnZXQsIHN0dWZmLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnZvY2F0aW9uIElELCBmb3IgdGhpcyBpbnZvY2F0aW9uXG4gICAgICAgIHZhciBpbnZvY2F0aW9uSWQgPSByYW5kb20oKTtcblxuICAgICAgICAvLyBSZWdpc3RlciB0aGUgdXNlcidzIGNhbGxiYWNrc1xuICAgICAgICByZWdpc3Rlckludm9jYXRpb24oaW52b2NhdGlvbklkLCB7XG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIGNhbGxlZFdpdGg6IGFyZ3VtZW50c09ialxuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvciwgc3R1ZmYubWV0aG9kX3Jlc3BvbnNlX3RpbWVvdXQpO1xuXG4gICAgICAgIHByb3RvY29sLmludm9rZShpbnZvY2F0aW9uSWQsIG1ldGhvZCwgYXJndW1lbnRzT2JqLCB0YXJnZXQsIHN0dWZmKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBpbnZvY2F0aW9uIHNvIHdlIGNhbiBmaW5kIGl0IGxhdGVyIHdoZW4gaW52b2NhdGlvbiByZXN1bHQgaXMgcmVjZWl2ZWRcbiAgICAgKiBAcGFyYW0gaW52b2NhdGlvbklkXG4gICAgICogQHBhcmFtIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHN1Y2Nlc3NcbiAgICAgKiBAcGFyYW0gZXJyb3JcbiAgICAgKiBAcGFyYW0gdGltZW91dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZ2lzdGVySW52b2NhdGlvbihpbnZvY2F0aW9uSWQsIHJlc3BvbnNlLCBzdWNjZXNzLCBlcnJvciwgdGltZW91dCkge1xuICAgICAgICAvLyBBZGRzIHRoZSBjYWxsYmFja3NcbiAgICAgICAgcGVuZGluZ0NhbGxiYWNrc1tpbnZvY2F0aW9uSWRdID0geyByZXNwb25zZTogcmVzcG9uc2UsIHN1Y2Nlc3M6IHN1Y2Nlc3MsIGVycm9yOiBlcnJvciB9O1xuICAgICAgICAvLyBTY2hlZHVsZXMgdG8gdGhyb3cgYSB0aW1lb3V0IGlmIG5vYm9keSBhbnN3ZXJzXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHBlbmRpbmdDYWxsYmFja3NbaW52b2NhdGlvbklkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogcmVzcG9uc2UubWV0aG9kLFxuICAgICAgICAgICAgICAgIGNhbGxlZF93aXRoOiByZXNwb25zZS5jYWxsZWRXaXRoLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaW1lb3V0IHJlYWNoZWQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlbGV0ZSBwZW5kaW5nQ2FsbGJhY2tzW2ludm9jYXRpb25JZF07XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgaW52b2NhdGlvbiByZXN1bHQgcmVjZWl2ZWQgZnJvbSBwcm90b2NsXG4gICAgICogQHBhcmFtIGludm9jYXRpb25JZFxuICAgICAqIEBwYXJhbSBleGVjdXRlZEJ5XG4gICAgICogQHBhcmFtIHN0YXR1c1xuICAgICAqIEBwYXJhbSByZXN1bHRcbiAgICAgKiBAcGFyYW0gcmVzdWx0TWVzc2FnZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NJbnZvY2F0aW9uUmVzdWx0KGludm9jYXRpb25JZCwgZXhlY3V0ZWRCeSwgc3RhdHVzLCByZXN1bHQsIHJlc3VsdE1lc3NhZ2UpIHtcbiAgICAgICAgLy8gRmluZHMgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrXG4gICAgICAgIHZhciBjYWxsYmFjayA9IHBlbmRpbmdDYWxsYmFja3NbaW52b2NhdGlvbklkXTtcbiAgICAgICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgc2VydmVyIHJldHVybmVkIHN1Y2Nlc3MsIGV4ZWN1dGUgdGhlIHN1Y2Nlc3MgY2FsbGJhY2tcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMCAmJiB0eXBlb2YgY2FsbGJhY2suc3VjY2VzcyA9PT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgICAgICAgICAvLyBFeGVjdXRlIHRoZSBzdWNjZXNzIGNhbGxiYWNrXG4gICAgICAgICAgICBjYWxsYmFjay5zdWNjZXNzKHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IGNhbGxiYWNrLnJlc3BvbnNlLm1ldGhvZC5pbmZvLFxuICAgICAgICAgICAgICAgIGNhbGxlZF93aXRoOiBjYWxsYmFjay5yZXNwb25zZS5jYWxsZWRXaXRoLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGVkX2J5OiBleGVjdXRlZEJ5LFxuICAgICAgICAgICAgICAgIHJldHVybmVkOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogcmVzdWx0TWVzc2FnZVxuICAgICAgICAgICAgICAgIC8vIGxvZ19kZXRhaWxzOiBtZXNzYWdlLlJlc3VsdExvZ0RldGFpbHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gRWxzZSwgcmV0dXJuIGFuIGVycm9yXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNhbGxiYWNrLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG5cbiAgICAgICAgICAgIGNhbGxiYWNrLmVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IGNhbGxiYWNrLnJlc3BvbnNlLm1ldGhvZC5pbmZvLFxuICAgICAgICAgICAgICAgIGNhbGxlZF93aXRoOiBjYWxsYmFjay5yZXNwb25zZS5jYWxsZWRXaXRoLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGVkX2J5OiBleGVjdXRlZEJ5LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHJlc3VsdE1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgLy8gbG9nX2RldGFpbHM6IG1lc3NhZ2UuUmVzdWx0TG9nRGV0YWlscyxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHN0YXR1c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluYWxseSwgcmVtb3ZlIHRoZSBjYWxsYmFja3NcbiAgICAgICAgZGVsZXRlIHBlbmRpbmdDYWxsYmFja3NbaW52b2NhdGlvbklkXTtcbiAgICB9XG5cbiAgICAvLyBzdWJzY3JpYmUgZm9yIGludm9jYXRpb24gcmVzdWx0c1xuICAgIHByb3RvY29sLm9uSW52b2NhdGlvblJlc3VsdChwcm9jZXNzSW52b2NhdGlvblJlc3VsdCk7XG5cbiAgICByZXR1cm4geyBpbnZva2U6IGludm9rZSB9O1xufTtcbiIsIi8qXG4gVGhlIEFHTSBDbGllbnQgYW5hbHlzZXMgc2VydmVyIHByZXNlbmNlcywgY29sbGVjdHMgaW5mb3JtYXRpb24gYWJvdXQgdGhlaXIgbWV0aG9kcyBhbmQgYWxsb3dzIHVzZXJzIHRvIGludm9rZSB0aGVzZSBtZXRob2RzLlxuICovXG5cbnZhciBQcm9taXNlID0gcmVxdWlyZSgnZXM2LXByb21pc2UnKS5Qcm9taXNlO1xudmFyIENsaWVudEludm9jYXRpb25zU3RhdGUgPSByZXF1aXJlKCcuL2FnbS1jbGllbnQtaW52b2tlJyk7XG52YXIgcHJvbWlzaWZ5ID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb21pc2lmeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwcm90b2NvbCwgcmVwbywgaW5zdGFuY2UsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBJbnN0YW50aWF0ZSB0aGUgbW9kdWxlIHRoYXQgaGFuZGxlcyBtZXRob2QgZXhlY3V0aW9uIGFuZCByZXNwb25zZXNcbiAgICB2YXIgY2xpZW50SW52b2NhdGlvbnMgPSBuZXcgQ2xpZW50SW52b2NhdGlvbnNTdGF0ZShwcm90b2NvbCk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBtZXRob2RzIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIGZpbHRlci4gSWYgbm8gZmlsdGVyIHNwZWNpZmllZCByZXR1cm5zIGFsbCBtZXRob2RzLlxuICAgICAqIEBwYXJhbSAgICBtZXRob2RGaWx0ZXIgT3B0aW9uYWwgb2JqZWN0IC0gcGFydGlhbCBtZXRob2QgZGVmaW5pdGlvblxuICAgICAqIEByZXR1cm4gQW4gYXJyYXkgb2Yge3NlcnZlcjp7fSwgbWV0aG9kczpbXX0gb2JqZWN0cyAtIG1ldGhvZHMgZm9yIGVhY2ggc2VydmVyIHRoYXQgbWF0Y2ggdGhlIGZpbHRlclxuICAgICAqICovXG4gICAgZnVuY3Rpb24gZ2V0TWV0aG9kcyhtZXRob2RGaWx0ZXIpIHtcbiAgICAgICAgaWYgKG1ldGhvZEZpbHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwby5nZXRNZXRob2RzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2RGaWx0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBtZXRob2RGaWx0ZXIgPSB7IG5hbWU6IG1ldGhvZEZpbHRlciB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXBvLmdldE1ldGhvZHMoKS5maWx0ZXIoZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZE1hdGNoKG1ldGhvZEZpbHRlciwgbWV0aG9kLmluZm8pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIHNlcnZlcnMgdGhhdCBzdXBwb3J0IGFueSBvZiBzZXZlcmFsIG1ldGhvZHMsIGxpc3RlZCBhcyBhbiBhcnJheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE1ldGhvZHNGb3JJbnN0YW5jZShpbnN0YW5jZUZpbHRlcikge1xuICAgICAgICB2YXIgYWxsU2VydmVycyA9IHJlcG8uZ2V0U2VydmVycygpO1xuXG4gICAgICAgIHZhciBtYXRjaGluZ1NlcnZlcnMgPSBhbGxTZXJ2ZXJzLmZpbHRlcihmdW5jdGlvbiAoc2VydmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2VNYXRjaChpbnN0YW5jZUZpbHRlciwgc2VydmVyLmluZm8pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWF0Y2hpbmdTZXJ2ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdE1ldGhvZHNPYmplY3QgPSB7fTtcblxuICAgICAgICBpZiAobWF0Y2hpbmdTZXJ2ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmVzdWx0TWV0aG9kc09iamVjdCA9IG1hdGNoaW5nU2VydmVyc1swXS5tZXRob2RzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd2UgaGF2ZSBtb3JlIHRoYW4gb25lIHNlcnZlciBtYXRjaGluZywgam9pbiBhbGwgbWV0aG9kc1xuICAgICAgICAgICAgbWF0Y2hpbmdTZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gKHNlcnZlcikge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHNlcnZlci5tZXRob2RzKS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2RLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IHNlcnZlci5tZXRob2RzW21ldGhvZEtleV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdE1ldGhvZHNPYmplY3RbbWV0aG9kLmlkXSA9IG1ldGhvZC5nZXRJbmZvRm9yVXNlcigpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyYW5zZm9ybSB0aGUgb2JqZWN0IHRvIGFycmF5XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhyZXN1bHRNZXRob2RzT2JqZWN0KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdE1ldGhvZHNPYmplY3Rba2V5XVxuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFsbCBnZXRTZXJ2ZXJzIHRoYXQgc3VwcG9ydCBhIGdpdmVuIG1ldGhvZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNlcnZlcnMobWV0aG9kRmlsdGVyKSB7XG4gICAgICAgIHZhciBzZXJ2ZXJzID0gcmVwby5nZXRTZXJ2ZXJzKCk7XG5cbiAgICAgICAgLy8gTm8gbWV0aG9kIC0gZ2V0IGFsbCBnZXRTZXJ2ZXJzXG4gICAgICAgIGlmIChtZXRob2RGaWx0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcnZlcnMubWFwKGZ1bmN0aW9uIChzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzZXJ2ZXI6IHNlcnZlciB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9uLWV4aXN0aW5nIG1ldGhvZCAtIHJldHVybiBhbiBlbXB0eSBhcnJheVxuICAgICAgICB2YXIgbWV0aG9kcyA9IGdldE1ldGhvZHMobWV0aG9kRmlsdGVyKTtcbiAgICAgICAgaWYgKG1ldGhvZHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlcnZlcnMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyZW50KSB7XG5cbiAgICAgICAgICAgIHZhciBtZXRob2RzID0gcmVwby5nZXRTZXJ2ZXJNZXRob2RzQnlJZChjdXJyZW50LmlkKTtcblxuICAgICAgICAgICAgdmFyIG1hdGNoaW5nTWV0aG9kcyA9IG1ldGhvZHMuZmlsdGVyKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kTWF0Y2gobWV0aG9kRmlsdGVyLCBtZXRob2QuaW5mbyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nTWV0aG9kcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcHJldi5wdXNoKHsgc2VydmVyOiBjdXJyZW50LCBtZXRob2RzOiBtYXRjaGluZ01ldGhvZHMgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBzZXJ2ZXItbWV0aG9kcyBwYWlycyBmb3IgYWxsIHNlcnZlcnMgdGhhdCBtYXRjaCB0aGUgdGFyZ2V0IGFuZCBoYXZlIGF0IGxlYXNlIG9uZSBtZXRob2QgbWF0aGluZyB0aGUgbWV0aG9kIGZpbHRlclxuICAgICAqIEBwYXJhbSBtZXRob2RGaWx0ZXJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2VydmVyTWV0aG9kc0J5RmlsdGVyQW5kVGFyZ2V0KG1ldGhvZEZpbHRlciwgdGFyZ2V0KSB7XG4gICAgICAgIC8vIGdldCBhbGwgc2VydmVycyB0aGF0IGhhdmUgbWV0aG9kKHMpIG1hdGNoaW5nIHRoZSBmaWx0ZXJcbiAgICAgICAgdmFyIHNlcnZlcnNNZXRob2RNYXAgPSBnZXRTZXJ2ZXJzKG1ldGhvZEZpbHRlcik7XG4gICAgICAgIC8vIGZpbHRlciB0aGUgc2VydmVyLW1ldGhvZCBtYXAgYnkgdGFyZ2V0XG4gICAgICAgIHJldHVybiBmaWx0ZXJCeVRhcmdldCh0YXJnZXQsIHNlcnZlcnNNZXRob2RNYXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgYW4gQUdNIG1ldGhvZFxuICAgICAqIEBwYXJhbSBtZXRob2RGaWx0ZXJcbiAgICAgKiBAcGFyYW0gYXJndW1lbnRPYmpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0XG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxPcHRpb25zXG4gICAgICogQHBhcmFtIHN1Y2Nlc3NcbiAgICAgKiBAcGFyYW0gZXJyb3JcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiovXG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZEZpbHRlciwgYXJndW1lbnRPYmosIHRhcmdldCwgYWRkaXRpb25hbE9wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHN1Y2Nlc3NQcm94eSwgZXJyb3JQcm94eTtcblxuICAgICAgICAgICAgc3VjY2Vzc1Byb3h5ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAvLyB2YXIgcGFyc2VkID0gSlNPTi5wYXJzZShhcmdzKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVycm9yUHJveHkgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgIC8vIHZhciBwYXJzZWQgPSBKU09OLnBhcnNlKGFyZ3MpO1xuICAgICAgICAgICAgICAgIHJlamVjdChhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBBZGQgZGVmYXVsdCBwYXJhbXNcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRPYmopIHtcbiAgICAgICAgICAgICAgICBhcmd1bWVudE9iaiA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSAnYmVzdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycgJiYgdGFyZ2V0ICE9PSAnYWxsJyAmJiB0YXJnZXQgIT09ICdiZXN0Jykge1xuICAgICAgICAgICAgICAgIHJlamVjdCh7IG1lc3NhZ2U6ICdcIicgKyB0YXJnZXQgKyAnXCIgaXMgbm90IGEgdmFsaWQgdGFyZ2V0LiBWYWxpZCB0YXJnZXRzIGFyZSBcImFsbFwiIGFuZCBcImJlc3RcIi4nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhZGRpdGlvbmFsT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhZGRpdGlvbmFsT3B0aW9ucy5tZXRob2RfcmVzcG9uc2VfdGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnMubWV0aG9kX3Jlc3BvbnNlX3RpbWVvdXQgPSBjb25maWd1cmF0aW9uLm1ldGhvZF9yZXNwb25zZV90aW1lb3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFkZGl0aW9uYWxPcHRpb25zLndhaXRfZm9yX21ldGhvZF90aW1lb3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsT3B0aW9ucy53YWl0X2Zvcl9tZXRob2RfdGltZW91dCA9IGNvbmZpZ3VyYXRpb24ud2FpdF9mb3JfbWV0aG9kX3RpbWVvdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBhcmd1bWVudHMgYXJlIGFuIG9iamVjdFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudE9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoeyBtZXNzYWdlOiAnVGhlIG1ldGhvZCBhcmd1bWVudHMgbXVzdCBiZSBhbiBvYmplY3QuJyB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXRob2RGaWx0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kRmlsdGVyID0geyBuYW1lOiBtZXRob2RGaWx0ZXIgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNlcnZlcnNNZXRob2RNYXAgPSBnZXRTZXJ2ZXJNZXRob2RzQnlGaWx0ZXJBbmRUYXJnZXQobWV0aG9kRmlsdGVyLCB0YXJnZXQpO1xuXG4gICAgICAgICAgICBpZiAoc2VydmVyc01ldGhvZE1hcC5sZW5ndGggPT09IDApIHtcblxuICAgICAgICAgICAgICAgIGludm9rZVVuZXhpc3RpbmcobWV0aG9kRmlsdGVyLCBhcmd1bWVudE9iaiwgdGFyZ2V0LCBhZGRpdGlvbmFsT3B0aW9ucywgc3VjY2Vzc1Byb3h5LCBlcnJvclByb3h5KTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXJ2ZXJzTWV0aG9kTWFwLmxlbmd0aCA9PT0gMSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHNlcnZlck1ldGhvZFBhaXIgPSBzZXJ2ZXJzTWV0aG9kTWFwWzBdO1xuICAgICAgICAgICAgICAgIGNsaWVudEludm9jYXRpb25zLmludm9rZShzZXJ2ZXJNZXRob2RQYWlyLm1ldGhvZHNbMF0sIGFyZ3VtZW50T2JqLCBzZXJ2ZXJNZXRob2RQYWlyLnNlcnZlciwgYWRkaXRpb25hbE9wdGlvbnMsIHN1Y2Nlc3NQcm94eSwgZXJyb3JQcm94eSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBpbnZva2VPbkFsbChzZXJ2ZXJzTWV0aG9kTWFwLCBhcmd1bWVudE9iaiwgYWRkaXRpb25hbE9wdGlvbnMsIHN1Y2Nlc3NQcm94eSwgZXJyb3JQcm94eSk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHByb21pc2lmeShwcm9taXNlLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHVzZXIgdHJpZXMgdG8gaW52b2tlIGEgbWV0aG9kIHdoaWNoIGRvZXMgbm90IGV4aXN0XG4gICAgICogQHBhcmFtIG1ldGhvZEZpbHRlclxuICAgICAqIEBwYXJhbSBhcmd1bWVudE9ialxuICAgICAqIEBwYXJhbSB0YXJnZXRcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbE9wdGlvbnNcbiAgICAgKiBAcGFyYW0gc3VjY2Vzc1xuICAgICAqIEBwYXJhbSBlcnJvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludm9rZVVuZXhpc3RpbmcobWV0aG9kRmlsdGVyLCBhcmd1bWVudE9iaiwgdGFyZ2V0LCBhZGRpdGlvbmFsT3B0aW9ucywgc3VjY2VzcywgZXJyb3IpIHtcblxuICAgICAgICBpZiAoYWRkaXRpb25hbE9wdGlvbnMud2FpdF9mb3JfbWV0aG9kX3RpbWVvdXQgPT09IDApIHtcbiAgICAgICAgICAgIGNhbGxFcnJvcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGFsbCBzZXJ2ZXJzIHRoYXQgaGF2ZSBtZXRob2QocykgbWF0Y2hpbmcgdGhlIGZpbHRlclxuICAgICAgICAgICAgICAgIHZhciBzZXJ2ZXJzTWV0aG9kTWFwID0gZ2V0U2VydmVyTWV0aG9kc0J5RmlsdGVyQW5kVGFyZ2V0KG1ldGhvZEZpbHRlciwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VydmVyc01ldGhvZE1hcC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGludm9rZShtZXRob2RGaWx0ZXIsIGFyZ3VtZW50T2JqLCB0YXJnZXQsIGFkZGl0aW9uYWxPcHRpb25zLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgYWRkaXRpb25hbE9wdGlvbnMud2FpdF9mb3JfbWV0aG9kX3RpbWVvdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2FsbEVycm9yKCkge1xuICAgICAgICAgICAgZXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kRmlsdGVyLFxuICAgICAgICAgICAgICAgIGNhbGxlZF93aXRoOiBhcmd1bWVudE9iaixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQ2FuIG5vdCBmaW5kIGEgbWV0aG9kIG1hdGNoaW5nIFwiJyArIEpTT04uc3RyaW5naWZ5KG1ldGhvZEZpbHRlcikgKyAnXCIgd2l0aCBzZXJ2ZXIgZmlsdGVyIFwiJyArIEpTT04uc3RyaW5naWZ5KHRhcmdldCkgKyAnXCInXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxzIGEgbWV0aG9kIGZvciBhbGwgc2VydmVycyBhbmQgdW5pZmllcyB0aGUgcmVzdWx0cyB0aGV5IHJldHVybiBpbnRvIG9uZTpcbiAgICAgKiBAcGFyYW0gc2VydmVyTWV0aG9kc01hcFxuICAgICAqIEBwYXJhbSBhcmd1bWVudE9ialxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsT3B0aW9uc1xuICAgICAqIEBwYXJhbSBzdWNjZXNzXG4gICAgICogQHBhcmFtIGVycm9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52b2tlT25BbGwoc2VydmVyTWV0aG9kc01hcCwgYXJndW1lbnRPYmosIGFkZGl0aW9uYWxPcHRpb25zLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAvLyBIZXJlIHdlIHdpbGwgc3RvcmUgdGhlIHJlc3VsdHMgdGhhdCB0aGUgZ2V0U2VydmVycyByZXR1cm5cbiAgICAgICAgdmFyIHN1Y2Nlc3NlcyA9IFtdO1xuICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgIC8vIFRoZXNlIGFyZSB0aGUgY2FsbGJhY2tzXG4gICAgICAgIHZhciBzdWNjZXNzQ2FsbGJhY2sgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBzdWNjZXNzZXMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgc2VuZFJlc3BvbnNlKHN1Y2Nlc3NlcywgZXJyb3JzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGVycm9yQ2FsbGJhY2sgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgc2VuZFJlc3BvbnNlKHN1Y2Nlc3NlcywgZXJyb3JzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ2FsbCB0aGUgbWV0aG9kIGZvciBhbGwgdGFyZ2V0c1xuICAgICAgICBzZXJ2ZXJNZXRob2RzTWFwLmZvckVhY2goZnVuY3Rpb24gKHNlcnZlck1ldGhvZHNQYWlyKSB7XG4gICAgICAgICAgICBjbGllbnRJbnZvY2F0aW9ucy5pbnZva2Uoc2VydmVyTWV0aG9kc1BhaXIubWV0aG9kc1swXSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudE9iaixcbiAgICAgICAgICAgICAgICBzZXJ2ZXJNZXRob2RzUGFpci5zZXJ2ZXIsXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2spO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDYWxscyB0aGUgbWFpbiBzdWNjZXNzIGFuZCBlcnJvciBjYWxsYmFja3Mgd2l0aCB0aGUgYWdncmVnYXRlZCByZXN1bHRzXG4gICAgICAgIGZ1bmN0aW9uIHNlbmRSZXNwb25zZSgpIHtcbiAgICAgICAgICAgIC8vIHdhaXQgdGlsbCBldmVyeWJvZHkgaXMgZmluaXNoZWRcbiAgICAgICAgICAgIGlmIChzdWNjZXNzZXMubGVuZ3RoICsgZXJyb3JzLmxlbmd0aCA8IHNlcnZlck1ldGhvZHNNYXAubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRXhlY3V0ZSB0aGUgXCJzdWNjZXNzXCIgY2FsbGJhY2tcbiAgICAgICAgICAgIGlmIChzdWNjZXNzZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHN1Y2Nlc3Nlcy5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBvYmoubWV0aG9kID0gc3VjY2Vzcy5tZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgIG9iai5jYWxsZWRfd2l0aCA9IHN1Y2Nlc3MuY2FsbGVkX3dpdGg7XG4gICAgICAgICAgICAgICAgICAgIG9iai5yZXR1cm5lZCA9IHN1Y2Nlc3MucmV0dXJuZWQ7XG4gICAgICAgICAgICAgICAgICAgIG9iai5hbGxfcmV0dXJuX3ZhbHVlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVkX2J5OiBzdWNjZXNzLmV4ZWN1dGVkX2J5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWQ6IHN1Y2Nlc3MucmV0dXJuZWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG9iai5leGVjdXRlZF9ieSA9IHN1Y2Nlc3MuZXhlY3V0ZWRfYnk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgfSwgeyBhbGxfcmV0dXJuX3ZhbHVlczogW10gfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBnZXQgZXJyb3JzIGZyb20gb25lIG9mIHRoZSBnZXRTZXJ2ZXJzIGFkZCB0aGVtIHRvIHRoZSBzdWNjZXNzIG9iamVjdCB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQuXG4gICAgICAgICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFsbF9lcnJvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFsbF9lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhlY3V0ZWRfYnkgOiBvYmouZXhlY3V0ZWRfYnksIC8vIHdlIGRvbid0IGdldCBleGVjdXRlZF9ieSBvYmplY3QgZnJvbSB0aGUgZXJyb3IgY2xpZW50SW52b2NhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBvYmoubWV0aG9kLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogb2JqLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdWNjZXNzKHJlc3VsdCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3JzLmxlbmd0aCAhPT0gMCkgeyAvLyBFeGVjdXRlIHRoZSBcImVycm9yXCIgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBlcnJvcihlcnJvcnMucmVkdWNlKGZ1bmN0aW9uIChvYmosIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai5tZXRob2QgPSBlcnJvci5tZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgIG9iai5jYWxsZWRfd2l0aCA9IGVycm9yLmNhbGxlZF93aXRoO1xuICAgICAgICAgICAgICAgICAgICBvYmoubWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIG9iai5hbGxfZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZWRfYnk6IGVycm9yLmV4ZWN1dGVkX2J5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gb2JqLmV4ZWN1dGVkX2J5ID0gc3VjY2Vzcy5leGVjdXRlZF9ieTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICB9LCB7IGFsbF9lcnJvcnM6IFtdIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbHRlcnMgYW4gYXJyYXkgb2Ygc2VydmVycyBhbmQgcmV0dXJucyB0aGUgb25lcyB3aGljaCBtYXRjaCB0aGUgdGFyZ2V0IGNyaXRlcmlhXG4gICAgICogQHBhcmFtIHRhcmdldFxuICAgICAqIEBwYXJhbSBzZXJ2ZXJNZXRob2RNYXBcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiAqL1xuICAgIGZ1bmN0aW9uIGZpbHRlckJ5VGFyZ2V0KHRhcmdldCwgc2VydmVyTWV0aG9kTWFwKSB7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIHNwZWNpZmllZCB0YXJnZXQgYXMgc3RyaW5nOlxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT09ICdhbGwnKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gc2VydmVyTWV0aG9kTWFwO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQgPT09ICdiZXN0Jykge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHNlcnZlck1ldGhvZE1hcFswXSAhPT0gdW5kZWZpbmVkID8gW3NlcnZlck1ldGhvZE1hcFswXV0gOiBbXTsgIC8vIElmIHRoZSB1c2VyIHNwZWNpZmllZCB0aGUgdGFyZ2V0IGFzIHNlcnZlciBmaWx0ZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gW3RhcmdldF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSBhbGwgZ2V0U2VydmVycyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXJzXG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucmVkdWNlKGZ1bmN0aW9uIChtYXRjaGVzLCBmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgbWF0Y2hlcyBmb3IgZWFjaCBmaWx0ZXJcbiAgICAgICAgICAgICAgICB2YXIgbXlNYXRjaGVzID0gc2VydmVyTWV0aG9kTWFwLmZpbHRlcihmdW5jdGlvbiAoc2VydmVyTWV0aG9kUGFpcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2VNYXRjaChmaWx0ZXIsIHNlcnZlck1ldGhvZFBhaXIuc2VydmVyLmluZm8pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzLmNvbmNhdChteU1hdGNoZXMpO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWF0Y2hlcyBhIHNlcnZlciBkZWZpbml0aW9uIGFnYWluc3QgYSBzZXJ2ZXIgZmlsdGVyXG4gICAgICogQHBhcmFtIGluc3RhbmNlRmlsdGVyXG4gICAgICogQHBhcmFtIGluc3RhbmNlRGVmaW5pdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc3RhbmNlTWF0Y2goaW5zdGFuY2VGaWx0ZXIsIGluc3RhbmNlRGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gY29udGFpbnNQcm9wcyhpbnN0YW5jZUZpbHRlciwgaW5zdGFuY2VEZWZpbml0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXRjaGVzIGEgbWV0aG9kIGRlZmluaXRpb24gYWdhaW5zdCBhIG1ldGhvZCBmaWx0ZXJcbiAgICAgKiBAcGFyYW0gbWV0aG9kRmlsdGVyXG4gICAgICogQHBhcmFtIG1ldGhvZERlZmluaXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXRob2RNYXRjaChtZXRob2RGaWx0ZXIsIG1ldGhvZERlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zUHJvcHMobWV0aG9kRmlsdGVyLCBtZXRob2REZWZpbml0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYWxsIHByb3BlcnRpZXMgb2YgZmlsdGVyIG1hdGNoIHByb3BlcnRpZXMgaW4gb2JqZWN0XG4gICAgICogQHBhcmFtIGZpbHRlclxuICAgICAqIEBwYXJhbSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb250YWluc1Byb3BzKGZpbHRlciwgb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhmaWx0ZXIpLnJlZHVjZShmdW5jdGlvbiAobWF0Y2gsIHByb3ApIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSB1bmRlZmluZWQgcHJvcGVydGllc1xuICAgICAgICAgICAgaWYgKCFmaWx0ZXJbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmaWx0ZXJbcHJvcF0uY29uc3RydWN0b3IgPT09IFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgIGlmICghZmlsdGVyW3Byb3BdLnRlc3Qob2JqZWN0W3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKFN0cmluZyhmaWx0ZXJbcHJvcF0pLnRvTG93ZXJDYXNlKCkgIT09IFN0cmluZyhvYmplY3RbcHJvcF0pLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgdG8gYW4gQUdNIHN0cmVhbWluZyBtZXRob2RcbiAgICAgKiBAcGFyYW0gbmFtZVxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIHN1Y2Nlc3NDYWxsYmFja1xuICAgICAqIEBwYXJhbSBlcnJvckNhbGxiYWNrXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3Vic2NyaWJlKG5hbWUsIG9wdGlvbnMsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICAvLyBvcHRpb25zIGNhbiBoYXZlIGFyZ3VtZW50czp7fSwgdGFyZ2V0OiAnYmVzdCcvJ2FsbCcve3NlcnZlcl9pbnN0YW5jZX0sIHdhaXRUaW1lb3V0TXM6MzAwMFxuXG4gICAgICAgIGZ1bmN0aW9uIGNhbGxQcm90b2NvbFN1YnNjcmliZSh0YXJnZXRTZXJ2ZXJzLCBzdHJlYW0sIG9wdGlvbnMsIHN1Y2Nlc3NQcm94eSwgZXJyb3JQcm94eSkge1xuICAgICAgICAgICAgaWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgY29uZmlndXJhdGlvbi5kZWJ1ZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCc+Pj4gU3Vic2NyaWJpbmcgdG8gXCInICsgbmFtZSArICdcIiBvbiAnICsgdGFyZ2V0U2VydmVycy5sZW5ndGggKyAnIHNlcnZlcnMnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvdG9jb2wuc3Vic2NyaWJlKFxuICAgICAgICAgICAgICAgIHN0cmVhbSxcbiAgICAgICAgICAgICAgICBvcHRpb25zLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICB0YXJnZXRTZXJ2ZXJzLFxuICAgICAgICAgICAgICAgIHsgbWV0aG9kX3Jlc3BvbnNlX3RpbWVvdXQ6IG9wdGlvbnMud2FpdFRpbWVvdXRNcyB9LFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3NQcm94eSxcbiAgICAgICAgICAgICAgICBlcnJvclByb3h5XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cbiAgICAgICAgICAgIHZhciBzdWNjZXNzUHJveHkgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoYXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGVycm9yUHJveHkgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgIHJlamVjdChhcmdzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7XG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSAnYmVzdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycgJiYgdGFyZ2V0ICE9PSAnYWxsJyAmJiB0YXJnZXQgIT09ICdiZXN0Jykge1xuICAgICAgICAgICAgICAgIHJlamVjdCh7IG1lc3NhZ2U6ICdcIicgKyB0YXJnZXQgKyAnXCIgaXMgbm90IGEgdmFsaWQgdGFyZ2V0LiBWYWxpZCB0YXJnZXRzIGFyZSBcImFsbFwiLCBcImJlc3RcIiwgb3IgYW4gaW5zdGFuY2UuJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53YWl0VGltZW91dE1zICE9PSAnbnVtYmVyJyB8fCBvcHRpb25zLndhaXRUaW1lb3V0TXMgIT09IG9wdGlvbnMud2FpdFRpbWVvdXRNcyAvKiBOYU4gKi8pIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLndhaXRUaW1lb3V0TXMgPSBjb25maWd1cmF0aW9uLndhaXRfZm9yX21ldGhvZF90aW1lb3V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkb24ndCBjaGVjayBpZiB0aGUgbWV0aG9kIGlzIHN0cmVhbWluZyBvciBub3QsIHN1YnNjcmliaW5nIHRvIG5vbi1zdHJlYW1pbmcgbWV0aG9kIGhhcyB0byBpbnZva2UgaXRcbiAgICAgICAgICAgIHZhciBjdXJyZW50U2VydmVycyA9IGdldFNlcnZlck1ldGhvZHNCeUZpbHRlckFuZFRhcmdldCh7IG5hbWU6IG5hbWUgfSwgdGFyZ2V0KTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTZXJ2ZXJzLmxlbmd0aCA9PT0gMCkge1xuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJy4uLm5vIHNlcnZlcnMnKS8vdGVzdFxuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXRlU2VydmVycyA9IGdldFNlcnZlck1ldGhvZHNCeUZpbHRlckFuZFRhcmdldCh7IG5hbWU6IG5hbWUgfSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogY2hhbmdlIHRvIHVzZSB0aGUgbWV0aG9kQWRkZWQgaGFuZGxlclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBzZXQgYWdtLm1ldGhvZEFkZGVkIGFuZCBpZih3YWl0VGltZW91dD49MCl7c2V0VGltZW91dH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyZWFtSW5mbyA9IGxhdGVTZXJ2ZXJzLmxlbmd0aCA+IDAgPyBsYXRlU2VydmVyc1swXS5tZXRob2RzWzBdIDogeyBuYW1lOiBuYW1lIH07XG4gICAgICAgICAgICAgICAgICAgIGNhbGxQcm90b2NvbFN1YnNjcmliZShsYXRlU2VydmVycywgc3RyZWFtSW5mbywgb3B0aW9ucywgc3VjY2Vzc1Byb3h5LCBlcnJvclByb3h5KVxuXG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucy53YWl0VGltZW91dE1zKVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxQcm90b2NvbFN1YnNjcmliZShjdXJyZW50U2VydmVycywgY3VycmVudFNlcnZlcnNbMF0ubWV0aG9kc1swXSwgb3B0aW9ucywgc3VjY2Vzc1Byb3h5LCBlcnJvclByb3h5KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHByb21pc2UsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgICAgIGludm9rZTogaW52b2tlLFxuICAgICAgICBzZXJ2ZXJzOiBmdW5jdGlvbiAobWV0aG9kRmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U2VydmVycyhtZXRob2RGaWx0ZXIpLm1hcChmdW5jdGlvbiAoc2VydmVyTWV0aG9kTWFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcnZlck1ldGhvZE1hcC5zZXJ2ZXIuZ2V0SW5mb0ZvclVzZXIoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGhvZHM6IGZ1bmN0aW9uIChtZXRob2RGaWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRNZXRob2RzKG1ldGhvZEZpbHRlcikubWFwKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG0uZ2V0SW5mb0ZvclVzZXIoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgbWV0aG9kc0Zvckluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRNZXRob2RzRm9ySW5zdGFuY2UoaW5zdGFuY2UpLm1hcChmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtLmdldEluZm9Gb3JVc2VyKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGhvZEFkZGVkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJlcG8ub25NZXRob2RBZGRlZChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobWV0aG9kLmdldEluZm9Gb3JVc2VyKCkpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBtZXRob2RSZW1vdmVkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJlcG8ub25NZXRob2RSZW1vdmVkKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhtZXRob2QuZ2V0SW5mb0ZvclVzZXIoKSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIHNlcnZlckFkZGVkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJlcG8ub25TZXJ2ZXJBZGRlZChmdW5jdGlvbiAoc2VydmVyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soc2VydmVyLmdldEluZm9Gb3JVc2VyKCkpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBzZXJ2ZXJSZW1vdmVkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJlcG8ub25TZXJ2ZXJSZW1vdmVkKGZ1bmN0aW9uIChzZXJ2ZXIsIHJlYXNvbikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHNlcnZlci5nZXRJbmZvRm9yVXNlcigpLCByZWFzb24pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBzZXJ2ZXJNZXRob2RBZGRlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXBvLm9uU2VydmVyTWV0aG9kQWRkZWQoZnVuY3Rpb24gKHNlcnZlciwgbWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soeyBzZXJ2ZXI6IHNlcnZlci5nZXRJbmZvRm9yVXNlcigpLCBtZXRob2Q6IG1ldGhvZC5nZXRJbmZvRm9yVXNlcigpIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBzZXJ2ZXJNZXRob2RSZW1vdmVkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJlcG8ub25TZXJ2ZXJNZXRob2RSZW1vdmVkKGZ1bmN0aW9uIChzZXJ2ZXIsIG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHsgc2VydmVyOiBzZXJ2ZXIuZ2V0SW5mb0ZvclVzZXIoKSwgbWV0aG9kOiBtZXRob2QuZ2V0SW5mb0ZvclVzZXIoKSB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH07XG59O1xuIiwiLypcbiBUaGUgQUdNIGluc3RhbmNlIGNvbGxlY3RzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBtYWNoaW5lIHdlIGFyZSBpbixcbiBhbmQgaW50ZXJhY3RzIHdpdGggdGhlIC5ORVQgZ2F0ZXdheSBpbiBvdGhlciB3YXlzLFxuIHRvIGRlbGl2ZXIgZnVsbCBBR00gY29tcGF0aWJpbGl0eSB0byBBR00uSlMuXG5cbiBUbyBkbyBzbywgaXQgcmVsaWVzIG9uIHRoZSBkZWZhdWx0IEFHTSBjbGllbnQuXG4gKi9cblxudmFyIGRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50IHx8IGdsb2JhbC5wcm9jZXNzO1xudmFyIHJhbmRvbSA9IHJlcXVpcmUoJy4vaGVscGVycy9yYW5kb20nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXNlclN1Ym1pdHRlZFByb3BlcnRpZXMpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaW5zdGFuY2UgPSB7fTtcbiAgICAvLyBHZW5lcmF0ZSBkZWZhdWx0IGluc3RhbmNlIHByb3BlcnRpZXNcbiAgICBpbnN0YW5jZS5BcHBsaWNhdGlvbk5hbWUgPSBkb2N1bWVudC50aXRsZSArIHJhbmRvbSgpO1xuICAgIGluc3RhbmNlLlByb2Nlc3NJZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDAwKTsgLy8gUElEIHNob3VsZCBiZSBpbnRlZ2VyIGZvciBwcm90b2NvbFZlcnNpb24gMVxuICAgIGluc3RhbmNlLlByb2Nlc3NTdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgIC8vIEFwcGx5IHVzZXItc3VibWl0dGVkIGluc3RhbmNlIHByb3BlcnRpZXNcbiAgICBpZiAodHlwZW9mIHVzZXJTdWJtaXR0ZWRQcm9wZXJ0aWVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAodXNlclN1Ym1pdHRlZFByb3BlcnRpZXMuYXBwbGljYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5zdGFuY2UuQXBwbGljYXRpb25OYW1lID0gdXNlclN1Ym1pdHRlZFByb3BlcnRpZXMuYXBwbGljYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UuTWFjaGluZU5hbWUgPSB1c2VyU3VibWl0dGVkUHJvcGVydGllcy5tYWNoaW5lO1xuICAgICAgICBpbnN0YW5jZS5Vc2VyTmFtZSA9IHVzZXJTdWJtaXR0ZWRQcm9wZXJ0aWVzLnVzZXI7XG4gICAgICAgIGluc3RhbmNlLkVudmlyb25tZW50ID0gdXNlclN1Ym1pdHRlZFByb3BlcnRpZXMuZW52aXJvbm1lbnQ7XG4gICAgICAgIGluc3RhbmNlLlJlZ2lvbiA9IHVzZXJTdWJtaXR0ZWRQcm9wZXJ0aWVzLnJlZ2lvbjtcbiAgICAgICAgaW5zdGFuY2UuU3RhdGUgPSAxO1xuICAgIH1cbiAgICB2YXIgaWRlbnRpdHlVcGRhdGVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVJZGVudGl0eShuZXdJbnN0YW5jZSkge1xuICAgICAgICBpZiAoaWRlbnRpdHlVcGRhdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3RhbmNlLk1hY2hpbmVOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLk1hY2hpbmVOYW1lID0gbmV3SW5zdGFuY2UuTWFjaGluZU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3RhbmNlLlVzZXJOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLlVzZXJOYW1lID0gbmV3SW5zdGFuY2UuVXNlck5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3RhbmNlLkVudmlyb25tZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLkVudmlyb25tZW50ID0gbmV3SW5zdGFuY2UuRW52aXJvbm1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3RhbmNlLlJlZ2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5SZWdpb24gPSBuZXdJbnN0YW5jZS5SZWdpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3RhbmNlLlN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLlN0YXRlID0gbmV3SW5zdGFuY2UuU3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgZ2xvYmFsLmNvbnNvbGUudGFibGUgIT09IHVuZGVmaW5lZCAmJiBhZ20uZGVidWcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXZlZCBpbnN0YW5jZSB3aXRoIGluZm8gZnJvbSBHYXRld2F5LicpO1xuICAgICAgICB9XG4gICAgICAgIGlkZW50aXR5VXBkYXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgbWV0aG9kIGZvciBhY2Nlc3NpbmcgYSBwcm9wZXJ0eVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUdldHRlcihwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2VbcHJvcGVydHldO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYWxsIGluc3RhbmNlIHByb3BlcnRpZXNcbiAgICBmdW5jdGlvbiBpbmZvKCkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgX3VwZGF0ZUlkZW50aXR5OiB1cGRhdGVJZGVudGl0eSxcbiAgICAgICAgaW5mbzogaW5mbyxcbiAgICAgICAgZ2V0IGFwcGxpY2F0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUdldHRlcignQXBwbGljYXRpb25OYW1lJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBwaWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlR2V0dGVyKCdQcm9jZXNzSWQnKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHVzZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlR2V0dGVyKCdVc2VyTmFtZScpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgbWFjaGluZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVHZXR0ZXIoJ01hY2hpbmVOYW1lJyk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbiIsInZhciBQcm9taXNlID0gcmVxdWlyZSgnZXM2LXByb21pc2UnKS5Qcm9taXNlO1xudmFyIHByb21pc2lmeSA9IHJlcXVpcmUoJy4vaGVscGVycy9wcm9taXNpZnknKTtcbnZhciBwanNvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gZGF0ZSBwYXJzaW5nXG4gICAgdmFyIGZhY2FkZSA9IGdsb2JhbC5odG1sQ29udGFpbmVyLmpzQWdtRmFjYWRlO1xuICAgIHZhciBkYXRlVGltZUlkZW50aWZpZXIgPSBmYWNhZGUuanNvblZhbHVlRGF0ZVByZWZpeDtcbiAgICB2YXIgbGVuT2ZJZGVudGlmaWVyID0gZGF0ZVRpbWVJZGVudGlmaWVyLmxlbmd0aDtcblxuICAgIGZ1bmN0aW9uIHN0cmluZ1RvT2JqZWN0KHBhcmFtLCBzdHJpbmdQcm9wTmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICAgICAgb2JqW3N0cmluZ1Byb3BOYW1lXSA9IHBhcmFtO1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJhbTtcbiAgICB9XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIHBhcnNpbmcgZGF0ZXMgcHJvcGVybHlcbiAgICBmdW5jdGlvbiBhZ21QYXJzZShzdHIpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyLCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBwcmUtc2VlZCAtIHRoaXMgc2hvdWxkIGJlIGEgYml0IGZhc3RlciB0aGFuIGluZGV4T2ZcbiAgICAgICAgICAgIGlmICh2WzBdICE9PSBkYXRlVGltZUlkZW50aWZpZXJbMF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHYuaW5kZXhPZihkYXRlVGltZUlkZW50aWZpZXIpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB1bml4VGltZXN0YW1wTXMgPSB2LnN1YnN0cihsZW5PZklkZW50aWZpZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHBhcnNlRmxvYXQodW5peFRpbWVzdGFtcE1zKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgdGFyZ2V0IGFyZ3VtZW50IHRvIG9iamVjdCByZWFkeSB0byBiZSBwYXNzZWQgdG8gQWdtIGZhY2FkZVxuICAgICAqIEBwYXJhbSB0YXJnZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YXJnZXRBcmdUb09iamVjdCh0YXJnZXQpIHtcblxuICAgICAgICB0YXJnZXQgPSB0YXJnZXQgfHwgJ2Jlc3QnO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gJ2FsbCcgJiYgdGFyZ2V0ICE9PSAnYmVzdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIHRhcmdldCArICdcIiBpcyBub3QgYSB2YWxpZCB0YXJnZXQuIFZhbGlkIHRhcmdldHMgYXJlIFwiYWxsXCIgYW5kIFwiYmVzdFwiLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgdGFyZ2V0OiB0YXJnZXQgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gW3RhcmdldF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydEluc3RhbmNlVG9SZWdleChlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4geyBzZXJ2ZXJGaWx0ZXI6IHRhcmdldCB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udmVydEluc3RhbmNlVG9SZWdleChpbnN0YW5jZSkge1xuICAgICAgICB2YXIgaW5zdGFuY2VDb252ZXJ0ZWQgPSB7fTtcblxuICAgICAgICBPYmplY3Qua2V5cyhpbnN0YW5jZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gaW5zdGFuY2Vba2V5XTtcbiAgICAgICAgICAgIGluc3RhbmNlQ29udmVydGVkW2tleV0gPSBwcm9wVmFsdWU7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIGRvIGV4YWN0IG1hdGNoaW5nIGlmIHVzZXIgcGFzc2VkIGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VDb252ZXJ0ZWRba2V5XSA9ICdeJyArIGluc3RhbmNlW2tleV0gKyAnJCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluc3RhbmNlW2tleV0uY29uc3RydWN0b3IgPT09IFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlQ29udmVydGVkW2tleV0gPSBpbnN0YW5jZVtrZXldLnNvdXJjZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VDb252ZXJ0ZWRba2V5XSA9IGluc3RhbmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2VDb252ZXJ0ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG5cbiAgICAgICAgICAgIHZlcnNpb246IHBqc29uLnZlcnNpb24sXG5cbiAgICAgICAgICAgIC8vIFJlZ2lzdGVycyBhIEphdmFTY3JpcHQgZnVuY3Rpb24gYXMgYW4gQUdNIG1ldGhvZCwgdGh1cyBtYWtpbmcgaXQgYXZhaWxhYmxlIG90aGVyIEFHTSBpbnN0YW5jZXMgb24gdGhlIHNhbWUgdHJhbnNwb3J0LlxuICAgICAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIChtZXRob2RJbmZvLCBjYWxsYmFjaykge1xuXG4gICAgICAgICAgICAgICAgdmFyIHB2ID0gdGhpcy5hZ21GYWNhZGUucHJvdG9jb2xWZXJzaW9uO1xuXG4gICAgICAgICAgICAgICAgaWYgKHB2ICYmIHB2ID49IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIG5ld2VyIEhDIHVzZSB0aGUgdmVyc2lvbiB3aGVyZSB3ZSBkb24ndCBwYXNzIGFyZ3VtZW50cyBhcyBKU09OIChiZWNhdXNlIG9mIGRpZmZlcmVudCBpc3N1ZXMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWdtRmFjYWRlLnJlZ2lzdGVyKEpTT04uc3RyaW5naWZ5KHN0cmluZ1RvT2JqZWN0KG1ldGhvZEluZm8sICduYW1lJykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlKTsgLy8gcmV0dXJuIGFzIG9iamVjdHNcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFnbUZhY2FkZS5yZWdpc3RlcihKU09OLnN0cmluZ2lmeShzdHJpbmdUb09iamVjdChtZXRob2RJbmZvLCAnbmFtZScpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2soSlNPTi5wYXJzZShhcmcpLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVnaXN0ZXJBc3luYzogZnVuY3Rpb24gKG1ldGhvZEluZm8sIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFnbUZhY2FkZS5yZWdpc3RlckFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IHN1cHBvcnRlZCBpbiB0aGF0IHZlcnNpb24gb2YgSHRtbENvbnRhaW5lcicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuYWdtRmFjYWRlLnJlZ2lzdGVyQXN5bmMoc3RyaW5nVG9PYmplY3QobWV0aG9kSW5mbywgJ25hbWUnKSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGFyZ3MsIGluc3RhbmNlLCB0cmFja2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBleGVjdXRlIHRoZSB1c2VyIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzdWNjZXNzQXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja2VyLnN1Y2Nlc3Moc3VjY2Vzc0FyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrZXIuZXJyb3IoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdW5yZWdpc3RlcjogZnVuY3Rpb24gKG1ldGhvZEZpbHRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWdtRmFjYWRlLnVucmVnaXN0ZXIoSlNPTi5zdHJpbmdpZnkoc3RyaW5nVG9PYmplY3QobWV0aG9kRmlsdGVyLCAnbmFtZScpKSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBJbnZva2VzIGFuIEFHTSBtZXRob2QgYXN5bmNocm9ub3VzbHkuXG4gICAgICAgICAgICBpbnZva2U6IGZ1bmN0aW9uIChtZXRob2RGaWx0ZXIsIGFyZ3MsIHRhcmdldCwgb3B0aW9ucywgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0ge307XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3MgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoeyBtZXNzYWdlOiAnVGhlIG1ldGhvZCBhcmd1bWVudHMgbXVzdCBiZSBhbiBvYmplY3QuJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldEFyZ1RvT2JqZWN0KHRhcmdldCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWdtRmFjYWRlLmludm9rZTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGludm9rZSB2ZXIyIC0gZG8gbm90IHN0cmluZ2lmeSBhcmd1bWVudHMgYW5kIHJlc3VsdCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWdtRmFjYWRlLmludm9rZTIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoc3RyaW5nVG9PYmplY3QobWV0aG9kRmlsdGVyLCAnbmFtZScpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHRhcmdldCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkob3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShhcmdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VjY2Vzc1Byb3h5LCBlcnJvclByb3h5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzUHJveHkgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWQgPSBKU09OLnBhcnNlKGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocGFyc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclByb3h5ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VkID0gSlNPTi5wYXJzZShhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QocGFyc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFnbUZhY2FkZS5pbnZva2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoc3RyaW5nVG9PYmplY3QobWV0aG9kRmlsdGVyLCAnbmFtZScpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShhcmdzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh0YXJnZXQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NQcm94eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvclByb3h5XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2lmeShwcm9taXNlLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gUmVnaXN0ZXJzIGEgaGFuZGxlciB3aGljaCBub3RpZmllcyB5b3Ugd2hlbiBhIG5ldyBBR00gbWV0aG9kIGlzIGF2YWlsYWJsZS5cbiAgICAgICAgICAgIG1ldGhvZEFkZGVkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFnbUZhY2FkZS5tZXRob2RBZGRlZChjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBSZWdpc3RlcnMgYSBoYW5kbGVyIHdoaWNoIG5vdGlmaWVzIHlvdSB3aGVuIGFuIEFHTSBtZXRob2Qgc3RvcHMgYmVpbmcgYXZhaWxhYmxlLlxuICAgICAgICAgICAgbWV0aG9kUmVtb3ZlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZ21GYWNhZGUubWV0aG9kUmVtb3ZlZChjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXJ2ZXJBZGRlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZ21GYWNhZGUuc2VydmVyQWRkZWQoY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2VydmVyUmVtb3ZlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZ21GYWNhZGUuc2VydmVyUmVtb3ZlZChjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXJ2ZXJNZXRob2RBZGRlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZ21GYWNhZGUuc2VydmVyTWV0aG9kQWRkZWQoY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2VydmVyTWV0aG9kUmVtb3ZlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZ21GYWNhZGUuc2VydmVyTWV0aG9kUmVtb3ZlZChjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBSZXRyaWV2ZXMgYSBsaXN0IG9mIEFHTSBzZXJ2ZXJzIChpbnN0YW5jZXMpIG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgbWV0aG9kLlxuICAgICAgICAgICAgc2VydmVyczogZnVuY3Rpb24gKG1ldGhvZEZpbHRlcikge1xuICAgICAgICAgICAgICAgIHZhciBqc29uUmVzdWx0ID0gdGhpcy5hZ21GYWNhZGUuc2VydmVycyhKU09OLnN0cmluZ2lmeShtZXRob2RGaWx0ZXIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWdtUGFyc2UoanNvblJlc3VsdCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBSZXRyaWV2ZXMgYSBsaXN0IG9mIG1ldGhvZHMgdGhhdCBtYXRjaGVzIGEgZ2l2ZW4gZmlsdGVyLiBZb3UgY2FuIHVzZSB0aGlzIHRvIGNoZWNrIGlmIGEgZ2l2ZW4gbWV0aG9kIGV4aXN0cy5cbiAgICAgICAgICAgIG1ldGhvZHM6IGZ1bmN0aW9uIChtZXRob2RGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIganNvblJlc3VsdCA9IHRoaXMuYWdtRmFjYWRlLm1ldGhvZHMoSlNPTi5zdHJpbmdpZnkobWV0aG9kRmlsdGVyKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFnbVBhcnNlKGpzb25SZXN1bHQpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbWV0aG9kc0Zvckluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2VGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIganNvblJlc3VsdCA9IHRoaXMuYWdtRmFjYWRlLm1ldGhvZHNGb3JJbnN0YW5jZShKU09OLnN0cmluZ2lmeShpbnN0YW5jZUZpbHRlcikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhZ21QYXJzZShqc29uUmVzdWx0KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIHN0cmVhbWluZyBzdXBwb3J0XG4gICAgICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIChuYW1lLCBvcHRpb25zLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuYXJncyA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuYXJndW1lbnRzIHx8IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy50YXJnZXQgPSB0YXJnZXRBcmdUb09iamVjdChvcHRpb25zLnRhcmdldCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZ21GYWNhZGUuc3Vic2NyaWJlMihuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkob3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkocHJvbWlzZSwgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNyZWF0ZVN0cmVhbTogZnVuY3Rpb24gKHN0cmVhbURlZiwgY2FsbGJhY2tzLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHJlYW1EZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1EZWYgPSB7IG5hbWU6IHN0cmVhbURlZiB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZ21GYWNhZGUuY3JlYXRlU3RyZWFtMihcbiAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHN0cmVhbURlZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIC0gd3JhcCB0byB0cmFuc2Zvcm0gcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3Muc3Vic2NyaXB0aW9uUmVxdWVzdEhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIC0gd3JhcCB0byB0cmFuc2Zvcm0gcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3Muc3Vic2NyaXB0aW9uQWRkZWRIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyAtIHdyYXAgdG8gdHJhbnNmb3JtIHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnN1YnNjcmlwdGlvblJlbW92ZWRIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3VjY2VzcyBoYW5kbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkocHJvbWlzZSwgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBhZGQgbWV0cmljc1xuICAgICAgICBpZiAoY29uZmlndXJhdGlvbiAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZ3VyYXRpb24ubWV0cmljcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25maWd1cmF0aW9uLm1ldHJpY3MubWV0cmljc0lkZW50aXR5ID0gY29uZmlndXJhdGlvbi5tZXRyaWNzLmlkZW50aXR5O1xuXG5cbiAgICAgICAgICAgIC8vIHF1aWNrIGFuZCBkaXJ0eSAtIHdlIG5lZWQgdG8gc3RyaW5naWZ5IHRoZSBjb25maWd1cmF0aW9uIHNvIHdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgbWV0cmljcyBvYmplY3QgKHdoaWNoIGhhcyBjaXJjdWxhciByZWZlcmVuY2VzKVxuICAgICAgICAgICAgLy8gd2l0aCBhbiBvYmplY3QgdGhhdCBob2xkcyBvbmx5IHRoZSBwcm9wZXJ0aWVzIG5lZWRlZFxuICAgICAgICAgICAgdmFyIG1ldHJpY3NDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgbWV0cmljc0lkZW50aXR5OiBjb25maWd1cmF0aW9uLm1ldHJpY3MubWV0cmljc0lkZW50aXR5LFxuICAgICAgICAgICAgICAgIHBhdGg6IGNvbmZpZ3VyYXRpb24ubWV0cmljcy5wYXRoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uZmlndXJhdGlvbi5tZXRyaWNzID0gbWV0cmljc0NvbmZpZztcbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmUgdGhlIGxvZ2dlciAtIHdlIGRvbid0IG5lZWQgaXQgaW4gSEMgYW5kIGhhcyBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgICAgIGRlbGV0ZSBjb25maWd1cmF0aW9uLmxvZ2dlcjtcblxuICAgICAgICAvLyBjcmVhdGUgbmV3IEFHTSBmYcOnYWRlIGZvciB0aGlzIGluc3RhbmNlXG4gICAgICAgIHJlc3VsdC5pbnN0YW5jZSA9IGZhY2FkZS5pbml0KEpTT04uc3RyaW5naWZ5KGNvbmZpZ3VyYXRpb24pKTtcbiAgICAgICAgcmVzdWx0LmFnbUZhY2FkZSA9IGZhY2FkZTtcblxuICAgICAgICAvLyBkZXByZWNhdGVkIEFQSVxuICAgICAgICByZXN1bHQuY3JlYXRlX3N0cmVhbSA9IHJlc3VsdC5jcmVhdGVTdHJlYW07XG4gICAgICAgIHJlc3VsdC5tZXRob2RzX2Zvcl9pbnN0YW5jZSA9IHJlc3VsdC5tZXRob2RzRm9ySW5zdGFuY2U7XG4gICAgICAgIHJlc3VsdC5tZXRob2RfYWRkZWQgPSByZXN1bHQubWV0aG9kQWRkZWQ7XG4gICAgICAgIHJlc3VsdC5tZXRob2RfcmVtb3ZlZCA9IHJlc3VsdC5tZXRob2RSZW1vdmVkO1xuICAgICAgICByZXN1bHQuc2VydmVyX2FkZGVkID0gcmVzdWx0LnNlcnZlckFkZGVkO1xuICAgICAgICByZXN1bHQuc2VydmVyX3JlbW92ZWQgPSByZXN1bHQuc2VydmVyUmVtb3ZlZDtcbiAgICAgICAgcmVzdWx0LnNlcnZlcl9tZXRob2RfYWRkZWQgPSByZXN1bHQuc2VydmVyTWV0aG9kQWRkZWQ7XG4gICAgICAgIHJlc3VsdC5zZXJ2ZXJfbWV0aG9kX3JlbW92ZWQgPSByZXN1bHQuc2VydmVyTWV0aG9kUmVtb3ZlZDtcblxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgfSk7XG59O1xuIiwiLypcbiAqIFJlcG9zaXRvcnkgaG9sZGluZyBzZXJ2ZXJzIGFuZCBtZXRob2RzIHZpc2libGUgYnkgdGhpcyBwZWVyIGluY2x1ZGluZyB0aG9zZSBjcmVhdGVkIGJ5IHRoZSBwZWVyIGl0c2VsZi5cbiAqL1xuXG52YXIgQ2FsbGJhY2tzID0gcmVxdWlyZSgnY2FsbGJhY2stcmVnaXN0cnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gZWFjaCBzZXJ2ZXIgaGFzIGZvcm1hdCB7aWQ6JycsIGluZm86e30sIG1ldGhvZHM6e319XG4gICAgLy8gd2hlcmUgbWV0aG9kcyBoYXMgZm9ybWF0IHtpZDonJywgaW5mbzp7fX1cbiAgICB2YXIgc2VydmVycyA9IHt9O1xuXG4gICAgLy8gb2JqZWN0IGtleWVkIGJ5IG1ldGhvZCBpZCAtIHZhbHVlIGlzIG51bWJlciBvZiBzZXJ2ZXJzIHRoYXQgb2ZmZXIgdGhhdCBtZXRob2RcbiAgICB2YXIgbWV0aG9kc0NvdW50ID0ge307XG5cbiAgICAvLyBzdG9yZSBmb3IgY2FsbGJhY2tzXG4gICAgdmFyIGNhbGxiYWNrcyA9IG5ldyBDYWxsYmFja3MoKTtcblxuICAgIC8vIGFkZCBhIG5ldyBzZXJ2ZXIgdG8gaW50ZXJuYWwgY29sbGVjdGlvblxuICAgIGZ1bmN0aW9uIGFkZFNlcnZlcihpbmZvLCBzZXJ2ZXJJZCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IHNlcnZlcnNbc2VydmVySWRdO1xuICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQuaWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VydmVyRW50cnkgPSB7IGlkOiBzZXJ2ZXJJZCwgaW5mbzogaW5mbywgbWV0aG9kczoge30gfTtcbiAgICAgICAgc2VydmVyRW50cnkuZ2V0SW5mb0ZvclVzZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVXNlclNlcnZlckluZm8oc2VydmVyRW50cnkuaW5mbyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VydmVyc1tzZXJ2ZXJJZF0gPSBzZXJ2ZXJFbnRyeTtcbiAgICAgICAgY2FsbGJhY2tzLmV4ZWN1dGUoJ29uU2VydmVyQWRkZWQnLCBzZXJ2ZXJFbnRyeSk7XG4gICAgICAgIHJldHVybiBzZXJ2ZXJJZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVTZXJ2ZXJCeUlkKGlkLCByZWFzb24pIHtcbiAgICAgICAgdmFyIHNlcnZlciA9IHNlcnZlcnNbaWRdO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKHNlcnZlci5tZXRob2RzKS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2RJZCkge1xuICAgICAgICAgICAgcmVtb3ZlU2VydmVyTWV0aG9kKGlkLCBtZXRob2RJZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlbGV0ZSBzZXJ2ZXJzW2lkXTtcbiAgICAgICAgY2FsbGJhY2tzLmV4ZWN1dGUoJ29uU2VydmVyUmVtb3ZlZCcsIHNlcnZlciwgcmVhc29uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTZXJ2ZXJNZXRob2Qoc2VydmVySWQsIG1ldGhvZCkge1xuICAgICAgICB2YXIgc2VydmVyID0gc2VydmVyc1tzZXJ2ZXJJZF07XG4gICAgICAgIGlmICghc2VydmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlcnZlciBkb2VzIG5vdCBleGlzdHMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtZXRob2RJZCA9IGNyZWF0ZU1ldGhvZElkKG1ldGhvZCk7XG5cbiAgICAgICAgLy8gc2VydmVyIGFscmVhZHkgaGFzIHRoYXQgbWV0aG9kXG4gICAgICAgIGlmIChzZXJ2ZXIubWV0aG9kc1ttZXRob2RJZF0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtZXRob2RFbnRpdHkgPSB7IGlkOiBtZXRob2RJZCwgaW5mbzogbWV0aG9kIH07XG4gICAgICAgIG1ldGhvZEVudGl0eS5nZXRJbmZvRm9yVXNlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVVc2VyTWV0aG9kSW5mbyhtZXRob2RFbnRpdHkuaW5mbyk7XG4gICAgICAgIH07XG4gICAgICAgIHNlcnZlci5tZXRob2RzW21ldGhvZElkXSA9IG1ldGhvZEVudGl0eTtcblxuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgcmVmIGFuZCBub3RpZnkgbGlzdGVuZXJzXG4gICAgICAgIGlmICghbWV0aG9kc0NvdW50W21ldGhvZElkXSkge1xuICAgICAgICAgICAgbWV0aG9kc0NvdW50W21ldGhvZElkXSA9IDA7XG4gICAgICAgICAgICBjYWxsYmFja3MuZXhlY3V0ZSgnb25NZXRob2RBZGRlZCcsIG1ldGhvZEVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgICAgbWV0aG9kc0NvdW50W21ldGhvZElkXSA9IG1ldGhvZHNDb3VudFttZXRob2RJZF0gKyAxO1xuICAgICAgICBjYWxsYmFja3MuZXhlY3V0ZSgnb25TZXJ2ZXJNZXRob2RBZGRlZCcsIHNlcnZlciwgbWV0aG9kRW50aXR5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVNZXRob2RJZChtZXRob2RJbmZvKSB7XG4gICAgICAgIC8vIFNldHRpbmcgcHJvcGVydGllcyB0byBkZWZhdWx0czpcbiAgICAgICAgdmFyIGFjY2VwdHMgPSBtZXRob2RJbmZvLmFjY2VwdHMgIT09IHVuZGVmaW5lZCA/IG1ldGhvZEluZm8uYWNjZXB0cyA6ICcnO1xuICAgICAgICB2YXIgcmV0dXJucyA9IG1ldGhvZEluZm8ucmV0dXJucyAhPT0gdW5kZWZpbmVkID8gbWV0aG9kSW5mby5yZXR1cm5zIDogJyc7XG4gICAgICAgIHZhciB2ZXJzaW9uID0gbWV0aG9kSW5mby52ZXJzaW9uICE9PSB1bmRlZmluZWQgPyBtZXRob2RJbmZvLnZlcnNpb24gOiAwO1xuICAgICAgICByZXR1cm4gKG1ldGhvZEluZm8ubmFtZSArIGFjY2VwdHMgKyByZXR1cm5zICsgdmVyc2lvbikudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVTZXJ2ZXJNZXRob2Qoc2VydmVySWQsIG1ldGhvZElkKSB7XG4gICAgICAgIHZhciBzZXJ2ZXIgPSBzZXJ2ZXJzW3NlcnZlcklkXTtcbiAgICAgICAgaWYgKCFzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2VydmVyIGRvZXMgbm90IGV4aXN0cycpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1ldGhvZCA9IHNlcnZlci5tZXRob2RzW21ldGhvZElkXTtcbiAgICAgICAgZGVsZXRlIHNlcnZlci5tZXRob2RzW21ldGhvZElkXTtcblxuICAgICAgICAvLyB1cGRhdGUgcmVmIGNvdW50aW5nXG4gICAgICAgIG1ldGhvZHNDb3VudFttZXRob2RJZF0gPSBtZXRob2RzQ291bnRbbWV0aG9kSWRdIC0gMTtcbiAgICAgICAgaWYgKG1ldGhvZHNDb3VudFttZXRob2RJZF0gPT09IDApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5leGVjdXRlKCdvbk1ldGhvZFJlbW92ZWQnLCBtZXRob2QpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2tzLmV4ZWN1dGUoJ29uU2VydmVyTWV0aG9kUmVtb3ZlZCcsIHNlcnZlciwgbWV0aG9kKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRNZXRob2RzKCkge1xuXG4gICAgICAgIHZhciBhbGxNZXRob2RzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHNlcnZlcnMpLmZvckVhY2goZnVuY3Rpb24gKHNlcnZlcklkKSB7XG4gICAgICAgICAgICB2YXIgc2VydmVyID0gc2VydmVyc1tzZXJ2ZXJJZF07XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzZXJ2ZXIubWV0aG9kcykuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kSWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gc2VydmVyLm1ldGhvZHNbbWV0aG9kSWRdO1xuICAgICAgICAgICAgICAgIGFsbE1ldGhvZHNbbWV0aG9kLmlkXSA9IG1ldGhvZDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBtZXRob2RzQXNBcnJheSA9IE9iamVjdC5rZXlzKGFsbE1ldGhvZHMpLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBhbGxNZXRob2RzW2lkXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG1ldGhvZHNBc0FycmF5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNlcnZlcnMoKSB7XG4gICAgICAgIHZhciBhbGxTZXJ2ZXJzID0gW107XG4gICAgICAgIE9iamVjdC5rZXlzKHNlcnZlcnMpLmZvckVhY2goZnVuY3Rpb24gKHNlcnZlcklkKSB7XG4gICAgICAgICAgICB2YXIgc2VydmVyID0gc2VydmVyc1tzZXJ2ZXJJZF07XG4gICAgICAgICAgICBhbGxTZXJ2ZXJzLnB1c2goc2VydmVyKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYWxsU2VydmVycztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXJ2ZXJNZXRob2RCeUlkKHNlcnZlcklkKSB7XG4gICAgICAgIHZhciBzZXJ2ZXIgPSBzZXJ2ZXJzW3NlcnZlcklkXTtcblxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoc2VydmVyLm1ldGhvZHMpLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXJ2ZXIubWV0aG9kc1tpZF07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uU2VydmVyQWRkZWQoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2tzLmFkZCgnb25TZXJ2ZXJBZGRlZCcsIGNhbGxiYWNrKTtcblxuICAgICAgICAvLyByZXBsYXkgYWxsIHNlcnZlcnNcbiAgICAgICAgZ2V0U2VydmVycygpLmZvckVhY2goZnVuY3Rpb24gKHNlcnZlcikge1xuICAgICAgICAgICAgY2FsbGJhY2soc2VydmVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25NZXRob2RBZGRlZChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFja3MuYWRkKCdvbk1ldGhvZEFkZGVkJywgY2FsbGJhY2spO1xuXG4gICAgICAgIC8vIHJlcGx5IGFsbCBleGlzdGluZyBtZXRob2RzXG4gICAgICAgIGdldE1ldGhvZHMoKS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG1ldGhvZCk7XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25TZXJ2ZXJNZXRob2RBZGRlZChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFja3MuYWRkKCdvblNlcnZlck1ldGhvZEFkZGVkJywgY2FsbGJhY2spO1xuICAgICAgICAvLyBUT0RPIC0gdGhlIG9sZCB2ZXJzaW9uIGRvZXMgbm90IGRvIHRoaXMgLSBjb25maXJtIHdoYXQgaXMgY29ycmVjdFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNlcnZlckJ5SWQoaWQpIHtcbiAgICAgICAgcmV0dXJuIHNlcnZlcnNbaWRdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgaW50ZXJuYWwgc2VydmVyIG9iamVjdCB0byB1c2VyIG9iamVjdFxuICAgICAqIEBwYXJhbSBzZXJ2ZXJcbiAgICAgKiBAcmV0dXJucyB7e21hY2hpbmU6ICosIHBpZDogKiwgc3RhcnRlZDogKiwgdXNlcjogKiwgYXBwbGljYXRpb246ICosIGVudmlyb25tZW50OiAqLCByZWdpb246ICosIHNlcnZpY2VfbmFtZTogKiwgc3RhdGU6ICp9fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVVzZXJTZXJ2ZXJJbmZvKHNlcnZlckluZm8pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1hY2hpbmU6IHNlcnZlckluZm8ubWFjaGluZSxcbiAgICAgICAgICAgIHBpZDogc2VydmVySW5mby5waWQsXG4gICAgICAgICAgICB1c2VyOiBzZXJ2ZXJJbmZvLnVzZXIsXG4gICAgICAgICAgICBhcHBsaWNhdGlvbjogc2VydmVySW5mby5hcHBsaWNhdGlvbixcbiAgICAgICAgICAgIGVudmlyb25tZW50OiBzZXJ2ZXJJbmZvLmVudmlyb25tZW50LFxuICAgICAgICAgICAgcmVnaW9uOiBzZXJ2ZXJJbmZvLnJlZ2lvbixcbiAgICAgICAgICAgIGluc3RhbmNlOiBzZXJ2ZXJJbmZvLmluc3RhbmNlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBpbnRlcm5hbCBtZXRob2Qgb2JqZWN0IHRvIHVzZXIgb2JqZWN0XG4gICAgICogQHBhcmFtIG1ldGhvZFxuICAgICAqIEByZXR1cm5zIHt7bmFtZTogKiwgYWNjZXB0czogKiwgcmV0dXJuczogKiwgZGVzY3JpcHRpb246ICosIGRpc3BsYXlfbmFtZTogKiwgdmVyc2lvbjogKiwgb2JqZWN0X3R5cGVzOiAoKnxBcnJheSl9fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVVzZXJNZXRob2RJbmZvKG1ldGhvZEluZm8pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IG1ldGhvZEluZm8ubmFtZSxcbiAgICAgICAgICAgIGFjY2VwdHM6IG1ldGhvZEluZm8uYWNjZXB0cyxcbiAgICAgICAgICAgIHJldHVybnM6IG1ldGhvZEluZm8ucmV0dXJucyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBtZXRob2RJbmZvLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgZGlzcGxheU5hbWUgOiBtZXRob2RJbmZvLmRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgdmVyc2lvbjogbWV0aG9kSW5mby52ZXJzaW9uLFxuICAgICAgICAgICAgb2JqZWN0VHlwZXM6IG1ldGhvZEluZm8ub2JqZWN0VHlwZXMsXG4gICAgICAgICAgICBzdXBwb3J0c1N0cmVhbWluZzogbWV0aG9kSW5mby5zdXBwb3J0c1N0cmVhbWluZ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGdldFNlcnZlckJ5SWQ6IGdldFNlcnZlckJ5SWQsXG4gICAgICAgIGdldFNlcnZlcnM6IGdldFNlcnZlcnMsXG4gICAgICAgIGdldE1ldGhvZHM6IGdldE1ldGhvZHMsXG4gICAgICAgIGdldFNlcnZlck1ldGhvZHNCeUlkOiBnZXRTZXJ2ZXJNZXRob2RCeUlkLFxuICAgICAgICBnZXRNZXRob2RJZDogY3JlYXRlTWV0aG9kSWQsXG4gICAgICAgIGFkZFNlcnZlcjogYWRkU2VydmVyLFxuICAgICAgICBhZGRTZXJ2ZXJNZXRob2Q6IGFkZFNlcnZlck1ldGhvZCxcbiAgICAgICAgcmVtb3ZlU2VydmVyQnlJZDogcmVtb3ZlU2VydmVyQnlJZCxcbiAgICAgICAgcmVtb3ZlU2VydmVyTWV0aG9kOiByZW1vdmVTZXJ2ZXJNZXRob2QsXG5cbiAgICAgICAgb25TZXJ2ZXJBZGRlZDogb25TZXJ2ZXJBZGRlZCxcbiAgICAgICAgb25TZXJ2ZXJSZW1vdmVkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5hZGQoJ29uU2VydmVyUmVtb3ZlZCcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25NZXRob2RBZGRlZDogb25NZXRob2RBZGRlZCxcbiAgICAgICAgb25NZXRob2RSZW1vdmVkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5hZGQoJ29uTWV0aG9kUmVtb3ZlZCcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TZXJ2ZXJNZXRob2RBZGRlZDogb25TZXJ2ZXJNZXRob2RBZGRlZCxcbiAgICAgICAgb25TZXJ2ZXJNZXRob2RSZW1vdmVkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5hZGQoJ29uU2VydmVyTWV0aG9kUmVtb3ZlZCcsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIvKlxuIFRoZSBzdHJlYW1pbmcgbW9kdWxlIGRlZmluZXMgdGhlIHVzZXIgb2JqZWN0cyByZWxldmFudCB0byB0aGUgc3RyZWFtaW5nIGFwaSwgYW5kXG4gYXR0YWNoZXMgdG8gcmVsZXZhbnQgZXZlbnRzIGV4cG9zZWQgYnkgdGhlIHByb3RvY29sLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHByb3RvY29sLCB1bnJlZ2lzdGVyKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgZnVuY3Rpb24gc3RyZWFtRnJvbnRPYmoocmVwb01ldGhvZCkge1xuICAgICAgICB2YXIgZGVmID0gcmVwb01ldGhvZC5kZWZpbml0aW9uO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBicmFuY2hlczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBiTGlzdCA9IHByb3RvY29sLmdldEJyYW5jaExpc3QocmVwb01ldGhvZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJMaXN0Lm1hcChmdW5jdGlvbiAoYnJhbmNoS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBicmFuY2hGcm9udE9iaihyZXBvTWV0aG9kLCBicmFuY2hLZXkpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwcm90b2NvbC5jbG9zZUFsbFN1YnNjcmlwdGlvbnMocmVwb01ldGhvZCk7XG4gICAgICAgICAgICAgICAgdW5yZWdpc3RlcihyZXBvTWV0aG9kLmRlZmluaXRpb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmluaXRpb246IHtcbiAgICAgICAgICAgICAgICBhY2NlcHRzOiBkZWYuYWNjZXB0cyxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZGVmLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBkZWYuZGlzcGxheU5hbWUsXG4gICAgICAgICAgICAgICAgbmFtZTogZGVmLm5hbWUsXG4gICAgICAgICAgICAgICAgb2JqZWN0VHlwZXM6IGRlZi5vYmplY3RUeXBlcyxcbiAgICAgICAgICAgICAgICByZXR1cm5zOiBkZWYucmV0dXJucyxcbiAgICAgICAgICAgICAgICBzdXBwb3J0c1N0cmVhbWluZzogZGVmLnN1cHBvcnRzU3RyZWFtaW5nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZTogZGVmLm5hbWUsXG4gICAgICAgICAgICBwdXNoOiBmdW5jdGlvbiAoZGF0YSwgYnJhbmNoZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJyYW5jaGVzICE9PSAnc3RyaW5nJyAmJiAhQXJyYXkuaXNBcnJheShicmFuY2hlcykgJiYgYnJhbmNoZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYnJhbmNoZXMgc2hvdWxkIGJlIHN0cmluZyBvciBzdHJpbmcgYXJyYXknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETyB2YWxpZGF0ZSBpZiBpcyBwbGFpbiBvYmplY3RcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMuIERhdGEgbXVzdCBiZSBhbiBvYmplY3QuJylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvdG9jb2wucHVzaERhdGEocmVwb01ldGhvZCwgZGF0YSwgYnJhbmNoZXMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdWJMaXN0ID0gcHJvdG9jb2wuZ2V0U3Vic2NyaXB0aW9uTGlzdChyZXBvTWV0aG9kKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ViTGlzdC5tYXAoZnVuY3Rpb24gKHN1Yikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uRnJvbnRPYmoocmVwb01ldGhvZCwgc3ViKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3Vic2NyaXB0aW9uRnJvbnRPYmoocmVwb01ldGhvZCwgc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhcmd1bWVudHM6IHN1YnNjcmlwdGlvbi5hcmd1bWVudHMgfHwge30sXG4gICAgICAgICAgICBicmFuY2hLZXk6IHN1YnNjcmlwdGlvbi5icmFuY2hLZXksXG4gICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHByb3RvY29sLmNsb3NlU2luZ2xlU3Vic2NyaXB0aW9uKHJlcG9NZXRob2QsIHN1YnNjcmlwdGlvbilcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnN0YW5jZTogc3Vic2NyaXB0aW9uLmluc3RhbmNlLFxuICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBwcm90b2NvbC5wdXNoRGF0YVRvU2luZ2xlKHJlcG9NZXRob2QsIHN1YnNjcmlwdGlvbiwgZGF0YSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RyZWFtOiByZXBvTWV0aG9kLmRlZmluaXRpb25cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBicmFuY2hGcm9udE9iaihyZXBvTWV0aG9kLCBicmFuY2hLZXkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogYnJhbmNoS2V5LFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdWJMaXN0ID0gcHJvdG9jb2wuZ2V0U3Vic2NyaXB0aW9uTGlzdChyZXBvTWV0aG9kLCBicmFuY2hLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJMaXN0Lm1hcChmdW5jdGlvbiAoc3ViKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb25Gcm9udE9iaihyZXBvTWV0aG9kLCBzdWIpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwcm90b2NvbC5jbG9zZUFsbFN1YnNjcmlwdGlvbnMocmVwb01ldGhvZCwgYnJhbmNoS2V5KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwdXNoOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHByb3RvY29sLnB1c2hUb0JyYW5jaChyZXBvTWV0aG9kLCBkYXRhLCBicmFuY2hLZXkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqIEF0dGFjaCB0byBzdHJlYW0gJ2V2ZW50cycgKi9cbiAgICBwcm90b2NvbC5vblN1YlJlcXVlc3QoZnVuY3Rpb24gKHJlcXVlc3RDb250ZXh0LCByZXBvTWV0aG9kKSB7XG5cbiAgICAgICAgaWYgKCEoXG4gICAgICAgICAgICByZXBvTWV0aG9kICYmXG4gICAgICAgICAgICByZXBvTWV0aG9kLnN0cmVhbUNhbGxiYWNrcyAmJlxuICAgICAgICAgICAgdHlwZW9mIHJlcG9NZXRob2Quc3RyZWFtQ2FsbGJhY2tzLnN1YnNjcmlwdGlvblJlcXVlc3RIYW5kbGVyID09PSAnZnVuY3Rpb24nKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcG9NZXRob2Quc3RyZWFtQ2FsbGJhY2tzLnN1YnNjcmlwdGlvblJlcXVlc3RIYW5kbGVyKHtcbiAgICAgICAgICAgIGFjY2VwdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHByb3RvY29sLmFjY2VwdFJlcXVlc3RPbkJyYW5jaChyZXF1ZXN0Q29udGV4dCwgcmVwb01ldGhvZCwgJycpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFjY2VwdE9uQnJhbmNoOiBmdW5jdGlvbiAoYnJhbmNoKSB7XG4gICAgICAgICAgICAgICAgcHJvdG9jb2wuYWNjZXB0UmVxdWVzdE9uQnJhbmNoKHJlcXVlc3RDb250ZXh0LCByZXBvTWV0aG9kLCBicmFuY2gpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJndW1lbnRzOiByZXF1ZXN0Q29udGV4dC5hcmd1bWVudHMsXG4gICAgICAgICAgICBpbnN0YW5jZTogcmVxdWVzdENvbnRleHQuaW5zdGFuY2UsXG4gICAgICAgICAgICByZWplY3Q6IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICBwcm90b2NvbC5yZWplY3RSZXF1ZXN0KHJlcXVlc3RDb250ZXh0LCByZXBvTWV0aG9kLCByZWFzb24pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcHJvdG9jb2wub25TdWJBZGRlZChmdW5jdGlvbiAoc3Vic2NyaXB0aW9uLCByZXBvTWV0aG9kKSB7XG5cbiAgICAgICAgaWYgKCEoXG4gICAgICAgICAgICByZXBvTWV0aG9kICYmXG4gICAgICAgICAgICByZXBvTWV0aG9kLnN0cmVhbUNhbGxiYWNrcyAmJlxuICAgICAgICAgICAgdHlwZW9mIHJlcG9NZXRob2Quc3RyZWFtQ2FsbGJhY2tzLnN1YnNjcmlwdGlvbkFkZGVkSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXBvTWV0aG9kLnN0cmVhbUNhbGxiYWNrcy5zdWJzY3JpcHRpb25BZGRlZEhhbmRsZXIoc3Vic2NyaXB0aW9uRnJvbnRPYmoocmVwb01ldGhvZCwgc3Vic2NyaXB0aW9uKSlcblxuICAgIH0pO1xuXG4gICAgcHJvdG9jb2wub25TdWJSZW1vdmVkKGZ1bmN0aW9uIChzdWJzY3JpYmVyLCByZXBvTWV0aG9kKSB7XG5cbiAgICAgICAgaWYgKCEoXG4gICAgICAgICAgICByZXBvTWV0aG9kICYmXG4gICAgICAgICAgICByZXBvTWV0aG9kLnN0cmVhbUNhbGxiYWNrcyAmJlxuICAgICAgICAgICAgdHlwZW9mIHJlcG9NZXRob2Quc3RyZWFtQ2FsbGJhY2tzLnN1YnNjcmlwdGlvblJlbW92ZWRIYW5kbGVyID09PSAnZnVuY3Rpb24nKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcG9NZXRob2Quc3RyZWFtQ2FsbGJhY2tzLnN1YnNjcmlwdGlvblJlbW92ZWRIYW5kbGVyKHN1YnNjcmliZXIpXG5cbiAgICB9KTtcblxuICAgIHJldHVybiB7IHN0cmVhbUZyb250T2JqOiBzdHJlYW1Gcm9udE9iaiB9O1xufTtcbiIsIi8qXG4gKiBBIHN0b3JlIGZvciBob2xkaW5nIG1ldGhvZCBiYWNrLW9iamVjdHMgcmVnaXN0ZXJlZCBieSB0aGlzIGluc3RhbmNlJ3Mgc2VydmVyXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBuZXh0SWQgPSAwO1xuICAgIHZhciBfbWV0aG9kcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gYWRkKG1ldGhvZCkge1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXRob2QuX3JlcG9JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBtZXRob2QuX3JlcG9JZCA9IG5leHRJZDtcbiAgICAgICAgbmV4dElkICs9IDE7XG5cbiAgICAgICAgX21ldGhvZHMucHVzaChtZXRob2QpO1xuXG4gICAgICAgIHJldHVybiBtZXRob2Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlKHJlcG9JZCkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcG9JZCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKCdFeHBlY3RpbmcgYSBudW1iZXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9tZXRob2RzID0gX21ldGhvZHMuZmlsdGVyKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5fcmVwb0lkICE9PSByZXBvSWQ7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJ5SWQoaWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpZCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKCdFeHBlY3RpbmcgYSBudW1iZXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfbWV0aG9kcy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHJldHVybiBtLl9yZXBvSWQgPT09IGlkXG4gICAgICAgIH0pWzBdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldExpc3QoKSB7XG4gICAgICAgIHJldHVybiBfbWV0aG9kcy5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiBfbWV0aG9kcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkOiBhZGQsXG4gICAgICAgIHJlbW92ZTogcmVtb3ZlLFxuICAgICAgICBnZXRCeUlkOiBnZXRCeUlkLFxuICAgICAgICBnZXRMaXN0OiBnZXRMaXN0LFxuICAgICAgICBsZW5ndGg6IGxlbmd0aFxuICAgIH07XG59O1xuIiwiLypcbiBUaGUgQUdNIFNlcnZlciBhbGxvd3MgdXNlcnMgcmVnaXN0ZXIgQUdNIG1ldGhvZHMuXG4gSXQgZXhwb3NlcyB0aGVzZSBtZXRob2RzIHRvIEFHTSBjbGllbnRzICh1c2luZyBwcmVzZW5jZSBtZXNzYWdlcykgYW5kIGxpc3RlbnMgZm9yIHRoZWlyIGludm9jYXRpb25cbiAqL1xuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ2VzNi1wcm9taXNlJykuUHJvbWlzZTtcbnZhciBQcm9taXNpZnkgPSByZXF1aXJlKCcuL2hlbHBlcnMvcHJvbWlzaWZ5Jyk7XG52YXIgU3RyZWFtaW5nID0gcmVxdWlyZSgnLi9hZ20tc2VydmVyLXN0cmVhbWluZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwcm90b2NvbCwgdmF1bHQsIGluc3RhbmNlLCBjb25maWd1cmF0aW9uKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gU2F2ZSB0aGUgcmVmZXJlbmNlIHRvIHRoZSBtZXRyaWMgZnVuY3Rpb24gaWYgaXQgZXhpc3RzXG4gICAgdmFyIG1ldHJpYyA9IChjb25maWd1cmF0aW9uLm1ldHJpY3MgIT09IHVuZGVmaW5lZCkgPyBjb25maWd1cmF0aW9uLm1ldHJpY3MubnVtYmVyTWV0cmljLmJpbmQoY29uZmlndXJhdGlvbi5tZXRyaWNzKSA6IGZ1bmN0aW9uICgpIHtcbiAgICB9O1xuXG4gICAgLy8gQW4gYXJyYXkgb2YgdGhlIHNlcnZlcidzIG1ldGhvZHNcbiAgICB2YXIgc3RyZWFtaW5nID0gbmV3IFN0cmVhbWluZyhwcm90b2NvbCwgdW5yZWdpc3Rlcik7XG5cbiAgICBwcm90b2NvbC5vbkludm9rZWQob25NZXRob2RJbnZva2VkKTtcblxuICAgIHZhciBpbnZvY2F0aW9ucyA9IDA7XG5cbiAgICBmdW5jdGlvbiBvbk1ldGhvZEludm9rZWQobWV0aG9kVG9FeGVjdXRlLCBpbnZvY2F0aW9uSWQsIGludm9jYXRpb25BcmdzKSB7XG4gICAgICAgIG1ldHJpYygnSW52b2NhdGlvbnMgY291bnQnLCBpbnZvY2F0aW9ucysrKTtcblxuICAgICAgICBpZiAoIW1ldGhvZFRvRXhlY3V0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXhlY3V0ZSBpdCBhbmQgc2F2ZSB0aGUgcmVzdWx0XG4gICAgICAgIG1ldGhvZFRvRXhlY3V0ZS50aGVGdW5jdGlvbihpbnZvY2F0aW9uQXJncywgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGVycm9yIGNhc2VcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVyci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBlcnIgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlcnIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyciA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhlIEFHTSBsaWJyYXJ5IG9ubHkgdHJhbnNmZXJzIG9iamVjdHMuIElmIHRoZSByZXN1bHQgaXMgbm90IGFuIG9iamVjdCwgcHV0IGl0IGluIG9uZVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQgfHwgdHlwZW9mIHJlc3VsdCAhPT0gJ29iamVjdCcgfHwgcmVzdWx0LmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHsgX3Jlc3VsdDogcmVzdWx0IH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByb3RvY29sLm1ldGhvZEludm9jYXRpb25SZXN1bHQobWV0aG9kVG9FeGVjdXRlLCBpbnZvY2F0aW9uSWQsIGVyciwgcmVzdWx0KVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyByZWdpc3RlcnMgYSBuZXcgYWdtIG1ldGhvZFxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyKG1ldGhvZERlZmluaXRpb24sIGNhbGxiYWNrKSB7XG5cbiAgICAgICAgcmVnaXN0ZXJDb3JlKG1ldGhvZERlZmluaXRpb24sIGZ1bmN0aW9uIChjb250ZXh0LCByZXN1bHRDYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSByZXN1bHQgYXMgZGlyZWN0IGludm9jYXRpb24gb2YgdGhlIGNhbGxiYWNrIGFuZCByZXR1cm4gaXQgdXNpbmcgcmVzdWx0Q2FsbGJhY2tcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNhbGxiYWNrKGNvbnRleHQuYXJncywgY29udGV4dC5pbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0Q2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRDYWxsYmFjayhlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gcmVnaXN0ZXJzIGEgbmV3IGFzeW5jIGFnbSBtZXRob2QgKHRoZSByZXN1bHQgY2FuIGJlIHJldHVybmVkIGluIGFzeW5jIHdheSlcbiAgICBmdW5jdGlvbiByZWdpc3RlckFzeW5jKG1ldGhvZERlZmluaXRpb24sIGNhbGxiYWNrKSB7XG5cbiAgICAgICAgcmVnaXN0ZXJDb3JlKG1ldGhvZERlZmluaXRpb24sIGZ1bmN0aW9uIChjb250ZXh0LCByZXN1bHRDYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gaW52b2tlIHRoZSBjYWxsYmFjayBwYXNzaW5nIHN1Y2Nlc3MgYW5kIGVycm9yIGNhbGxiYWNrc1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhjb250ZXh0LmFyZ3MsIGNvbnRleHQuaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3MgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Q2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gZXJyb3IgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdENhbGxiYWNrKGUsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRDYWxsYmFjayhlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmVnaXN0ZXJzIGEgbmV3IHN0cmVhbWluZyBhZ20gbWV0aG9kXG4gICAgZnVuY3Rpb24gY3JlYXRlU3RyZWFtKHN0cmVhbURlZiwgY2FsbGJhY2tzLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgLy8gaW4gY2FsbGJhY2tzIHdlIGhhdmUgc3Vic2NyaXB0aW9uUmVxdWVzdEhhbmRsZXIsIHN1YnNjcmlwdGlvbkFkZGVkSGFuZGxlciwgc3Vic2NyaXB0aW9uUmVtb3ZlZEhhbmRsZXJcblxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyZWFtRGVmID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbURlZiA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCdJbnZhbGlkIHN0cmVhbSBuYW1lLicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN0cmVhbURlZiA9IHsgbmFtZTogc3RyZWFtRGVmIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0cmVhbURlZi5zdXBwb3J0c1N0cmVhbWluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIFVzZXItc3VwcGxpZWQgc3Vic2NyaXB0aW9uIGNhbGxiYWNrc1xuICAgICAgICAgICAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3MgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFja3Muc3Vic2NyaXB0aW9uUmVxdWVzdEhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3Muc3Vic2NyaXB0aW9uUmVxdWVzdEhhbmRsZXIgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmFjY2VwdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlcG9NZXRob2QgPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiB1bmRlZmluZWQsIC8vIHRvIGJlIGluaXRpYWxpemVkIGJ5IHByb3RvY29sXG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbjogc3RyZWFtRGVmLCAvLyBzdG9yZSB1bi1mb3JtYXR0ZWQgZGVmaW5pdGlvbiBmb3IgY2hlY2t1cHMgaW4gdW4tcmVnaXN0ZXIgbWV0aG9kXG4gICAgICAgICAgICAgICAgc3RyZWFtQ2FsbGJhY2tzOiBjYWxsYmFja3NcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbWV0aG9kXG4gICAgICAgICAgICB2YXVsdC5hZGQocmVwb01ldGhvZCk7XG5cbiAgICAgICAgICAgIHByb3RvY29sLmNyZWF0ZVN0cmVhbShyZXBvTWV0aG9kLCBzdHJlYW1EZWYsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcHJvdG9jb2xTdWNjZXNzKCkge1xuICAgICAgICAgICAgICAgICAgICBtZXRyaWMoJ1JlZ2lzdGVyZWQgbWV0aG9kcycsIHZhdWx0Lmxlbmd0aCgpKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyZWFtRnJvYmplY3QgPSBzdHJlYW1pbmcuc3RyZWFtRnJvbnRPYmoocmVwb01ldGhvZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzdHJlYW1Gcm9iamVjdCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBwcm90b2NvbEZhaWwoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhdWx0LnJlbW92ZShyZXBvTWV0aG9kLl9yZXBvSWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2lmeShwcm9taXNlLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8vIENvcmUgbWV0aG9kIGZvciByZWdpc3RlcmluZyBhZ20gbWV0aG9kXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJDb3JlKG1ldGhvZERlZmluaXRpb24sIHRoZUZ1bmN0aW9uKSB7XG4gICAgICAgIC8vIHRyYW5zZm9ybSB0aGUgZGVmaW5pdGlvblxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZERlZmluaXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBtZXRob2REZWZpbml0aW9uID0geyBuYW1lOiBtZXRob2REZWZpbml0aW9uIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdGhlIG1ldGhvZCAoKVxuICAgICAgICB2YXIgcmVwb01ldGhvZCA9IHZhdWx0LmFkZCh7XG4gICAgICAgICAgICBkZWZpbml0aW9uOiBtZXRob2REZWZpbml0aW9uLCAvLyBzdG9yZSB1bi1mb3JtYXR0ZWQgZGVmaW5pdGlvbiBmb3IgY2hlY2t1cHMgaW4gdW4tcmVnaXN0ZXIgbWV0aG9kXG4gICAgICAgICAgICB0aGVGdW5jdGlvbjogdGhlRnVuY3Rpb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvdG9jb2wucmVnaXN0ZXIocmVwb01ldGhvZCxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHByb3RvY29sU3VjY2VzcygpIHtcbiAgICAgICAgICAgICAgICBtZXRyaWMoJ1JlZ2lzdGVyZWQgbWV0aG9kcycsIHZhdWx0Lmxlbmd0aCgpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiBwcm90b2NvbEZhaWwoKSB7XG4gICAgICAgICAgICAgICAgdmF1bHQucmVtb3ZlKHJlcG9NZXRob2QuX3JlcG9JZCk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0cyB0aGUgbWV0aG9kIGRlZmluaXRpb24gZnJvbSBjYW1lbCBjYXNlIHRvIHNuYWtlIGNhc2VcbiAgICBmdW5jdGlvbiBjb250YWluc1Byb3BzKGZpbHRlciwgb2JqZWN0KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHRydWU7XG4gICAgICAgIE9iamVjdC5rZXlzKGZpbHRlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgaWYgKGZpbHRlcltwcm9wXSAhPT0gb2JqZWN0W3Byb3BdKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG5cblxuICAgIC8vIFRPRE8gYWRkIHN1Y2Nlc3MvZmFpbCBoZXJlIGFuZCBhdCBndzErMiBpbXBsZW1lbnRhdGlvbnM/XG4gICAgLy8gVW5yZWdpc3RlcnMgYSBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgQUdNIG1ldGhvZFxuICAgIGZ1bmN0aW9uIHVucmVnaXN0ZXIobWV0aG9kRmlsdGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kRmlsdGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbWV0aG9kRmlsdGVyID0geyBuYW1lOiBtZXRob2RGaWx0ZXIgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtZXRob2RzVG9CZVJlbW92ZWQgPSB2YXVsdC5nZXRMaXN0KCkuZmlsdGVyKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluc1Byb3BzKG1ldGhvZEZpbHRlciwgbWV0aG9kLmRlZmluaXRpb24pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB1cGRhdGUgcmVwb3NpdG9yeVxuICAgICAgICBtZXRob2RzVG9CZVJlbW92ZWQuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgICAgICB2YXVsdC5yZW1vdmUobWV0aG9kLl9yZXBvSWQpO1xuICAgICAgICAgICAgcHJvdG9jb2wudW5yZWdpc3RlcihtZXRob2QpO1xuICAgICAgICB9KTtcblxuICAgICAgICBtZXRyaWMoJ1JlZ2lzdGVyZWQgbWV0aG9kcycsIHZhdWx0Lmxlbmd0aCgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyByZWdpc3RlcjogcmVnaXN0ZXIsIHJlZ2lzdGVyQXN5bmM6IHJlZ2lzdGVyQXN5bmMsIHVucmVnaXN0ZXI6IHVucmVnaXN0ZXIsIGNyZWF0ZVN0cmVhbTogY3JlYXRlU3RyZWFtIH07XG59O1xuIiwidmFyIGNvbm5lY3Rpb24gPSByZXF1aXJlKCd0aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uJyk7XG52YXIgaW5zdGFuY2UgPSByZXF1aXJlKCcuL2FnbS1pbnN0YW5jZScpO1xudmFyIG5hdGl2ZUFnbSA9IHJlcXVpcmUoJy4vYWdtLW5hdGl2ZScpO1xudmFyIGRlcHJlY2F0ZSA9IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJyk7XG52YXIgcGpzb24gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKTtcbnZhciBjbGllbnQgPSByZXF1aXJlKCcuL2FnbS1jbGllbnQnKTtcbnZhciBzZXJ2ZXIgPSByZXF1aXJlKCcuL2FnbS1zZXJ2ZXInKTtcbnZhciBnVzFQcm90b2NvbCA9IHJlcXVpcmUoJy4vcHJvdG9jb2xzL2d3MS9wcm90b2NvbCcpO1xudmFyIGdXM1Byb3RvY29sID0gcmVxdWlyZSgnLi9wcm90b2NvbHMvZ3czL3Byb3RvY29sJyk7XG52YXIgcmVwb3NpdG9yeSA9IHJlcXVpcmUoJy4vYWdtLXJlcG9zaXRvcnknKTtcbnZhciB2YXVsdCA9IHJlcXVpcmUoJy4vYWdtLXNlcnZlci12YXVsdCcpO1xudmFyIFByb21pc2UgPSByZXF1aXJlKCdlczYtcHJvbWlzZScpLlByb21pc2U7XG5cbi8vIEFkZCBhIGdsb2JhbCBmdW5jdGlvbiB0aGF0IG1ha2VzIGFuIEFHTSBpbnN0YW5jZVxuYWdtID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gV2Ugd2lsbCBzdG9yZSB0aGUgbGlicmFyeSBoZXJlXG4gICAgdmFyIGFnbSA9IHt9O1xuICAgIGFnbS52ZXJzaW9uID0gcGpzb24udmVyc2lvbjtcblxuXG4gICAgLy8gSW5pdCBjb25maWd1cmF0aW9uXG4gICAgaWYgKHR5cGVvZiBjb25maWd1cmF0aW9uICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25maWd1cmF0aW9uID0ge307XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgY29uZmlndXJhdGlvblxuXG4gICAgLy8gSW5pdCBjaGlsZCBjb25maWd1cmF0aW9uIGlmIGl0IGlzIG5vdCBhbHJlYWR5IHBhc3NlZCBieSB1c2VyXG4gICAgdmFyIGNoaWxkQ29uZmlndXJhdGlvbnMgPSBbJ2Nvbm5lY3Rpb24nLCAnY2xpZW50JywgJ3NlcnZlciddO1xuICAgIGNoaWxkQ29uZmlndXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoY29uZikge1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZ3VyYXRpb25bY29uZl0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25maWd1cmF0aW9uW2NvbmZdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IGRlYnVnIGlmIGdsb2JhbCBkZWJ1ZyBpcyBub3Qgc2V0OlxuICAgICAgICBpZiAoY29uZmlndXJhdGlvbi5kZWJ1Zykge1xuICAgICAgICAgICAgY29uZmlndXJhdGlvbltjb25mXS5kZWJ1ZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh0eXBlb2YgY29uZmlndXJhdGlvbi5jbGllbnQucmVtb3ZlX3NlcnZlcl9vbl9uX21pc3NpbmdfaGVhcnRiZWF0cyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uZmlndXJhdGlvbi5jbGllbnQucmVtb3ZlX3NlcnZlcl9vbl9uX21pc3NpbmdfaGVhcnRiZWF0cyA9IDM7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29uZmlndXJhdGlvbi5jbGllbnQubWV0aG9kX3Jlc3BvbnNlX3RpbWVvdXQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24uY2xpZW50Lm1ldGhvZF9yZXNwb25zZV90aW1lb3V0ID0gMzAwMDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25maWd1cmF0aW9uLmNsaWVudC53YWl0X2Zvcl9tZXRob2RfdGltZW91dCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uZmlndXJhdGlvbi5jbGllbnQud2FpdF9mb3JfbWV0aG9kX3RpbWVvdXQgPSAzMDAwO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29uZmlndXJhdGlvbi5zZXJ2ZXIuaGVhcnRiZWF0X2ludGVydmFsICE9PSAnbnVtYmVyJykge1xuICAgICAgICBjb25maWd1cmF0aW9uLnNlcnZlci5oZWFydGJlYXRfaW50ZXJ2YWwgPSA1MDAwO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbmZpZ3VyYXRpb24uc2VydmVyLnByZXNlbmNlX2ludGVydmFsICE9PSAnbnVtYmVyJykge1xuICAgICAgICBjb25maWd1cmF0aW9uLnNlcnZlci5wcmVzZW5jZV9pbnRlcnZhbCA9IDEwMDAwO1xuICAgIH1cblxuICAgIC8vIERldGVybWluZSBpZiB3ZSBhcmUgZ2l2ZW4gYSBjb25uZWN0aW9uIG9iamVjdC4gSWYgbm90LCBjcmVhdGUgaXQgb3Vyc2VsdmVzOlxuICAgIHZhciBjID0gY29uZmlndXJhdGlvbi5jb25uZWN0aW9uO1xuICAgIGFnbS5jb25uZWN0aW9uID0gKHR5cGVvZiBjID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYy5zZW5kID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjLm9uID09PSAnZnVuY3Rpb24nKSA/IGMgOiBjb25uZWN0aW9uKGNvbmZpZ3VyYXRpb24uY29ubmVjdGlvbik7XG5cbiAgICAvLyBDcmVhdGUgYSBjb25uZWN0aW9uIHByb3h5IHdoaWNoIHNldHMgdGhlIHByb2R1Y3QgbmFtZSBhdXRvbWF0aWNhbGx5XG4gICAgdmFyIHByb2R1Y3ROYW1lID0gJ2FnbSc7XG4gICAgdmFyIGFnbUVuYWJsZWRDb25uZWN0aW9uID0ge1xuICAgICAgICBzZW5kOiBmdW5jdGlvbiAodHlwZSwgbWVzc2FnZSkge1xuICAgICAgICAgICAgYWdtLmNvbm5lY3Rpb24uc2VuZChwcm9kdWN0TmFtZSwgdHlwZSwgbWVzc2FnZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uOiBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgYWdtLmNvbm5lY3Rpb24ub24ocHJvZHVjdE5hbWUsIHR5cGUsIGhhbmRsZXIpO1xuICAgICAgICB9LFxuICAgICAgICBjb25uZWN0ZWQ6IGFnbS5jb25uZWN0aW9uLmNvbm5lY3RlZCxcbiAgICAgICAgLy8gVE9ETyAtIHN0b3Agd3JhcHBpbmcgY29ubmVjdGlvbiAsIGp1c3QgZXh0ZW5kIGl0IHdpdGggc2VuZEFHTSwgb25BR01cbiAgICAgICAgZ2V0UGVlcklkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBhZ20uY29ubmVjdGlvbi5wZWVySWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFNhdmUgYSByZWZlcmVuY2UgdG8gdGhlIHJvb3Qgc3lzdGVtIG9iamVjdCB0aGF0IHdlIGFyZSBnaXZlblxuICAgIHZhciBtZXRyaWNzUm9vdCA9IGNvbmZpZ3VyYXRpb24ubWV0cmljcztcbiAgICAvLyBDcmVhdGUgc3Vic3lzdGVtcyBmb3Igb3VyIG1vZHVsZXMgYW5kIHNhdmUgdGhlbSBpbiB0aGVpciBjb25maWd1cmF0aW9uLlxuICAgIGlmIChtZXRyaWNzUm9vdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24uY2xpZW50Lm1ldHJpY3MgPSBtZXRyaWNzUm9vdC5zdWJTeXN0ZW0oJ0NsaWVudCcpO1xuICAgICAgICBjb25maWd1cmF0aW9uLnNlcnZlci5tZXRyaWNzID0gbWV0cmljc1Jvb3Quc3ViU3lzdGVtKCdTZXJ2ZXInKTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIG91ciBtb2R1bGVzXG4gICAgYWdtLmluc3RhbmNlID0gaW5zdGFuY2UoY29uZmlndXJhdGlvbi5pbnN0YW5jZSk7XG4gICAgdmFyIGNsaWVudFJlcG9zaXRvcnkgPSByZXBvc2l0b3J5KCk7XG4gICAgdmFyIHNlcnZlclJlcG9zaXRvcnkgPSB2YXVsdCgpO1xuICAgIHZhciBwcm90b2NvbFByb21pc2U7XG4gICAgdmFyIHByb3RvY29sVmVyc2lvbiA9IGMucHJvdG9jb2xWZXJzaW9uO1xuICAgIGlmIChwcm90b2NvbFZlcnNpb24gPT09IDMpIHtcbiAgICAgICAgcHJvdG9jb2xQcm9taXNlID0gZ1czUHJvdG9jb2woYWdtLmluc3RhbmNlLCBhZ21FbmFibGVkQ29ubmVjdGlvbiwgY2xpZW50UmVwb3NpdG9yeSwgc2VydmVyUmVwb3NpdG9yeSwgY29uZmlndXJhdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvdG9jb2xQcm9taXNlID0gZ1cxUHJvdG9jb2woYWdtLmluc3RhbmNlLCBhZ21FbmFibGVkQ29ubmVjdGlvbiwgY2xpZW50UmVwb3NpdG9yeSwgc2VydmVyUmVwb3NpdG9yeSwgY29uZmlndXJhdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyB3YWl0IGZvciBwcm90b2NvbCB0byByZXNvbHZlXG4gICAgICAgIHByb3RvY29sUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChwcm90b2NvbCkge1xuICAgICAgICAgICAgYWdtLmNsaWVudCA9IGNsaWVudChwcm90b2NvbCwgY2xpZW50UmVwb3NpdG9yeSwgYWdtLmluc3RhbmNlLCBjb25maWd1cmF0aW9uLmNsaWVudCk7XG4gICAgICAgICAgICBhZ20uc2VydmVyID0gc2VydmVyKHByb3RvY29sLCBzZXJ2ZXJSZXBvc2l0b3J5LCBhZ20uaW5zdGFuY2UsIGNvbmZpZ3VyYXRpb24uc2VydmVyKTtcblxuICAgICAgICAgICAgLy8gQWRkIG1ldGhvZCBhbGlhc2VzXG4gICAgICAgICAgICBhZ20uaW52b2tlID0gYWdtLmNsaWVudC5pbnZva2U7XG4gICAgICAgICAgICBhZ20ucmVnaXN0ZXIgPSBhZ20uc2VydmVyLnJlZ2lzdGVyO1xuICAgICAgICAgICAgYWdtLnJlZ2lzdGVyQXN5bmMgPSBhZ20uc2VydmVyLnJlZ2lzdGVyQXN5bmM7XG4gICAgICAgICAgICBhZ20udW5yZWdpc3RlciA9IGFnbS5zZXJ2ZXIudW5yZWdpc3RlcjtcbiAgICAgICAgICAgIGFnbS5jcmVhdGVTdHJlYW0gPSBhZ20uc2VydmVyLmNyZWF0ZVN0cmVhbTtcbiAgICAgICAgICAgIGFnbS5zdWJzY3JpYmUgPSBhZ20uY2xpZW50LnN1YnNjcmliZTtcbiAgICAgICAgICAgIGFnbS5zZXJ2ZXJzID0gYWdtLmNsaWVudC5zZXJ2ZXJzO1xuICAgICAgICAgICAgYWdtLm1ldGhvZHMgPSBhZ20uY2xpZW50Lm1ldGhvZHM7XG5cbiAgICAgICAgICAgIGFnbS5tZXRob2RzRm9ySW5zdGFuY2UgPSBhZ20uY2xpZW50Lm1ldGhvZHNGb3JJbnN0YW5jZTtcbiAgICAgICAgICAgIGFnbS5tZXRob2QgPSBhZ20uY2xpZW50Lm1ldGhvZDtcbiAgICAgICAgICAgIGFnbS5tZXRob2RBZGRlZCA9IGFnbS5jbGllbnQubWV0aG9kQWRkZWQ7XG4gICAgICAgICAgICBhZ20ubWV0aG9kUmVtb3ZlZCA9IGFnbS5jbGllbnQubWV0aG9kUmVtb3ZlZDtcblxuICAgICAgICAgICAgYWdtLnNlcnZlck1ldGhvZEFkZGVkID0gYWdtLmNsaWVudC5zZXJ2ZXJNZXRob2RBZGRlZDtcbiAgICAgICAgICAgIGFnbS5zZXJ2ZXJNZXRob2RSZW1vdmVkID0gYWdtLmNsaWVudC5zZXJ2ZXJNZXRob2RSZW1vdmVkO1xuXG4gICAgICAgICAgICBhZ20uc2VydmVyQWRkZWQgPSBhZ20uY2xpZW50LnNlcnZlckFkZGVkO1xuICAgICAgICAgICAgYWdtLnNlcnZlclJlbW92ZWQgPSBhZ20uY2xpZW50LnNlcnZlclJlbW92ZWQ7XG5cbiAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWQgQVBJXG4gICAgICAgICAgICBhZ20ubWV0aG9kc19mb3JfaW5zdGFuY2UgPSBkZXByZWNhdGUoYWdtLmNsaWVudC5tZXRob2RzRm9ySW5zdGFuY2UsICdnbHVlLmFnbS5jbGllbnQubWV0aG9kc19mb3JfaW5zdGFuY2UoKSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBnbHVlLmFnbS5jbGllbnQubWV0aG9kc0Zvckluc3RhbmNlKCkgaW5zdGVhZCcpO1xuICAgICAgICAgICAgYWdtLm1ldGhvZF9hZGRlZCA9IGRlcHJlY2F0ZShhZ20uY2xpZW50Lm1ldGhvZEFkZGVkLCAnZ2x1ZS5hZ20ubWV0aG9kX2FkZGVkKCkgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgZ2x1ZS5hZ20ubWV0aG9kQWRkZWQoKSBpbnN0ZWFkJyk7XG4gICAgICAgICAgICBhZ20ubWV0aG9kX3JlbW92ZWQgPSBkZXByZWNhdGUoYWdtLmNsaWVudC5tZXRob2RSZW1vdmVkLCAnZ2x1ZS5hZ20ubWV0aG9kX3JlbW92ZWQoKSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBnbHVlLmFnbS5tZXRob2RSZW1vdmVkKCkgaW5zdGVhZCcpO1xuICAgICAgICAgICAgYWdtLnNlcnZlcl9tZXRob2RfYWRkZWQgPSBkZXByZWNhdGUoYWdtLmNsaWVudC5zZXJ2ZXJNZXRob2RBZGRlZCwgJ2dsdWUuYWdtLnNlcnZlcl9tZXRob2RfYWRkZWQoKSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBnbHVlLmFnbS5zZXJ2ZXJNZXRob2RBZGRlZCgpIGluc3RlYWQnKTtcbiAgICAgICAgICAgIGFnbS5zZXJ2ZXJfbWV0aG9kX3JlbW92ZWQgPSBkZXByZWNhdGUoYWdtLmNsaWVudC5zZXJ2ZXJNZXRob2RSZW1vdmVkLCAnZ2x1ZS5hZ20uc2VydmVyX21ldGhvZF9yZW1vdmVkKCkgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgZ2x1ZS5hZ20uc2VydmVyTWV0aG9kUmVtb3ZlZCgpIGluc3RlYWQnKTtcbiAgICAgICAgICAgIGFnbS5zZXJ2ZXJfYWRkZWQgPSBkZXByZWNhdGUoYWdtLmNsaWVudC5zZXJ2ZXJBZGRlZCwgJ2dsdWUuYWdtLnNlcnZlcl9hZGRlZCgpIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGdsdWUuYWdtLnNlcnZlckFkZGVkKCkgaW5zdGVhZCcpO1xuICAgICAgICAgICAgYWdtLnNlcnZlcl9yZW1vdmVkID0gZGVwcmVjYXRlKGFnbS5jbGllbnQuc2VydmVyUmVtb3ZlZCwgJ2dsdWUuYWdtLnNlcnZlcl9yZW1vdmVkKCkgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgZ2x1ZS5hZ20uc2VydmVyUmVtb3ZlZCgpIGluc3RlYWQnKTtcblxuICAgICAgICAgICAgcmVzb2x2ZShhZ20pO1xuXG4gICAgICAgIH0pWydjYXRjaCddKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxufTtcbmFnbSA9IGdsb2JhbC5odG1sQ29udGFpbmVyICE9PSB1bmRlZmluZWQgPyBuYXRpdmVBZ20gOiBhZ207XG5cbi8vIEV4cG9ydCBmb3IgYnJvd3NlcnNcbmlmIChnbG9iYWwudGljazQyID09PSB1bmRlZmluZWQpIHtcbiAgICBnbG9iYWwudGljazQyID0ge307XG59XG5nbG9iYWwudGljazQyLmFnbSA9IGFnbTtcblxubW9kdWxlLmV4cG9ydHMgPSBhZ207XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwcm9taXNlLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgaWYgKHR5cGVvZiBzdWNjZXNzQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVycm9yQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzdWNjZXNzQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc3VjY2Vzc0NhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgYWdtLmRlYnVnID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1N1Y2Nlc3MhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXJyb3JDYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvckNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgYWdtLmRlYnVnID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0FuIGVycm9yIG9jY3VycmVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xufVxuIiwidmFyIGN1aWQgPSByZXF1aXJlKCdjdWlkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICByZXR1cm4gY3VpZCgpO1xufTtcbiIsInZhciByYW5kb20gPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvcmFuZG9tJyk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBpbnN0YW5jZSwgc2VuZFJlcXVlc3QsIG5leHRSZXNwb25zZVN1YmplY3QpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgU1RBVFVTX0FXQUlUSU5HX0FDQ0VQVCA9ICdhd2FpdGluZ0FjY2VwdCc7IC8vIG5vdCBldmVuIG9uZSBzZXJ2ZXIgaGFzIGFjY2VwdGVkIHlldFxuICAgIHZhciBTVEFUVVNfU1VCU0NSSUJFRCA9ICdzdWJzY3JpYmVkJzsgLy8gYXQgbGVhc3Qgb25lIHNlcnZlciBoYXMgcmVzcG9uZGVkIGFzICdBY2NlcHRpbmcnXG4gICAgdmFyIEVSUl9NU0dfU1VCX0ZBSUxFRCA9ICdTdWJzY3JpcHRpb24gZmFpbGVkLic7XG4gICAgdmFyIEVSUl9NU0dfU1VCX1JFSkVDVEVEID0gJ1N1YnNjcmlwdGlvbiByZWplY3RlZC4nO1xuICAgIHZhciBPTl9DTE9TRV9NU0dfU0VSVkVSX0lOSVQgPSAnU2VydmVySW5pdGlhdGVkJztcbiAgICB2YXIgT05fQ0xPU0VfTVNHX0NMSUVOVF9JTklUID0gJ0NsaWVudEluaXRpYXRlZCc7XG5cbiAgICB2YXIgc3Vic2NyaXB0aW9uc0xpc3QgPSB7fTtcblxuICAgIGZ1bmN0aW9uIHN1YnNjcmliZShzdHJlYW1pbmdNZXRob2QsIGFyZ3VtZW50T2JqLCB0YXJnZXRTZXJ2ZXJzLCBzdHVmZiwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgaWYgKHRhcmdldFNlcnZlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBlcnJvcihFUlJfTVNHX1NVQl9GQUlMRUQgKyAnIE5vIGF2YWlsYWJsZSBzZXJ2ZXJzIG1hdGNoZWQgdGhlIHRhcmdldCBwYXJhbXMuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGlzIHNhbWUgSWQgd2lsbCBiZSBwYXNzZWQgdG8gYWxsIHRoZSBzZXJ2ZXJzIChhcyAnSW52b2NhdGlvbklkJylcbiAgICAgICAgLy8gc28gdGhleSBjYW4gcmVzcG9uZCBiYWNrIHdpdGggaXQgZHVyaW5nIHRoZSBpbml0aWFsIGhhbmRzaGFrZVxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uSWQgPSAnc3Vic2NyaXB0aW9uSWRfJyArIHJhbmRvbSgpO1xuXG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSB1c2VyJ3MgY2FsbGJhY2tzXG4gICAgICAgIHZhciBwZW5kaW5nU3ViID0gcmVnaXN0ZXJTdWJzY3JpcHRpb24oXG4gICAgICAgICAgICBzdWJzY3JpcHRpb25JZCxcbiAgICAgICAgICAgIHN0cmVhbWluZ01ldGhvZCxcbiAgICAgICAgICAgIGFyZ3VtZW50T2JqLFxuICAgICAgICAgICAgc3VjY2VzcyxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgc3R1ZmYubWV0aG9kX3Jlc3BvbnNlX3RpbWVvdXRcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodHlwZW9mIHBlbmRpbmdTdWIgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBlcnJvcihFUlJfTVNHX1NVQl9GQUlMRUQgKyAnIFVuYWJsZSB0byByZWdpc3RlciB0aGUgdXNlciBjYWxsYmFja3MuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZW5kIGEgc3Vic2NyaXB0aW9uIHJlcXVlc3QgdG8gZWFjaCBzZXJ2ZXJcbiAgICAgICAgdGFyZ2V0U2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcblxuICAgICAgICAgICAgLy8gR2V0IGEgcmVzcG9uc2Ugc3ViamVjdCBmb3IgdGhpcyBpbnZvY2F0aW9uXG4gICAgICAgICAgICB2YXIgcmVzcG9uc2VTdWJqZWN0ID0gbmV4dFJlc3BvbnNlU3ViamVjdCgpO1xuXG4gICAgICAgICAgICAvLyBBZGQgc2VydmVyIHRvIHRoZSBsaXN0IG9mIG9uZXMgdGhlIGNsaWVudCBpcyBleHBlY3RpbmcgYSByZXNwb25zZSBmcm9tXG4gICAgICAgICAgICBwZW5kaW5nU3ViLnRyYWNrZWRTZXJ2ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIHNlcnZlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHN0cmVhbUlkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgc3RyZWFtU3ViamVjdHM6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHByaXZhdGU6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWV0aG9kUmVxdWVzdFN1YmplY3Q6IHN0cmVhbWluZ01ldGhvZC5pbmZvLnJlcXVlc3RTdWJqZWN0LFxuICAgICAgICAgICAgICAgIG1ldGhvZFJlc3BvbnNlU3ViamVjdDogcmVzcG9uc2VTdWJqZWN0XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQ29uc3RydWN0IGEgbWVzc2FnZVxuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgRXZlbnRTdHJlYW1BY3Rpb246IDEsIC8vIFwiU3Vic2NyaWJlXCIgPSBjbGllbnQgd2lzaGVzIHRvIHN1YnNjcmliZVxuICAgICAgICAgICAgICAgIE1ldGhvZFJlcXVlc3RTdWJqZWN0OiBzdHJlYW1pbmdNZXRob2QuaW5mby5yZXF1ZXN0U3ViamVjdCxcbiAgICAgICAgICAgICAgICBNZXRob2RSZXNwb25zZVN1YmplY3Q6IHJlc3BvbnNlU3ViamVjdCxcbiAgICAgICAgICAgICAgICBDbGllbnQ6IGluc3RhbmNlLmluZm8oKSxcbiAgICAgICAgICAgICAgICBDb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgIEFyZ3VtZW50c0pzb246IGFyZ3VtZW50T2JqLFxuICAgICAgICAgICAgICAgICAgICBJbnZvY2F0aW9uSWQ6IHN1YnNjcmlwdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICBPYmplY3RUeXBlOiBzdHVmZi5vYmplY3RfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgRGlzcGxheUNvbnRleHQ6IHN0dWZmLmRpc3BsYXlfY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgTWV0aG9kTmFtZTogc3RyZWFtaW5nTWV0aG9kLmluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgRXhlY3V0aW9uU2VydmVyOiB0YXJnZXQuc2VydmVyLFxuICAgICAgICAgICAgICAgICAgICBUaW1lb3V0OiBzdHVmZi5tZXRob2RfcmVzcG9uc2VfdGltZW91dFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFNlbmQgaXRcbiAgICAgICAgICAgIHNlbmRSZXF1ZXN0KG1lc3NhZ2UpO1xuXG4gICAgICAgICAgICBpZiAoZ2xvYmFsLmNvbnNvbGUgIT09IHVuZGVmaW5lZCAmJiBjb25maWd1cmF0aW9uLmRlYnVnID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnJWM+Pj4gc2VuZGluZyBNZXRob2RJbnZvY2F0aW9uUmVxdWVzdE1lc3NhZ2UnLCAnYmFja2dyb3VuZC1jb2xvcjpoc2xhKDE5OCwgNTElLCA3OSUsIDAuNSknKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCclYycgKyBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSwgJ2JhY2tncm91bmQtY29sb3I6aHNsYSgxOTgsIDUxJSwgNzklLCAwLjUpJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbklkLCBtZXRob2QsIGFyZ3MsIHN1Y2Nlc3MsIGVycm9yLCB0aW1lb3V0KSB7XG5cbiAgICAgICAgc3Vic2NyaXB0aW9uc0xpc3Rbc3Vic2NyaXB0aW9uSWRdID0ge1xuICAgICAgICAgICAgc3RhdHVzOiBTVEFUVVNfQVdBSVRJTkdfQUNDRVBULFxuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICBhcmd1bWVudHM6IGFyZ3MsXG4gICAgICAgICAgICBzdWNjZXNzOiBzdWNjZXNzLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgdHJhY2tlZFNlcnZlcnM6IFtdLFxuICAgICAgICAgICAgaGFuZGxlcnM6IHtcbiAgICAgICAgICAgICAgICBvbkRhdGE6IFtdLFxuICAgICAgICAgICAgICAgIG9uQ2xvc2VkOiBbXVxuICAgICAgICAgICAgICAgIC8vIG9uRmFpbGVkOiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHF1ZXVlZDoge1xuICAgICAgICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgICAgICAgIGNsb3NlcnM6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGltZW91dElkOiB1bmRlZmluZWRcbiAgICAgICAgfTtcblxuXG4gICAgICAgIHN1YnNjcmlwdGlvbnNMaXN0W3N1YnNjcmlwdGlvbklkXS50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25zTGlzdFtzdWJzY3JpcHRpb25JZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gbm8gc3VjaCBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvbnNMaXN0W3N1YnNjcmlwdGlvbklkXTtcblxuXG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLnN0YXR1cyA9PT0gU1RBVFVTX0FXQUlUSU5HX0FDQ0VQVCkge1xuICAgICAgICAgICAgICAgIGVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxlZF93aXRoOiBhcmdzLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBFUlJfTVNHX1NVQl9GQUlMRUQgKyAnIFN1YnNjcmlwdGlvbiBhdHRlbXB0IHRpbWVkIG91dCBhZnRlciAnICsgdGltZW91dCArICdtcy4nXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBOb25lIG9mIHRoZSB0YXJnZXQgc2VydmVycyBoYXMgYW5zd2VyZWQgdGhlIHN1YnNjcmlwdGlvbiBhdHRlbXB0XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN1YnNjcmlwdGlvbnNMaXN0W3N1YnNjcmlwdGlvbklkXTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdWJzY3JpcHRpb24uc3RhdHVzID09PSBTVEFUVVNfU1VCU0NSSUJFRCAmJlxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi50cmFja2VkU2VydmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4gdGhlIHRyYWNrZWRTZXJ2ZXJzLCByZW1vdmluZyB0aG9zZSB3aXRob3V0IHZhbGlkIHN0cmVhbUlkXG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnRyYWNrZWRTZXJ2ZXJzID0gc3Vic2NyaXB0aW9uLnRyYWNrZWRTZXJ2ZXJzLmZpbHRlcihmdW5jdGlvbiAoc2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodHlwZW9mIHNlcnZlci5zdHJlYW1JZCA9PT0gJ3N0cmluZycgJiYgc2VydmVyLnN0cmVhbUlkICE9PSAnJylcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi50aW1lb3V0SWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLnRyYWNrZWRTZXJ2ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHRoaXMgbWlnaHQgYmUgZGVhZC1jb2RlLCB3aGVyZSBpcyBjbG9zZXJzLnB1c2g/XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBubyBvcGVuIHN0cmVhbXMsIHNvbWUgc2VydmVycyBhY2NlcHRlZCB0aGVuIGNsb3NlZCB2ZXJ5IHF1aWNrbHlcbiAgICAgICAgICAgICAgICAgICAgLy9cdCh0aGF0J3Mgd2h5IHRoZSBzdGF0dXMgY2hhbmdlZCBidXQgdGhlcmUncyBubyBnb29kIHNlcnZlciB3aXRoIGEgU3RyZWFtSWQpXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCB0aGUgb25DbG9zZWQgaGFuZGxlcnNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsb3NlcnNDb3VudCA9IHN1YnNjcmlwdGlvbi5xdWV1ZWQuY2xvc2Vycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbG9zaW5nU2VydmVyID0gKGNsb3NlcnNDb3VudCA+IDApID8gc3Vic2NyaXB0aW9uLnF1ZXVlZC5jbG9zZXJzW2Nsb3NlcnNDb3VudCAtIDFdIDogbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uaGFuZGxlcnMub25DbG9zZWQuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IE9OX0NMT1NFX01TR19TRVJWRVJfSU5JVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEFyZ3VtZW50czogc3Vic2NyaXB0aW9uLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyOiBjbG9zaW5nU2VydmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW06IHN1YnNjcmlwdGlvbi5tZXRob2RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3Vic2NyaXB0aW9uc0xpc3Rbc3Vic2NyaXB0aW9uSWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGltZW91dCk7XG5cbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbnNMaXN0W3N1YnNjcmlwdGlvbklkXVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NQdWJsaXNoZXJNc2cobXNnKSB7XG4gICAgICAgIGlmICghKG1zZyAmJiBtc2cuRXZlbnRTdHJlYW1BY3Rpb24gJiYgbXNnLkV2ZW50U3RyZWFtQWN0aW9uICE9PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1zZy5FdmVudFN0cmVhbUFjdGlvbiA9PT0gMikge1xuXG4gICAgICAgICAgICBzZXJ2ZXJJc0tpY2tpbmdBU3Vic2NyaWJlcihtc2cpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobXNnLkV2ZW50U3RyZWFtQWN0aW9uID09PSAzKSB7XG5cbiAgICAgICAgICAgIHNlcnZlckFja25vd2xlZGdlc0dvb2RTdWJzY3JpcHRpb24obXNnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKG1zZy5FdmVudFN0cmVhbUFjdGlvbiA9PT0gNSkge1xuXG4gICAgICAgICAgICBzZXJ2ZXJIYXNQdXNoZWRTb21lRGF0YUludG9UaGVTdHJlYW0obXNnKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqIG1zZyAnUmVzcG9uc2UnIEFjdGlvbnMgKi9cbiAgICAvLyBhY3Rpb24gMlxuICAgIGZ1bmN0aW9uIHNlcnZlcklzS2lja2luZ0FTdWJzY3JpYmVyKG1zZykge1xuICAgICAgICAvLyBOb3RlOiB0aGlzIG1pZ2h0IGJlIGVpdGhlciB0aGUgc2VydmVyIHJlamVjdGluZyBhIHN1YnNjcmlwdGlvbiByZXF1ZXN0IE9SIGNsb3NpbmcgYW4gZXhpc3Rpbmcgc3Vic2NyaXB0aW9uXG5cbiAgICAgICAgLy8gR2V0IEFMTCBzdWJzY3JpcHRpb25zXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3Vic2NyaXB0aW9uc0xpc3QpO1xuXG4gICAgICAgIC8vIElmIGl0IGlzIGEgcmVqZWN0aW9uIHRoZXJlIG1heSBiZSBhbiBJbnZvY2F0aW9uSWQsIGl0IGNhbiBuYXJyb3cgdGhlIHNlYXJjaFxuICAgICAgICBpZiAodHlwZW9mIG1zZy5JbnZvY2F0aW9uSWQgPT09ICdzdHJpbmcnICYmIG1zZy5JbnZvY2F0aW9uSWQgIT09ICcnKSB7XG4gICAgICAgICAgICBrZXlzID0ga2V5cy5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gayA9PT0gbXNnLkludm9jYXRpb25JZDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVsZXRpb25zTGlzdCA9IFtdO1xuXG4gICAgICAgIC8vIEZpbmQgdGhlIGtpY2tpbmcvcmVqZWN0aW5nIHNlcnZlciBhbmQgcmVtb3ZlIGl0IGZyb20gdGhlIHN1YnNjcmlwdGlvbi50cmFja2VkU2VydmVyc1tdXG4gICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN1YnNjcmlwdGlvbnNMaXN0W2tleV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zTGlzdFtrZXldLnRyYWNrZWRTZXJ2ZXJzID0gc3Vic2NyaXB0aW9uc0xpc3Rba2V5XS50cmFja2VkU2VydmVycy5maWx0ZXIoZnVuY3Rpb24gKHNlcnZlcikge1xuICAgICAgICAgICAgICAgIHZhciBpc1JlamVjdGluZyA9IChcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyLm1ldGhvZFJlcXVlc3RTdWJqZWN0ID09PSBtc2cuTWV0aG9kUmVxdWVzdFN1YmplY3QgJiYgc2VydmVyLm1ldGhvZFJlc3BvbnNlU3ViamVjdCA9PT0gbXNnLk1ldGhvZFJlc3BvbnNlU3ViamVjdFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaXNLaWNraW5nID0gKFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIuc3RyZWFtSWQgPT09IG1zZy5TdHJlYW1JZCAmJlxuICAgICAgICAgICAgICAgICAgICAoc2VydmVyLnN0cmVhbVN1YmplY3RzLmdsb2JhbCA9PT0gbXNnLkV2ZW50U3RyZWFtU3ViamVjdCB8fCBzZXJ2ZXIuc3RyZWFtU3ViamVjdHMucHJpdmF0ZSA9PT0gbXNnLkV2ZW50U3RyZWFtU3ViamVjdClcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgdmFyIGlzUmVqZWN0aW5nT3JLaWNraW5nID0gaXNSZWplY3RpbmcgfHwgaXNLaWNraW5nO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuICFpc1JlamVjdGluZ09yS2lja2luZztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uc0xpc3Rba2V5XS50cmFja2VkU2VydmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBkZWxldGlvbnNMaXN0LnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2FsbCBvbkNsb3NlZCBPUiBlcnJvcigpXG4gICAgICAgIC8vIGFuZCByZW1vdmUgdGhlIHN1YnNjcmlwdGlvblxuICAgICAgICBkZWxldGlvbnNMaXN0LmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdWJzY3JpcHRpb25zTGlzdFtrZXldICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbnNMaXN0W2tleV0uc3RhdHVzID09PSBTVEFUVVNfQVdBSVRJTkdfQUNDRVBUICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHN1YnNjcmlwdGlvbnNMaXN0W2tleV0udGltZW91dElkID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVhc29uID0gKHR5cGVvZiBtc2cuUmVzdWx0TWVzc2FnZSA9PT0gJ3N0cmluZycgJiYgbXNnLlJlc3VsdE1lc3NhZ2UgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICA/ICcgUHVibGlzaGVyIHNhaWQgXCInICsgbXNnLlJlc3VsdE1lc3NhZ2UgKyAnXCIuJ1xuICAgICAgICAgICAgICAgICAgICA6ICcgTm8gcmVhc29uIGdpdmVuLic7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2FsbEFyZ3MgPSB0eXBlb2Ygc3Vic2NyaXB0aW9uc0xpc3Rba2V5XS5hcmd1bWVudHMgPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkoc3Vic2NyaXB0aW9uc0xpc3Rba2V5XS5hcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgICAgIDogJ3t9JztcblxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbnNMaXN0W2tleV0uZXJyb3IoRVJSX01TR19TVUJfUkVKRUNURUQgKyByZWFzb24gKyAnIENhbGxlZCB3aXRoOicgKyBjYWxsQXJncyk7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHN1YnNjcmlwdGlvbnNMaXN0W2tleV0udGltZW91dElkKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIFRoZSB0aW1lb3V0IG1heSBvciBtYXkgbm90IGhhdmUgZXhwaXJlZCB5ZXQsXG4gICAgICAgICAgICAgICAgLy8gYnV0IHRoZSBzdGF0dXMgaXMgJ3N1YnNjcmliZWQnIGFuZCB0cmFja2VkU2VydmVycyBpcyBub3cgZW1wdHlcblxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbnNMaXN0W2tleV0uaGFuZGxlcnMub25DbG9zZWQuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogT05fQ0xPU0VfTVNHX1NFUlZFUl9JTklULFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEFyZ3VtZW50czogc3Vic2NyaXB0aW9uc0xpc3Rba2V5XS5hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXI6IGhlbHBlcnMuY29udmVydEluZm9Ub0luc3RhbmNlKG1zZy5TZXJ2ZXIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtOiBzdWJzY3JpcHRpb25zTGlzdFtrZXldLm1ldGhvZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgc3Vic2NyaXB0aW9uc0xpc3Rba2V5XTtcblxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBhY3Rpb24gM1xuICAgIGZ1bmN0aW9uIHNlcnZlckFja25vd2xlZGdlc0dvb2RTdWJzY3JpcHRpb24obXNnKSB7XG5cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbklkID0gbXNnLkludm9jYXRpb25JZDtcblxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uc0xpc3Rbc3Vic2NyaXB0aW9uSWRdO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygc3Vic2NyaXB0aW9uICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFjY2VwdGluZ1NlcnZlciA9IHN1YnNjcmlwdGlvbi50cmFja2VkU2VydmVycy5maWx0ZXIoZnVuY3Rpb24gKHNlcnZlcikge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBzZXJ2ZXIubWV0aG9kUmVxdWVzdFN1YmplY3QgPT09IG1zZy5NZXRob2RSZXF1ZXN0U3ViamVjdCAmJlxuICAgICAgICAgICAgICAgIHNlcnZlci5tZXRob2RSZXNwb25zZVN1YmplY3QgPT09IG1zZy5NZXRob2RSZXNwb25zZVN1YmplY3RcbiAgICAgICAgICAgIClcbiAgICAgICAgfSlbMF07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhY2NlcHRpbmdTZXJ2ZXIgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNGaXJzdFJlc3BvbnNlID0gKHN1YnNjcmlwdGlvbi5zdGF0dXMgPT09IFNUQVRVU19BV0FJVElOR19BQ0NFUFQpO1xuXG4gICAgICAgIHN1YnNjcmlwdGlvbi5zdGF0dXMgPSBTVEFUVVNfU1VCU0NSSUJFRDtcblxuICAgICAgICB2YXIgcHJpdmF0ZVN0cmVhbVN1YmplY3QgPSBnZW5lcmF0ZVByaXZhdGVTdHJlYW1TdWJqZWN0KHN1YnNjcmlwdGlvbi5tZXRob2QubmFtZSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhY2NlcHRpbmdTZXJ2ZXIuc3RyZWFtSWQgPT09ICdzdHJpbmcnICYmIGFjY2VwdGluZ1NlcnZlci5zdHJlYW1JZCAhPT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gYWxyZWFkeSBhY2NlcHRlZCBwcmV2aW91c2x5XG4gICAgICAgIH1cblxuICAgICAgICBhY2NlcHRpbmdTZXJ2ZXIuc2VydmVyID0gaGVscGVycy5jb252ZXJ0SW5mb1RvSW5zdGFuY2UobXNnLlNlcnZlcik7XG4gICAgICAgIGFjY2VwdGluZ1NlcnZlci5zdHJlYW1JZCA9IG1zZy5TdHJlYW1JZDtcbiAgICAgICAgYWNjZXB0aW5nU2VydmVyLnN0cmVhbVN1YmplY3RzLmdsb2JhbCA9IG1zZy5FdmVudFN0cmVhbVN1YmplY3Q7XG4gICAgICAgIGFjY2VwdGluZ1NlcnZlci5zdHJlYW1TdWJqZWN0cy5wcml2YXRlID0gcHJpdmF0ZVN0cmVhbVN1YmplY3Q7XG4gICAgICAgIC8vIGFjY2VwdGluZ1NlcnZlci5tZXRob2RSZXNwb25zZVN1YmplY3Qgc3RheXMgdGhlIHNhbWVcblxuICAgICAgICB2YXIgY29uZmlybWF0b3J5UmVxdWVzdCA9IHtcbiAgICAgICAgICAgIEV2ZW50U3RyZWFtQWN0aW9uOiAzLCAvLyBcIlN1YnNjcmliZWRcIiA9IGNsaWVudCBjb25maXJtcyBpbnRlbnRpb24gdG8gc3Vic2NyaWJlXG4gICAgICAgICAgICBFdmVudFN0cmVhbVN1YmplY3Q6IHByaXZhdGVTdHJlYW1TdWJqZWN0LFxuICAgICAgICAgICAgU3RyZWFtSWQ6IG1zZy5TdHJlYW1JZCxcbiAgICAgICAgICAgIE1ldGhvZFJlcXVlc3RTdWJqZWN0OiBtc2cuTWV0aG9kUmVxdWVzdFN1YmplY3QsXG4gICAgICAgICAgICBNZXRob2RSZXNwb25zZVN1YmplY3Q6IGFjY2VwdGluZ1NlcnZlci5tZXRob2RSZXNwb25zZVN1YmplY3QsXG4gICAgICAgICAgICBDbGllbnQ6IGluc3RhbmNlLmluZm8oKSxcbiAgICAgICAgICAgIENvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICBBcmd1bWVudHNKc29uOiBzdWJzY3JpcHRpb24uYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgIE1ldGhvZE5hbWU6IHN1YnNjcmlwdGlvbi5tZXRob2QubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHNlbmRSZXF1ZXN0KGNvbmZpcm1hdG9yeVJlcXVlc3QpO1xuXG4gICAgICAgIGlmIChpc0ZpcnN0UmVzcG9uc2UpIHtcbiAgICAgICAgICAgIC8vIFBhc3MgaW4gdGhlIHN1YnNjcmlwdGlvbiBvYmplY3RcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5zdWNjZXNzKHtcbiAgICAgICAgICAgICAgICBvbkRhdGE6IGZ1bmN0aW9uIChkYXRhQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBkYXRhIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbi4nKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVycy5vbkRhdGEucHVzaChkYXRhQ2FsbGJhY2spXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhbmRsZXJzLm9uRGF0YS5sZW5ndGggPT09IDEgJiYgdGhpcy5xdWV1ZWQuZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlZC5kYXRhLmZvckVhY2goZnVuY3Rpb24gKGRhdGFJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUNhbGxiYWNrKGRhdGFJdGVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0uYmluZChzdWJzY3JpcHRpb24pLFxuICAgICAgICAgICAgICAgIG9uQ2xvc2VkOiBmdW5jdGlvbiAoY2xvc2VkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjbG9zZWRDYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbi4nKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMub25DbG9zZWQucHVzaChjbG9zZWRDYWxsYmFjaylcbiAgICAgICAgICAgICAgICB9LmJpbmQoc3Vic2NyaXB0aW9uKSxcbiAgICAgICAgICAgICAgICBvbkZhaWxlZDogZnVuY3Rpb24gKCkgeyAvKiBXaWxsIG5vdCBiZSBpbXBsZW1lbnRlZCBmb3IgYnJvd3Nlci4gKi9cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNsb3NlOiBjbG9zZVN1YnNjcmlwdGlvbi5iaW5kKHN1YnNjcmlwdGlvbiwgc3Vic2NyaXB0aW9uSWQpLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RBcmd1bWVudHM6IHN1YnNjcmlwdGlvbi5hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgc2VydmVySW5zdGFuY2U6IGhlbHBlcnMuY29udmVydEluZm9Ub0luc3RhbmNlKG1zZy5TZXJ2ZXIpLFxuICAgICAgICAgICAgICAgIHN0cmVhbTogc3Vic2NyaXB0aW9uLm1ldGhvZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhY3Rpb24gNVxuICAgIGZ1bmN0aW9uIHNlcnZlckhhc1B1c2hlZFNvbWVEYXRhSW50b1RoZVN0cmVhbShtc2cpIHtcblxuICAgICAgICAvLyBGaW5kIHRoZSBzdWJzY3JpcHRpb24gb2YgaW50ZXJlc3QgYnkgdHJhd2xpbmcgdGhlIGRpY3Rpb25hcnlcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHN1YnNjcmlwdGlvbnNMaXN0KSB7XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uc0xpc3QuaGFzT3duUHJvcGVydHkoa2V5KSAmJiB0eXBlb2Ygc3Vic2NyaXB0aW9uc0xpc3Rba2V5XSA9PT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgICAgIHZhciBpc1ByaXZhdGVEYXRhO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRyYWNrZWRTZXJ2ZXJzRm91bmQgPSBzdWJzY3JpcHRpb25zTGlzdFtrZXldLnRyYWNrZWRTZXJ2ZXJzLmZpbHRlcihmdW5jdGlvbiAobHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGxzLnN0cmVhbUlkID09PSBtc2cuU3RyZWFtSWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChscy5zdHJlYW1TdWJqZWN0cy5nbG9iYWwgPT09IG1zZy5FdmVudFN0cmVhbVN1YmplY3QgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxzLnN0cmVhbVN1YmplY3RzLnByaXZhdGUgPT09IG1zZy5FdmVudFN0cmVhbVN1YmplY3QpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHJhY2tlZFNlcnZlcnNGb3VuZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaXNQcml2YXRlRGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRyYWNrZWRTZXJ2ZXJzRm91bmRbMF0uc3RyZWFtU3ViamVjdHMuZ2xvYmFsID09PSBtc2cuRXZlbnRTdHJlYW1TdWJqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlzUHJpdmF0ZURhdGEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRyYWNrZWRTZXJ2ZXJzRm91bmRbMF0uc3RyZWFtU3ViamVjdHMucHJpdmF0ZSA9PT0gbXNnLkV2ZW50U3RyZWFtU3ViamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBpc1ByaXZhdGVEYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNQcml2YXRlRGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgYXJyaXZlZERhdGEgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWNlaXZlZFN0cmVhbURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBtc2cuUmVzdWx0Q29udGV4dEpzb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXI6IGhlbHBlcnMuY29udmVydEluZm9Ub0luc3RhbmNlKG1zZy5TZXJ2ZXIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEFyZ3VtZW50czogc3Vic2NyaXB0aW9uc0xpc3Rba2V5XS5hcmd1bWVudHMgfHwge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2cuUmVzdWx0TWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaXZhdGU6IGlzUHJpdmF0ZURhdGFcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgb25EYXRhSGFuZGxlcnMgPSBzdWJzY3JpcHRpb25zTGlzdFtrZXldLmhhbmRsZXJzLm9uRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXVlZERhdGEgPSBzdWJzY3JpcHRpb25zTGlzdFtrZXldLnF1ZXVlZC5kYXRhO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9uRGF0YUhhbmRsZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uRGF0YUhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkRhdGFIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZWNlaXZlZFN0cmVhbURhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZWREYXRhLnB1c2gocmVjZWl2ZWRTdHJlYW1EYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9Ly8gZW5kIGZvci1pblxuICAgIH1cblxuICAgIC8qKiAoc3Vic2NyaXB0aW9uKSBNZXRob2RzICovXG4gICAgZnVuY3Rpb24gY2xvc2VTdWJzY3JpcHRpb24oc3ViSWQpIHtcblxuICAgICAgICB2YXIgcmVzcG9uc2VTdWJqZWN0ID0gbmV4dFJlc3BvbnNlU3ViamVjdCgpO1xuXG4gICAgICAgIHRoaXMudHJhY2tlZFNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAoc2VydmVyKSB7XG4gICAgICAgICAgICBzZW5kUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgRXZlbnRTdHJlYW1BY3Rpb246IDIsXG4gICAgICAgICAgICAgICAgQ2xpZW50OiBpbnN0YW5jZS5pbmZvKCksXG4gICAgICAgICAgICAgICAgTWV0aG9kUmVxdWVzdFN1YmplY3Q6IHNlcnZlci5tZXRob2RSZXF1ZXN0U3ViamVjdCxcbiAgICAgICAgICAgICAgICBNZXRob2RSZXNwb25zZVN1YmplY3Q6IHJlc3BvbnNlU3ViamVjdCxcbiAgICAgICAgICAgICAgICBTdHJlYW1JZDogc2VydmVyLnN0cmVhbUlkLFxuICAgICAgICAgICAgICAgIEV2ZW50U3RyZWFtU3ViamVjdDogc2VydmVyLnN0cmVhbVN1YmplY3RzLnByaXZhdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc3ViID0gdGhpcztcblxuICAgICAgICAvLyBDYWxsIHRoZSBvbkNsb3NlZCBoYW5kbGVyc1xuICAgICAgICB0aGlzLmhhbmRsZXJzLm9uQ2xvc2VkLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBPTl9DTE9TRV9NU0dfQ0xJRU5UX0lOSVQsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBcmd1bWVudHM6IHN1Yi5hcmd1bWVudHMgfHwge30sXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlcjogc3ViLnRyYWNrZWRTZXJ2ZXJzW3N1Yi50cmFja2VkU2VydmVycy5sZW5ndGggLSAxXS5zZXJ2ZXIsIC8vIHRoZSBsYXN0IG9uZSBvZiBtdWx0aS1zZXJ2ZXIgc3Vic2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbTogc3ViLm1ldGhvZFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlbGV0ZSBzdWJzY3JpcHRpb25zTGlzdFtzdWJJZF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVQcml2YXRlU3RyZWFtU3ViamVjdChtZXRob2ROYW1lKSB7XG5cbiAgICAgICAgdmFyIGFwcEluZm8gPSBpbnN0YW5jZS5pbmZvKCk7XG5cbiAgICAgICAgdmFyIHByaXZhdGVTdHJlYW1TdWJqZWN0ID0gJ0VTU3ByaXYtanNiXycgK1xuICAgICAgICAgICAgYXBwSW5mby5BcHBsaWNhdGlvbk5hbWUgK1xuICAgICAgICAgICAgJ19vbl8nICtcbiAgICAgICAgICAgIG1ldGhvZE5hbWUgK1xuICAgICAgICAgICAgJ18nICtcbiAgICAgICAgICAgIHJhbmRvbSgpO1xuXG4gICAgICAgIHJldHVybiBwcml2YXRlU3RyZWFtU3ViamVjdDtcbiAgICB9XG5cbiAgICByZXR1cm4geyAvLyBhbiBpbnN0YW5jZSBvZiB0aGUgc3RyZWFtaW5nIG1vZHVsZVxuICAgICAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcbiAgICAgICAgcHJvY2Vzc1B1Ymxpc2hlck1zZzogcHJvY2Vzc1B1Ymxpc2hlck1zZ1xuICAgIH07XG59O1xuIiwidmFyIHJhbmRvbSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy9yYW5kb20nKTtcbnZhciBjYWxsYmFja1JlZ2lzdHJ5ID0gcmVxdWlyZSgnY2FsbGJhY2stcmVnaXN0cnknKTtcbnZhciBTdHJlYW1pbmcgPSByZXF1aXJlKCcuL2NsaWVudC1zdHJlYW1pbmcnKTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbm5lY3Rpb24sIGluc3RhbmNlLCBjb25maWd1cmF0aW9uLCByZXBvc2l0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciB0aW1lcnMgPSB7fTtcbiAgICB2YXIgcmVzcENvdW50ZXIgPSAwO1xuICAgIHZhciBjYWxsYmFja3MgPSBjYWxsYmFja1JlZ2lzdHJ5KCk7XG5cbiAgICB2YXIgc3RyZWFtaW5nID0gbmV3IFN0cmVhbWluZyhcbiAgICAgICAgY29uZmlndXJhdGlvbixcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgIGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uLnNlbmQoJ01ldGhvZEludm9jYXRpb25SZXF1ZXN0TWVzc2FnZScsIG0pXG4gICAgICAgIH0sXG4gICAgICAgIG5leHRSZXNwb25zZVN1YmplY3RcbiAgICApO1xuXG4gICAgZnVuY3Rpb24gbmV4dFJlc3BvbnNlU3ViamVjdCgpIHtcbiAgICAgICAgcmV0dXJuICdyZXNwXycgKyAocmVzcENvdW50ZXIrKykgKyAnXycgKyByYW5kb20oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVTZXJ2ZXJJbmZvKGluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtYWNoaW5lOiBpbnN0YW5jZS5NYWNoaW5lTmFtZSxcbiAgICAgICAgICAgIHBpZDogaW5zdGFuY2UuUHJvY2Vzc0lkLFxuICAgICAgICAgICAgc3RhcnRlZDogaW5zdGFuY2UuUHJvY2Vzc1N0YXJ0VGltZSxcbiAgICAgICAgICAgIHVzZXI6IGluc3RhbmNlLlVzZXJOYW1lLFxuICAgICAgICAgICAgYXBwbGljYXRpb246IGluc3RhbmNlLkFwcGxpY2F0aW9uTmFtZSxcbiAgICAgICAgICAgIGVudmlyb25tZW50OiBpbnN0YW5jZS5FbnZpcm9ubWVudCxcbiAgICAgICAgICAgIHJlZ2lvbjogaW5zdGFuY2UuUmVnaW9uLFxuICAgICAgICAgICAgc2VydmljZV9uYW1lOiBpbnN0YW5jZS5TZXJ2aWNlTmFtZSxcbiAgICAgICAgICAgIG1ldHJpY3NfcmVwb3NpdG9yeV9pZDogaW5zdGFuY2UuTWV0cmljc1JlcG9zaXRvcnlJZCxcbiAgICAgICAgICAgIHN0YXRlOiBpbnN0YW5jZS5TdGF0ZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZU1ldGhvZChtZXRob2RJbmZvKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBtZXRob2RJbmZvLk1ldGhvZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IG1ldGhvZC5OYW1lLFxuICAgICAgICAgICAgYWNjZXB0czogbWV0aG9kLklucHV0U2lnbmF0dXJlLFxuICAgICAgICAgICAgcmV0dXJuczogbWV0aG9kLlJlc3VsdFNpZ25hdHVyZSxcbiAgICAgICAgICAgIHJlcXVlc3RTdWJqZWN0OiBtZXRob2RJbmZvLk1ldGhvZFJlcXVlc3RTdWJqZWN0LFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IG1ldGhvZC5EZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBtZXRob2QuRGlzcGxheU5hbWUsXG4gICAgICAgICAgICB2ZXJzaW9uOiBtZXRob2QuVmVyc2lvbixcbiAgICAgICAgICAgIG9iamVjdFR5cGVzOiBtZXRob2QuT2JqZWN0VHlwZVJlc3RyaWN0aW9ucyxcbiAgICAgICAgICAgIHN1cHBvcnRzU3RyZWFtaW5nOiBoZWxwZXJzLmlzU3RyZWFtaW5nRmxhZ1NldChtZXRob2QuRmxhZ3MpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGVzIGEgdW5pcXVlIElEIGZvciBhIHNlcnZlclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVNlcnZlcklkKHNlcnZlckluZm8pIHtcbiAgICAgICAgaWYgKHNlcnZlckluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbc2VydmVySW5mby5hcHBsaWNhdGlvbixcbiAgICAgICAgICAgIHNlcnZlckluZm8udXNlcixcbiAgICAgICAgICAgIHNlcnZlckluZm8ubWFjaGluZSxcbiAgICAgICAgICAgIHNlcnZlckluZm8uc3RhcnRlZCxcbiAgICAgICAgICAgIHNlcnZlckluZm8ucGlkXS5qb2luKCcvJykudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzU2VydmVyUHJlc2VuY2UocHJlc2VuY2UsIGlzUHJlc2VuY2UpIHtcblxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBwcmVzZW5jZS5JbnN0YW5jZTtcbiAgICAgICAgdmFyIHNlcnZlckluZm8gPSBjcmVhdGVTZXJ2ZXJJbmZvKGluc3RhbmNlKTtcbiAgICAgICAgdmFyIHNlcnZlcklkID0gY3JlYXRlU2VydmVySWQoc2VydmVySW5mbyk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VuY2UpIHtcbiAgICAgICAgICAgIC8vIHRlc3RcbiAgICAgICAgICAgIC8vIGNvbnNvbGUuZGVidWcobmV3IERhdGUoKSwgJyAgaGVhcmQgcHJlc2VuY2UnKTtcbiAgICAgICAgICAgIC8vIGlmIChpbnN0YW5jZS5BcHBsaWNhdGlvbk5hbWUgPT09ICdEdW1teSBzZXJ2ZXInKSB7XG4gICAgICAgICAgICAvLyAgICAgY29uc29sZS5kZWJ1ZyhuZXcgRGF0ZSgpLCAnICBnb3QgRHVtbXkgc2VydmVyIHByZXNlbmNlJywgcHJlc2VuY2UpO1xuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICBzZXJ2ZXJJZCA9IHJlcG9zaXRvcnkuYWRkU2VydmVyKHNlcnZlckluZm8sIHNlcnZlcklkKTtcblxuICAgICAgICAgICAgaWYgKHByZXNlbmNlLlB1Ymxpc2hpbmdJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlVGltZW91dChzZXJ2ZXJJZCwgcHJlc2VuY2UuUHVibGlzaGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmFsbHksIHVwZGF0ZSB0aGUgbWV0aG9kc1xuICAgICAgICBpZiAocHJlc2VuY2UuTWV0aG9kRGVmaW5pdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdXBkYXRlU2VydmVyTWV0aG9kcyhzZXJ2ZXJJZCwgcHJlc2VuY2UuTWV0aG9kRGVmaW5pdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBzZXRzIGEgdGltZW91dCB3aGljaCByZW1vdmVzIHRoZSBzZXJ2ZXIgdW5sZXNzIC0gdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZ2FpbiBiZWZvcmUgdGhlIHRpbWVvdXQgaXMgb3ZlclxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlVGltZW91dChzZXJ2ZXJJZCwgZHVyYXRpb24pIHtcblxuICAgICAgICBpZiAoZHVyYXRpb24gPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcCB0aGUgcHJldmlvdXMgdGltZW91dFxuICAgICAgICB2YXIgdGltZXIgPSB0aW1lcnNbc2VydmVySWRdO1xuICAgICAgICBpZiAodGltZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCBhIG5ldyBvbmVcbiAgICAgICAgdGltZXJzW3NlcnZlcklkXSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVwb3NpdG9yeS5yZW1vdmVTZXJ2ZXJCeUlkKHNlcnZlcklkKTtcbiAgICAgICAgfSwgZHVyYXRpb24gKiAoY29uZmlndXJhdGlvbi5jbGllbnQucmVtb3ZlX3NlcnZlcl9vbl9uX21pc3NpbmdfaGVhcnRiZWF0cyArIDEpKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGVzIHRoZSBtZXRob2RzIG9mIGEgc2VydmVyXG4gICAgZnVuY3Rpb24gdXBkYXRlU2VydmVyTWV0aG9kcyhzZXJ2ZXJJZCwgbmV3TWV0aG9kcykge1xuXG4gICAgICAgIC8vIEdldCBhbiBhcnJheSBvZiB0aGUgbWV0aG9kcyB0aGUgc2VydmVyIGhhZCBiZWZvcmUgd2Ugc3RhcnRlZCB0aGlzXG4gICAgICAgIHZhciBvbGRNZXRob2RzID0gcmVwb3NpdG9yeS5nZXRTZXJ2ZXJNZXRob2RzQnlJZChzZXJ2ZXJJZCk7XG5cbiAgICAgICAgLy8gR2V0IGFuIGFycmF5IG9mIHRoZSBtZXRob2RzIHRoYXQgdGhlIHNlcnZlciBoYXMgbm93XG4gICAgICAgIG5ld01ldGhvZHMgPSBuZXdNZXRob2RzLm1hcChjcmVhdGVNZXRob2QpLnJlZHVjZShmdW5jdGlvbiAob2JqLCBtZXRob2QpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2RJZCA9IHJlcG9zaXRvcnkuZ2V0TWV0aG9kSWQobWV0aG9kKTtcbiAgICAgICAgICAgIG9ialttZXRob2RJZF0gPSBtZXRob2Q7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LCB7fSk7XG5cbiAgICAgICAgLy8gRm9yIGVhY2ggb2YgdGhlIG9sZCBtZXRob2RzXG4gICAgICAgIE9iamVjdC5rZXlzKG9sZE1ldGhvZHMpLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZElkKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gb2xkTWV0aG9kc1ttZXRob2RJZF07XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBpdCBpcyBzdGlsbCB0aGVyZVxuICAgICAgICAgICAgaWYgKG5ld01ldGhvZHNbbWV0aG9kLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQgaXNuJ3QsIHJlbW92ZSBpdFxuICAgICAgICAgICAgICAgIHJlcG9zaXRvcnkucmVtb3ZlU2VydmVyTWV0aG9kKHNlcnZlcklkLCBtZXRob2QuaWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCBpcyB0aGVyZSBpbiBib3RoIHRoZSBvbGQgYXJyYXkgYW5kIHRoZSBuZXcgb25lLCB3ZSBkb24ndCBuZWVkIHRvIGFkZCBpdCBhZ2FpblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXdNZXRob2RzW21ldGhvZC5pZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBOb3cgYWRkIHRoZSBuZXcgbWV0aG9kc1xuICAgICAgICBPYmplY3Qua2V5cyhuZXdNZXRob2RzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBuZXdNZXRob2RzW2tleV07XG4gICAgICAgICAgICByZXBvc2l0b3J5LmFkZFNlcnZlck1ldGhvZChzZXJ2ZXJJZCwgbWV0aG9kKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52b2tlKGlkLCBtZXRob2QsIGFyZ3MsIHRhcmdldCwgc3R1ZmYpIHtcblxuICAgICAgICB2YXIgbWV0aG9kSW5mbyA9IG1ldGhvZC5pbmZvO1xuICAgICAgICAvLyBDb25zdHJ1Y3QgYSBtZXNzYWdlXG4gICAgICAgIHZhciBtZXNzYWdlID0ge1xuICAgICAgICAgICAgTWV0aG9kUmVxdWVzdFN1YmplY3Q6IG1ldGhvZEluZm8ucmVxdWVzdFN1YmplY3QsXG4gICAgICAgICAgICBNZXRob2RSZXNwb25zZVN1YmplY3Q6IG5leHRSZXNwb25zZVN1YmplY3QoKSxcbiAgICAgICAgICAgIENsaWVudDogaW5zdGFuY2UuaW5mbygpLFxuICAgICAgICAgICAgQ29udGV4dDoge1xuICAgICAgICAgICAgICAgIEFyZ3VtZW50c0pzb246IGFyZ3MsXG4gICAgICAgICAgICAgICAgSW52b2NhdGlvbklkOiBpZCxcbiAgICAgICAgICAgICAgICBPYmplY3RUeXBlOiBzdHVmZi5vYmplY3RfdHlwZSxcbiAgICAgICAgICAgICAgICBEaXNwbGF5Q29udGV4dDogc3R1ZmYuZGlzcGxheV9jb250ZXh0LFxuICAgICAgICAgICAgICAgIE1ldGhvZE5hbWU6IG1ldGhvZEluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICBFeGVjdXRpb25TZXJ2ZXI6IHRhcmdldC5pbmZvLFxuICAgICAgICAgICAgICAgIFRpbWVvdXQ6IHN0dWZmLm1ldGhvZF9yZXNwb25zZV90aW1lb3V0XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29ubmVjdGlvbi5zZW5kKCdNZXRob2RJbnZvY2F0aW9uUmVxdWVzdE1lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVJbnZva2VSZXN1bHRNZXNzYWdlKG1lc3NhZ2UpIHtcblxuICAgICAgICAvLyBEZWxlZ2F0ZSBzdHJlYW1pbmctcmVsYXRlZCBtZXNzYWdlcyB0byBzdHJlYW1pbmdcbiAgICAgICAgaWYgKG1lc3NhZ2UgJiYgbWVzc2FnZS5FdmVudFN0cmVhbUFjdGlvbiAmJiBtZXNzYWdlLkV2ZW50U3RyZWFtQWN0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICBzdHJlYW1pbmcucHJvY2Vzc1B1Ymxpc2hlck1zZyhtZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZXJ2ZXIgPSBtZXNzYWdlLlNlcnZlciA/IGNyZWF0ZVNlcnZlckluZm8obWVzc2FnZS5TZXJ2ZXIpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIHBhcnNlIHRoZSByZXN1bHRcbiAgICAgICAgdmFyIHJlc3VsdCA9IG1lc3NhZ2UuUmVzdWx0Q29udGV4dEpzb247XG4gICAgICAgIC8vIElmIHRoZSByZXN1bHQgaXMgYW4gZW1wdHkgb2JqZWN0LCB0aGVyZSBpcyBubyByZXN1bHRcbiAgICAgICAgaWYgKHJlc3VsdCAmJiBPYmplY3Qua2V5cyhyZXN1bHQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2tzLmV4ZWN1dGUoJ29uUmVzdWx0JywgbWVzc2FnZS5JbnZvY2F0aW9uSWQsIHNlcnZlciwgbWVzc2FnZS5TdGF0dXMsIHJlc3VsdCwgbWVzc2FnZS5SZXN1bHRNZXNzYWdlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkludm9jYXRpb25SZXN1bHQoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2tzLmFkZCgnb25SZXN1bHQnLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdGVuRm9yRXZlbnRzKCkge1xuICAgICAgICBjb25uZWN0aW9uLm9uKCdTZXJ2ZXJQcmVzZW5jZU1lc3NhZ2UnLCBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgICAgICBwcm9jZXNzU2VydmVyUHJlc2VuY2UobXNnLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbm5lY3Rpb24ub24oJ1NlcnZlckhlYXJ0YmVhdE1lc3NhZ2UnLCBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgICAgICBwcm9jZXNzU2VydmVyUHJlc2VuY2UobXNnLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25uZWN0aW9uLm9uKCdNZXRob2RJbnZvY2F0aW9uUmVzdWx0TWVzc2FnZScsIGhhbmRsZUludm9rZVJlc3VsdE1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGxpc3RlbkZvckV2ZW50cygpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW52b2tlOiBpbnZva2UsXG4gICAgICAgIG9uSW52b2NhdGlvblJlc3VsdDogb25JbnZvY2F0aW9uUmVzdWx0LFxuICAgICAgICBzdWJzY3JpYmU6IHN0cmVhbWluZy5zdWJzY3JpYmVcbiAgICB9XG59O1xuIiwiLypcbiogSGVscGVyIGZ1bmN0aW9ucyB1c2VkIG9ubHkgaW4gdGhpcyBwcm90b2NvbC5cbiogKi9cblxuZnVuY3Rpb24gY29udmVydEluZm9Ub0luc3RhbmNlKGluZm8pIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAodHlwZW9mIGluZm8gIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGluZm8gPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhcHBsaWNhdGlvbjogaW5mby5BcHBsaWNhdGlvbk5hbWUsXG4gICAgICAgIGVudmlyb25tZW50OiBpbmZvLkVudmlyb25tZW50LFxuICAgICAgICBtYWNoaW5lOiBpbmZvLk1hY2hpbmVOYW1lLFxuICAgICAgICBwaWQ6IGluZm8uUHJvY2Vzc0lkLFxuICAgICAgICByZWdpb246IGluZm8uUmVnaW9uLFxuICAgICAgICBzZXJ2aWNlOiBpbmZvLlNlcnZpY2VOYW1lLFxuICAgICAgICB1c2VyOiBpbmZvLlVzZXJOYW1lLFxuICAgICAgICBzdGFydGVkOiBpbmZvLlByb2Nlc3NTdGFydFRpbWVcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RyZWFtaW5nRmxhZ1NldChmbGFncykge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmICh0eXBlb2YgZmxhZ3MgIT09ICdudW1iZXInIHx8IGlzTmFOKGZsYWdzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gY2hlY2tpbmcgdGhlIGxhcmdlc3QgQml0IHVzaW5nIGJpdHdpc2Ugb3BzXG4gICAgdmFyIG1hc2sgPSAzMjtcbiAgICB2YXIgcmVzdWx0ID0gZmxhZ3MgJiBtYXNrO1xuXG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gbWFzaztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSAge1xuICAgIGlzU3RyZWFtaW5nRmxhZ1NldDogaXNTdHJlYW1pbmdGbGFnU2V0LFxuICAgIGNvbnZlcnRJbmZvVG9JbnN0YW5jZTogY29udmVydEluZm9Ub0luc3RhbmNlXG59O1xuIiwidmFyIFNlcnZlclByb3RvY29sID0gcmVxdWlyZSgnLi9zZXJ2ZXIuanMnKTtcbnZhciBDbGllbnRQcm90b2NvbCA9IHJlcXVpcmUoJy4vY2xpZW50LmpzJyk7XG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ2VzNi1wcm9taXNlJykuUHJvbWlzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGNvbm5lY3Rpb24sIHJlcG9zaXRvcnksIHZhdWx0LCBjb25maWd1cmF0aW9uKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGNvbm5lY3Rpb24ub24oJ0luc3RhbmNlJywgaW5zdGFuY2UuX3VwZGF0ZUlkZW50aXR5KTtcblxuICAgIHZhciBzZXJ2ZXJQcm90b2NvbCA9IG5ldyBTZXJ2ZXJQcm90b2NvbChjb25uZWN0aW9uLCBpbnN0YW5jZSwgY29uZmlndXJhdGlvbiwgdmF1bHQpO1xuICAgIHZhciBjbGllbnRQcm90b2NvbCA9IG5ldyBDbGllbnRQcm90b2NvbChjb25uZWN0aW9uLCBpbnN0YW5jZSwgY29uZmlndXJhdGlvbiwgcmVwb3NpdG9yeSk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcblxuICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIC8vIG1ldGhvZC1yZWxhdGVkXG4gICAgICAgICAgICBpbnZva2U6IGNsaWVudFByb3RvY29sLmludm9rZSxcbiAgICAgICAgICAgIG9uSW52b2NhdGlvblJlc3VsdDogY2xpZW50UHJvdG9jb2wub25JbnZvY2F0aW9uUmVzdWx0LFxuICAgICAgICAgICAgcmVnaXN0ZXI6IHNlcnZlclByb3RvY29sLnJlZ2lzdGVyLFxuICAgICAgICAgICAgdW5yZWdpc3Rlcjogc2VydmVyUHJvdG9jb2wudW5yZWdpc3RlcixcbiAgICAgICAgICAgIG9uSW52b2tlZDogc2VydmVyUHJvdG9jb2wub25JbnZva2VkLFxuICAgICAgICAgICAgbWV0aG9kSW52b2NhdGlvblJlc3VsdDogc2VydmVyUHJvdG9jb2wubWV0aG9kSW52b2NhdGlvblJlc3VsdCxcblxuICAgICAgICAgICAgLy8gc3RyZWFtLXJlbGF0ZWRcbiAgICAgICAgICAgIHN1YnNjcmliZTogY2xpZW50UHJvdG9jb2wuc3Vic2NyaWJlLFxuICAgICAgICAgICAgY3JlYXRlU3RyZWFtOiBzZXJ2ZXJQcm90b2NvbC5jcmVhdGVTdHJlYW0sXG4gICAgICAgICAgICBnZXRCcmFuY2hMaXN0OiBzZXJ2ZXJQcm90b2NvbC5nZXRCcmFuY2hMaXN0LFxuICAgICAgICAgICAgZ2V0U3Vic2NyaXB0aW9uTGlzdDogc2VydmVyUHJvdG9jb2wuZ2V0U3Vic2NyaXB0aW9uTGlzdCxcbiAgICAgICAgICAgIGNsb3NlQWxsU3Vic2NyaXB0aW9uczogc2VydmVyUHJvdG9jb2wuY2xvc2VBbGxTdWJzY3JpcHRpb25zLFxuICAgICAgICAgICAgY2xvc2VTaW5nbGVTdWJzY3JpcHRpb246IHNlcnZlclByb3RvY29sLmNsb3NlU2luZ2xlU3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgcHVzaERhdGE6IHNlcnZlclByb3RvY29sLnB1c2hEYXRhLFxuICAgICAgICAgICAgcHVzaERhdGFUb1NpbmdsZTogc2VydmVyUHJvdG9jb2wucHVzaERhdGFUb1NpbmdsZSxcbiAgICAgICAgICAgIG9uU3ViUmVxdWVzdDogc2VydmVyUHJvdG9jb2wub25TdWJSZXF1ZXN0LFxuICAgICAgICAgICAgYWNjZXB0UmVxdWVzdE9uQnJhbmNoOiBzZXJ2ZXJQcm90b2NvbC5hY2NlcHRSZXF1ZXN0T25CcmFuY2gsXG4gICAgICAgICAgICByZWplY3RSZXF1ZXN0OiBzZXJ2ZXJQcm90b2NvbC5yZWplY3RSZXF1ZXN0LFxuICAgICAgICAgICAgb25TdWJBZGRlZDogc2VydmVyUHJvdG9jb2wub25TdWJBZGRlZCxcbiAgICAgICAgICAgIG9uU3ViUmVtb3ZlZDogc2VydmVyUHJvdG9jb2wub25TdWJSZW1vdmVkXG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbiIsInZhciByYW5kb20gPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvcmFuZG9tJyk7XG4vLyBUT0RPIHVzZSBDYWxsYmFja3MgPSByZXF1aXJlKH4pXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25uZWN0aW9uLCBpbnN0YW5jZSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBUT0RPIGV4dHJhY3QgdGhlc2UgaW50byBDYWxsYmFja3NcbiAgICB2YXIgcmVxdWVzdEhhbmRsZXIgPSBudWxsO1xuICAgIHZhciBzdWJBZGRlZEhhbmRsZXIgPSBudWxsO1xuICAgIHZhciBzdWJSZW1vdmVkSGFuZGxlciA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBzZW5kUmVzdWx0KG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1lc3NhZ2UuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuU3RhdHVzICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgbWVzc2FnZS5TdGF0dXMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29ubmVjdGlvbi5zZW5kKCdNZXRob2RJbnZvY2F0aW9uUmVzdWx0TWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU3RyZWFtTXNnRm9yU3RyZWFtaW5nTWV0aG9kKG1zZywgbWV0aG9kKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBtc2cgJiZcbiAgICAgICAgICAgIG1zZy5FdmVudFN0cmVhbUFjdGlvbiAmJlxuICAgICAgICAgICAgbXNnLkV2ZW50U3RyZWFtQWN0aW9uICE9PSAwICYmXG4gICAgICAgICAgICB0eXBlb2YgbWV0aG9kID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgbWV0aG9kLmRlZmluaXRpb24uc3VwcG9ydHNTdHJlYW1pbmcgPT09IHRydWVcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzU3Vic2NyaWJlck1zZyhtc2csIHN0cmVhbWluZ01ldGhvZCkge1xuICAgICAgICBpZiAoIShtc2cgJiYgbXNnLkV2ZW50U3RyZWFtQWN0aW9uICYmIG1zZy5FdmVudFN0cmVhbUFjdGlvbiAhPT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtc2cuRXZlbnRTdHJlYW1BY3Rpb24gPT09IDEpIHtcbiAgICAgICAgICAgIGNsaWVudFdpc2hlc1RvU3Vic2NyaWJlKG1zZywgc3RyZWFtaW5nTWV0aG9kKTtcblxuICAgICAgICB9IGVsc2UgaWYgKG1zZy5FdmVudFN0cmVhbUFjdGlvbiA9PT0gMikge1xuICAgICAgICAgICAgY2xpZW50V2lzaGVzVG9VbnN1YnNjcmliZShtc2csIHN0cmVhbWluZ01ldGhvZCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChtc2cuRXZlbnRTdHJlYW1BY3Rpb24gPT09IDMpIHtcbiAgICAgICAgICAgIGNsaWVudEFja25vd2xlZGdlc0l0RGlkU3Vic2NyaWJlKG1zZywgc3RyZWFtaW5nTWV0aG9kKTtcblxuICAgICAgICB9IGVsc2UgaWYgKG1zZy5FdmVudFN0cmVhbUFjdGlvbiA9PT0gNCkge1xuICAgICAgICAgICAgY2xpZW50UGVyU3ViSGVhcnRiZWF0KG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogbXNnICdSZXF1ZXN0JyBBY3Rpb25zICovXG4gICAgLy8gYWN0aW9uIDFcbiAgICBmdW5jdGlvbiBjbGllbnRXaXNoZXNUb1N1YnNjcmliZShtc2csIHN0cmVhbWluZ01ldGhvZCkge1xuXG4gICAgICAgIHZhciByZXF1ZXN0Q29udGV4dCA9IHtcbiAgICAgICAgICAgIG1zZzogbXNnLFxuICAgICAgICAgICAgYXJndW1lbnRzOiBtc2cuQ29udGV4dC5Bcmd1bWVudHNKc29uIHx8IHt9LFxuICAgICAgICAgICAgaW5zdGFuY2U6IGhlbHBlcnMuY29udmVydEluZm9Ub0luc3RhbmNlKG1zZy5DbGllbnQpXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0SGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVxdWVzdEhhbmRsZXIocmVxdWVzdENvbnRleHQsIHN0cmVhbWluZ01ldGhvZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhY3Rpb24gMlxuICAgIGZ1bmN0aW9uIGNsaWVudFdpc2hlc1RvVW5zdWJzY3JpYmUobXNnLCBzdHJlYW1pbmdNZXRob2QpIHtcblxuICAgICAgICBpZiAoIShcbiAgICAgICAgICAgIHN0cmVhbWluZ01ldGhvZCAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShzdHJlYW1pbmdNZXRob2Quc3Vic2NyaXB0aW9ucykgJiZcbiAgICAgICAgICAgIHN0cmVhbWluZ01ldGhvZC5zdWJzY3JpcHRpb25zLmxlbmd0aCA+IDApXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xvc2VJbmRpdmlkdWFsU3Vic2NyaXB0aW9uKHN0cmVhbWluZ01ldGhvZCwgbXNnLlN0cmVhbUlkLCBtc2cuRXZlbnRTdHJlYW1TdWJqZWN0LCBmYWxzZSlcbiAgICB9XG5cbiAgICAvLyBhY3Rpb24gM1xuICAgIGZ1bmN0aW9uIGNsaWVudEFja25vd2xlZGdlc0l0RGlkU3Vic2NyaWJlKG1zZywgc3RyZWFtaW5nTWV0aG9kKSB7XG4gICAgICAgIC8vIENsaWVudCBpbmRpY2F0ZXMgaXQgaXMgbGlzdGVuaW5nIHRvIGEgc3BlY2lmaWMgU3RyZWFtSWRcblxuICAgICAgICBpZiAodHlwZW9mIG1zZy5TdHJlYW1JZCAhPT0gJ3N0cmluZycgfHwgbXNnLlN0cmVhbUlkID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJyYW5jaEtleSA9IGdldEJyYW5jaEtleShzdHJlYW1pbmdNZXRob2QsIG1zZy5TdHJlYW1JZCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBicmFuY2hLZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3RyZWFtaW5nTWV0aG9kLnN1YnNjcmlwdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0ge1xuICAgICAgICAgICAgYnJhbmNoS2V5OiBicmFuY2hLZXksXG4gICAgICAgICAgICBpbnN0YW5jZTogaGVscGVycy5jb252ZXJ0SW5mb1RvSW5zdGFuY2UobXNnLkNsaWVudCksXG4gICAgICAgICAgICBhcmd1bWVudHM6IG1zZy5Db250ZXh0LkFyZ3VtZW50c0pzb24sXG4gICAgICAgICAgICBzdHJlYW1JZDogbXNnLlN0cmVhbUlkLFxuICAgICAgICAgICAgcHJpdmF0ZUV2ZW50U3RyZWFtU3ViamVjdDogbXNnLkV2ZW50U3RyZWFtU3ViamVjdCxcbiAgICAgICAgICAgIG1ldGhvZFJlc3BvbnNlU3ViamVjdDogbXNnLk1ldGhvZFJlc3BvbnNlU3ViamVjdFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFN1YnNjcmlwdGlvbiBiYWNrLW9iaiBpcyBzdG9yZWRcbiAgICAgICAgc3RyZWFtaW5nTWV0aG9kLnN1YnNjcmlwdGlvbnMucHVzaChzdWJzY3JpcHRpb24pO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygc3ViQWRkZWRIYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdWJBZGRlZEhhbmRsZXIoc3Vic2NyaXB0aW9uLCBzdHJlYW1pbmdNZXRob2QpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWN0aW9uIDRcbiAgICBmdW5jdGlvbiBjbGllbnRQZXJTdWJIZWFydGJlYXQoKSB7XG4gICAgICAgIC8vIEEgY2xpZW50IG1heSBoYXZlIG11bHRpcGxlIHN1YnNjcmlwdGlvbnMsIGVhY2ggb25lIGhhdmluZyBpdHMgb3duIGhlYXJ0YmVhdFxuICAgICAgICAvLyBDdXJyZW50bHkgbm90IGltcGxlbWVudGVkIGJ5IHRoZSBHVyBvciB0aGUgY2xpZW50XG4gICAgfVxuXG5cbiAgICAvKiogKHJlcXVlc3QpIE1ldGhvZHMgKi9cbiAgICBmdW5jdGlvbiBhY2NlcHRSZXF1ZXN0T25CcmFuY2gocmVxdWVzdENvbnRleHQsIHN0cmVhbWluZ01ldGhvZCwgYnJhbmNoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYnJhbmNoICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYnJhbmNoID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RyZWFtSWQgPSBnZXRTdHJlYW1JZChzdHJlYW1pbmdNZXRob2QsIGJyYW5jaCk7XG5cbiAgICAgICAgdmFyIG1zZyA9IHJlcXVlc3RDb250ZXh0Lm1zZztcblxuICAgICAgICBzZW5kUmVzdWx0KHtcbiAgICAgICAgICAgIEV2ZW50U3RyZWFtQWN0aW9uOiAzLFxuICAgICAgICAgICAgRXZlbnRTdHJlYW1TdWJqZWN0OiBzdHJlYW1pbmdNZXRob2QuZ2xvYmFsRXZlbnRTdHJlYW1TdWJqZWN0LFxuICAgICAgICAgICAgSW52b2NhdGlvbklkOiBtc2cuQ29udGV4dC5JbnZvY2F0aW9uSWQsXG4gICAgICAgICAgICBNZXRob2ROYW1lOiBzdHJlYW1pbmdNZXRob2QubWV0aG9kLk1ldGhvZC5OYW1lLFxuICAgICAgICAgICAgTWV0aG9kUmVxdWVzdFN1YmplY3Q6IHN0cmVhbWluZ01ldGhvZC5tZXRob2QuTWV0aG9kUmVxdWVzdFN1YmplY3QsXG4gICAgICAgICAgICBNZXRob2RSZXNwb25zZVN1YmplY3Q6IG1zZy5NZXRob2RSZXNwb25zZVN1YmplY3QsXG4gICAgICAgICAgICBNZXRob2RWZXJzaW9uOiBzdHJlYW1pbmdNZXRob2QubWV0aG9kLk1ldGhvZC5WZXJzaW9uLFxuICAgICAgICAgICAgUmVzdWx0TWVzc2FnZTogJ0FjY2VwdGVkJyxcbiAgICAgICAgICAgIFNlcnZlcjogaW5zdGFuY2UuaW5mbygpLFxuICAgICAgICAgICAgU3RyZWFtSWQ6IHN0cmVhbUlkXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJyYW5jaEtleShzdHJlYW1pbmdNZXRob2QsIHN0cmVhbUlkKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyZWFtSWQgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBzdHJlYW1pbmdNZXRob2QgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmVlZGxlID0gc3RyZWFtaW5nTWV0aG9kLmJyYW5jaEtleVRvU3RyZWFtSWRNYXAuZmlsdGVyKGZ1bmN0aW9uIChicmFuY2gpIHtcbiAgICAgICAgICAgIHJldHVybiBicmFuY2guc3RyZWFtSWQgPT09IHN0cmVhbUlkO1xuICAgICAgICB9KVswXTtcblxuICAgICAgICBpZiAodHlwZW9mIG5lZWRsZSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIG5lZWRsZS5rZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmVlZGxlLmtleTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdHJlYW1JZChzdHJlYW1pbmdNZXRob2QsIGJyYW5jaEtleSkge1xuICAgICAgICBpZiAodHlwZW9mIGJyYW5jaEtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJyYW5jaEtleSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5lZWRsZUJyYW5jaCA9IHN0cmVhbWluZ01ldGhvZC5icmFuY2hLZXlUb1N0cmVhbUlkTWFwLmZpbHRlcihmdW5jdGlvbiAoYnJhbmNoKSB7XG4gICAgICAgICAgICByZXR1cm4gYnJhbmNoLmtleSA9PT0gYnJhbmNoS2V5O1xuICAgICAgICB9KVswXTtcblxuICAgICAgICB2YXIgc3RyZWFtSWQgPSAobmVlZGxlQnJhbmNoID8gbmVlZGxlQnJhbmNoLnN0cmVhbUlkIDogdW5kZWZpbmVkKTtcblxuICAgICAgICBpZiAodHlwZW9mICAgIHN0cmVhbUlkICE9PSAnc3RyaW5nJyB8fCBzdHJlYW1JZCA9PT0gJycpIHtcbiAgICAgICAgICAgIHN0cmVhbUlkID0gZ2VuZXJhdGVOZXdTdHJlYW1JZChzdHJlYW1pbmdNZXRob2QubWV0aG9kLk1ldGhvZC5OYW1lKTtcbiAgICAgICAgICAgIHN0cmVhbWluZ01ldGhvZC5icmFuY2hLZXlUb1N0cmVhbUlkTWFwLnB1c2goeyBrZXk6IGJyYW5jaEtleSwgc3RyZWFtSWQ6IHN0cmVhbUlkIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cmVhbUlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlTmV3U3RyZWFtSWQoc3RyZWFtaW5nTWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgYXBwSW5mbyA9IGluc3RhbmNlLmluZm8oKTtcblxuICAgICAgICB2YXIgbmV3U3RyZWFtSWQgPSAnc3RyZWFtSWQtanNiX29mXycgK1xuICAgICAgICAgICAgc3RyZWFtaW5nTWV0aG9kTmFtZSArXG4gICAgICAgICAgICAnX19ieV8nICtcbiAgICAgICAgICAgIGFwcEluZm8uQXBwbGljYXRpb25OYW1lICtcbiAgICAgICAgICAgICdfJyArXG4gICAgICAgICAgICByYW5kb20oKTtcblxuICAgICAgICByZXR1cm4gbmV3U3RyZWFtSWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVqZWN0UmVxdWVzdChyZXF1ZXN0Q29udGV4dCwgc3RyZWFtaW5nTWV0aG9kLCByZWFzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWFzb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZWFzb24gPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtc2cgPSByZXF1ZXN0Q29udGV4dC5tc2c7XG5cbiAgICAgICAgc2VuZFJlc3VsdCh7XG4gICAgICAgICAgICBFdmVudFN0cmVhbUFjdGlvbjogMixcbiAgICAgICAgICAgIEV2ZW50U3RyZWFtU3ViamVjdDogc3RyZWFtaW5nTWV0aG9kLmdsb2JhbEV2ZW50U3RyZWFtU3ViamVjdCxcbiAgICAgICAgICAgIC8vIEludm9jYXRpb25JZDogbXNnLkNvbnRleHQuSW52b2NhdGlvbklkLFxuICAgICAgICAgICAgTWV0aG9kTmFtZTogc3RyZWFtaW5nTWV0aG9kLm1ldGhvZC5NZXRob2QuTmFtZSxcbiAgICAgICAgICAgIE1ldGhvZFJlcXVlc3RTdWJqZWN0OiBzdHJlYW1pbmdNZXRob2QubWV0aG9kLk1ldGhvZFJlcXVlc3RTdWJqZWN0LFxuICAgICAgICAgICAgTWV0aG9kUmVzcG9uc2VTdWJqZWN0OiBtc2cuTWV0aG9kUmVzcG9uc2VTdWJqZWN0LFxuICAgICAgICAgICAgTWV0aG9kVmVyc2lvbjogc3RyZWFtaW5nTWV0aG9kLm1ldGhvZC5NZXRob2QuVmVyc2lvbixcbiAgICAgICAgICAgIFJlc3VsdE1lc3NhZ2U6IHJlYXNvbixcbiAgICAgICAgICAgIFNlcnZlcjogaW5zdGFuY2UuaW5mbygpLFxuICAgICAgICAgICAgU3RyZWFtSWQ6ICdkZWZhdWx0X3JlamVjdGlvbl9zdHJlYW1JZCdcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIChzdWJzY3JpcHRpb24pIE1ldGhvZHMgKi9cbiAgICBmdW5jdGlvbiBjbG9zZUluZGl2aWR1YWxTdWJzY3JpcHRpb24oc3RyZWFtaW5nTWV0aG9kLCBzdHJlYW1JZCwgcHJpdmF0ZUV2ZW50U3RyZWFtU3ViamVjdCwgc2VuZEtpY2tNZXNzYWdlKSB7XG5cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHN0cmVhbWluZ01ldGhvZC5zdWJzY3JpcHRpb25zLmZpbHRlcihmdW5jdGlvbiAoc3ViSXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBzdWJJdGVtLnByaXZhdGVFdmVudFN0cmVhbVN1YmplY3QgPT09IHByaXZhdGVFdmVudFN0cmVhbVN1YmplY3QgJiZcbiAgICAgICAgICAgICAgICBzdWJJdGVtLnN0cmVhbUlkID09PSBzdHJlYW1JZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSlbMF07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzdWJzY3JpcHRpb24gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIHVucmVjb2duaXNlZCBzdWJzY3JpcHRpb25cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbml0aWFsTGVuZ3RoID0gc3RyZWFtaW5nTWV0aG9kLnN1YnNjcmlwdGlvbnMubGVuZ3RoO1xuXG4gICAgICAgIHN0cmVhbWluZ01ldGhvZC5zdWJzY3JpcHRpb25zID0gc3RyZWFtaW5nTWV0aG9kLnN1YnNjcmlwdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChzdWJJdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gIShcbiAgICAgICAgICAgICAgICBzdWJJdGVtLnByaXZhdGVFdmVudFN0cmVhbVN1YmplY3QgPT09IHN1YnNjcmlwdGlvbi5wcml2YXRlRXZlbnRTdHJlYW1TdWJqZWN0ICYmXG4gICAgICAgICAgICAgICAgc3ViSXRlbS5zdHJlYW1JZCA9PT0gc3Vic2NyaXB0aW9uLnN0cmVhbUlkXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZmlsdGVyZWRMZW5ndGggPSBzdHJlYW1pbmdNZXRob2Quc3Vic2NyaXB0aW9ucy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGZpbHRlcmVkTGVuZ3RoICE9PSAoaW5pdGlhbExlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIHRoZSBzdWJzY3JpcHRpb24gd2Fzbid0IHJlbW92ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZW5kS2lja01lc3NhZ2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHNlbmRSZXN1bHQoe1xuICAgICAgICAgICAgICAgIEV2ZW50U3RyZWFtQWN0aW9uOiAyLFxuICAgICAgICAgICAgICAgIEV2ZW50U3RyZWFtU3ViamVjdDogcHJpdmF0ZUV2ZW50U3RyZWFtU3ViamVjdCxcbiAgICAgICAgICAgICAgICBNZXRob2ROYW1lOiBzdHJlYW1pbmdNZXRob2QubWV0aG9kLk1ldGhvZC5OYW1lLFxuICAgICAgICAgICAgICAgIE1ldGhvZFJlcXVlc3RTdWJqZWN0OiBzdHJlYW1pbmdNZXRob2QubWV0aG9kLk1ldGhvZFJlcXVlc3RTdWJqZWN0LFxuICAgICAgICAgICAgICAgIE1ldGhvZFJlc3BvbnNlU3ViamVjdDogc3Vic2NyaXB0aW9uLm1ldGhvZFJlc3BvbnNlU3ViamVjdCxcbiAgICAgICAgICAgICAgICBNZXRob2RWZXJzaW9uOiBzdHJlYW1pbmdNZXRob2QubWV0aG9kLk1ldGhvZC5WZXJzaW9uLFxuICAgICAgICAgICAgICAgIFJlc3BvbnNlQ29udGV4dEpzb246IHt9LFxuICAgICAgICAgICAgICAgIFNlcnZlcjogaW5zdGFuY2UuaW5mbygpLFxuICAgICAgICAgICAgICAgIFN0cmVhbUlkOiBzdWJzY3JpcHRpb24uc3RyZWFtSWQsXG4gICAgICAgICAgICAgICAgU3RhdHVzOiAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc3ViUmVtb3ZlZEhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBzdWJzY3JpYmVyID0gc3Vic2NyaXB0aW9uLmluc3RhbmNlO1xuICAgICAgICAgICAgc3ViUmVtb3ZlZEhhbmRsZXIoc3Vic2NyaWJlciwgc3RyZWFtaW5nTWV0aG9kKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvc2VNdWx0aXBsZVN1YnNjcmlwdGlvbnMoc3RyZWFtaW5nTWV0aG9kLCBicmFuY2hLZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHJlYW1pbmdNZXRob2QgIT09ICdvYmplY3QnIHx8ICFBcnJheS5pc0FycmF5KHN0cmVhbWluZ01ldGhvZC5icmFuY2hLZXlUb1N0cmVhbUlkTWFwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0cmVhbUxpc3QgPSBzdHJlYW1pbmdNZXRob2QuYnJhbmNoS2V5VG9TdHJlYW1JZE1hcDtcblxuICAgICAgICBpZiAodHlwZW9mIGJyYW5jaEtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHN0cmVhbUxpc3QgPSBzdHJlYW1pbmdNZXRob2QuYnJhbmNoS2V5VG9TdHJlYW1JZE1hcC5maWx0ZXIoZnVuY3Rpb24gKGJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgYnIgPT09ICdvYmplY3QnICYmIGJyLmtleSA9PT0gYnJhbmNoS2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogY29uc2lkZXIgZ2V0dGluZyB0aGUgdW5pcXVlIGJyYW5jaCBrZXlzIGZyb20gJ2xpdmUgc3Vic2NyaWJlcnMnXG5cbiAgICAgICAgc3RyZWFtTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChicikge1xuICAgICAgICAgICAgdmFyIHN0cmVhbUlkID0gYnIuc3RyZWFtSWQ7XG5cbiAgICAgICAgICAgIHNlbmRSZXN1bHQoe1xuICAgICAgICAgICAgICAgIEV2ZW50U3RyZWFtQWN0aW9uOiAyLFxuICAgICAgICAgICAgICAgIEV2ZW50U3RyZWFtU3ViamVjdDogc3RyZWFtaW5nTWV0aG9kLmdsb2JhbEV2ZW50U3RyZWFtU3ViamVjdCxcbiAgICAgICAgICAgICAgICBNZXRob2ROYW1lOiBzdHJlYW1pbmdNZXRob2QubWV0aG9kLk1ldGhvZC5OYW1lLFxuICAgICAgICAgICAgICAgIE1ldGhvZFJlcXVlc3RTdWJqZWN0OiBzdHJlYW1pbmdNZXRob2QubWV0aG9kLk1ldGhvZFJlcXVlc3RTdWJqZWN0LFxuICAgICAgICAgICAgICAgIFNlcnZlcjogaW5zdGFuY2UuaW5mbygpLFxuICAgICAgICAgICAgICAgIFN0cmVhbUlkOiBzdHJlYW1JZCxcbiAgICAgICAgICAgICAgICBTdGF0dXM6IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9zZVNpbmdsZVN1YnNjcmlwdGlvbihzdHJlYW1pbmdNZXRob2QsIHN1YnNjcmlwdGlvbikge1xuICAgICAgICBjbG9zZUluZGl2aWR1YWxTdWJzY3JpcHRpb24oXG4gICAgICAgICAgICBzdHJlYW1pbmdNZXRob2QsXG4gICAgICAgICAgICBzdWJzY3JpcHRpb24uc3RyZWFtSWQsXG4gICAgICAgICAgICBzdWJzY3JpcHRpb24ucHJpdmF0ZUV2ZW50U3RyZWFtU3ViamVjdCxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwdXNoRGF0YVRvU2luZ2xlKHN0cmVhbWluZ01ldGhvZCwgc3Vic2NyaXB0aW9uLCBkYXRhKSB7XG5cbiAgICAgICAgLy8gVE9ETyB2YWxpZGF0ZSBkYXRhIGlzIGEgcGxhaW4gb2JqZWN0XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMuIERhdGEgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZW5kUmVzdWx0KHtcbiAgICAgICAgICAgIEV2ZW50U3RyZWFtQWN0aW9uOiA1LFxuICAgICAgICAgICAgRXZlbnRTdHJlYW1TdWJqZWN0OiBzdWJzY3JpcHRpb24ucHJpdmF0ZUV2ZW50U3RyZWFtU3ViamVjdCxcbiAgICAgICAgICAgIE1ldGhvZE5hbWU6IHN0cmVhbWluZ01ldGhvZC5tZXRob2QuTWV0aG9kLk5hbWUsXG4gICAgICAgICAgICBNZXRob2RSZXF1ZXN0U3ViamVjdDogc3RyZWFtaW5nTWV0aG9kLm1ldGhvZC5NZXRob2RSZXF1ZXN0U3ViamVjdCxcbiAgICAgICAgICAgIFJlc3VsdENvbnRleHRKc29uOiBkYXRhLFxuICAgICAgICAgICAgU2VydmVyOiBpbnN0YW5jZS5pbmZvKCksXG4gICAgICAgICAgICBTdHJlYW1JZDogc3Vic2NyaXB0aW9uLnN0cmVhbUlkXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1c2hUb0JyYW5jaChzdHJlYW1pbmdNZXRob2QsIGRhdGEsIGJyYW5jaGVzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyZWFtaW5nTWV0aG9kICE9PSAnb2JqZWN0JyB8fCAhQXJyYXkuaXNBcnJheShzdHJlYW1pbmdNZXRob2QuYnJhbmNoS2V5VG9TdHJlYW1JZE1hcCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE8gdmFsaWRhdGUgZGF0YSBpcyBhIHBsYWluIG9iamVjdFxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzLiBEYXRhIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBicmFuY2hlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJyYW5jaGVzID0gW2JyYW5jaGVzXTsgLy8gdXNlciB3YW50cyB0byBwdXNoIHRvIHNpbmdsZSBicmFuY2hcbiAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShicmFuY2hlcykgfHwgYnJhbmNoZXMubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgIGJyYW5jaGVzID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCB0aGUgU3RyZWFtSWQncyBmcm9tIHRoZSBtZXRob2QncyBicmFuY2ggbWFwXG4gICAgICAgIHZhciBzdHJlYW1JZExpc3QgPSBzdHJlYW1pbmdNZXRob2QuYnJhbmNoS2V5VG9TdHJlYW1JZE1hcFxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoYnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICBicmFuY2hlcyA9PT0gbnVsbCB8fCAoQm9vbGVhbihicikgJiYgdHlwZW9mIGJyLmtleSA9PT0gJ3N0cmluZycgJiYgYnJhbmNoZXMuaW5kZXhPZihici5rZXkpID49IDApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbiAoYnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnIuc3RyZWFtSWQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBzdHJlYW1JZExpc3QuZm9yRWFjaChmdW5jdGlvbiAoc3RyZWFtSWQpIHtcblxuICAgICAgICAgICAgc2VuZFJlc3VsdCh7XG4gICAgICAgICAgICAgICAgRXZlbnRTdHJlYW1BY3Rpb246IDUsXG4gICAgICAgICAgICAgICAgRXZlbnRTdHJlYW1TdWJqZWN0OiBzdHJlYW1pbmdNZXRob2QuZ2xvYmFsRXZlbnRTdHJlYW1TdWJqZWN0LFxuICAgICAgICAgICAgICAgIE1ldGhvZE5hbWU6IHN0cmVhbWluZ01ldGhvZC5tZXRob2QuTWV0aG9kLk5hbWUsXG4gICAgICAgICAgICAgICAgTWV0aG9kUmVxdWVzdFN1YmplY3Q6IHN0cmVhbWluZ01ldGhvZC5tZXRob2QuTWV0aG9kUmVxdWVzdFN1YmplY3QsXG4gICAgICAgICAgICAgICAgUmVzdWx0Q29udGV4dEpzb246IGRhdGEsXG4gICAgICAgICAgICAgICAgU2VydmVyOiBpbnN0YW5jZS5pbmZvKCksXG4gICAgICAgICAgICAgICAgU3RyZWFtSWQ6IHN0cmVhbUlkXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdWJzY3JpcHRpb25MaXN0KHN0cmVhbWluZ01ldGhvZCwgYnJhbmNoS2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyZWFtaW5nTWV0aG9kICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSBbXTtcblxuICAgICAgICBpZiAodHlwZW9mIGJyYW5jaEtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMgPSBzdHJlYW1pbmdNZXRob2Quc3Vic2NyaXB0aW9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMgPSBzdHJlYW1pbmdNZXRob2Quc3Vic2NyaXB0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKHN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWIuYnJhbmNoS2V5ID09PSBicmFuY2hLZXk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb25zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJyYW5jaExpc3Qoc3RyZWFtaW5nTWV0aG9kKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyZWFtaW5nTWV0aG9kICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldFVuaXF1ZUJyYW5jaE5hbWVzKHN0cmVhbWluZ01ldGhvZCk7XG5cbiAgICAgICAgLy8gVE9ETyB0aGUgYWdtLWFwaSBwYXNzZXMgZWFjaCBzdWIgdG8gcHJvdG9jb2wgbWV0aG9kcyBmb3IgY3JlYXRpbmcgdGhlIHN1YiBmcm9udCBvYmpcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIHRoZSBuYW1lcyBvZiBicmFuY2hlcyBmb3Igd2hpY2ggdGhlcmUgYXJlIGxpdmUgc3Vic2NyaXB0aW9uc1xuICAgIGZ1bmN0aW9uIGdldFVuaXF1ZUJyYW5jaE5hbWVzKHN0cmVhbWluZ01ldGhvZCkge1xuICAgICAgICB2YXIga2V5c1dpdGhEdXBsaWNhdGVzID0gc3RyZWFtaW5nTWV0aG9kLnN1YnNjcmlwdGlvbnMubWFwKGZ1bmN0aW9uIChzdWIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdWIgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzdWIuYnJhbmNoS2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHN1Yi5icmFuY2hLZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc2VlbiA9IFtdO1xuXG4gICAgICAgIHZhciBicmFuY2hBcnJheSA9IGtleXNXaXRoRHVwbGljYXRlcy5maWx0ZXIoZnVuY3Rpb24gKGJLZXkpIHtcbiAgICAgICAgICAgIGlmIChiS2V5ID09PSBudWxsIHx8IHNlZW4uaW5kZXhPZihiS2V5KSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2Vlbi5wdXNoKGJLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBicmFuY2hBcnJheTtcbiAgICB9XG5cbiAgICAvKiogc2V0dGluZyB1c2VyLXByb3ZpZGVkIGhhbmRsZXJzICovIC8vIFRPRE8gcmVwbGFjZSBpbm5lcmRzIHdpdGggY2FsbGJhY2suanNcbiAgICBmdW5jdGlvbiBhZGRSZXF1ZXN0SGFuZGxlcihoYW5kbGVyRnVuYykge1xuICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXJGdW5jICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0SGFuZGxlciA9IGhhbmRsZXJGdW5jO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFN1YkFkZGVkSGFuZGxlcihoYW5kbGVyRnVuYykge1xuICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXJGdW5jICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzdWJBZGRlZEhhbmRsZXIgPSBoYW5kbGVyRnVuYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTdWJSZW1vdmVkSGFuZGxlcihoYW5kbGVyRnVuYykge1xuICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXJGdW5jICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzdWJSZW1vdmVkSGFuZGxlciA9IGhhbmRsZXJGdW5jO1xuICAgIH1cblxuICAgIHJldHVybiB7IC8vIGFuIGluc3RhbmNlIG9mIHRoZSBwdWJsaXNoZXJcbiAgICAgICAgaXNTdHJlYW1Nc2c6IGlzU3RyZWFtTXNnRm9yU3RyZWFtaW5nTWV0aG9kLFxuICAgICAgICBwcm9jZXNzU3Vic2NyaWJlck1zZzogcHJvY2Vzc1N1YnNjcmliZXJNc2csXG4gICAgICAgIHB1c2hEYXRhOiBwdXNoVG9CcmFuY2gsXG4gICAgICAgIHB1c2hEYXRhVG9TaW5nbGU6IHB1c2hEYXRhVG9TaW5nbGUsXG4gICAgICAgIGNsb3NlQWxsU3Vic2NyaXB0aW9uczogY2xvc2VNdWx0aXBsZVN1YnNjcmlwdGlvbnMsXG4gICAgICAgIGNsb3NlU2luZ2xlU3Vic2NyaXB0aW9uOiBjbG9zZVNpbmdsZVN1YnNjcmlwdGlvbixcbiAgICAgICAgZ2V0U3Vic2NyaXB0aW9uTGlzdDogZ2V0U3Vic2NyaXB0aW9uTGlzdCxcbiAgICAgICAgZ2V0QnJhbmNoTGlzdDogZ2V0QnJhbmNoTGlzdCxcbiAgICAgICAgb25TdWJSZXF1ZXN0OiBhZGRSZXF1ZXN0SGFuZGxlcixcbiAgICAgICAgYWNjZXB0UmVxdWVzdE9uQnJhbmNoOiBhY2NlcHRSZXF1ZXN0T25CcmFuY2gsXG4gICAgICAgIHJlamVjdFJlcXVlc3Q6IHJlamVjdFJlcXVlc3QsXG4gICAgICAgIG9uU3ViQWRkZWQ6IGFkZFN1YkFkZGVkSGFuZGxlcixcbiAgICAgICAgb25TdWJSZW1vdmVkOiBhZGRTdWJSZW1vdmVkSGFuZGxlcixcbiAgICAgICAgZ2VuZXJhdGVOZXdTdHJlYW1JZDogZ2VuZXJhdGVOZXdTdHJlYW1JZFxuXG4gICAgfTtcbn07XG4iLCJ2YXIgcmFuZG9tID0gcmVxdWlyZSgnLi8uLi8uLi9oZWxwZXJzL3JhbmRvbScpO1xudmFyIGNhbGxiYWNrUmVnaXN0cnkgPSByZXF1aXJlKCdjYWxsYmFjay1yZWdpc3RyeScpO1xudmFyIFN0cmVhbWluZyA9IHJlcXVpcmUoJy4vc2VydmVyLXN0cmVhbWluZycpO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29ubmVjdGlvbiwgaW5zdGFuY2UsIGNvbmZpZ3VyYXRpb24sIHZhdWx0KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBpbnZvY2F0aW9uTWVzc2FnZXNNYXAgPSB7fTsgIC8vIHtpbnZvY2F0aW9uSWQ6IEludm9jYXRpb25fUmVxdWVzdE1lc3NhZ2V9XG5cbiAgICB2YXIgcmVxQ291bnRlciA9IDA7XG4gICAgdmFyIHByZXNlbmNlVGltZXI7XG4gICAgdmFyIGhlYXJ0YmVhdFRpbWVyO1xuICAgIHZhciBjYWxsYmFja3MgPSBjYWxsYmFja1JlZ2lzdHJ5KCk7XG4gICAgdmFyIHN0cmVhbWluZyA9IG5ldyBTdHJlYW1pbmcoY29ubmVjdGlvbiwgaW5zdGFuY2UpO1xuXG4gICAgY29ubmVjdGlvbi5vbignTWV0aG9kSW52b2NhdGlvblJlcXVlc3RNZXNzYWdlJywgaGFuZGxlTWV0aG9kSW52b2NhdGlvbk1lc3NhZ2UpO1xuXG4gICAgaWYgKGhlYXJ0YmVhdFRpbWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGVhcnRiZWF0VGltZXIgPSBzZXRJbnRlcnZhbChzZW5kSGVhcnRiZWF0LCBjb25maWd1cmF0aW9uLnNlcnZlci5oZWFydGJlYXRfaW50ZXJ2YWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5leHRSZXF1ZXN0U3ViamVjdCgpIHtcbiAgICAgICAgcmV0dXJuICdyZXFfJyArIChyZXFDb3VudGVyKyspICsgJ18nICsgcmFuZG9tKCk7XG4gICAgfVxuXG4gICAgLy8gQ29uc3RydWN0cyBhIGhlYXJ0YmVhdCBtZXNzYWdlXG4gICAgZnVuY3Rpb24gY29uc3RydWN0SGVhcnRiZWF0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgUHVibGlzaGluZ0ludGVydmFsOiBjb25maWd1cmF0aW9uLnNlcnZlci5oZWFydGJlYXRfaW50ZXJ2YWwsXG4gICAgICAgICAgICBJbnN0YW5jZTogaW5zdGFuY2UuaW5mbygpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQ29uc3RydWN0cyBhIHByZXNlbmNlIG1lc3NhZ2VcbiAgICBmdW5jdGlvbiBjb25zdHJ1Y3RQcmVzZW5jZSgpIHtcbiAgICAgICAgdmFyIG1ldGhvZHMgPSB2YXVsdC5nZXRMaXN0KCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFB1Ymxpc2hpbmdJbnRlcnZhbDogY29uZmlndXJhdGlvbi5zZXJ2ZXIucHJlc2VuY2VfaW50ZXJ2YWwsXG4gICAgICAgICAgICBJbnN0YW5jZTogaW5zdGFuY2UuaW5mbygpLFxuICAgICAgICAgICAgTWV0aG9kRGVmaW5pdGlvbnM6IG1ldGhvZHMubWFwKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG0ubWV0aG9kXG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIFNlbmRzIGEgcHJlc2VuY2VcbiAgICBmdW5jdGlvbiBzZW5kUHJlc2VuY2UoKSB7XG4gICAgICAgIGNvbm5lY3Rpb24uc2VuZCgnU2VydmVyUHJlc2VuY2VNZXNzYWdlJywgY29uc3RydWN0UHJlc2VuY2UoKSk7XG4gICAgfVxuXG4gICAgLy8gU2VuZHMgYSBoZWFydGJlYXRcbiAgICBmdW5jdGlvbiBzZW5kSGVhcnRiZWF0KCkge1xuICAgICAgICBjb25uZWN0aW9uLnNlbmQoJ1NlcnZlckhlYXJ0YmVhdE1lc3NhZ2UnLCBjb25zdHJ1Y3RIZWFydGJlYXQoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTmV3TWV0aG9kTWVzc2FnZShtZXRob2RJZGVudGlmaWVyLCBzdWJqZWN0KSB7XG4gICAgICAgIC8vIElmIHdlIGFyZSBnaXZlbiBhIHN0cmluZyBpbnN0ZWFkIG9mIGFuIG9iamVjdCwgd2UgcHJlc3VtZSB0aGF0IGlzIHRoZSBtZXRob2QncyBuYW1lOlxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZElkZW50aWZpZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBtZXRob2RJZGVudGlmaWVyID0geyBuYW1lOiBtZXRob2RJZGVudGlmaWVyIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgZGVmYXVsdCB2YWx1ZXNcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2RJZGVudGlmaWVyLnZlcnNpb24gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBtZXRob2RJZGVudGlmaWVyLnZlcnNpb24gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29udmVydCB0aGUgbWV0aG9kIGRlZmluaXRpb24gdG8gdGhlIGZvcm1hdCB0aGF0IEFHTSByZXF1aXJlc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgTWV0aG9kOiB7XG4gICAgICAgICAgICAgICAgTmFtZTogbWV0aG9kSWRlbnRpZmllci5uYW1lLFxuICAgICAgICAgICAgICAgIElucHV0U2lnbmF0dXJlOiBtZXRob2RJZGVudGlmaWVyLmFjY2VwdHMsXG4gICAgICAgICAgICAgICAgUmVzdWx0U2lnbmF0dXJlOiBtZXRob2RJZGVudGlmaWVyLnJldHVybnMsXG4gICAgICAgICAgICAgICAgRGVzY3JpcHRpb246IG1ldGhvZElkZW50aWZpZXIuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgRGlzcGxheU5hbWU6IG1ldGhvZElkZW50aWZpZXIuZGlzcGxheU5hbWUsXG4gICAgICAgICAgICAgICAgVmVyc2lvbjogbWV0aG9kSWRlbnRpZmllci52ZXJzaW9uLFxuICAgICAgICAgICAgICAgIE9iamVjdFR5cGVSZXN0cmljdGlvbnM6IG1ldGhvZElkZW50aWZpZXIub2JqZWN0VHlwZXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBNZXRob2RSZXF1ZXN0U3ViamVjdDogc3ViamVjdFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyKHJlcG9NZXRob2QsIHN1Y2Nlc3MpIHtcblxuICAgICAgICAvLyBHZXQgYSByZXF1ZXN0IHN1YmplY3QgZm9yIHRoaXMgbWV0aG9kXG4gICAgICAgIHZhciByZXFTdWJqID0gbmV4dFJlcXVlc3RTdWJqZWN0KCk7XG5cbiAgICAgICAgcmVwb01ldGhvZC5tZXRob2QgPSBjcmVhdGVOZXdNZXRob2RNZXNzYWdlKHJlcG9NZXRob2QuZGVmaW5pdGlvbiwgcmVxU3Viaik7XG5cbiAgICAgICAgYW5ub3VuY2VOZXdNZXRob2QoKTtcblxuICAgICAgICBzdWNjZXNzKCk7XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhIHN0cmVhbWluZyBtZXRob2QgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVTdHJlYW0ocmVwb01ldGhvZCwgc3RyZWFtRGVmLCBzdWNjZXNzKSB7XG5cbiAgICAgICAgdmFyIHJlcVN1YmogPSBuZXh0UmVxdWVzdFN1YmplY3QoKTtcblxuICAgICAgICB2YXIgc3RyZWFtQ29udmVydGVkID0gY3JlYXRlTmV3TWV0aG9kTWVzc2FnZShzdHJlYW1EZWYsIHJlcVN1YmopO1xuICAgICAgICBzdHJlYW1Db252ZXJ0ZWQuTWV0aG9kLkZsYWdzID0gMzI7IC8vIDEwMDAwMCBiaXRtYXNrIHdpdGggdGhlIGxhcmdlc3QgZmxhZyAoc3RyZWFtaW5nOiB0cnVlKVxuXG4gICAgICAgIC8vIFVzZWQgZm9yIHByZXNlbmNlc1xuICAgICAgICByZXBvTWV0aG9kLm1ldGhvZCA9IHN0cmVhbUNvbnZlcnRlZDtcblxuICAgICAgICAvLyBVdGlsaXR5IHRoaW5ncyBmb3IgdGhpcyBwcm90b2NvbFxuICAgICAgICByZXBvTWV0aG9kLmdsb2JhbEV2ZW50U3RyZWFtU3ViamVjdCA9IHN0cmVhbURlZi5uYW1lICsgJy5qc1N0cmVhbS4nICsgcmFuZG9tKCk7XG4gICAgICAgIHJlcG9NZXRob2Quc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICByZXBvTWV0aG9kLmJyYW5jaEtleVRvU3RyZWFtSWRNYXAgPSBbXTsgLy8gWyB7YnJhbmNoS2V5OiAnJywgc3RyZWFtSWQ6ICdzdHJqX25kczdgOGA2eTIzNzh5Yid9LCB7Li4ufSwgLi4uXVxuXG4gICAgICAgIGFubm91bmNlTmV3TWV0aG9kKCk7XG5cbiAgICAgICAgc3VjY2VzcygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFubm91bmNlTmV3TWV0aG9kKCkge1xuXG4gICAgICAgIC8vIFNlbmQgcHJlc2VuY2Ugc28gdGhlIGNsaWVudHMga25vdyB3ZSBoYXZlIGl0XG4gICAgICAgIHNlbmRQcmVzZW5jZSgpO1xuXG4gICAgICAgIC8vIFN0YXJ0IHNlbmRpbmcgcHJlc2VuY2UgcmVndWxhcmx5IChpZiB3ZSBhcmVuJ3QgYWxyZWFkeSBkb2luZyBpdClcbiAgICAgICAgaWYgKHByZXNlbmNlVGltZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJlc2VuY2VUaW1lciA9IHNldEludGVydmFsKHNlbmRQcmVzZW5jZSwgY29uZmlndXJhdGlvbi5zZXJ2ZXIucHJlc2VuY2VfaW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTGlzdGVucyBmb3IgbWV0aG9kIGludm9jYXRpb25zXG4gICAgZnVuY3Rpb24gaGFuZGxlTWV0aG9kSW52b2NhdGlvbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICB2YXIgc3ViamVjdCA9IG1lc3NhZ2UuTWV0aG9kUmVxdWVzdFN1YmplY3Q7XG4gICAgICAgIHZhciBtZXRob2RMaXN0ID0gdmF1bHQuZ2V0TGlzdCgpO1xuXG4gICAgICAgIHZhciBtZXRob2QgPSBtZXRob2RMaXN0LmZpbHRlcihmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgcmV0dXJuIG0ubWV0aG9kLk1ldGhvZFJlcXVlc3RTdWJqZWN0ID09PSBzdWJqZWN0O1xuICAgICAgICB9KVswXTtcblxuICAgICAgICAvLyBTdG9wIGlmIHRoZSBtZXNzYWdlIGlzbid0IGZvciB1c1xuICAgICAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE8gc2VlIGlmIGhhdmUgdG8gbW92ZSB0aGlzIGVhcmxpZXIgLSBpLmUuIGlmIHNvbWUgbWVzc2FnZXMgZnJvbSBDbGllbnQgZG9uJ3QgaGF2ZSBNZXRob2RSZXF1ZXN0U3ViamVjdFxuICAgICAgICAvLyBDaGVjayBpZiBtZXNzYWdlIGlzIHN0cmVhbS1yZWxhdGVkIDogZGVmZXIgdG8gc3RyZWFtaW5nIG1vZHVsZVxuICAgICAgICBpZiAoc3RyZWFtaW5nLmlzU3RyZWFtTXNnKG1lc3NhZ2UsIG1ldGhvZCkpIHtcbiAgICAgICAgICAgIHN0cmVhbWluZy5wcm9jZXNzU3Vic2NyaWJlck1zZyhtZXNzYWdlLCBtZXRob2QpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGludm9jYXRpb25JZCA9IG1lc3NhZ2UuQ29udGV4dC5JbnZvY2F0aW9uSWQ7XG4gICAgICAgIGludm9jYXRpb25NZXNzYWdlc01hcFtpbnZvY2F0aW9uSWRdID0gbWVzc2FnZTtcblxuICAgICAgICB2YXIgaW52b2NhdGlvbkFyZ3MgPSB7XG4gICAgICAgICAgICBhcmdzOiBtZXNzYWdlLkNvbnRleHQuQXJndW1lbnRzSnNvbixcbiAgICAgICAgICAgIGluc3RhbmNlOiBoZWxwZXJzLmNvbnZlcnRJbmZvVG9JbnN0YW5jZShtZXNzYWdlLkNsaWVudClcbiAgICAgICAgfTtcbiAgICAgICAgY2FsbGJhY2tzLmV4ZWN1dGUoJ29uSW52b2tlZCcsIG1ldGhvZCwgaW52b2NhdGlvbklkLCBpbnZvY2F0aW9uQXJncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25JbnZva2VkKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrcy5hZGQoJ29uSW52b2tlZCcsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXRob2RJbnZvY2F0aW9uUmVzdWx0KGV4ZWN1dGVkTWV0aG9kLCBpbnZvY2F0aW9uSWQsIGVyciwgcmVzdWx0KSB7XG5cbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBpbnZvY2F0aW9uTWVzc2FnZXNNYXBbaW52b2NhdGlvbklkXTtcbiAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb24ndCBzZW5kIHJlc3VsdCBpZiB0aGUgY2xpZW50IGRvZXMgbm90IHJlcXVpcmUgaXRcbiAgICAgICAgaWYgKG1lc3NhZ2UuTWV0aG9kUmVzcG9uc2VTdWJqZWN0ID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleGVjdXRlZE1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0TWVzc2FnZSA9IHtcbiAgICAgICAgICAgIE1ldGhvZFJlcXVlc3RTdWJqZWN0OiBtZXNzYWdlLk1ldGhvZFJlcXVlc3RTdWJqZWN0LFxuICAgICAgICAgICAgTWV0aG9kUmVzcG9uc2VTdWJqZWN0OiBtZXNzYWdlLk1ldGhvZFJlc3BvbnNlU3ViamVjdCxcbiAgICAgICAgICAgIE1ldGhvZE5hbWU6IGV4ZWN1dGVkTWV0aG9kLm1ldGhvZC5NZXRob2QuTmFtZSxcbiAgICAgICAgICAgIEludm9jYXRpb25JZDogaW52b2NhdGlvbklkLFxuICAgICAgICAgICAgUmVzdWx0Q29udGV4dEpzb246IHJlc3VsdCxcbiAgICAgICAgICAgIFNlcnZlcjogaW5zdGFuY2UuaW5mbygpLFxuICAgICAgICAgICAgUmVzdWx0TWVzc2FnZTogZXJyLFxuICAgICAgICAgICAgU3RhdHVzOiBlcnIgPyAxIDogMFxuICAgICAgICB9O1xuICAgICAgICAvLyBTZW5kIHJlc3VsdFxuICAgICAgICBjb25uZWN0aW9uLnNlbmQoJ01ldGhvZEludm9jYXRpb25SZXN1bHRNZXNzYWdlJywgcmVzdWx0TWVzc2FnZSk7XG5cbiAgICAgICAgZGVsZXRlIGludm9jYXRpb25NZXNzYWdlc01hcFtpbnZvY2F0aW9uSWRdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVucmVnaXN0ZXIoKSB7XG4gICAgICAgIHNlbmRQcmVzZW5jZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHJlZ2lzdGVyOiByZWdpc3RlcixcbiAgICAgICAgb25JbnZva2VkOiBvbkludm9rZWQsXG4gICAgICAgIG1ldGhvZEludm9jYXRpb25SZXN1bHQ6IG1ldGhvZEludm9jYXRpb25SZXN1bHQsXG4gICAgICAgIHVucmVnaXN0ZXI6IHVucmVnaXN0ZXIsXG5cbiAgICAgICAgLy8gc3RyZWFtLXJlbGF0ZWRcbiAgICAgICAgY3JlYXRlU3RyZWFtOiBjcmVhdGVTdHJlYW0sXG4gICAgICAgIGdldEJyYW5jaExpc3Q6IHN0cmVhbWluZy5nZXRCcmFuY2hMaXN0LFxuICAgICAgICBnZXRTdWJzY3JpcHRpb25MaXN0OiBzdHJlYW1pbmcuZ2V0U3Vic2NyaXB0aW9uTGlzdCxcbiAgICAgICAgY2xvc2VBbGxTdWJzY3JpcHRpb25zOiBzdHJlYW1pbmcuY2xvc2VBbGxTdWJzY3JpcHRpb25zLFxuICAgICAgICBjbG9zZVNpbmdsZVN1YnNjcmlwdGlvbjogc3RyZWFtaW5nLmNsb3NlU2luZ2xlU3Vic2NyaXB0aW9uLFxuICAgICAgICBwdXNoRGF0YVRvU2luZ2xlOiBzdHJlYW1pbmcucHVzaERhdGFUb1NpbmdsZSxcbiAgICAgICAgcHVzaERhdGE6IHN0cmVhbWluZy5wdXNoRGF0YSxcbiAgICAgICAgb25TdWJSZXF1ZXN0OiBzdHJlYW1pbmcub25TdWJSZXF1ZXN0LFxuICAgICAgICBhY2NlcHRSZXF1ZXN0T25CcmFuY2g6IHN0cmVhbWluZy5hY2NlcHRSZXF1ZXN0T25CcmFuY2gsXG4gICAgICAgIHJlamVjdFJlcXVlc3Q6IHN0cmVhbWluZy5yZWplY3RSZXF1ZXN0LFxuICAgICAgICBvblN1YkFkZGVkOiBzdHJlYW1pbmcub25TdWJBZGRlZCxcbiAgICAgICAgb25TdWJSZW1vdmVkOiBzdHJlYW1pbmcub25TdWJSZW1vdmVkXG4gICAgfVxufTtcbiIsIi8qKlxuICogSGFuZGxlcyByZWdpc3RlcmluZyBtZXRob2RzIGFuZCBzZW5kaW5nIGRhdGEgdG8gY2xpZW50c1xuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGNvbm5lY3Rpb24sIHJlcG9zaXRvcnksIHNlc3Npb24sIGxvZ2dlcikge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBjb25uZWN0aW9uLm9uKCdzdWJzY3JpYmVkJywgaGFuZGxlU3Vic2NyaWJlZCk7XG4gICAgY29ubmVjdGlvbi5vbignZXZlbnQnLCBoYW5kbGVFdmVudERhdGEpO1xuICAgIGNvbm5lY3Rpb24ub24oJ3N1YnNjcmlwdGlvbi1jYW5jZWxsZWQnLCBoYW5kbGVTdWJzY3JpcHRpb25DYW5jZWxsZWQpO1xuXG4gICAgdmFyIE1TR19UWVBFX1NVQlNDUklCRSA9ICdzdWJzY3JpYmUnO1xuICAgIHZhciBTVEFUVVNfQVdBSVRJTkdfQUNDRVBUID0gJ2F3YWl0aW5nQWNjZXB0JzsgLy8gbm90IGV2ZW4gb25lIHNlcnZlciBoYXMgYWNjZXB0ZWQgeWV0XG4gICAgdmFyIFNUQVRVU19TVUJTQ1JJQkVEID0gJ3N1YnNjcmliZWQnOyAvLyBhdCBsZWFzdCBvbmUgc2VydmVyIGhhcyByZXNwb25kZWQgYXMgJ0FjY2VwdGluZydcbiAgICB2YXIgRVJSX01TR19TVUJfRkFJTEVEID0gJ1N1YnNjcmlwdGlvbiBmYWlsZWQuJztcbiAgICB2YXIgRVJSX01TR19TVUJfUkVKRUNURUQgPSAnU3Vic2NyaXB0aW9uIHJlamVjdGVkLic7XG4gICAgdmFyIE9OX0NMT1NFX01TR19TRVJWRVJfSU5JVCA9ICdTZXJ2ZXJJbml0aWF0ZWQnO1xuICAgIHZhciBPTl9DTE9TRV9NU0dfQ0xJRU5UX0lOSVQgPSAnQ2xpZW50SW5pdGlhdGVkJztcblxuICAgIHZhciBzdWJzY3JpcHRpb25zTGlzdCA9IHt9O1xuICAgIHZhciBzdWJzY3JpcHRpb25JZFRvTG9jYWxLZXlNYXAgPSB7fTtcbiAgICB2YXIgbmV4dFN1YkxvY2FsS2V5ID0gMDtcblxuICAgIGZ1bmN0aW9uIGdldE5leHRTdWJzY3JpcHRpb25Mb2NhbEtleSgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0U3ViTG9jYWxLZXk7XG4gICAgICAgIG5leHRTdWJMb2NhbEtleSArPSAxO1xuXG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1YnNjcmliZShzdHJlYW1pbmdNZXRob2QsIGFyZ3VtZW50T2JqLCB0YXJnZXRTZXJ2ZXJzLCBzdHVmZiwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgaWYgKHRhcmdldFNlcnZlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBlcnJvcihFUlJfTVNHX1NVQl9GQUlMRUQgKyAnIE5vIGF2YWlsYWJsZSBzZXJ2ZXJzIG1hdGNoZWQgdGhlIHRhcmdldCBwYXJhbXMuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsb2dnZXIuZGVidWcoJ3N1YnNjcmliZSB0byB0YXJnZXQgc2VydmVyczogJywgdGFyZ2V0U2VydmVycylcblxuICAgICAgICAvLyBOb3RlOiB1c2VkIHRvIGZpbmQgdGhlIHN1YnNjcmlwdGlvbiBpbiBzdWJMaXN0LiBEbyBub3QgY29uZnVzZSBpdCB3aXRoIHRoZSBndy1nZW5lcmF0ZWQgc3Vic2NyaXB0aW9uX2lkXG4gICAgICAgIHZhciBzdWJMb2NhbEtleSA9IGdldE5leHRTdWJzY3JpcHRpb25Mb2NhbEtleSgpO1xuXG4gICAgICAgIHZhciBwZW5kaW5nU3ViID0gcmVnaXN0ZXJTdWJzY3JpcHRpb24oXG4gICAgICAgICAgICBzdWJMb2NhbEtleSxcbiAgICAgICAgICAgIHN0cmVhbWluZ01ldGhvZCxcbiAgICAgICAgICAgIGFyZ3VtZW50T2JqLFxuICAgICAgICAgICAgc3VjY2VzcyxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgc3R1ZmYubWV0aG9kX3Jlc3BvbnNlX3RpbWVvdXRcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodHlwZW9mIHBlbmRpbmdTdWIgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBlcnJvcihFUlJfTVNHX1NVQl9GQUlMRUQgKyAnIFVuYWJsZSB0byByZWdpc3RlciB0aGUgdXNlciBjYWxsYmFja3MuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXRTZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24odGFyZ2V0KSB7XG5cbiAgICAgICAgICAgIHZhciBzZXJ2ZXJJZCA9IHRhcmdldC5zZXJ2ZXIuaWQ7XG5cbiAgICAgICAgICAgIHBlbmRpbmdTdWIudHJhY2tlZFNlcnZlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgc2VydmVySWQ6IHNlcnZlcklkLFxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbklkOiB1bmRlZmluZWQgLy8gaXMgYXNzaWduZWQgYnkgZ3czXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIG1zZyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBNU0dfVFlQRV9TVUJTQ1JJQkUsXG4gICAgICAgICAgICAgICAgc2VydmVyX2lkOiBzZXJ2ZXJJZCxcbiAgICAgICAgICAgICAgICBtZXRob2RfaWQ6IHN0cmVhbWluZ01ldGhvZC5pbmZvLmlkLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50c19rdjogYXJndW1lbnRPYmpcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbm5lY3Rpb24uc2VuZChtc2csIHsgc2VydmVySWQ6IHNlcnZlcklkLCBzdWJMb2NhbEtleTogc3ViTG9jYWxLZXkgfSlcbiAgICAgICAgICAgICAgICAudGhlbihoYW5kbGVTdWJzY3JpYmVkKVsnY2F0Y2gnXShoYW5kbGVFcnJvclN1YnNjcmliaW5nKTtcblxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWdpc3RlclN1YnNjcmlwdGlvbihzdWJMb2NhbEtleSwgbWV0aG9kLCBhcmdzLCBzdWNjZXNzLCBlcnJvciwgdGltZW91dCkge1xuICAgICAgICBzdWJzY3JpcHRpb25zTGlzdFtzdWJMb2NhbEtleV0gPSB7XG4gICAgICAgICAgICBzdGF0dXM6IFNUQVRVU19BV0FJVElOR19BQ0NFUFQsXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIGFyZ3VtZW50czogYXJncyxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3MsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICB0cmFja2VkU2VydmVyczogW10sXG4gICAgICAgICAgICBoYW5kbGVyczoge1xuICAgICAgICAgICAgICAgIG9uRGF0YTogW10sXG4gICAgICAgICAgICAgICAgb25DbG9zZWQ6IFtdXG4gICAgICAgICAgICAgICAgLy8gb25GYWlsZWQ6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcXVldWVkOiB7XG4gICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgICAgY2xvc2VyczogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aW1lb3V0SWQ6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuXG4gICAgICAgIHN1YnNjcmlwdGlvbnNMaXN0W3N1YkxvY2FsS2V5XS50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25zTGlzdFtzdWJMb2NhbEtleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gbm8gc3VjaCBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBlbmRpbmdTdWIgPSBzdWJzY3JpcHRpb25zTGlzdFtzdWJMb2NhbEtleV07XG5cbiAgICAgICAgICAgIGlmIChwZW5kaW5nU3ViLnN0YXR1cyA9PT0gU1RBVFVTX0FXQUlUSU5HX0FDQ0VQVCkge1xuICAgICAgICAgICAgICAgIGVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxlZF93aXRoOiBhcmdzLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBFUlJfTVNHX1NVQl9GQUlMRUQgKyAnIFN1YnNjcmlwdGlvbiBhdHRlbXB0IHRpbWVkIG91dCBhZnRlciAnICsgdGltZW91dCArICdtcy4nXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBOb25lIG9mIHRoZSB0YXJnZXQgc2VydmVycyBoYXMgYW5zd2VyZWQgdGhlIHN1YnNjcmlwdGlvbiBhdHRlbXB0XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN1YnNjcmlwdGlvbnNMaXN0W3N1YkxvY2FsS2V5XTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChwZW5kaW5nU3ViLnN0YXR1cyA9PT0gU1RBVFVTX1NVQlNDUklCRUQgJiYgcGVuZGluZ1N1Yi50cmFja2VkU2VydmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4gdGhlIHRyYWNrZWRTZXJ2ZXJzLCByZW1vdmluZyB0aG9zZSB3aXRob3V0IHZhbGlkIHN0cmVhbUlkXG4gICAgICAgICAgICAgICAgcGVuZGluZ1N1Yi50cmFja2VkU2VydmVycyA9IHBlbmRpbmdTdWIudHJhY2tlZFNlcnZlcnMuZmlsdGVyKGZ1bmN0aW9uIChzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0eXBlb2Ygc2VydmVyLnN0cmVhbUlkICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBwZW5kaW5nU3ViLnRpbWVvdXRJZDtcblxuICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nU3ViLnRyYWNrZWRTZXJ2ZXJzLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBubyBvcGVuIHN0cmVhbXMsIHNvbWUgc2VydmVycyBhY2NlcHRlZCB0aGVuIGNsb3NlZCB2ZXJ5IHF1aWNrbHlcbiAgICAgICAgICAgICAgICAgICAgLy8gICh0aGF0J3Mgd2h5IHRoZSBzdGF0dXMgY2hhbmdlZCBidXQgdGhlcmUncyBubyBnb29kIHNlcnZlciB3aXRoIGEgU3RyZWFtSWQpXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCB0aGUgb25DbG9zZWQgaGFuZGxlcnNcbiAgICAgICAgICAgICAgICAgICAgY2FsbE9uQ2xvc2VkSGFuZGxlcnMocGVuZGluZ1N1Yik7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN1YnNjcmlwdGlvbnNMaXN0W3N1YkxvY2FsS2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb25zTGlzdFtzdWJMb2NhbEtleV1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVFcnJvclN1YnNjcmliaW5nKGVycm9yUmVzcG9uc2UpIHtcbiAgICAgICAgLy8gQSB0YXJnZXQgc2VydmVyIGlzIHJlamVjdGluZ1xuICAgICAgICBsb2dnZXIuZGVidWcoJ1N1YnNjcmlwdGlvbiBhdHRlbXB0IGZhaWxlZCcsIGVycm9yUmVzcG9uc2UpO1xuXG4gICAgICAgIHZhciB0YWcgPSBlcnJvclJlc3BvbnNlLl90YWc7XG4gICAgICAgIHZhciBzdWJMb2NhbEtleSA9IHRhZy5zdWJMb2NhbEtleTtcblxuICAgICAgICB2YXIgcGVuZGluZ1N1YiA9IHN1YnNjcmlwdGlvbnNMaXN0W3N1YkxvY2FsS2V5XTtcblxuICAgICAgICBpZiAodHlwZW9mIHBlbmRpbmdTdWIgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwZW5kaW5nU3ViLnRyYWNrZWRTZXJ2ZXJzID0gcGVuZGluZ1N1Yi50cmFja2VkU2VydmVycy5maWx0ZXIoZnVuY3Rpb24gKHNlcnZlcikge1xuICAgICAgICAgICAgcmV0dXJuIHNlcnZlci5zZXJ2ZXJJZCAhPT0gdGFnLnNlcnZlcklkO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocGVuZGluZ1N1Yi50cmFja2VkU2VydmVycy5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHBlbmRpbmdTdWIudGltZW91dElkKTtcblxuICAgICAgICAgICAgaWYgKHBlbmRpbmdTdWIuc3RhdHVzID09PSBTVEFUVVNfQVdBSVRJTkdfQUNDRVBUKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVqZWN0IHdpdGggcmVhc29uXG4gICAgICAgICAgICAgICAgdmFyIHJlYXNvbiA9ICh0eXBlb2YgZXJyb3JSZXNwb25zZS5yZWFzb24gPT09ICdzdHJpbmcnICYmIGVycm9yUmVzcG9uc2UucmVhc29uICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgPyAnIFB1Ymxpc2hlciBzYWlkIFwiJyArIGVycm9yUmVzcG9uc2UucmVhc29uICsgJ1wiLidcbiAgICAgICAgICAgICAgICAgICAgOiAnIE5vIHJlYXNvbiBnaXZlbi4nO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNhbGxBcmdzID0gdHlwZW9mIHBlbmRpbmdTdWIuYXJndW1lbnRzID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KHBlbmRpbmdTdWIuYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgICAgICA6ICd7fSc7XG5cbiAgICAgICAgICAgICAgICBwZW5kaW5nU3ViLmVycm9yKEVSUl9NU0dfU1VCX1JFSkVDVEVEICsgcmVhc29uICsgJyBDYWxsZWQgd2l0aDonICsgY2FsbEFyZ3MpO1xuXG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGVuZGluZ1N1Yi5zdGF0dXMgPT09IFNUQVRVU19TVUJTQ1JJQkVEKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHRpbWVvdXQgbWF5IG9yIG1heSBub3QgaGF2ZSBleHBpcmVkIHlldCxcbiAgICAgICAgICAgICAgICAvLyBidXQgdGhlIHN0YXR1cyBpcyAnc3Vic2NyaWJlZCcgYW5kIHRyYWNrZWRTZXJ2ZXJzIGlzIG5vdyBlbXB0eVxuXG4gICAgICAgICAgICAgICAgY2FsbE9uQ2xvc2VkSGFuZGxlcnMocGVuZGluZ1N1Yik7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgZGVsZXRlIHN1YnNjcmlwdGlvbnNMaXN0W3N1YkxvY2FsS2V5XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVN1YnNjcmliZWQobXNnKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnaGFuZGxlU3Vic2NyaWJlZCcsIG1zZyk7XG5cbiAgICAgICAgdmFyIHN1YkxvY2FsS2V5ID0gbXNnLl90YWcuc3ViTG9jYWxLZXk7XG4gICAgICAgIHZhciBwZW5kaW5nU3ViID0gc3Vic2NyaXB0aW9uc0xpc3Rbc3ViTG9jYWxLZXldO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcGVuZGluZ1N1YiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZXJ2ZXJJZCA9IG1zZy5fdGFnLnNlcnZlcklkO1xuXG4gICAgICAgIC8vIEFkZCBhIHN1YnNjcmlwdGlvbl9pZCB0byB0aGlzIHRyYWNrZWRTZXJ2ZXJcblxuICAgICAgICB2YXIgYWNjZXB0aW5nU2VydmVyID0gcGVuZGluZ1N1Yi50cmFja2VkU2VydmVyc1xuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VydmVyLnNlcnZlcklkID09PSBzZXJ2ZXJJZDtcbiAgICAgICAgICAgIH0pWzBdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgYWNjZXB0aW5nU2VydmVyICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYWNjZXB0aW5nU2VydmVyLnN1YnNjcmlwdGlvbklkID0gbXNnLnN1YnNjcmlwdGlvbl9pZDtcbiAgICAgICAgc3Vic2NyaXB0aW9uSWRUb0xvY2FsS2V5TWFwW21zZy5zdWJzY3JpcHRpb25faWRdID0gc3ViTG9jYWxLZXk7XG5cbiAgICAgICAgdmFyIGlzRmlyc3RSZXNwb25zZSA9IChwZW5kaW5nU3ViLnN0YXR1cyA9PT0gU1RBVFVTX0FXQUlUSU5HX0FDQ0VQVCk7XG5cbiAgICAgICAgcGVuZGluZ1N1Yi5zdGF0dXMgPSBTVEFUVVNfU1VCU0NSSUJFRDtcblxuICAgICAgICBpZiAoaXNGaXJzdFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAvLyBQYXNzIGluIHRoZSBzdWJzY3JpcHRpb24gb2JqZWN0XG4gICAgICAgICAgICBwZW5kaW5nU3ViLnN1Y2Nlc3Moe1xuICAgICAgICAgICAgICAgIG9uRGF0YTogZnVuY3Rpb24gKGRhdGFDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGFDYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGRhdGEgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uLicpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXJzLm9uRGF0YS5wdXNoKGRhdGFDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhbmRsZXJzLm9uRGF0YS5sZW5ndGggPT09IDEgJiYgdGhpcy5xdWV1ZWQuZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlZC5kYXRhLmZvckVhY2goZnVuY3Rpb24gKGRhdGFJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUNhbGxiYWNrKGRhdGFJdGVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0uYmluZChwZW5kaW5nU3ViKSxcbiAgICAgICAgICAgICAgICBvbkNsb3NlZDogZnVuY3Rpb24gKGNsb3NlZENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2xvc2VkQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24uJylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXJzLm9uQ2xvc2VkLnB1c2goY2xvc2VkQ2FsbGJhY2spXG4gICAgICAgICAgICAgICAgfS5iaW5kKHBlbmRpbmdTdWIpLFxuICAgICAgICAgICAgICAgIG9uRmFpbGVkOiBmdW5jdGlvbiAoKSB7IC8qIFdpbGwgbm90IGJlIGltcGxlbWVudGVkIGZvciBicm93c2VyLiAqL1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2xvc2U6IGNsb3NlU3Vic2NyaXB0aW9uLmJpbmQoc3ViTG9jYWxLZXkpLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RBcmd1bWVudHM6IHBlbmRpbmdTdWIuYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgIHNlcnZlckluc3RhbmNlOiByZXBvc2l0b3J5LmdldFNlcnZlckJ5SWQoc2VydmVySWQpLmdldEluZm9Gb3JVc2VyKCksXG4gICAgICAgICAgICAgICAgc3RyZWFtOiBwZW5kaW5nU3ViLm1ldGhvZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVFdmVudERhdGEobXNnKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnaGFuZGxlRXZlbnREYXRhJywgbXNnKTtcblxuICAgICAgICB2YXIgc3ViTG9jYWxLZXkgPSBzdWJzY3JpcHRpb25JZFRvTG9jYWxLZXlNYXBbbXNnLnN1YnNjcmlwdGlvbl9pZF07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzdWJMb2NhbEtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBzdWJzY3JpcHRpb25zTGlzdFtzdWJMb2NhbEtleV07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzdWJzY3JpcHRpb24gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHJhY2tlZFNlcnZlcnNGb3VuZCA9IHN1YnNjcmlwdGlvbi50cmFja2VkU2VydmVycy5maWx0ZXIoZnVuY3Rpb24gKHNlcnZlcikge1xuICAgICAgICAgICAgcmV0dXJuIHNlcnZlci5zdWJzY3JpcHRpb25JZCA9PT0gbXNnLnN1YnNjcmlwdGlvbl9pZDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRyYWNrZWRTZXJ2ZXJzRm91bmQubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNQcml2YXRlRGF0YSA9IG1zZy5vb2IgJiYgbXNnLnNuYXBzaG90O1xuXG4gICAgICAgIHZhciBzZW5kaW5nU2VydmVySWQgPSB0cmFja2VkU2VydmVyc0ZvdW5kWzBdLnNlcnZlcklkO1xuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgYXJyaXZlZERhdGEgb2JqZWN0LCBuZXcgb2JqZWN0IGZvciBlYWNoIGhhbmRsZXIgY2FsbFxuICAgICAgICBmdW5jdGlvbiByZWNlaXZlZFN0cmVhbURhdGEoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IG1zZy5kYXRhLFxuICAgICAgICAgICAgICAgIHNlcnZlcjogcmVwb3NpdG9yeS5nZXRTZXJ2ZXJCeUlkKHNlbmRpbmdTZXJ2ZXJJZCkuZ2V0SW5mb0ZvclVzZXIoKSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0QXJndW1lbnRzOiBzdWJzY3JpcHRpb24uYXJndW1lbnRzIHx8IHt9LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG51bGwsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZTogaXNQcml2YXRlRGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvbkRhdGFIYW5kbGVycyA9IHN1YnNjcmlwdGlvbi5oYW5kbGVycy5vbkRhdGE7XG4gICAgICAgIHZhciBxdWV1ZWREYXRhID0gc3Vic2NyaXB0aW9uLnF1ZXVlZC5kYXRhO1xuXG4gICAgICAgIGlmIChvbkRhdGFIYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvbkRhdGFIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVjZWl2ZWRTdHJlYW1EYXRhKCkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXVlZERhdGEucHVzaChyZWNlaXZlZFN0cmVhbURhdGEoKSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVN1YnNjcmlwdGlvbkNhbmNlbGxlZChtc2cpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdoYW5kbGVTdWJzY3JpcHRpb25DYW5jZWxsZWQnLCBtc2cpO1xuXG4gICAgICAgIHZhciBzdWJMb2NhbEtleSA9IHN1YnNjcmlwdGlvbklkVG9Mb2NhbEtleU1hcFttc2cuc3Vic2NyaXB0aW9uX2lkXTtcblxuICAgICAgICBpZiAodHlwZW9mIHN1YkxvY2FsS2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvbnNMaXN0W3N1YkxvY2FsS2V5XTtcblxuICAgICAgICBpZiAodHlwZW9mIHN1YnNjcmlwdGlvbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbHRlciB0cmFja2VkIHNlcnZlcnNcbiAgICAgICAgdmFyIGV4cGVjdGVkTmV3TGVuZ3RoID0gc3Vic2NyaXB0aW9uLnRyYWNrZWRTZXJ2ZXJzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgc3Vic2NyaXB0aW9uLnRyYWNrZWRTZXJ2ZXJzID0gc3Vic2NyaXB0aW9uLnRyYWNrZWRTZXJ2ZXJzLmZpbHRlcihmdW5jdGlvbihzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGlmIChzZXJ2ZXIuc3Vic2NyaXB0aW9uSWQgPT09IG1zZy5zdWJzY3JpcHRpb25faWQpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24ucXVldWVkLmNsb3NlcnMucHVzaChzZXJ2ZXIuc2VydmVySWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGEgc2VydmVyIHdhcyBhY3R1YWxseSByZW1vdmVkXG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24udHJhY2tlZFNlcnZlcnMubGVuZ3RoICE9PSBleHBlY3RlZE5ld0xlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyB3YXMgdGhlIGxhc3QgcmVtYWluaW5nIHNlcnZlclxuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLnRyYWNrZWRTZXJ2ZXJzLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoc3Vic2NyaXB0aW9uLnRpbWVvdXRJZCk7XG4gICAgICAgICAgICBjYWxsT25DbG9zZWRIYW5kbGVycyhzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgZGVsZXRlIHN1YnNjcmlwdGlvbnNMaXN0W3N1YkxvY2FsS2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBzdWJzY3JpcHRpb25JZFRvTG9jYWxLZXlNYXBbbXNnLnN1YnNjcmlwdGlvbl9pZF1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxsT25DbG9zZWRIYW5kbGVycyhzdWJzY3JpcHRpb24sIHJlYXNvbikge1xuXG4gICAgICAgIHZhciBjbG9zZXJzQ291bnQgPSBzdWJzY3JpcHRpb24ucXVldWVkLmNsb3NlcnMubGVuZ3RoO1xuICAgICAgICB2YXIgY2xvc2luZ1NlcnZlcklkID0gKGNsb3NlcnNDb3VudCA+IDApID8gc3Vic2NyaXB0aW9uLnF1ZXVlZC5jbG9zZXJzW2Nsb3NlcnNDb3VudCAtIDFdIDogbnVsbDtcblxuICAgICAgICB2YXIgY2xvc2luZ1NlcnZlciA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgY2xvc2luZ1NlcnZlcklkID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgY2xvc2luZ1NlcnZlciA9IHJlcG9zaXRvcnkuZ2V0U2VydmVyQnlJZChjbG9zaW5nU2VydmVySWQpLmdldEluZm9Gb3JVc2VyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzdWJzY3JpcHRpb24uaGFuZGxlcnMub25DbG9zZWQuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiByZWFzb24gfHwgT05fQ0xPU0VfTVNHX1NFUlZFUl9JTklULFxuICAgICAgICAgICAgICAgIHJlcXVlc3RBcmd1bWVudHM6IHN1YnNjcmlwdGlvbi5hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgc2VydmVyOiBjbG9zaW5nU2VydmVyLFxuICAgICAgICAgICAgICAgIHN0cmVhbTogc3Vic2NyaXB0aW9uLm1ldGhvZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb3NlU3Vic2NyaXB0aW9uKHN1YkxvY2FsS2V5KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY2xvc2VTdWJzY3JpcHRpb24nLCBzdWJMb2NhbEtleSk7XG5cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvbnNMaXN0W3N1YkxvY2FsS2V5XTtcblxuICAgICAgICBpZiAodHlwZW9mIHN1YnNjcmlwdGlvbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlbGwgZWFjaCBzZXJ2ZXIgdGhhdCB3ZSdyZSB1bnN1YnNjcmliaW5nXG4gICAgICAgIHN1YnNjcmlwdGlvbi50cmFja2VkU2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VydmVyLnN1YnNjcmlwdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29ubmVjdGlvbi5zZW5kRmlyZUFuZEZvcmdldCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Vuc3Vic2NyaWJlJyxcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25faWQ6IHNlcnZlci5zdWJzY3JpcHRpb25JZCxcbiAgICAgICAgICAgICAgICByZWFzb25fdXJpOiAnJyxcbiAgICAgICAgICAgICAgICByZWFzb246IE9OX0NMT1NFX01TR19DTElFTlRfSU5JVFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlbGV0ZSBzdWJzY3JpcHRpb25JZFRvTG9jYWxLZXlNYXBbc2VydmVyLnN1YnNjcmlwdGlvbklkXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3Vic2NyaXB0aW9uLnRyYWNrZWRTZXJ2ZXJzID0gW107XG5cbiAgICAgICAgY2FsbE9uQ2xvc2VkSGFuZGxlcnMoc3Vic2NyaXB0aW9uLCBPTl9DTE9TRV9NU0dfQ0xJRU5UX0lOSVQpO1xuXG4gICAgICAgIGRlbGV0ZSBzdWJzY3JpcHRpb25zTGlzdFtzdWJMb2NhbEtleV07XG5cblxuICAgIH1cblxuICAgIHJldHVybiB7IHN1YnNjcmliZTogc3Vic2NyaWJlIH07XG59O1xuIiwidmFyIGNhbGxiYWNrUmVnaXN0cnkgPSByZXF1aXJlKCdjYWxsYmFjay1yZWdpc3RyeScpO1xudmFyIFN0cmVhbWluZyA9IHJlcXVpcmUoJy4vY2xpZW50LXN0cmVhbWluZycpO1xuXG4vKipcbiAqIEhhbmRsZXMgc2Vzc2lvbiBsaWZldGltZSBhbmQgZXZlbnRzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluc3RhbmNlLCBjb25uZWN0aW9uLCByZXBvc2l0b3J5LCBzZXNzaW9uLCBsb2dnZXIpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgY29ubmVjdGlvbi5vbigncGVlci1hZGRlZCcsIGhhbmRsZVBlZXJBZGRlZCk7XG4gICAgY29ubmVjdGlvbi5vbigncGVlci1yZW1vdmVkJywgaGFuZGxlUGVlclJlbW92ZWQpO1xuICAgIGNvbm5lY3Rpb24ub24oJ21ldGhvZHMtYWRkZWQnLCBoYW5kbGVNZXRob2RzQWRkZWRNZXNzYWdlKTtcbiAgICBjb25uZWN0aW9uLm9uKCdtZXRob2RzLXJlbW92ZWQnLCBoYW5kbGVNZXRob2RzUmVtb3ZlZE1lc3NhZ2UpO1xuXG4gICAgdmFyIGNhbGxiYWNrcyA9IGNhbGxiYWNrUmVnaXN0cnkoKTtcbiAgICB2YXIgc3RyZWFtaW5nID0gbmV3IFN0cmVhbWluZyhpbnN0YW5jZSwgY29ubmVjdGlvbiwgcmVwb3NpdG9yeSwgc2Vzc2lvbiwgbG9nZ2VyKTtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZVBlZXJBZGRlZChtc2cpIHtcbiAgICAgICAgdmFyIG5ld1BlZXJJZCA9IG1zZy5uZXdfcGVlcl9pZDtcbiAgICAgICAgdmFyIHJlbW90ZUlkID0gbXNnLmlkZW50aXR5O1xuXG4gICAgICAgIHZhciBzZXJ2ZXJJbmZvID0ge1xuICAgICAgICAgICAgbWFjaGluZTogcmVtb3RlSWQubWFjaGluZSxcbiAgICAgICAgICAgIHBpZDogcmVtb3RlSWQucHJvY2VzcyxcbiAgICAgICAgICAgIGluc3RhbmNlOiByZW1vdGVJZC5pbnN0YW5jZSxcbiAgICAgICAgICAgIGFwcGxpY2F0aW9uOiByZW1vdGVJZC5hcHBsaWNhdGlvbixcbiAgICAgICAgICAgIGVudmlyb25tZW50OiByZW1vdGVJZC5lbnZpcm9ubWVudCxcbiAgICAgICAgICAgIHJlZ2lvbjogcmVtb3RlSWQucmVnaW9uLFxuICAgICAgICAgICAgdXNlcjogcmVtb3RlSWQudXNlclxuICAgICAgICB9O1xuXG4gICAgICAgIHJlcG9zaXRvcnkuYWRkU2VydmVyKHNlcnZlckluZm8sIG5ld1BlZXJJZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlUGVlclJlbW92ZWQobXNnKSB7XG4gICAgICAgIHZhciByZW1vdmVkUGVlcklkID0gbXNnLnJlbW92ZWRfaWQ7XG4gICAgICAgIHZhciByZWFzb24gPSBtc2cucmVhc29uO1xuXG4gICAgICAgIHJlcG9zaXRvcnkucmVtb3ZlU2VydmVyQnlJZChyZW1vdmVkUGVlcklkLCByZWFzb24pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZU1ldGhvZHNBZGRlZE1lc3NhZ2UobXNnKSB7XG4gICAgICAgIHZhciBzZXJ2ZXJJZCA9IG1zZy5zZXJ2ZXJfaWQ7XG4gICAgICAgIHZhciBtZXRob2RzID0gbXNnLm1ldGhvZHM7XG5cbiAgICAgICAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2RJbmZvID0ge1xuICAgICAgICAgICAgICAgIGlkOiBtZXRob2QuaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogbWV0aG9kLm5hbWUsXG4gICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IG1ldGhvZC5kaXNwbGF5X25hbWUsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG1ldGhvZC5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBtZXRob2QudmVyc2lvbixcbiAgICAgICAgICAgICAgICBvYmplY3RUeXBlczogbWV0aG9kLm9iamVjdF90eXBlcyxcbiAgICAgICAgICAgICAgICBhY2NlcHRzOiBtZXRob2QuaW5wdXRfc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgIHJldHVybnM6IG1ldGhvZC5yZXN1bHRfc2lnbmF0dXJlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXBvc2l0b3J5LmFkZFNlcnZlck1ldGhvZChzZXJ2ZXJJZCwgbWV0aG9kSW5mbyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZU1ldGhvZHNSZW1vdmVkTWVzc2FnZShtc2cpIHtcbiAgICAgICAgdmFyIHNlcnZlcklkID0gbXNnLnNlcnZlcl9pZDtcbiAgICAgICAgdmFyIG1ldGhvZElkTGlzdCA9IG1zZy5tZXRob2RzO1xuXG4gICAgICAgIHZhciBzZXJ2ZXIgPSByZXBvc2l0b3J5LmdldFNlcnZlckJ5SWQoc2VydmVySWQpO1xuXG4gICAgICAgIHZhciBzZXJ2ZXJNZXRob2RLZXlzID0gT2JqZWN0LmtleXMoc2VydmVyLm1ldGhvZHMpO1xuXG4gICAgICAgIHNlcnZlck1ldGhvZEtleXMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kS2V5KSB7XG5cbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBzZXJ2ZXIubWV0aG9kc1ttZXRob2RLZXldO1xuXG4gICAgICAgICAgICBpZiAobWV0aG9kSWRMaXN0LmluZGV4T2YobWV0aG9kLmluZm8uaWQpID4gLTEpIHtcblxuICAgICAgICAgICAgICAgIHJlcG9zaXRvcnkucmVtb3ZlU2VydmVyTWV0aG9kKHNlcnZlcklkLCBtZXRob2RLZXkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52b2tlKGlkLCBtZXRob2QsIGFyZ3MsIHRhcmdldCkge1xuXG4gICAgICAgIHZhciBzZXJ2ZXJJZCA9IHRhcmdldC5pZDtcbiAgICAgICAgdmFyIG1ldGhvZElkID0gbWV0aG9kLmluZm8uaWQ7XG5cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kaW5nIGNhbGwgKCcgKyBpZCArICcpIGZvciBtZXRob2QgaWQgJyArIG1ldGhvZElkICsgJyB0byBzZXJ2ZXIgJyArIHNlcnZlcklkKTtcbiAgICAgICAgdmFyIG1zZyA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdjYWxsJyxcbiAgICAgICAgICAgIHNlcnZlcl9pZDogc2VydmVySWQsXG4gICAgICAgICAgICBtZXRob2RfaWQ6IG1ldGhvZElkLFxuICAgICAgICAgICAgYXJndW1lbnRzX2t2OiBhcmdzXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gd2UgdHJhbnNmZXIgdGhlIGludm9jYXRpb24gaWQgYXMgdGFnXG4gICAgICAgIGNvbm5lY3Rpb24uc2VuZChtc2csIHsgaW52b2NhdGlvbklkOiBpZCwgc2VydmVySWQ6IHNlcnZlcklkIH0pXG4gICAgICAgICAgICAudGhlbihoYW5kbGVSZXN1bHRNZXNzYWdlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkludm9jYXRpb25SZXN1bHQoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2tzLmFkZCgnb25SZXN1bHQnLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlUmVzdWx0TWVzc2FnZShtc2cpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdoYW5kbGUgcmVzdWx0IG1lc3NhZ2UgJyArIG1zZyk7XG5cbiAgICAgICAgdmFyIGludm9jYXRpb25JZCA9IG1zZy5fdGFnLmludm9jYXRpb25JZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG1zZy5yZXN1bHQ7XG4gICAgICAgIHZhciBzZXJ2ZXJJZCA9IG1zZy5fdGFnLnNlcnZlcklkO1xuICAgICAgICB2YXIgc2VydmVyID0gcmVwb3NpdG9yeS5nZXRTZXJ2ZXJCeUlkKHNlcnZlcklkKTtcblxuICAgICAgICBjYWxsYmFja3MuZXhlY3V0ZSgnb25SZXN1bHQnLCBpbnZvY2F0aW9uSWQsIHNlcnZlci5nZXRJbmZvRm9yVXNlcigpLCAwLCByZXN1bHQsICcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBpbnZva2U6IGludm9rZSxcbiAgICAgICAgb25JbnZvY2F0aW9uUmVzdWx0OiBvbkludm9jYXRpb25SZXN1bHQsXG4gICAgICAgIHN1YnNjcmliZTogc3RyZWFtaW5nLnN1YnNjcmliZVxuICAgIH07XG59O1xuIiwidmFyIHJhbmRvbSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy9yYW5kb20nKTtcbnZhciBQcm9taXNlID0gcmVxdWlyZSgnZXM2LXByb21pc2UnKS5Qcm9taXNlO1xudmFyIHByb21pc2lmeSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy9wcm9taXNpZnknKTtcblxuLyoqXG4qIFByb3ZpZGVzIHdheSBvZiBkZWxlZ2F0aW5nIGVycm9yIGFuZCBzdWNjZXNzIG1lc3NhZ2VzIGZyb20gZ3czIHRvIHRoZSBjbGllbnQgb3Igc2VydmVyXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29ubmVjdGlvbiwgbG9nZ2VyKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIHBlZXJJZCA9IGNvbm5lY3Rpb24uZ2V0UGVlcklkKCk7XG5cbiAgICBjb25uZWN0aW9uLm9uKCd3ZWxjb21lJywgaGFuZGxlV2VsY29tZU1lc3NhZ2UpOyAvLyBzdWJzY3JpYmUgZm9yIHdlbGNvbWUgc28gd2UgZ2V0IG91ciBwZWVyLWlkXG4gICAgY29ubmVjdGlvbi5vbignZXJyb3InLCBoYW5kbGVFcnJvck1lc3NhZ2UpO1xuICAgIGNvbm5lY3Rpb24ub24oJ3N1Y2Nlc3MnLCBoYW5kbGVTdWNjZXNzTWVzc2FnZSk7XG4gICAgY29ubmVjdGlvbi5vbigncmVzdWx0JywgaGFuZGxlU3VjY2Vzc01lc3NhZ2UpO1xuICAgIGNvbm5lY3Rpb24ub24oJ3N1YnNjcmliZWQnLCBoYW5kbGVTdWNjZXNzTWVzc2FnZSk7XG5cbiAgICB2YXIgcmVxdWVzdHNNYXAgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZUVycm9yTWVzc2FnZShtc2cpIHtcbiAgICAgICAgdmFyIHJlcXVlc3RJZCA9IG1zZy5yZXF1ZXN0X2lkO1xuICAgICAgICB2YXIgZW50cnkgPSByZXF1ZXN0c01hcFtyZXF1ZXN0SWRdO1xuICAgICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsb2dnZXIuZXJyb3IoJ2Vycm9yIG1lc3NhZ2UgJyArIEpTT04uc3RyaW5naWZ5KG1zZykpO1xuICAgICAgICBlbnRyeS5lcnJvcihtc2cpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVN1Y2Nlc3NNZXNzYWdlKG1zZykge1xuICAgICAgICB2YXIgcmVxdWVzdElkID0gbXNnLnJlcXVlc3RfaWQ7XG5cbiAgICAgICAgdmFyIGVudHJ5ID0gcmVxdWVzdHNNYXBbcmVxdWVzdElkXTtcbiAgICAgICAgaWYgKCFlbnRyeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVudHJ5LnN1Y2Nlc3MobXNnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVXZWxjb21lTWVzc2FnZShtc2cpIHtcbiAgICAgICAgaGFuZGxlU3VjY2Vzc01lc3NhZ2UobXNnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXROZXh0UmVxdWVzdElkKCkge1xuICAgICAgICByZXR1cm4gcmFuZG9tKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZCBhIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gbXNnIG1lc3NhZ2UgdG8gc2VuZFxuICAgICAqIEBwYXJhbSB0YWcgYSBjdXN0b20gb2JqZWN0ICh0YWcpIC0gaXQgd2lsbCBiZSB0cmFuc2ZlcnJlZCB0byBzdWNjZXNzL2Vycm9yIGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHN1Y2Nlc3NcbiAgICAgKiBAcGFyYW0gZXJyb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZW5kKG1zZywgdGFnLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAvLyBBbGxvd3MgZnVuY3Rpb24gY2FsbGVyIHRvIG92ZXJyaWRlIHJlcXVlc3RfaWRcbiAgICAgICAgdmFyIHJlcXVlc3RJZCA9IGdldE5leHRSZXF1ZXN0SWQoKTtcbiAgICAgICAgbXNnLnJlcXVlc3RfaWQgPSBtc2cucmVxdWVzdF9pZCA/IG1zZy5yZXF1ZXN0X2lkIDogcmVxdWVzdElkO1xuICAgICAgICBtc2cucGVlcl9pZCA9IHBlZXJJZDtcblxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHJlcXVlc3RzTWFwW3JlcXVlc3RJZF0gPSB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oc3VjY2Vzc01zZykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVxdWVzdHNNYXBbcmVxdWVzdElkXTtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc01zZy5fdGFnID0gdGFnO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHN1Y2Nlc3NNc2cpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKGVycm9yTXNnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0c01hcFtyZXF1ZXN0SWRdO1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1zZy5fdGFnID0gdGFnO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3JNc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25uZWN0aW9uLnNlbmQoJ3RpY2s0Mi1hZ20nLCBtc2cpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHByb21pc2UsIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZW5kRmlyZUFuZEZvcmdldChtc2cpIHtcbiAgICAgICAgLy8gQWxsb3dzIGZ1bmN0aW9uIGNhbGxlciB0byBvdmVycmlkZSByZXF1ZXN0X2lkXG4gICAgICAgIG1zZy5yZXF1ZXN0X2lkID0gbXNnLnJlcXVlc3RfaWQgPyBtc2cucmVxdWVzdF9pZCA6IGdldE5leHRSZXF1ZXN0SWQoKTtcbiAgICAgICAgbXNnLnBlZXJfaWQgPSBwZWVySWQ7XG5cbiAgICAgICAgY29ubmVjdGlvbi5zZW5kKCd0aWNrNDItYWdtJywgbXNnKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzZW5kOiBzZW5kLFxuICAgICAgICBzZW5kRmlyZUFuZEZvcmdldDogc2VuZEZpcmVBbmRGb3JnZXQsXG4gICAgICAgIG9uOiBjb25uZWN0aW9uLm9uLFxuICAgICAgICBwZWVySWQgOiBwZWVySWRcbiAgICB9XG59O1xuIiwidmFyIHNlc3Npb25GYWN0b3J5ID0gcmVxdWlyZSgnLi9zZXNzaW9uJyk7XG52YXIgc2VydmVyRmFjdG9yeSA9IHJlcXVpcmUoJy4vc2VydmVyJyk7XG52YXIgY2xpZW50RmFjdG9yeSA9IHJlcXVpcmUoJy4vY2xpZW50Jyk7XG52YXIgY29ubmVjdGlvbldyYXBwZXJGYWN0b3J5ID0gcmVxdWlyZSgnLi9jb253cmFwJyk7XG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ2VzNi1wcm9taXNlJykuUHJvbWlzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGNvbm5lY3Rpb24sIHJlcG9zaXRvcnksIHZhdWx0LCBjb25maWd1cmF0aW9uKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGxvZ2dlciA9IGNvbmZpZ3VyYXRpb24ubG9nZ2VyLnN1YkxvZ2dlcignZ3cyLXByb3RvY29sJyk7XG5cbiAgICBpZiAoIWNvbm5lY3Rpb24uZ2V0UGVlcklkKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgbG9nZ2VkIGluISBDYW4gbm90IGNvbnRpbnVlJyk7XG4gICAgfVxuXG4gICAgdmFyIGNvbm5lY3Rpb25XcmFwcGVyID0gY29ubmVjdGlvbldyYXBwZXJGYWN0b3J5KGNvbm5lY3Rpb24sIGxvZ2dlcik7XG4gICAgdmFyIHNlc3Npb24gPSBzZXNzaW9uRmFjdG9yeShpbnN0YW5jZSwgY29ubmVjdGlvbldyYXBwZXIsIHJlcG9zaXRvcnksIGxvZ2dlci5zdWJMb2dnZXIoJ3Nlc3Npb24nKSk7XG4gICAgdmFyIHNlcnZlciA9IHNlcnZlckZhY3RvcnkoaW5zdGFuY2UsIGNvbm5lY3Rpb25XcmFwcGVyLCByZXBvc2l0b3J5LCB2YXVsdCwgc2Vzc2lvbiwgbG9nZ2VyLnN1YkxvZ2dlcignc2VydmVyJykpO1xuICAgIHZhciBjbGllbnQgPSBjbGllbnRGYWN0b3J5KGluc3RhbmNlLCBjb25uZWN0aW9uV3JhcHBlciwgcmVwb3NpdG9yeSwgc2Vzc2lvbiwgbG9nZ2VyLnN1YkxvZ2dlcignY2xpZW50JykpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblxuICAgICAgICBzZXNzaW9uLm9uQ29ubmVjdGVkKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgIGludm9rZTogY2xpZW50Lmludm9rZSxcbiAgICAgICAgICAgICAgICBvbkludm9jYXRpb25SZXN1bHQ6IGNsaWVudC5vbkludm9jYXRpb25SZXN1bHQsXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXI6IHNlcnZlci5yZWdpc3RlcixcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGNoYW5nZSBwYXJhbXNcbiAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyOiBzZXJ2ZXIudW5yZWdpc3RlcixcbiAgICAgICAgICAgICAgICBvbkludm9rZWQ6IHNlcnZlci5vbkludm9rZWQsXG4gICAgICAgICAgICAgICAgbWV0aG9kSW52b2NhdGlvblJlc3VsdDogc2VydmVyLm1ldGhvZEludm9jYXRpb25SZXN1bHQsXG5cbiAgICAgICAgICAgICAgICAvLyBzdHJlYW0tcmVsYXRlZFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZTogY2xpZW50LnN1YnNjcmliZSxcbiAgICAgICAgICAgICAgICBjcmVhdGVTdHJlYW06IHNlcnZlci5jcmVhdGVTdHJlYW0sXG4gICAgICAgICAgICAgICAgZ2V0QnJhbmNoTGlzdDogc2VydmVyLmdldEJyYW5jaExpc3QsXG4gICAgICAgICAgICAgICAgZ2V0U3Vic2NyaXB0aW9uTGlzdDogc2VydmVyLmdldFN1YnNjcmlwdGlvbkxpc3QsXG4gICAgICAgICAgICAgICAgY2xvc2VBbGxTdWJzY3JpcHRpb25zOiBzZXJ2ZXIuY2xvc2VBbGxTdWJzY3JpcHRpb25zLFxuICAgICAgICAgICAgICAgIGNsb3NlU2luZ2xlU3Vic2NyaXB0aW9uOiBzZXJ2ZXIuY2xvc2VTaW5nbGVTdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgcHVzaERhdGE6IHNlcnZlci5wdXNoRGF0YSxcbiAgICAgICAgICAgICAgICBwdXNoRGF0YVRvU2luZ2xlOiBzZXJ2ZXIucHVzaERhdGFUb1NpbmdsZSxcbiAgICAgICAgICAgICAgICBvblN1YlJlcXVlc3Q6IHNlcnZlci5vblN1YlJlcXVlc3QsXG4gICAgICAgICAgICAgICAgYWNjZXB0UmVxdWVzdE9uQnJhbmNoOiBzZXJ2ZXIuYWNjZXB0UmVxdWVzdE9uQnJhbmNoLFxuICAgICAgICAgICAgICAgIHJlamVjdFJlcXVlc3Q6IHNlcnZlci5yZWplY3RSZXF1ZXN0LFxuICAgICAgICAgICAgICAgIG9uU3ViQWRkZWQ6IHNlcnZlci5vblN1YkFkZGVkLFxuICAgICAgICAgICAgICAgIG9uU3ViUmVtb3ZlZDogc2VydmVyLm9uU3ViUmVtb3ZlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZXNzaW9uLnN0YXJ0KCk7XG4gICAgfSk7XG59O1xuIiwidmFyIGNhbGxiYWNrUmVnaXN0cnkgPSByZXF1aXJlKCdjYWxsYmFjay1yZWdpc3RyeScpO1xuXG4vKipcbiAqIEhhbmRsZXMgcmVnaXN0ZXJpbmcgbWV0aG9kcyBhbmQgc2VuZGluZyBkYXRhIHRvIGNsaWVudHNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGNvbm5lY3Rpb24sIHJlcG9zaXRvcnksIHZhdWx0LCBzZXNzaW9uLCBsb2dnZXIpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgY29ubmVjdGlvbi5vbignYWRkLWludGVyZXN0JywgaGFuZGxlQWRkSW50ZXJlc3QpO1xuICAgIGNvbm5lY3Rpb24ub24oJ3JlbW92ZS1pbnRlcmVzdCcsIGhhbmRsZVJlbW92ZUludGVyZXN0KTtcblxuICAgIHZhciBTVUJTQ1JJUFRJT05fUkVRVUVTVCA9ICdvblN1YnNjcmlwdGlvblJlcXVlc3QnO1xuICAgIHZhciBTVUJTQ1JJUFRJT05fQURERUQgPSAnb25TdWJzY3JpcHRpb25BZGRlZCc7XG4gICAgdmFyIFNVQlNDUklQVElPTl9SRU1PVkVEID0gJ29uU3Vic2NyaXB0aW9uUmVtb3ZlZCc7XG4gICAgdmFyIEVSUl9VUklfU1VCU0NSSVBUSU9OX0ZBSUxFRCA9ICdjb20udGljazQyLmFnbS5lcnJvcnMuc3Vic2NyaXB0aW9uLmZhaWx1cmUnO1xuICAgIHZhciBjYWxsYmFja3MgPSBjYWxsYmFja1JlZ2lzdHJ5KCk7XG4gICAgdmFyIG5leHRTdHJlYW1JZCA9IDA7XG5cbiAgICAvLyBUT0RPIHRoZXJlIGFyZSBtYW55IG9mIHRoZXNlIGluY3JlbWVudGluZyBpbnRlZ2VyIGlkJ3MgLT4gbWFrZSBhIGhlbHBlciBtb2R1bGVcbiAgICBmdW5jdGlvbiBnZXROZXh0U3RyZWFtSWQoKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbmV4dFN0cmVhbUlkO1xuICAgICAgICBuZXh0U3RyZWFtSWQgKz0gMTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIGEgc3Vic2NyaXB0aW9uIHJlcXVlc3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYW5kbGVBZGRJbnRlcmVzdChtc2cpIHtcblxuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlcnZlcl9BZGRJbnRlcmVzdCAnLCBtc2cpO1xuXG4gICAgICAgIHZhciBjYWxsZXIgPSByZXBvc2l0b3J5LmdldFNlcnZlckJ5SWQobXNnLmNhbGxlcl9pZCk7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9ICh0eXBlb2YgY2FsbGVyLmdldEluZm9Gb3JVc2VyID09PSAnZnVuY3Rpb24nKSA/IGNhbGxlci5nZXRJbmZvRm9yVXNlcigpIDogbnVsbDtcblxuICAgICAgICAvLyBjYWxsIHN1YnNjcmlwdGlvblJlcXVlc3RIYW5kbGVyXG4gICAgICAgIHZhciByZXF1ZXN0Q29udGV4dCA9IHtcbiAgICAgICAgICAgIG1zZzogbXNnLFxuICAgICAgICAgICAgYXJndW1lbnRzOiBtc2cuYXJndW1lbnRzX2t2IHx8IHt9LFxuICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHN0cmVhbWluZ01ldGhvZCA9IHZhdWx0LmdldEJ5SWQobXNnLm1ldGhvZF9pZCk7XG5cbiAgICAgICAgaWYgKHN0cmVhbWluZ01ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZW5kU3Vic2NyaXB0aW9uRmFpbGVkKFxuICAgICAgICAgICAgICAgICdObyBtZXRob2Qgd2l0aCBpZCAnICsgbXNnLm1ldGhvZF9pZCArICcgb24gdGhpcyBzZXJ2ZXIuJyxcbiAgICAgICAgICAgICAgICBtc2cuc3Vic2NyaXB0aW9uX2lkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmVhbWluZ01ldGhvZC5zdWJzY3JpcHRpb25zTWFwICYmIHN0cmVhbWluZ01ldGhvZC5zdWJzY3JpcHRpb25zTWFwW21zZy5zdWJzY3JpcHRpb25faWRdKSB7XG4gICAgICAgICAgICBzZW5kU3Vic2NyaXB0aW9uRmFpbGVkKFxuICAgICAgICAgICAgICAgICdBIHN1YnNjcmlwdGlvbiB3aXRoIGlkICcgKyBtc2cuc3Vic2NyaXB0aW9uX2lkICsgJyBhbHJlYWR5IGV4aXN0cy4nLFxuICAgICAgICAgICAgICAgIG1zZy5zdWJzY3JpcHRpb25faWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFja3MuZXhlY3V0ZShTVUJTQ1JJUFRJT05fUkVRVUVTVCwgcmVxdWVzdENvbnRleHQsIHN0cmVhbWluZ01ldGhvZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VuZFN1YnNjcmlwdGlvbkZhaWxlZChyZWFzb24sIHN1YnNjcmlwdGlvbklkKSB7XG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSB7XG4gICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgcmVhc29uX3VyaTogRVJSX1VSSV9TVUJTQ1JJUFRJT05fRkFJTEVELFxuICAgICAgICAgICAgcmVhc29uOiByZWFzb24sXG4gICAgICAgICAgICByZXF1ZXN0X2lkOiBzdWJzY3JpcHRpb25JZCAvLyB0aGlzIG92ZXJyaWRlcyBjb25uZWN0aW9uIHdyYXBwZXJcbiAgICAgICAgfTtcblxuICAgICAgICBjb25uZWN0aW9uLnNlbmRGaXJlQW5kRm9yZ2V0KGVycm9yTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWNjZXB0UmVxdWVzdE9uQnJhbmNoIChyZXF1ZXN0Q29udGV4dCwgc3RyZWFtaW5nTWV0aG9kLCBicmFuY2gpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3JlcXVlc3RDb250ZXh0JywgcmVxdWVzdENvbnRleHQpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgYnJhbmNoICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYnJhbmNoID0gJyc7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZW1wdHkgYnJhbmNoJywgYnJhbmNoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzdHJlYW1pbmdNZXRob2Quc3Vic2NyaXB0aW9uc01hcCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBzdHJlYW1pbmcgbWV0aG9kIGlzIG1pc3NpbmcgaXRzIHN1YnNjcmlwdGlvbnMuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3RyZWFtaW5nTWV0aG9kLmJyYW5jaEtleVRvU3RyZWFtSWRNYXApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgc3RyZWFtaW5nIG1ldGhvZCBpcyBtaXNzaW5nIGl0cyBicmFuY2hlcy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHJlYW1JZCA9IGdldFN0cmVhbUlkKHN0cmVhbWluZ01ldGhvZCwgYnJhbmNoKTtcblxuICAgICAgICAvLyBBZGQgYSBuZXcgc3Vic2NyaXB0aW9uIHRvIHRoZSBtZXRob2RcbiAgICAgICAgdmFyIGtleSA9IHJlcXVlc3RDb250ZXh0Lm1zZy5zdWJzY3JpcHRpb25faWQ7XG5cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgIGlkOiBrZXksXG4gICAgICAgICAgICBhcmd1bWVudHM6IHJlcXVlc3RDb250ZXh0LmFyZ3VtZW50cyxcbiAgICAgICAgICAgIGluc3RhbmNlOiByZXF1ZXN0Q29udGV4dC5pbnN0YW5jZSxcbiAgICAgICAgICAgIGJyYW5jaEtleTogYnJhbmNoLFxuICAgICAgICAgICAgc3RyZWFtSWQ6IHN0cmVhbUlkLFxuICAgICAgICAgICAgc3Vic2NyaWJlTXNnOiByZXF1ZXN0Q29udGV4dC5tc2dcbiAgICAgICAgfTtcblxuICAgICAgICBzdHJlYW1pbmdNZXRob2Quc3Vic2NyaXB0aW9uc01hcFtrZXldID0gc3Vic2NyaXB0aW9uO1xuXG4gICAgICAgIC8vIEluZm9ybSB0aGUgZ3dcbiAgICAgICAgY29ubmVjdGlvbi5zZW5kRmlyZUFuZEZvcmdldCh7XG4gICAgICAgICAgICB0eXBlOiAnYWNjZXB0ZWQnLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uX2lkOiBrZXksXG4gICAgICAgICAgICBzdHJlYW1faWQ6IHN0cmVhbUlkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFBhc3Mgc3RhdGUgYWJvdmUtcHJvdG9jb2wgZm9yIHVzZXIgb2JqZWN0c1xuICAgICAgICBjYWxsYmFja3MuZXhlY3V0ZShTVUJTQ1JJUFRJT05fQURERUQsIHN1YnNjcmlwdGlvbiwgc3RyZWFtaW5nTWV0aG9kKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFN0cmVhbUlkKHN0cmVhbWluZ01ldGhvZCwgYnJhbmNoS2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgYnJhbmNoS2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYnJhbmNoS2V5ID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmVlZGxlQnJhbmNoID0gc3RyZWFtaW5nTWV0aG9kLmJyYW5jaEtleVRvU3RyZWFtSWRNYXAuZmlsdGVyKGZ1bmN0aW9uIChicmFuY2gpIHtcbiAgICAgICAgICAgIHJldHVybiBicmFuY2gua2V5ID09PSBicmFuY2hLZXk7XG4gICAgICAgIH0pWzBdO1xuXG4gICAgICAgIHZhciBzdHJlYW1JZCA9IChuZWVkbGVCcmFuY2ggPyBuZWVkbGVCcmFuY2guc3RyZWFtSWQgOiB1bmRlZmluZWQpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgICAgc3RyZWFtSWQgIT09ICdzdHJpbmcnIHx8IHN0cmVhbUlkID09PSAnJykge1xuICAgICAgICAgICAgc3RyZWFtSWQgPSBnZXROZXh0U3RyZWFtSWQoKTtcbiAgICAgICAgICAgIHN0cmVhbWluZ01ldGhvZC5icmFuY2hLZXlUb1N0cmVhbUlkTWFwLnB1c2goeyBrZXk6IGJyYW5jaEtleSwgc3RyZWFtSWQ6IHN0cmVhbUlkIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cmVhbUlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlamVjdFJlcXVlc3QocmVxdWVzdENvbnRleHQsIHN0cmVhbWluZ01ldGhvZCwgcmVhc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVhc29uICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVhc29uID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBzZW5kU3Vic2NyaXB0aW9uRmFpbGVkKFxuICAgICAgICAgICAgJ1N1YnNjcmlwdGlvbiByZWplY3RlZCBieSB1c2VyLiAnICsgcmVhc29uLFxuICAgICAgICAgICAgcmVxdWVzdENvbnRleHQubXNnLnN1YnNjcmlwdGlvbl9pZFxuICAgICAgICApXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25TdWJzY3JpcHRpb25MaWZldGltZUV2ZW50KGV2ZW50TmFtZSwgaGFuZGxlckZ1bmMpIHtcbiAgICAgICAgY2FsbGJhY2tzLmFkZChldmVudE5hbWUsIGhhbmRsZXJGdW5jKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1c2hUb0JyYW5jaChzdHJlYW1pbmdNZXRob2QsIGRhdGEsIGJyYW5jaGVzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyZWFtaW5nTWV0aG9kICE9PSAnb2JqZWN0JyB8fCAhQXJyYXkuaXNBcnJheShzdHJlYW1pbmdNZXRob2QuYnJhbmNoS2V5VG9TdHJlYW1JZE1hcCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE8gdmFsaWRhdGUgZGF0YSBpcyBhIHBsYWluIG9iamVjdFxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzLiBEYXRhIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBicmFuY2hlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJyYW5jaGVzID0gW2JyYW5jaGVzXTsgLy8gdXNlciB3YW50cyB0byBwdXNoIHRvIHNpbmdsZSBicmFuY2hcbiAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShicmFuY2hlcykgfHwgYnJhbmNoZXMubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgIGJyYW5jaGVzID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCB0aGUgU3RyZWFtSWQncyBmcm9tIHRoZSBtZXRob2QncyBicmFuY2ggbWFwXG4gICAgICAgIHZhciBzdHJlYW1JZExpc3QgPSBzdHJlYW1pbmdNZXRob2QuYnJhbmNoS2V5VG9TdHJlYW1JZE1hcFxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoYnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICBicmFuY2hlcyA9PT0gbnVsbCB8fCAoQm9vbGVhbihicikgJiYgdHlwZW9mIGJyLmtleSA9PT0gJ3N0cmluZycgJiYgYnJhbmNoZXMuaW5kZXhPZihici5rZXkpID49IDApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbiAoYnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnIuc3RyZWFtSWQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBzdHJlYW1JZExpc3QuZm9yRWFjaChmdW5jdGlvbiAoc3RyZWFtSWQpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uc2VuZEZpcmVBbmRGb3JnZXQoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdwdWJsaXNoJyxcbiAgICAgICAgICAgICAgICBzdHJlYW1faWQ6IHN0cmVhbUlkLFxuICAgICAgICAgICAgICAgIC8vIHNlcXVlbmNlOiBudWxsLCAgLy8gdGhlIHN0cmVhbWluZ01ldGhvZCBtaWdodCBiZSB1c2VkIGZvciB0aGlzXG4gICAgICAgICAgICAgICAgLy8gc25hcHNob3Q6IGZhbHNlLCAvLyAuLi5hbmQgdGhpc1xuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1c2hEYXRhVG9TaW5nbGUoc3RyZWFtaW5nTWV0aG9kLCBzdWJzY3JpcHRpb24sIGRhdGEpIHtcbiAgICAgICAgLy8gVE9ETyB2YWxpZGF0ZSBkYXRhIGlzIGEgcGxhaW4gb2JqZWN0XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMuIERhdGEgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25uZWN0aW9uLnNlbmRGaXJlQW5kRm9yZ2V0KHtcbiAgICAgICAgICAgIHR5cGU6ICdwb3N0JyxcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbl9pZDogc3Vic2NyaXB0aW9uLmlkLFxuICAgICAgICAgICAgLy8gc2VxdWVuY2U6IG51bGwsICAvLyB0aGUgc3RyZWFtaW5nTWV0aG9kIG1pZ2h0IGJlIHVzZWQgZm9yIHRoaXNcbiAgICAgICAgICAgIC8vIHNuYXBzaG90OiBmYWxzZSwgLy8gLi4uYW5kIHRoaXNcbiAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9zZVNpbmdsZVN1YnNjcmlwdGlvbihzdHJlYW1pbmdNZXRob2QsIHN1YnNjcmlwdGlvbikge1xuXG4gICAgICAgIGRlbGV0ZSBzdHJlYW1pbmdNZXRob2Quc3Vic2NyaXB0aW9uc01hcFtzdWJzY3JpcHRpb24uaWRdO1xuXG4gICAgICAgIGNvbm5lY3Rpb24uc2VuZEZpcmVBbmRGb3JnZXQoe1xuICAgICAgICAgICAgdHlwZTogJ2Ryb3Atc3Vic2NyaXB0aW9uJyxcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbl9pZDogc3Vic2NyaXB0aW9uLmlkLFxuICAgICAgICAgICAgcmVhc29uOiAnU2VydmVyIGRyb3BwaW5nIGEgc2luZ2xlIHN1YnNjcmlwdGlvbidcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHN1YnNjcmliZXIgPSBzdWJzY3JpcHRpb24uaW5zdGFuY2U7XG5cbiAgICAgICAgY2FsbGJhY2tzLmV4ZWN1dGUoU1VCU0NSSVBUSU9OX1JFTU9WRUQsIHN1YnNjcmliZXIsIHN0cmVhbWluZ01ldGhvZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvc2VNdWx0aXBsZVN1YnNjcmlwdGlvbnMoc3RyZWFtaW5nTWV0aG9kLCBicmFuY2hLZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHJlYW1pbmdNZXRob2QgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBzdHJlYW1pbmdNZXRob2Quc3Vic2NyaXB0aW9uc01hcCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25zVG9DbG9zZSA9IE9iamVjdC5rZXlzKHN0cmVhbWluZ01ldGhvZC5zdWJzY3JpcHRpb25zTWFwKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyZWFtaW5nTWV0aG9kLnN1YnNjcmlwdGlvbnNNYXBba2V5XTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0eXBlb2YgYnJhbmNoS2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uc1RvQ2xvc2UgPSBzdWJzY3JpcHRpb25zVG9DbG9zZS5maWx0ZXIoZnVuY3Rpb24oc3ViKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Yi5icmFuY2hLZXkgPT09IGJyYW5jaEtleTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc3Vic2NyaXB0aW9uc1RvQ2xvc2UuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBkZWxldGUgc3RyZWFtaW5nTWV0aG9kLnN1YnNjcmlwdGlvbnNNYXBbc3Vic2NyaXB0aW9uLmlkXTtcblxuICAgICAgICAgICAgY29ubmVjdGlvbi5zZW5kRmlyZUFuZEZvcmdldCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Ryb3Atc3Vic2NyaXB0aW9uJyxcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25faWQ6IHN1YnNjcmlwdGlvbi5pZCxcbiAgICAgICAgICAgICAgICByZWFzb246ICdTZXJ2ZXIgZHJvcHBpbmcgYWxsIHN1YnNjcmlwdGlvbnMgb24gc3RyZWFtX2lkOiAnICsgc3Vic2NyaXB0aW9uLnN0cmVhbUlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3Vic2NyaXB0aW9uTGlzdChzdHJlYW1pbmdNZXRob2QsIGJyYW5jaEtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHN0cmVhbWluZ01ldGhvZCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gW107XG5cbiAgICAgICAgdmFyIGFsbFN1YnNjcmlwdGlvbnMgPSBPYmplY3Qua2V5cyhzdHJlYW1pbmdNZXRob2Quc3Vic2NyaXB0aW9uc01hcCkubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmVhbWluZ01ldGhvZC5zdWJzY3JpcHRpb25zTWFwW2tleV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0eXBlb2YgYnJhbmNoS2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9ucyA9IGFsbFN1YnNjcmlwdGlvbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zID0gYWxsU3Vic2NyaXB0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKHN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWIuYnJhbmNoS2V5ID09PSBicmFuY2hLZXk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb25zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJyYW5jaExpc3Qoc3RyZWFtaW5nTWV0aG9kKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyZWFtaW5nTWV0aG9kICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFsbFN1YnNjcmlwdGlvbnMgPSBPYmplY3Qua2V5cyhzdHJlYW1pbmdNZXRob2Quc3Vic2NyaXB0aW9uc01hcCkubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmVhbWluZ01ldGhvZC5zdWJzY3JpcHRpb25zTWFwW2tleV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBrZXlzV2l0aER1cGxpY2F0ZXMgPSBhbGxTdWJzY3JpcHRpb25zLm1hcChmdW5jdGlvbiAoc3ViKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3ViID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygc3ViLmJyYW5jaEtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzdWIuYnJhbmNoS2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHNlZW4gPSBbXTtcblxuICAgICAgICB2YXIgYnJhbmNoQXJyYXkgPSBrZXlzV2l0aER1cGxpY2F0ZXMuZmlsdGVyKGZ1bmN0aW9uIChiS2V5KSB7XG4gICAgICAgICAgICBpZiAoYktleSA9PT0gbnVsbCB8fCBzZWVuLmluZGV4T2YoYktleSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW4ucHVzaChiS2V5KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYnJhbmNoQXJyYXk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlUmVtb3ZlSW50ZXJlc3QobXNnKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnaGFuZGxlUmVtb3ZlSW50ZXJlc3QnLCBtc2cpO1xuXG4gICAgICAgIHZhciBzdHJlYW1pbmdNZXRob2QgPSB2YXVsdC5nZXRCeUlkKG1zZy5tZXRob2RfaWQpXG5cbiAgICAgICAgaWYgKHR5cGVvZiBtc2cuc3Vic2NyaXB0aW9uX2lkICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgdHlwZW9mIHN0cmVhbWluZ01ldGhvZCAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBzdHJlYW1pbmdNZXRob2Quc3Vic2NyaXB0aW9uc01hcFttc2cuc3Vic2NyaXB0aW9uX2lkXSAhPT0gJ29iamVjdCdcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3Vic2NyaWJlciA9IHN0cmVhbWluZ01ldGhvZC5zdWJzY3JpcHRpb25zTWFwW21zZy5zdWJzY3JpcHRpb25faWRdLmluc3RhbmNlO1xuXG4gICAgICAgIGRlbGV0ZSBzdHJlYW1pbmdNZXRob2Quc3Vic2NyaXB0aW9uc01hcFttc2cuc3Vic2NyaXB0aW9uX2lkXTtcblxuICAgICAgICBjYWxsYmFja3MuZXhlY3V0ZShTVUJTQ1JJUFRJT05fUkVNT1ZFRCwgc3Vic2NyaWJlciwgc3RyZWFtaW5nTWV0aG9kKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBwdXNoRGF0YTogcHVzaFRvQnJhbmNoLFxuICAgICAgICBwdXNoRGF0YVRvU2luZ2xlOiBwdXNoRGF0YVRvU2luZ2xlLFxuICAgICAgICBvblN1YlJlcXVlc3Q6IG9uU3Vic2NyaXB0aW9uTGlmZXRpbWVFdmVudC5iaW5kKG51bGwsIFNVQlNDUklQVElPTl9SRVFVRVNUKSxcbiAgICAgICAgb25TdWJBZGRlZDogb25TdWJzY3JpcHRpb25MaWZldGltZUV2ZW50LmJpbmQobnVsbCwgU1VCU0NSSVBUSU9OX0FEREVEKSxcbiAgICAgICAgb25TdWJSZW1vdmVkOiBvblN1YnNjcmlwdGlvbkxpZmV0aW1lRXZlbnQuYmluZChudWxsLCBTVUJTQ1JJUFRJT05fUkVNT1ZFRCksXG4gICAgICAgIGFjY2VwdFJlcXVlc3RPbkJyYW5jaDogYWNjZXB0UmVxdWVzdE9uQnJhbmNoLFxuICAgICAgICByZWplY3RSZXF1ZXN0OiByZWplY3RSZXF1ZXN0LFxuICAgICAgICBnZXRTdWJzY3JpcHRpb25MaXN0OiBnZXRTdWJzY3JpcHRpb25MaXN0LFxuICAgICAgICBnZXRCcmFuY2hMaXN0OiBnZXRCcmFuY2hMaXN0LFxuICAgICAgICBjbG9zZVNpbmdsZVN1YnNjcmlwdGlvbjogY2xvc2VTaW5nbGVTdWJzY3JpcHRpb24sXG4gICAgICAgIGNsb3NlTXVsdGlwbGVTdWJzY3JpcHRpb25zOiBjbG9zZU11bHRpcGxlU3Vic2NyaXB0aW9uc1xuICAgIH07XG59O1xuXG4iLCJ2YXIgY2FsbGJhY2tSZWdpc3RyeSA9IHJlcXVpcmUoJ2NhbGxiYWNrLXJlZ2lzdHJ5Jyk7XG52YXIgU3RyZWFtaW5nID0gcmVxdWlyZSgnLi9zZXJ2ZXItc3RyZWFtaW5nJyk7XG5cbi8qKlxuICogSGFuZGxlcyByZWdpc3RlcmluZyBtZXRob2RzIGFuZCBzZW5kaW5nIGRhdGEgdG8gY2xpZW50c1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgY29ubmVjdGlvbiwgcmVwb3NpdG9yeSwgdmF1bHQsIHNlc3Npb24sIGxvZ2dlcikge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgY2FsbGJhY2tzID0gY2FsbGJhY2tSZWdpc3RyeSgpO1xuICAgIHZhciBzdHJlYW1pbmcgPSBuZXcgU3RyZWFtaW5nKGluc3RhbmNlLCBjb25uZWN0aW9uLCByZXBvc2l0b3J5LCB2YXVsdCwgc2Vzc2lvbiwgbG9nZ2VyKTtcblxuICAgIGNvbm5lY3Rpb24ub24oJ2ludm9rZScsIGhhbmRsZUludm9rZU1lc3NhZ2UpO1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlUmVnaXN0ZXJlZE1lc3NhZ2UobXNnKSB7XG4gICAgICAgIHZhciBtZXRob2RJZCA9IG1zZy5fdGFnLm1ldGhvZElkO1xuICAgICAgICB2YXIgcmVwb01ldGhvZCA9IHZhdWx0LmdldEJ5SWQobWV0aG9kSWQpO1xuXG4gICAgICAgIGlmIChyZXBvTWV0aG9kICYmIHJlcG9NZXRob2QucmVnaXN0cmF0aW9uQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlZ2lzdGVyZWQgbWV0aG9kICcgKyByZXBvTWV0aG9kLmRlZmluaXRpb24ubmFtZSArICcgd2l0aCBpZCAnICsgbWV0aG9kSWQpO1xuICAgICAgICAgICAgcmVwb01ldGhvZC5yZWdpc3RyYXRpb25DYWxsYmFja3Muc3VjY2VzcygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlRXJyb3JSZWdpc3Rlcihtc2cpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4obXNnKTtcblxuICAgICAgICB2YXIgbWV0aG9kSWQgPSBtc2cuX3RhZy5tZXRob2RJZDtcbiAgICAgICAgdmFyIHJlcG9NZXRob2QgPSB2YXVsdC5nZXRCeUlkKG1ldGhvZElkKTtcblxuICAgICAgICBpZiAocmVwb01ldGhvZCAmJiByZXBvTWV0aG9kLnJlZ2lzdHJhdGlvbkNhbGxiYWNrcykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdmYWlsZWQgdG8gcmVnaXN0ZXIgbWV0aG9kICcgKyByZXBvTWV0aG9kLmRlZmluaXRpb24ubmFtZSArICcgd2l0aCBpZCAnICsgbWV0aG9kSWQpO1xuICAgICAgICAgICAgcmVwb01ldGhvZC5yZWdpc3RyYXRpb25DYWxsYmFja3MuZmFpbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlSW52b2tlTWVzc2FnZShtc2cpIHtcbiAgICAgICAgdmFyIGludm9jYXRpb25JZCA9IG1zZy5pbnZvY2F0aW9uX2lkO1xuICAgICAgICB2YXIgcGVlcklkID0gbXNnLnBlZXJfaWQ7XG4gICAgICAgIHZhciBtZXRob2RJZCA9IG1zZy5tZXRob2RfaWQ7XG4gICAgICAgIHZhciBhcmdzID0gbXNnLmFyZ3VtZW50c19rdjtcblxuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVkIGludm9jYXRpb24gZm9yIG1ldGhvZCBpZCBcIicgKyBtZXRob2RJZCArICdcIicpO1xuXG4gICAgICAgIHZhciBtZXRob2RMaXN0ID0gdmF1bHQuZ2V0TGlzdCgpO1xuXG4gICAgICAgIHZhciBtZXRob2QgPSBtZXRob2RMaXN0LmZpbHRlcihmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgcmV0dXJuIG0uX3JlcG9JZCA9PT0gbWV0aG9kSWQ7XG4gICAgICAgIH0pWzBdO1xuXG4gICAgICAgIC8vIFN0b3AgaWYgdGhlIG1lc3NhZ2UgaXNuJ3QgZm9yIHVzXG4gICAgICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNsaWVudCA9IHJlcG9zaXRvcnkuZ2V0U2VydmVyQnlJZChwZWVySWQpO1xuICAgICAgICB2YXIgaW52b2NhdGlvbkFyZ3MgPSB7IGFyZ3M6IGFyZ3MsIGluc3RhbmNlOiBjbGllbnQuZ2V0SW5mb0ZvclVzZXIoKSB9O1xuXG4gICAgICAgIGNhbGxiYWNrcy5leGVjdXRlKCdvbkludm9rZWQnLCBtZXRob2QsIGludm9jYXRpb25JZCwgaW52b2NhdGlvbkFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVN0cmVhbShyZXBvTWV0aG9kLCBzdHJlYW1EZWYsIHN1Y2Nlc3MsIGZhaWwpIHtcbiAgICAgICAgdmFyIGlzU3RyZWFtaW5nID0gdHJ1ZTtcblxuICAgICAgICAvLyBVdGlsaXR5IHRoaW5ncyBmb3IgdGhpcyBwcm90b2NvbFxuICAgICAgICByZXBvTWV0aG9kLnN1YnNjcmlwdGlvbnNNYXAgPSB7fTsgLy8gfnN1YnNjcmlwdGlvbl9pZH4gOiB7aWQ6fiwgYnJhbmNoS2V5OiAnficsIGFyZ3VtZW50czoge359LCBpbnN0YW5jZTp7fn0sIGV0Yy59XG4gICAgICAgIHJlcG9NZXRob2QuYnJhbmNoS2V5VG9TdHJlYW1JZE1hcCA9IFtdOyAvLyBbIHticmFuY2hLZXk6ICcnLCBzdHJlYW1JZDogN30sIHsuLi59LCAuLi5dXG5cbiAgICAgICAgcmVnaXN0ZXIocmVwb01ldGhvZCwgc3VjY2VzcywgZmFpbCwgaXNTdHJlYW1pbmcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyKHJlcG9NZXRob2QsIHN1Y2Nlc3MsIGZhaWwsIGlzU3RyZWFtaW5nKSB7XG5cbiAgICAgICAgdmFyIG1ldGhvZERlZiA9IHJlcG9NZXRob2QuZGVmaW5pdGlvbjtcblxuICAgICAgICAvLyBUT0RPIHJldmlldywgd2h5IGlzIHRoaXMgdHlwZSBvZiBjbG9zdXJlIG5lY2Vzc2FyeVxuICAgICAgICByZXBvTWV0aG9kLnJlZ2lzdHJhdGlvbkNhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3MsXG4gICAgICAgICAgICBmYWlsOiBmYWlsXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGZsYWdzID0ge307XG4gICAgICAgIGlmIChpc1N0cmVhbWluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZmxhZ3MgPSB7IHN1cHBvcnRzU3RyZWFtaW5nOiB0cnVlIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVnaXN0ZXJpbmcgbWV0aG9kIFwiJyArIG1ldGhvZERlZi5uYW1lICsgJ1wiJyk7XG4gICAgICAgIHZhciByZWdpc3Rlck1zZyA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdyZWdpc3RlcicsXG4gICAgICAgICAgICBtZXRob2RzOiBbe1xuICAgICAgICAgICAgICAgIGlkOiByZXBvTWV0aG9kLl9yZXBvSWQsXG4gICAgICAgICAgICAgICAgbmFtZTogbWV0aG9kRGVmLm5hbWUsXG4gICAgICAgICAgICAgICAgZGlzcGxheV9uYW1lOiBtZXRob2REZWYuZGlzcGxheU5hbWUsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG1ldGhvZERlZi5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBtZXRob2REZWYudmVyc2lvbixcbiAgICAgICAgICAgICAgICBmbGFnczogZmxhZ3MsXG4gICAgICAgICAgICAgICAgb2JqZWN0X3R5cGVzOiBtZXRob2REZWYub2JqZWN0VHlwZXMsXG4gICAgICAgICAgICAgICAgaW5wdXRfc2lnbmF0dXJlOiBtZXRob2REZWYuYWNjZXB0cyxcbiAgICAgICAgICAgICAgICByZXN1bHRfc2lnbmF0dXJlOiBtZXRob2REZWYucmV0dXJucyxcbiAgICAgICAgICAgICAgICByZXN0cmljdGlvbnM6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcblxuICAgICAgICBjb25uZWN0aW9uLnNlbmQocmVnaXN0ZXJNc2csIHsgbWV0aG9kSWQ6IHJlcG9NZXRob2QuX3JlcG9JZCB9KVxuICAgICAgICAgICAgLnRoZW4oaGFuZGxlUmVnaXN0ZXJlZE1lc3NhZ2UpWydjYXRjaCddKGhhbmRsZUVycm9yUmVnaXN0ZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uSW52b2tlZChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFja3MuYWRkKCdvbkludm9rZWQnLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWV0aG9kSW52b2NhdGlvblJlc3VsdChyZWdpc3RyYXRpb25JZCwgaW52b2NhdGlvbklkLCBlcnIsIHJlc3VsdCkge1xuICAgICAgICB2YXIgbXNnID0ge1xuICAgICAgICAgICAgdHlwZTogJ3lpZWxkJyxcbiAgICAgICAgICAgIGludm9jYXRpb25faWQ6IGludm9jYXRpb25JZCxcbiAgICAgICAgICAgIHBlZXJfaWQ6IHNlc3Npb24ucGVlcklkKCksXG4gICAgICAgICAgICByZXN1bHQ6IHJlc3VsdFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbm5lY3Rpb24uc2VuZEZpcmVBbmRGb3JnZXQobXNnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bnJlZ2lzdGVyKG1ldGhvZCkge1xuICAgICAgICB2YXIgbXNnID0ge1xuICAgICAgICAgICAgdHlwZTogJ3VucmVnaXN0ZXInLFxuICAgICAgICAgICAgbWV0aG9kczogW21ldGhvZC5fcmVwb0lkXVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbm5lY3Rpb24uc2VuZChtc2cpXG4gICAgICAgICAgICAudGhlbihoYW5kbGVVbnJlZ2lzdGVyZWRNZXNzYWdlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVVbnJlZ2lzdGVyZWRNZXNzYWdlKG1zZykge1xuICAgICAgICB2YXIgcmVxdWVzdElkID0gbXNnLnJlcXVlc3RfaWQ7XG5cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCd1bnJlZ2lzdGVyZWQgYnkgcmVxdWVzdElkICcgKyByZXF1ZXN0SWQpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHJlZ2lzdGVyOiByZWdpc3RlcixcbiAgICAgICAgb25JbnZva2VkOiBvbkludm9rZWQsXG4gICAgICAgIG1ldGhvZEludm9jYXRpb25SZXN1bHQ6IG1ldGhvZEludm9jYXRpb25SZXN1bHQsXG4gICAgICAgIHVucmVnaXN0ZXI6IHVucmVnaXN0ZXIsXG5cbiAgICAgICAgY3JlYXRlU3RyZWFtOiBjcmVhdGVTdHJlYW0sXG4gICAgICAgIGdldEJyYW5jaExpc3Q6IHN0cmVhbWluZy5nZXRCcmFuY2hMaXN0LFxuICAgICAgICBnZXRTdWJzY3JpcHRpb25MaXN0OiBzdHJlYW1pbmcuZ2V0U3Vic2NyaXB0aW9uTGlzdCxcbiAgICAgICAgY2xvc2VBbGxTdWJzY3JpcHRpb25zOiBzdHJlYW1pbmcuY2xvc2VNdWx0aXBsZVN1YnNjcmlwdGlvbnMsXG4gICAgICAgIGNsb3NlU2luZ2xlU3Vic2NyaXB0aW9uOiBzdHJlYW1pbmcuY2xvc2VTaW5nbGVTdWJzY3JpcHRpb24sXG4gICAgICAgIHB1c2hEYXRhOiBzdHJlYW1pbmcucHVzaERhdGEsXG4gICAgICAgIHB1c2hEYXRhVG9TaW5nbGU6IHN0cmVhbWluZy5wdXNoRGF0YVRvU2luZ2xlLFxuICAgICAgICBvblN1YlJlcXVlc3Q6IHN0cmVhbWluZy5vblN1YlJlcXVlc3QsXG4gICAgICAgIGFjY2VwdFJlcXVlc3RPbkJyYW5jaDogc3RyZWFtaW5nLmFjY2VwdFJlcXVlc3RPbkJyYW5jaCxcbiAgICAgICAgcmVqZWN0UmVxdWVzdDogc3RyZWFtaW5nLnJlamVjdFJlcXVlc3QsXG4gICAgICAgIG9uU3ViQWRkZWQ6IHN0cmVhbWluZy5vblN1YkFkZGVkLFxuICAgICAgICBvblN1YlJlbW92ZWQ6IHN0cmVhbWluZy5vblN1YlJlbW92ZWRcbiAgICB9XG59O1xuIiwidmFyIGNhbGxiYWNrUmVnaXN0cnkgPSByZXF1aXJlKCdjYWxsYmFjay1yZWdpc3RyeScpO1xuXG4vKipcbiAqIEhhbmRsZXMgc2Vzc2lvbiBsaWZldGltZSBhbmQgZXZlbnRzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluc3RhbmNlLCBjb25uZWN0aW9uLCByZXBvc2l0b3J5LCBsb2dnZXIpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGRvbWFpbiA9ICdjb20udGljazQyLmFnbSc7XG5cbiAgICBjb25uZWN0aW9uLm9uKCdsZWF2ZScsIGhhbmRsZUdvb2RieWVNZXNzYWdlKVxuXG4gICAgdmFyIG15UGVlcklkID0gY29ubmVjdGlvbi5wZWVySWQ7XG4gICAgdmFyIGNhbGxiYWNrcyA9IGNhbGxiYWNrUmVnaXN0cnkoKTtcbiAgICB2YXIgam9pbmVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdGFydGluZyBzZXNzaW9uIC4uLicpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2pvaW5pbmcgZG9tYWluIFwiJyArIGRvbWFpbik7XG5cbiAgICAgICAgdmFyIGpvaW5Nc2cgPSB7XG4gICAgICAgICAgICB0eXBlOiAnam9pbicsXG4gICAgICAgICAgICBkb21haW46IGRvbWFpblxuICAgICAgICB9O1xuICAgICAgICBjb25uZWN0aW9uLnNlbmQoam9pbk1zZylcbiAgICAgICAgICAgIC50aGVuKGhhbmRsZUpvaW5lZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlSm9pbmVkKCkge1xuICAgICAgICBqb2luZWQgPSB0cnVlO1xuICAgICAgICByZXBvc2l0b3J5LmFkZFNlcnZlcihpbnN0YW5jZSwgbXlQZWVySWQpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2pvaW5lZCB0byBBR00gZG9tYWluIScpO1xuICAgICAgICBjYWxsYmFja3MuZXhlY3V0ZSgnb25Db25uZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BwaW5nIHNlc3Npb24uLi4nKTtcbiAgICAgICAgdmFyIG1zZyA9IFsnTEVBVkUnLCBteVBlZXJJZCwgZG9tYWluXTtcbiAgICAgICAgY29ubmVjdGlvbi5zZW5kKG1zZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlR29vZGJ5ZU1lc3NhZ2UoKSB7XG4gICAgICAgIGpvaW5lZCA9IGZhbHNlO1xuICAgICAgICBteVBlZXJJZCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNvbm5lY3RlZChjYWxsYmFjaykge1xuICAgICAgICBpZiAoY29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFja3MuYWRkKCdvbkNvbm5lY3RlZCcsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiBqb2luZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBzdG9wOiBzdG9wLFxuICAgICAgICBjb25uZWN0ZWQ6IGNvbm5lY3RlZCxcbiAgICAgICAgcGVlcklkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbXlQZWVySWQ7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ29ubmVjdGVkOiBvbkNvbm5lY3RlZFxuICAgIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiX2FyZ3NcIjogW1xuICAgIFtcbiAgICAgIFwidGljazQyLWFnbUBeMy4yLjBcIixcbiAgICAgIFwiQzpcXFxcd29ya1xcXFxzdGFzaFxcXFxHTFVFLWRldlxcXFxqcy1nbHVlXCJcbiAgICBdXG4gIF0sXG4gIFwiX2Zyb21cIjogXCJ0aWNrNDItYWdtQD49My4yLjAgPDQuMC4wXCIsXG4gIFwiX2lkXCI6IFwidGljazQyLWFnbUAzLjIuMVwiLFxuICBcIl9pbkNhY2hlXCI6IHRydWUsXG4gIFwiX2luc3RhbGxhYmxlXCI6IHRydWUsXG4gIFwiX2xvY2F0aW9uXCI6IFwiL3RpY2s0Mi1hZ21cIixcbiAgXCJfbm9kZVZlcnNpb25cIjogXCI2LjMuMFwiLFxuICBcIl9ucG1Vc2VyXCI6IHt9LFxuICBcIl9ucG1WZXJzaW9uXCI6IFwiMy44LjVcIixcbiAgXCJfcGhhbnRvbUNoaWxkcmVuXCI6IHt9LFxuICBcIl9yZXF1ZXN0ZWRcIjoge1xuICAgIFwibmFtZVwiOiBcInRpY2s0Mi1hZ21cIixcbiAgICBcInJhd1wiOiBcInRpY2s0Mi1hZ21AXjMuMi4wXCIsXG4gICAgXCJyYXdTcGVjXCI6IFwiXjMuMi4wXCIsXG4gICAgXCJzY29wZVwiOiBudWxsLFxuICAgIFwic3BlY1wiOiBcIj49My4yLjAgPDQuMC4wXCIsXG4gICAgXCJ0eXBlXCI6IFwicmFuZ2VcIlxuICB9LFxuICBcIl9yZXF1aXJlZEJ5XCI6IFtcbiAgICBcIi9cIlxuICBdLFxuICBcIl9zaGFzdW1cIjogXCI4YmJjODM1ZjMwMGI4MTc3NzU5MWI0NTVmMDRhMzE3MGViYjQ0MTgyXCIsXG4gIFwiX3Nocmlua3dyYXBcIjogbnVsbCxcbiAgXCJfc3BlY1wiOiBcInRpY2s0Mi1hZ21AXjMuMi4wXCIsXG4gIFwiX3doZXJlXCI6IFwiQzpcXFxcd29ya1xcXFxzdGFzaFxcXFxHTFVFLWRldlxcXFxqcy1nbHVlXCIsXG4gIFwiYXV0aG9yXCI6IHtcbiAgICBcIm5hbWVcIjogXCJUaWNrNDJcIixcbiAgICBcInVybFwiOiBcImh0dHA6Ly93d3cudGljazQyLmNvbVwiXG4gIH0sXG4gIFwiYmluXCI6IHtcbiAgICBcImJ1aWxkXCI6IFwiLi9iaW4vYnVpbGQuanNcIixcbiAgICBcImNsZWFuXCI6IFwiLi9iaW4vY2xlYW4uanNcIixcbiAgICBcImZpbGUtdmVyc2lvbmlmeVwiOiBcIi4vYmluL2ZpbGUtdmVyc2lvbmlmeS5qc1wiLFxuICAgIFwibWluaWZ5XCI6IFwiLi9iaW4vbWluaWZ5LmpzXCJcbiAgfSxcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vamlyYS50aWNrNDIuY29tL2Jyb3dzZS9BUFBDVFJMXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiY2FsbGJhY2stcmVnaXN0cnlcIjogXCJeMS4wLjFcIixcbiAgICBcImN1aWRcIjogXCJeMS4zLjhcIixcbiAgICBcImVzNi1wcm9taXNlXCI6IFwiXjMuMC4yXCIsXG4gICAgXCJ0aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uXCI6IFwiXjIuMC4wXCIsXG4gICAgXCJ1dGlsLWRlcHJlY2F0ZVwiOiBcIl4xLjAuMlwiXG4gIH0sXG4gIFwiZGVzY3JpcHRpb25cIjogXCJKYXZhU2NyaXB0IEFHTVwiLFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJibGFua2V0XCI6IFwiXjEuMS42XCIsXG4gICAgXCJibHVlYmlyZFwiOiBcIl4yLjkuMzBcIixcbiAgICBcImJyb3dzZXJpZnlcIjogXCJeMTMuMC4wXCIsXG4gICAgXCJicm93c2VyaWZ5LXJlcGxhY2lmeVwiOiBcIl4wLjAuNFwiLFxuICAgIFwiYnJvd3NlcmlmeS12ZXJzaW9uaWZ5XCI6IFwiXjEuMC40XCIsXG4gICAgXCJlc2xpbnRcIjogXCJeMy4xLjFcIixcbiAgICBcImVzbGludC1jb25maWctc3RhbmRhcmRcIjogXCJeNS4zLjVcIixcbiAgICBcImVzbGludC1jb25maWctdGljazQyXCI6IFwiXjEuMC4wXCIsXG4gICAgXCJlc2xpbnQtcGx1Z2luLXByb21pc2VcIjogXCJeMi4wLjBcIixcbiAgICBcImVzbGludC1wbHVnaW4tc3RhbmRhcmRcIjogXCJeMi4wLjBcIixcbiAgICBcImZzXCI6IFwiMC4wLjJcIixcbiAgICBcImh0dHAtc2VydmVyXCI6IFwiXjAuOS4wXCIsXG4gICAgXCJqc2RvbVwiOiBcIl44LjEuMFwiLFxuICAgIFwibWluaWZ5aWZ5XCI6IFwiXjcuMy4yXCIsXG4gICAgXCJvbmNoYW5nZVwiOiBcIl4yLjEuMlwiLFxuICAgIFwicGhhbnRvbWpzXCI6IFwiXjEuOS4xMlwiLFxuICAgIFwicXVuaXRqc1wiOiBcIl4xLjE1LjBcIixcbiAgICBcInNoZWxsanNcIjogXCJeMC42LjBcIlxuICB9LFxuICBcImRpc3RcIjoge1xuICAgIFwic2hhc3VtXCI6IFwiOGJiYzgzNWYzMDBiODE3Nzc1OTFiNDU1ZjA0YTMxNzBlYmI0NDE4MlwiLFxuICAgIFwidGFyYmFsbFwiOiBcImh0dHA6Ly8xOTIuMTY4LjAuMjM0OjQ4NzMvdGljazQyLWFnbS8tL3RpY2s0Mi1hZ20tMy4yLjEudGd6XCJcbiAgfSxcbiAgXCJnaXRIZWFkXCI6IFwiYjM2NTE3YWMwYTNiY2I3YTY5MmJlMTYxYmIyYWY0ZTQ4ZWU2OTRhZlwiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImFnbVwiLFxuICAgIFwiamF2YXNjcmlwdFwiLFxuICAgIFwibGlicmFyeVwiXG4gIF0sXG4gIFwibWFpblwiOiBcImxpYnJhcnkvYWdtLmpzXCIsXG4gIFwibmFtZVwiOiBcInRpY2s0Mi1hZ21cIixcbiAgXCJvcHRpb25hbERlcGVuZGVuY2llc1wiOiB7fSxcbiAgXCJyZWFkbWVcIjogXCJFUlJPUjogTm8gUkVBRE1FIGRhdGEgZm91bmQhXCIsXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJidWlsZFwiOiBcIm5wbSBydW4gZXNsaW50ICYmIG5vZGUgYmluL2NsZWFuLmpzICYmIG5vZGUgYmluL2J1aWxkLmpzICYmIG5vZGUgYmluL21pbmlmeSAmJiBub2RlIGJpbi9maWxlLXZlcnNpb25pZnlcIixcbiAgICBcImVzbGludFwiOiBcImVzbGludCBsaWJyYXJ5XCIsXG4gICAgXCJlc2xpbnQ6Zml4XCI6IFwiZXNsaW50IGxpYnJhcnkgLS1maXhcIixcbiAgICBcInByZXB1Ymxpc2hcIjogXCJucG0gdXBkYXRlICYgbnBtIHJ1biBidWlsZFwiLFxuICAgIFwic2VydmVcIjogXCJodHRwLXNlcnZlciAtcCA4MDAwIC1hIDEyNy4wLjAuMVwiLFxuICAgIFwidGVzdFwiOiBcIm5wbSBydW4gZXNsaW50ICYmIG1vY2hhIC0tcmVxdWlyZSAuL3Rlc3QvdGVzdF9oZWxwZXIgXFxcInRlc3QvKiovKi5qc1xcXCJcIixcbiAgICBcIndhdGNoXCI6IFwib25jaGFuZ2UgXFxcIi4vbGlicmFyeS8qKi8qLmpzXFxcIiAtaXYgLWUgXFxcIi4vYmluXFxcIiAtLSBucG0gcnVuIGJ1aWxkXCJcbiAgfSxcbiAgXCJ0aXRsZVwiOiBcIlRpY2s0MiBBR01cIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMy4yLjFcIlxufVxuIiwidmFyIGFwcGxpY2F0aW9uID0gcmVxdWlyZShcIi4vYXBwbGljYXRpb25cIik7XG52YXIgaW5zdGFuY2UgPSByZXF1aXJlKFwiLi9pbnN0YW5jZVwiKTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcbnZhciBQYWNrYWdlSnNvbiA9IHJlcXVpcmUoXCIuLi9wYWNrYWdlLmpzb25cIik7XG52YXIgZGVwcmVjYXRlID0gcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuYXBwX21hbmFnZXIgPSBmdW5jdGlvbiBhcHBfbWFuYWdlcihhZ20sIHdpbmRvd3MpIHtcblxuXHR2YXIgYXBwcyA9IGFwcGxpY2F0aW9uKGFnbSwgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBpbnN0YW5jZXM7XG5cdH0pO1xuXHR2YXIgaW5zdGFuY2VzID0gaW5zdGFuY2UoYWdtLCBhcHBzKTtcblx0dmFyIG1hbmFnZXIgPSB7XG5cdFx0YXBwbGljYXRpb25zOiBhcHBzLmFsbCxcblx0XHRhcHBsaWNhdGlvbjogYXBwcy5nZXRfYnlfaWQsXG5cdFx0b25BcHBBZGRlZDogaGVscGVycy5hZGRfY2FsbGJhY2soXCJhZGRlZFwiKS5iaW5kKGFwcHMpLFxuXHRcdG9uQXBwQXZhaWxhYmxlOiBoZWxwZXJzLmFkZF9jYWxsYmFjayhcImF2YWlsYWJsZVwiKS5iaW5kKGFwcHMpLFxuXHRcdG9uQXBwUmVtb3ZlZDogaGVscGVycy5hZGRfY2FsbGJhY2soXCJyZW1vdmVkXCIpLmJpbmQoYXBwcyksXG5cdFx0b25BcHBVbmF2YWlsYWJsZTogaGVscGVycy5hZGRfY2FsbGJhY2soXCJ1bmF2YWlsYWJsZVwiKS5iaW5kKGFwcHMpLFxuXG5cdFx0aW5zdGFuY2VzOiBpbnN0YW5jZXMuYWxsLFxuXHRcdG9uSW5zdGFuY2VTdGFydGVkOiBoZWxwZXJzLmFkZF9jYWxsYmFjayhcInN0YXJ0ZWRcIikuYmluZChpbnN0YW5jZXMpLFxuXHRcdG9uSW5zdGFuY2VTdG9wcGVkOiBoZWxwZXJzLmFkZF9jYWxsYmFjayhcInN0b3BwZWRcIikuYmluZChpbnN0YW5jZXMpLFxuXHRcdG9uSW5zdGFuY2VVcGRhdGVkOiBoZWxwZXJzLmFkZF9jYWxsYmFjayhcInVwZGF0ZWRcIikuYmluZChpbnN0YW5jZXMpLFxuXG5cdFx0Z2V0QnJhbmNoZXM6IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuXHRcdFx0YWdtLmludm9rZShcIlQ0Mi5BQ1MuR2V0QnJhbmNoZXNcIiwge30sIFwiYmVzdFwiLCB7fSwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0aWYgKHN1Y2Nlc3MpIHtcblx0XHRcdFx0XHRzdWNjZXNzKGhlbHBlcnMudmFscyhlLnJldHVybmVkLkJyYW5jaGVzKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIGVycm9yKTtcblx0XHR9LFxuXHRcdGdldEN1cnJlbnRCcmFuY2g6IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuXHRcdFx0YWdtLmludm9rZShcIlQ0Mi5BQ1MuR2V0Q3VycmVudEJyYW5jaFwiLCB7fSwgXCJiZXN0XCIsIHt9LCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRpZiAoc3VjY2Vzcykge1xuXHRcdFx0XHRcdHN1Y2Nlc3MoZS5yZXR1cm5lZC5CcmFuY2gpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBlcnJvcik7XG5cdFx0fSxcblx0XHRzZXRDdXJyZW50QnJhbmNoOiBmdW5jdGlvbiAoYnJhbmNoLCBzdWNjZXNzLCBlcnJvcikge1xuXHRcdFx0YWdtLmludm9rZShcIlQ0Mi5BQ1MuU2V0Q3VycmVudEJyYW5jaFwiLCB7QnJhbmNoOiBicmFuY2h9LCBcImJlc3RcIiwge30sIHN1Y2Nlc3MsIGVycm9yKTtcblx0XHR9LFxuXHRcdGN1cnJlbnRVc2VyOiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcblx0XHRcdGFnbS5pbnZva2UoXCJUNDIuQUNTLkdldFVzZXJcIiwge30sIFwiYmVzdFwiLCB7fSwgc3VjY2VzcywgZXJyb3IpO1xuXHRcdH0sXG5cdFx0Z2V0RnVuY3Rpb25hbEVudGl0bGVtZW50OiBmdW5jdGlvbiAoZm4sIHN1Y2Nlc3MsIGVycm9yKSB7XG5cdFx0XHRhZ20uaW52b2tlKFwiVDQyLkFDUy5HZXRGdW5jdGlvbmFsRW50aXRsZW1lbnRcIiwge0Z1bmN0aW9uOiBmbn0sIFwiYmVzdFwiLCB7fSwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0aWYgKHN1Y2Nlc3MpIHtcblx0XHRcdFx0XHRzdWNjZXNzKGUucmV0dXJuZWQuRW50aXRsZW1lbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBlcnJvcik7XG5cdFx0fSxcblx0XHRnZXRGdW5jdGlvbmFsRW50aXRsZW1lbnRCcmFuY2g6IGZ1bmN0aW9uIChmbiwgYnIsIHN1Y2Nlc3MsIGVycm9yKSB7XG5cdFx0XHRhZ20uaW52b2tlKFwiVDQyLkFDUy5HZXRGdW5jdGlvbmFsRW50aXRsZW1lbnRcIiwge0Z1bmN0aW9uOiBmbiwgQnJhbmNoOiBicn0sIFwiYmVzdFwiLCB7fSwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0aWYgKHN1Y2Nlc3MpIHtcblx0XHRcdFx0XHRzdWNjZXNzKGUucmV0dXJuZWQuRW50aXRsZW1lbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBlcnJvcik7XG5cdFx0fSxcblx0XHRjYW5JOiBmdW5jdGlvbiAoZm4sIHN1Y2Nlc3MsIGVycm9yKSB7XG5cdFx0XHRhZ20uaW52b2tlKFwiVDQyLkFDUy5DYW5JXCIsIHtGdW5jdGlvbjogZm59LCBcImJlc3RcIiwge30sIHN1Y2Nlc3MsIGVycm9yKTtcblx0XHR9LFxuXG5cdFx0Y2FuSUJyYW5jaDogZnVuY3Rpb24oZm4sIGJyYW5jaCwgc3VjY2VzcywgZXJyb3IpIHtcblx0XHRcdGFnbS5pbnZva2UoXCJUNDIuQUNTLkNhbklcIiwge0Z1bmN0aW9uOiBmbiwgQnJhbmNoOiBicmFuY2h9LCBcImJlc3RcIiwge30sIHN1Y2Nlc3MsIGVycm9yKTtcblx0XHR9LFxuXG5cdFx0ZXhpdDogZnVuY3Rpb24gKCkge1xuXHRcdFx0YWdtLmludm9rZShcIlQ0Mi5BQ1MuU2h1dGRvd25cIiwge30sIFwiYWxsXCIsIHt9LFxuXHRcdFx0XHRmdW5jdGlvbiAoYSkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGEpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGUpO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0c2V0UmVnaW9uOiBmdW5jdGlvbiAocmVnaW9uLCBzdWNjZXNzLCBlcnJvcil7XG5cdFx0XHRhZ20uaW52b2tlKFwiVDQyLkFDUy5TZXRDb25maWd1cmF0aW9uUmVnaW9uXCIsIHtSZWdpb246IHJlZ2lvbn0sIFwiYmVzdFwiLCB7fSwgc3VjY2VzcywgZXJyb3IpO1xuXHRcdH0sXG5cblx0XHRnZXRSZWdpb246IGZ1bmN0aW9uKHN1Y2Nlc3MsIGVycm9yKXtcblx0XHRcdGFnbS5pbnZva2UoXCJUNDIuQUNTLkdldENvbmZpZ3VyYXRpb25SZWdpb25cIiwge30sIFwiYmVzdFwiLCB7fSwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0aWYgKHN1Y2Nlc3MpIHtcblx0XHRcdFx0XHRzdWNjZXNzKGUucmV0dXJuZWQuUmVnaW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgZXJyb3IpO1xuXHRcdH0sXG5cblx0XHRfdHJpZ2dlcl9hcHBfZXZlbnQ6IGFwcHMuX3RyaWdnZXIsXG5cdFx0X3RyaWdnZXJfaW5zdGFuY2VfZXZlbnQ6IGluc3RhbmNlcy5fdHJpZ2dlclxuXG5cdH07XG5cblx0ZnVuY3Rpb24gY2FsbF93aXRoKHByb3AsIGZ1bmMpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKHJlc3VsdCkge1xuXHRcdFx0ZnVuYyhyZXN1bHRbcHJvcF0pO1xuXHRcdH07XG5cblx0fVxuXHQvL0NyZWF0ZSBldmVudCBiaW5kaW5nc1xuXG5cdC8vVGVsbCB0aGUgYXBwIHdoZW4gaXRzIGluc3RhbmNlcyBhcmUgYWRkZWQvcmVtb3ZlZFxuXG5cdG1hbmFnZXIub25JbnN0YW5jZVN0YXJ0ZWQoZnVuY3Rpb24gKGluc3RhbmNlKSB7XG5cdFx0aWYgKGluc3RhbmNlLmFwcGxpY2F0aW9uKSB7XG5cdFx0XHQvL1RyaWdnZXIgXCJpbnN0YW5jZV9zdGFydGVkXCIgZXZlbnQgb24gYXBwbGljYXRpb25cblx0XHRcdG1hbmFnZXIuX3RyaWdnZXJfYXBwX2V2ZW50KFwiaW5zdGFuY2VTdGFydGVkXCIsIGluc3RhbmNlLCBpbnN0YW5jZS5hcHBsaWNhdGlvbi5uYW1lKTtcblxuXHRcdFx0Ly9UcmlnZ2VyIFwid2luZG93X29wZW5lZFwiIGV2ZW50IG9uIGluc3RhbmNlXG5cdFx0XHR2YXIgY29udGFpbmVyO1xuXHRcdFx0aWYgKHdpbmRvd3MgJiYgZ2x1ZSkge1xuXHRcdFx0XHR2YXIgaWQgPSAoaW5zdGFuY2UuY29udGV4dCAmJiBpbnN0YW5jZS5jb250ZXh0Lmd1aWQpID8gaW5zdGFuY2UuY29udGV4dC5ndWlkIDogaW5zdGFuY2UuaWQ7XG5cdFx0XHRcdGNvbnRhaW5lciA9IGluc3RhbmNlLmFwcGxpY2F0aW9uLmNvbmZpZ3VyYXRpb24uY29udGFpbmVyO1xuXHRcdFx0XHRpZihjb250YWluZXIgIT09IG51bGwgJiYgY29udGFpbmVyICE9PSBcIlwiKXtcblx0XHRcdFx0XHRnbHVlLmFnbS5pbnZva2UoXCJUNDIuV25kLkZpbmRCeUlkXCIsIHt3aW5kb3dJZDogaW5zdGFuY2UuaWR9LCB7YXBwbGljYXRpb246IGNvbnRhaW5lcn0sIHt9LCB3aW5kb3dfb3BlbmVkLCBmdW5jdGlvbihlKXtjb25zb2xlLmxvZyhlKX0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gd2luZG93X29wZW5lZChhKSB7XG5cdFx0XHQvL1dyYXAgdGhlIHdpbmRvdyBpbiBhIHdpbmRvdyBvYmplY3QsIHVzaW5nIHRoZSBnbHVlIHdpbmRvd3MgbGliXG5cdFx0XHR2YXIgdyA9IGEucmV0dXJuZWQgW09iamVjdC5rZXlzKGEucmV0dXJuZWQpWzBdXTtcblx0XHRcdHZhciB3aW4gPSBnbHVlLndpbmRvd3MuX2Zyb21fZXZlbnQody53aW5kb3dOYW1lLCBjb250YWluZXIsIHcudXJsLCB3LndpbmRvd0lkLCB3LndpbmRvd1N0eWxlQXR0cmlidXRlcywgdy53aW5kb3dUaXRsZSk7XG5cblx0XHRcdC8vVHJpZ2dlciB0aGUgd2luZG93IG9wZW5lZCBldmVudFxuXHRcdFx0bWFuYWdlci5fdHJpZ2dlcl9pbnN0YW5jZV9ldmVudChcIndpbmRvd0FkZGVkXCIsIHdpbiwgaWQpO1xuXHRcdH1cblx0fSk7XG5cblx0bWFuYWdlci5vbkluc3RhbmNlU3RvcHBlZChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcblx0XHRpZiAoaW5zdGFuY2UuYXBwbGljYXRpb24pIHtcblx0XHRcdG1hbmFnZXIuX3RyaWdnZXJfYXBwX2V2ZW50KFwiaW5zdGFuY2VTdG9wcGVkXCIsIGluc3RhbmNlLCBpbnN0YW5jZS5hcHBsaWNhdGlvbi5uYW1lKTtcblxuXHRcdFx0dmFyIGlkID0gKGluc3RhbmNlLmNvbnRleHQgJiYgaW5zdGFuY2UuY29udGV4dC5ndWlkKSA/IGluc3RhbmNlLmNvbnRleHQuZ3VpZCA6IGluc3RhbmNlLmlkO1xuXHRcdFx0bWFuYWdlci5fdHJpZ2dlcl9pbnN0YW5jZV9ldmVudChcIndpbmRvd1JlbW92ZWRcIiwge30sIGlkKTtcblxuXHRcdH1cblx0fSk7XG5cblx0bWFuYWdlci5vbkluc3RhbmNlVXBkYXRlZChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcblx0XHRpZiAoaW5zdGFuY2UuYXBwbGljYXRpb24pIHtcblx0XHQvLyBtYW5hZ2VyLl90cmlnZ2VyX2FwcF9ldmVudChcImluc3RhbmNlX3N0b3BwZWRcIiwgaW5zdGFuY2UsIGluc3RhbmNlLmFwcGxpY2F0aW9uLm5hbWUpO1xuXG5cdFx0Ly8gdmFyIGlkID0gKGluc3RhbmNlLmNvbnRleHQgJiYgaW5zdGFuY2UuY29udGV4dC5ndWlkKSA/IGluc3RhbmNlLmNvbnRleHQuZ3VpZCA6IGluc3RhbmNlLmlkO1xuXHRcdC8vIG1hbmFnZXIuX3RyaWdnZXJfaW5zdGFuY2VfZXZlbnQoXCJ0aXRsZV9jaGFuZ2VkXCIsIHt9LCBpZCk7XG5cdFx0fVxuXHR9KTtcblx0Ly9XaGVuIGFuIGFwcCBpcyByZW1vdmVkLCByZW1vdmUgYWxzbyBpdHMgaW5zdGFuY2VzXG5cblx0bWFuYWdlci5vbkFwcFJlbW92ZWQoZnVuY3Rpb24gKGFwcCkge1xuXHRcdGFwcC5pbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcblx0XHRcdHZhciBpZCA9IChpbnN0YW5jZS5jb250ZXh0ICYmIGluc3RhbmNlLmNvbnRleHQuZ3VpZCkgPyBpbnN0YW5jZS5jb250ZXh0Lmd1aWQgOiBpbnN0YW5jZS5pZDtcblx0XHRcdG1hbmFnZXIuX3RyaWdnZXJfaW5zdGFuY2VfZXZlbnQoXCJzdG9wcGVkXCIsIHt9LCBpZCk7XG5cdFx0fSk7XG5cdH0pO1xuXHRcblx0dmFyIGJyYW5jaF9jaGFuZ2VkX2NhbGxiYWNrO1xuXHRtYW5hZ2VyLm9uQnJhbmNoZXNDaGFuZ2VkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0YnJhbmNoX2NoYW5nZWRfY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0fTtcblxuXHRmdW5jdGlvbiBvbl9icmFuY2hfY2hhbmdlZChlKSB7XG5cdFx0aWYgKHR5cGVvZiBicmFuY2hfY2hhbmdlZF9jYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRicmFuY2hfY2hhbmdlZF9jYWxsYmFjayhoZWxwZXJzLnZhbHMoZSkpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZV9hcHBfcmVhZHkoYXBwKSB7XG5cdFx0aWYgKGFwcC5Jc1JlYWR5KSB7XG5cdFx0XHRtYW5hZ2VyLl90cmlnZ2VyX2FwcF9ldmVudChcImF2YWlsYWJsZVwiLCBhcHApO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1hbmFnZXIuX3RyaWdnZXJfYXBwX2V2ZW50KFwidW5hdmFpbGFibGVcIiwgYXBwKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhcHBfZmFpbGVkKGUpIHtcblx0XHRtYW5hZ2VyLl90cmlnZ2VyX2luc3RhbmNlX2V2ZW50KFwiZXJyb3JcIiwgZSwgZS5Db250ZXh0Lmd1aWQpO1xuXHR9XG5cblx0Ly8gZGVwcmVjYXRlc1xuXHRtYW5hZ2VyLmNhbl9pID0gZGVwcmVjYXRlKG1hbmFnZXIuY2FuSSwgJ2FwcE1hbmFnZXIuY2FuX2kgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgYXBwTWFuYWdlci5jYW5JKCkgaW5zdGVhZCcpO1xuXHRtYW5hZ2VyLmNhbl9pX2JyYW5jaCA9IGRlcHJlY2F0ZShtYW5hZ2VyLmNhbklicmFuY2gsICdhcHBNYW5hZ2VyLmNhbl9pX2JyYW5jaCBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBhcHBNYW5hZ2VyLmNhbklicmFuY2goKSBpbnN0ZWFkJyk7XG5cdG1hbmFnZXIuY3VycmVudF91c2VyID0gZGVwcmVjYXRlKG1hbmFnZXIuY3VycmVudFVzZXIsICdhcHBNYW5hZ2VyLmN1cnJlbnRfdXNlciBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBhcHBNYW5hZ2VyLmN1cnJlbnRVc2VyKCkgaW5zdGVhZCcpO1xuXHRtYW5hZ2VyLnNldF9jdXJyZW50X2JyYW5jaCA9IGRlcHJlY2F0ZShtYW5hZ2VyLnNldEN1cnJlbnRCcmFuY2gsICdhcHBNYW5hZ2VyLnNldF9jdXJyZW50X2JyYW5jaCBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBhcHBNYW5hZ2VyLnNldEN1cnJlbnRCcmFuY2goKSBpbnN0ZWFkJyk7XG5cdG1hbmFnZXIuZ2V0X2N1cnJlbnRfYnJhbmNoID0gZGVwcmVjYXRlKG1hbmFnZXIuZ2V0Q3VycmVudEJyYW5jaCwgJ2FwcE1hbmFnZXIuZ2V0X2N1cnJlbnRfYnJhbmNoIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGFwcE1hbmFnZXIuZ2V0Q3VycmVudEJyYW5jaCgpIGluc3RlYWQnKTtcblx0bWFuYWdlci5nZXRfYnJhbmNoZXMgPSBkZXByZWNhdGUobWFuYWdlci5nZXRCcmFuY2hlcywgJ2FwcE1hbmFnZXIuZ2V0X2JyYW5jaGVzIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGFwcE1hbmFnZXIuZ2V0QnJhbmNoZXMoKSBpbnN0ZWFkJyk7XG5cdG1hbmFnZXIuZ2V0X2Z1bmN0aW9uYWxfZW50aXRsZW1lbnRfYnJhbmNoID0gZGVwcmVjYXRlKG1hbmFnZXIuZ2V0RnVuY3Rpb25hbEVudGl0bGVtZW50QnJhbmNoLCAnYXBwTWFuYWdlci5nZXRfZnVuY3Rpb25hbF9lbnRpdGxlbWVudF9icmFuY2ggaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgYXBwTWFuYWdlci5nZXRGdW5jdGlvbmFsRW50aXRsZW1lbnRCcmFuY2goKSBpbnN0ZWFkJyk7XG5cdG1hbmFnZXIuZ2V0X2Z1bmN0aW9uYWxfZW50aXRsZW1lbnQgPSBkZXByZWNhdGUobWFuYWdlci5nZXRGdW5jdGlvbmFsRW50aXRsZW1lbnQsICdhcHBNYW5hZ2VyLmdldF9mdW5jdGlvbmFsX2VudGl0bGVtZW50IGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGFwcE1hbmFnZXIuZ2V0RnVuY3Rpb25hbEVudGl0bGVtZW50KCkgaW5zdGVhZCcpO1xuXHRtYW5hZ2VyLmdldF9yZWdpb24gPSBkZXByZWNhdGUobWFuYWdlci5nZXRSZWdpb24sICdhcHBNYW5hZ2VyLmdldF9yZWdpb24gaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgYXBwTWFuYWdlci5nZXRSZWdpb24oKSBpbnN0ZWFkJyk7XG5cdG1hbmFnZXIuc2V0X3JlZ2lvbiA9IGRlcHJlY2F0ZShtYW5hZ2VyLnNldFJlZ2lvbiwgJ2FwcE1hbmFnZXIuc2V0X3JlZ2lvbiBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBhcHBNYW5hZ2VyLnNldFJlZ2lvbigpIGluc3RlYWQnKTtcblx0bWFuYWdlci5vbl9hcHBfdW5hdmFpbGFibGUgPSBkZXByZWNhdGUobWFuYWdlci5vbkFwcFVuYXZhaWxhYmxlLCAnYXBwTWFuYWdlci5vbl9hcHBfdW5hdmFpbGFibGUgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgYXBwTWFuYWdlci5vbkFwcFVuYXZhaWxhYmxlKCkgaW5zdGVhZCcpO1xuXHRtYW5hZ2VyLm9uX2FwcF9yZW1vdmVkID0gZGVwcmVjYXRlKG1hbmFnZXIub25BcHBSZW1vdmVkLCAnYXBwTWFuYWdlci5vbl9hcHBfcmVtb3ZlZCBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBhcHBNYW5hZ2VyLm9uQXBwUmVtb3ZlZCgpIGluc3RlYWQnKTtcblx0bWFuYWdlci5vbl9hcHBfYWRkZWQgPSBkZXByZWNhdGUobWFuYWdlci5vbkFwcEFkZGVkLCAnYXBwTWFuYWdlci5vbl9hcHBfYWRkZWQgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgYXBwTWFuYWdlci5vbkFwcEFkZGVkKCkgaW5zdGVhZCcpO1xuXHRtYW5hZ2VyLm9uX2FwcF9hdmFpbGFibGUgPSBkZXByZWNhdGUobWFuYWdlci5vbkFwcEF2YWlsYWJsZSwgJ2FwcE1hbmFnZXIub25fYXBwX2F2YWlsYWJsZSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBhcHBNYW5hZ2VyLm9uQXBwQXZhaWxhYmxlKCkgaW5zdGVhZCcpO1xuXHRtYW5hZ2VyLm9uX2JyYW5jaGVzX2NoYW5nZWQgPSBkZXByZWNhdGUobWFuYWdlci5vbkJyYW5jaGVzQ2hhbmdlZCwgJ2FwcE1hbmFnZXIub25fYnJhbmNoZXNfY2hhbmdlZCAgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgYXBwTWFuYWdlci5vbkJyYW5jaGVzQ2hhbmdlZCgpIGluc3RlYWQnKTtcblx0bWFuYWdlci5vbl9pbnN0YW5jZV9zdGFydGVkID0gZGVwcmVjYXRlKG1hbmFnZXIub25JbnN0YW5jZVN0YXJ0ZWQsICdhcHBNYW5hZ2VyLm9uX2luc3RhbmNlX3N0YXJ0ZWQgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgYXBwTWFuYWdlci5vbkluc3RhbmNlU3RhcnRlZCgpIGluc3RlYWQnKTtcblx0bWFuYWdlci5vbl9pbnN0YW5jZV9zdG9wcGVkID0gZGVwcmVjYXRlKG1hbmFnZXIub25JbnN0YW5jZVN0b3BwZWQsICdhcHBNYW5hZ2VyLm9uX2luc3RhbmNlX3N0b3BwZWQgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgYXBwTWFuYWdlci5vbkluc3RhbmNlU3RvcHBlZCgpIGluc3RlYWQnKTtcblx0bWFuYWdlci5vbl9pbnN0YW5jZV91cGRhdGVkPSBkZXByZWNhdGUobWFuYWdlci5vbkluc3RhbmNlVXBkYXRlZCwgJ2FwcE1hbmFnZXIub25faW5zdGFuY2VfdXBkYXRlZCBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBhcHBNYW5hZ2VyLm9uSW5zdGFuY2VVcGRhdGVkKCkgaW5zdGVhZCcpO1xuXG5cdGlmIChhZ20gJiYgYWdtLnN1YnNjcmliZSkge1xuXG5cdFx0bWFuYWdlci5hZ20gPSBhZ207XG5cdFx0dmFyIGhhbmRsZXJzID0gW1xuXHRcdFx0e2V2ZW50OiBcIk9uQXBwbGljYXRpb25BZGRlZFwiLCB0cmlnZ2VyOiBcImFkZGVkXCIsIG9uOiBhcHBzfSxcblx0XHRcdHtldmVudDogXCJPbkFwcGxpY2F0aW9uUmVtb3ZlZFwiLCB0cmlnZ2VyOiBcInJlbW92ZWRcIiwgb246IGFwcHN9LFxuXHRcdFx0e2V2ZW50OiBcIk9uQXBwbGljYXRpb25DaGFuZ2VkXCIsIHRyaWdnZXI6IFwiY2hhbmdlZFwiLCBvbjogYXBwc30sXG5cdFx0XHR7ZXZlbnQ6IFwiT25BcHBsaWNhdGlvblN0YXJ0ZWRcIiwgdHJpZ2dlcjogXCJzdGFydGVkXCIsIG9uOiBpbnN0YW5jZXN9LFxuXHRcdFx0e2V2ZW50OiBcIk9uQXBwbGljYXRpb25TdG9wcGVkXCIsIHRyaWdnZXI6IFwic3RvcHBlZFwiLCBvbjogaW5zdGFuY2VzfSxcblx0XHRcdHtldmVudDogXCJPbkFwcGxpY2F0aW9uVXBkYXRlZFwiLCB0cmlnZ2VyOiBcInVwZGF0ZWRcIiwgb246IGluc3RhbmNlc30sXG5cdFx0XHR7ZXZlbnQ6IFwiT25BcHBsaWNhdGlvbkFnbVNlcnZlclJlYWR5XCIsIHRyaWdnZXI6IFwiYWdtUmVhZHlcIiwgb246IGluc3RhbmNlc30sXG5cdFx0XHR7ZXZlbnQ6IFwiT25BcHBsaWNhdGlvblJlYWR5XCIsIGZ1bmM6IGhhbmRsZV9hcHBfcmVhZHl9LFxuXHRcdFx0e2V2ZW50OiBcIk9uQnJhbmNoZXNNb2RpZmllZFwiLCBmdW5jOiBvbl9icmFuY2hfY2hhbmdlZH0sXG5cdFx0XHR7ZXZlbnQ6IFwiT25BcHBsaWNhdGlvblN0YXJ0RmFpbGVkXCIsIHJhd19mdW5jOiBhcHBfZmFpbGVkfVxuXHRcdF07XG5cbiAgICAgICAgIGFnbS5zZXJ2ZXJNZXRob2RBZGRlZChmdW5jdGlvbiAocmVzcCkge1xuICAgICAgICAgICAgIGlmICgocmVzcC5zZXJ2ZXIuYXBwbGljYXRpb24uaW5kZXhPZignQXBwTWFuYWdlcicpICE9PSAtMSAmJiByZXNwLm1ldGhvZC5uYW1lLmluZGV4T2YoJ1Q0Mi5BQ1MuT25FdmVudCcpICE9PSAtMSkpIHtcbiAgICAgICAgICAgICAgICBhZ20uc3Vic2NyaWJlKFwiVDQyLkFDUy5PbkV2ZW50XCIsIHt0YXJnZXQ6IFwiYWxsXCJ9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24ub25EYXRhKGZ1bmN0aW9uIChzdHJlYW1EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHN0cmVhbURhdGEuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3RzID0gZXZlbnRzW2hhbmRsZXIuZXZlbnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqZWN0cykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYXdfZnVuYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5yYXdfZnVuYyhvYmplY3RzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlcnMudmFscyhvYmplY3RzKS5mb3JFYWNoKGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5vbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIub24uX3RyaWdnZXIoaGFuZGxlci50cmlnZ2VyLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuZnVuYyhvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICB9KTtcblx0fVxuXG5cdG1hbmFnZXIudmVyc2lvbiA9ICBQYWNrYWdlSnNvbi52ZXJzaW9uO1xuXG5cdHJldHVybiBtYW5hZ2VyO1xufTtcblxuZ2xvYmFsLnRpY2s0MiA9IGdsb2JhbC50aWNrNDIgfHx7fTtcbmdsb2JhbC50aWNrNDIuYXBwX21hbmFnZXIgPSBnbG9iYWwuYXBwX21hbmFnZXI7XG4iLCJ2YXIgZXZlbnRfbWFuYWdlciA9IHJlcXVpcmUoXCIuL2V2ZW50X21hbmFnZXJcIik7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XG52YXIgZGVwcmVjYXRlID0gcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhZ20sIGluc3RhbmNlcykge1xuXHR2YXIgYXBwX3Byb3RvID0gaGVscGVycy5hZGRfY2FsbGJhY2tzKHtcblxuXHRcdHN0YXJ0OiBmdW5jdGlvbiAocGFyYW1zLCBzdWNjZXNzLCBlcnJvcikge1xuXHRcdFx0cGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXHRcdFx0cGFyYW1zLmd1aWQgPSBwYXJhbXMuZ3VpZCB8fCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMCk7XG5cdFx0XHRpZiAoYWdtKSB7XG5cdFx0XHRcdGFnbS5pbnZva2UoXCJUNDIuQUNTLlN0YXJ0QXBwbGljYXRpb25cIiwge05hbWU6IHRoaXMubmFtZSwgQ29udGV4dDogcGFyYW1zfSwgXCJiZXN0XCIsIHt9LCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHR9LCBlcnJvcik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaW5zdGFuY2VzKCkuX3RyaWdnZXIoXCJjcmVhdGVcIiwge0NvbnRleHQ6IHBhcmFtc30pO1xuXG5cdFx0fVxuXG5cdH0sIFtcIkFkZGVkXCIsIFwiUmVtb3ZlZFwiLCBcIkF2YWlsYWJsZVwiLCBcIlVuYXZhaWxhYmxlXCIsIFwiSW5zdGFuY2VTdGFydGVkXCIsIFwiSW5zdGFuY2VTdG9wcGVkXCIsIFwiQ2hhbmdlZFwiXSwgXCJvblwiKTtcblxuXHQvL2RlcHJlY2F0ZWRcblx0YXBwX3Byb3RvLm9uX2FkZGVkID0gZGVwcmVjYXRlKGFwcF9wcm90by5vbkFkZGVkLCAnYXBwbGljYXRpb24ub25fYWRkZWQgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgYXBwbGljYXRpb24ub25BZGRlZCgpIGluc3RlYWQnKTtcblx0YXBwX3Byb3RvLm9uX3JlbW92ZWQgPSBkZXByZWNhdGUoYXBwX3Byb3RvLm9uUmVtb3ZlZCwgJ2FwcGxpY2F0aW9uLm9uX3JlbW92ZWQgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgYXBwbGljYXRpb24ub25SZW1vdmVkKCkgaW5zdGVhZCcpO1xuXHRhcHBfcHJvdG8ub25fYXZhaWxhYmxlID0gZGVwcmVjYXRlKGFwcF9wcm90by5vbkF2YWlsYWJsZSwgJ2FwcGxpY2F0aW9uLm9uX2F2YWlsYWJsZSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBhcHBsaWNhdGlvbi5vbkF2YWlsYWJsZSgpIGluc3RlYWQnKTtcblx0YXBwX3Byb3RvLm9uX3VuYXZhaWxhYmxlID0gZGVwcmVjYXRlKGFwcF9wcm90by5vblVuYXZhaWxhYmxlLCAnYXBwbGljYXRpb24ub25fdW5hdmFpbGFibGUgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgYXBwbGljYXRpb24ub25VbmF2YWlsYWJsZSgpIGluc3RlYWQnKTtcblx0YXBwX3Byb3RvLm9uX2luc3RhbmNlX3N0YXJ0ZWQgPSBkZXByZWNhdGUoYXBwX3Byb3RvLm9uSW5zdGFuY2VTdGFydGVkLCAnYXBwbGljYXRpb24ub25faW5zdGFuY2Vfc3RhcnRlZCBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBhcHBsaWNhdGlvbi5vbkluc3RhbmNlU3RhcnRlZCgpIGluc3RlYWQnKTtcblx0YXBwX3Byb3RvLm9uX2luc3RhbmNlX3N0b3BwZWQgPSBkZXByZWNhdGUoYXBwX3Byb3RvLm9uSW5zdGFuY2VTdG9wcGVkLCAnYXBwbGljYXRpb24ub25faW5zdGFuY2Vfc3RvcHBlZCBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBhcHBsaWNhdGlvbi5vbkluc3RhbmNlU3RvcHBlZCgpIGluc3RlYWQnKTtcblx0YXBwX3Byb3RvLm9uX2NoYW5nZWQgPSBkZXByZWNhdGUoYXBwX3Byb3RvLm9uQ2hhbmdlZCwgJ2FwcGxpY2F0aW9uLm9uX2NoYW5nZWQgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgYXBwbGljYXRpb24ub25DaGFuZ2VkKCkgaW5zdGVhZCcpO1xuXG5cblx0Ly9jb25zdHJ1Y3RvciwgaW5pdF9ldmVudCwgaWRfZmllbGRcblx0ZnVuY3Rpb24gdXBkYXRlX2FwcChwcm9wcywgb2JqKSB7XG5cdFx0b2JqLm5hbWUgPSBwcm9wcy5OYW1lO1xuXHRcdG9iai50aXRsZSA9IHByb3BzLlRpdGxlO1xuXHRcdG9iai52ZXJzaW9uID0gcHJvcHMuVmVyc2lvbjtcblx0XHRvYmouaW5zdGFuY2VzID0gW107XG5cdFx0b2JqLmNvbmZpZ3VyYXRpb24gPSB7fTtcblx0XHRvYmouY29uZmlndXJhdGlvbi5hdXRvX3N0YXJ0ID0gcHJvcHMuQXV0b1N0YXJ0O1xuXHRcdG9iai5jb25maWd1cmF0aW9uLmNhcHRpb24gPSBwcm9wcy5DYXB0aW9uO1xuXHRcdG9iai5jb25maWd1cmF0aW9uLmhpZGRlbiA9IHByb3BzLklzSGlkZGVuO1xuXHRcdG9iai5jb25maWd1cmF0aW9uLmNvbnRhaW5lciA9IHByb3BzLkFwcGxpY2F0aW9uTmFtZTtcblx0XHRvYmouY29uZmlndXJhdGlvbi5hY3Rpdml0eVR5cGUgPSBwcm9wcy5BY3Rpdml0eVR5cGU7XG5cdFx0Ly9vYmouZGlzYWJsZWQgPSBwcm9wcy5Jc0Rpc2FibGVkO1xuXHRcdG9iai5jb25maWd1cmF0aW9uLmFsbG93X211bHRpcGxlID0gcHJvcHMuQWxsb3dNdWx0aXBsZTtcblx0XHRvYmouYXZhaWxhYmxlID0gcHJvcHMuSXNSZWFkeSB8fCBmYWxzZTtcblx0XHRvYmouaWNvbiA9IHByb3BzLkljb247XG5cdFx0b2JqLnNvcnRPcmRlciA9IHByb3BzLlNvcnRPcmRlcjtcblx0XHRvYmoudXNlclByb3BlcnRpZXMgPSBwcm9wcy5Vc2VyUHJvcGVydGllcztcblx0XHRyZXR1cm4gb2JqO1xuXHR9XG5cblx0dmFyIGFwcFRvRXZlbnRNYW5hZ2VyID0ge1xuXHRcdGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlX2FwcChwcm9wcykge1xuXHRcdFx0cmV0dXJuIHVwZGF0ZV9hcHAocHJvcHMsIE9iamVjdC5jcmVhdGUoYXBwX3Byb3RvKSk7XG5cdFx0fSxcblx0XHR1cGRhdGU6IHVwZGF0ZV9hcHAsXG5cdFx0aW5pdF9ldmVudDogXCJhZGRlZFwiLFxuXHRcdGV4aXRfZXZlbnQ6IFwicmVtb3ZlZFwiLFxuXHRcdGlkX2ZpZWxkOiBcIk5hbWVcIixcblx0XHRjYWxsYmFja3M6IHtcblx0XHRcdGF2YWlsYWJsZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLmF2YWlsYWJsZSA9IHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0Y2hhbmdlZDogZnVuY3Rpb24gKHByb3BzKSB7XG5cdFx0XHRcdHRoaXMuaWNvbiA9IHByb3BzLkljb247XG5cdFx0XHRcdHRoaXMudGl0bGUgPSBwcm9wcy5UaXRsZTtcblx0XHRcdFx0dGhpcy5jb25maWd1cmF0aW9uLmNhcHRpb24gPSBwcm9wcy5DYXB0aW9uO1xuXHRcdFx0fSxcblx0XHRcdHVuYXZhaWxhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMuYXZhaWxhYmxlID0gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0aW5zdGFuY2VTdGFydGVkOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcblx0XHRcdFx0dGhpcy5pbnN0YW5jZXMucHVzaChpbnN0YW5jZSk7XG5cdFx0XHR9LFxuXHRcdFx0aW5zdGFuY2VTdG9wcGVkOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcblx0XHRcdFx0dGhpcy5pbnN0YW5jZXMgPSB0aGlzLmluc3RhbmNlcy5maWx0ZXIoZnVuY3Rpb24gKG15X2luc3RhbmNlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG15X2luc3RhbmNlICE9PSBpbnN0YW5jZTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vZGVwcmVjYXRlZFxuXHRhcHBUb0V2ZW50TWFuYWdlci5jYWxsYmFja3MuaW5zdGFuY2Vfc3RhcnRlZCA9IGRlcHJlY2F0ZShhcHBUb0V2ZW50TWFuYWdlci5jYWxsYmFja3MuaW5zdGFuY2VTdGFydGVkLCAnYXBwbGljYXRpb24uaW5zdGFuY2Vfc3RhcnRlZCBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBhcHBsaWNhdGlvbi5pbnN0YW5jZVN0YXJ0ZWQoKSBpbnN0ZWFkJyk7XG5cdGFwcFRvRXZlbnRNYW5hZ2VyLmNhbGxiYWNrcy5pbnN0YW5jZV9zdG9wcGVkID0gZGVwcmVjYXRlKGFwcFRvRXZlbnRNYW5hZ2VyLmNhbGxiYWNrcy5pbnN0YW5jZVN0b3BwZWQsICdhcHBsaWNhdGlvbi5pbnN0YW5jZV9zdG9wcGVkIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGFwcGxpY2F0aW9uLmluc3RhbmNlU3RvcHBlZCgpIGluc3RlYWQnKTtcblxuXG5cdHJldHVybiBldmVudF9tYW5hZ2VyKGFwcFRvRXZlbnRNYW5hZ2VyKTtcbn07XG4iLCJ2YXIgaGVscGVycyA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XG5cbmZ1bmN0aW9uIGV4ZWNfY2FsbGJhY2tzKG9iaiwgYXJyLCB2YWwpIHtcblx0aWYgKGFyciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0YXJyLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0XHRjYWxsYmFjay5jYWxsKG9iaiwgdmFsKTtcblx0XHR9KTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZV9lbnZpcm9ubWVudChzZXR0aW5ncykge1xuXHR2YXIgb2JqZWN0cyA9IHt9O1xuXHR2YXIgZ2xvYmFsX2NhbGxiYWNrcyA9IHt9O1xuXHRyZXR1cm4ge1xuXHRcdGFsbDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGhlbHBlcnMudmFscyhvYmplY3RzKTtcblx0XHR9LFxuXHRcdGdldF9ieV9pZDogZnVuY3Rpb24gKGlkKSB7XG5cdFx0XHRyZXR1cm4gb2JqZWN0c1tpZF07XG5cdFx0fSxcblx0XHRfdHJpZ2dlcjogZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBpZCkge1xuXHRcdFx0aWQgPSBpZCB8fCAoIHR5cGVvZiBzZXR0aW5ncy5pZF9maWVsZCA9PT0gXCJmdW5jdGlvblwiID8gc2V0dGluZ3MuaWRfZmllbGQocHJvcHMpIDogcHJvcHNbc2V0dGluZ3MuaWRfZmllbGRdKTtcblxuXHRcdFx0Ly9RdWl0IGlmIHdlIHJlY2VpdmUgYW4gZXZlbnQgZm9yIGFuIG9iamVjdCBiZWZvcmUgaW5pdGlhdGluZyBpdC5cblx0XHRcdGlmIChvYmplY3RzW2lkXSA9PT0gdW5kZWZpbmVkICYmICggdHlwZSAhPT0gc2V0dGluZ3MuaW5pdF9ldmVudCAmJiB0eXBlICE9PSBzZXR0aW5ncy5jcmVhdGVfZXZlbnQpKSB7XG5cdFx0XHRcdC8vY29uc29sZS5sb2cgKFwiUmVjZWl2ZWQgJ1wiK3R5cGUrXCInIGV2ZW50IGJlZm9yZSAnXCIrc2V0dGluZ3MuaW5pdF9ldmVudCtcIidcIik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXG5cdFx0XHQvL0NyZWF0ZSBvciByZXRyaWV2ZSBhbiBvYmplY3QsIHJlcHJlc2VudGluZyB0aGUgZW50aXR5XG5cdFx0XHR2YXIgb2JqID0gb2JqZWN0c1tpZF0gPSBvYmplY3RzW2lkXSB8fCBpbml0X29iamVjdChzZXR0aW5ncy5jcmVhdGUocHJvcHMpKTtcblxuXHRcdFx0aWYgKHR5cGUgPT09IHNldHRpbmdzLmluaXRfZXZlbnQpIHtcblx0XHRcdFx0Ly9RdWl0IGlmIHdlIHJlY2VpdmUgYSBpbml0IGV2ZW50IGZvciBhbiBvYmplY3QgdGhhdCBpcyBhbHJlYWR5IGFjdGl2ZVxuXHRcdFx0XHRpZiAob2JqLmFjdGl2ZSkge1xuXHRcdFx0XHRcdC8vY29uc29sZS5sb2cgKFwiUmVjZWl2ZWQgc2Vjb25kICdcIitzZXR0aW5ncy5pbml0X2V2ZW50K1wiJyBmb3IgYXBwIFwiK2lkKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0Ly9FbHNlLCBtYWtlIGl0IGFjdGl2ZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG9iai5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0XHRcdHNldHRpbmdzLnVwZGF0ZShwcm9wcywgb2JqKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL1doZW4gdGhlIGVudGl0eSBpcyByZW1vdmVkLCBzZXQgaXQgdG8gbm9uLWFjdGl2ZVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSBzZXR0aW5ncy5leGl0X2V2ZW50KSB7XG5cdFx0XHRcdG9iai5hY3RpdmUgPSBmYWxzZTtcblxuXHRcdFx0XHQvL1doZW4gYSBjcmVhdGUgZXZlbnQgaXMgcmVjZWl2ZWQsIGp1c3QgcmV0dXJuIHRoZSBvYmplY3Qgd2l0aG91dCBkb2luZyBhbnl0aGluZyBlbHNlXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IHNldHRpbmdzLmNyZWF0ZV9ldmVudCkge1xuXHRcdFx0XHRyZXR1cm4gb2JqO1xuXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IHNldHRpbmdzLnVwZGF0ZV9ldmVudCkge1xuXHRcdFx0XHRzZXR0aW5ncy51cGRhdGUocHJvcHMsIG9iaik7XG5cdFx0XHR9XG5cblx0XHRcdC8vRXhlY3V0ZSBzeXN0ZW0gY2FsbGJhY2tzXG5cdFx0XHRpZiAoc2V0dGluZ3MuY2FsbGJhY2tzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0c2V0dGluZ3MuY2FsbGJhY2tzW3R5cGVdLmNhbGwob2JqLCBwcm9wcyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIG1ha2Ugc3VyZSB0aGF0IGVycm9ycyBpbiB1c2VyIHNwZWNpZmllZCBjYWxsYmFja3MgZG9lcyBub3Rcblx0XHRcdC8vIGJyZWFrIG91ciBsaWJyYXJ5XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvL0V4ZWN1dGUgZ2xvYmFsIGNhbGxiYWNrc1xuXHRcdFx0XHRleGVjX2NhbGxiYWNrcyh1bmRlZmluZWQsIGdsb2JhbF9jYWxsYmFja3NbdHlwZV0sIG9iaik7XG5cblx0XHRcdFx0Ly9FeGVjdXRlIHVzZXItZGVmaW5lZCBjYWxsYmFja3MgdGhhdCBhcmUgYXR0YWNoZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRleGVjX2NhbGxiYWNrcyhvYmosIG9iai5jYWxsYmFja3NbdHlwZV0sIHByb3BzKTtcblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKXtcblx0XHRcdFx0Y29uc29sZS5lcnJvcihlKTtcblx0XHRcdH1cblx0XHRcdC8vV2hlbiB0aGUgZW50aXR5IGlzIHJlbW92ZWQsIHJlbW92ZSBhbGwgY2FsbGJhY2tzIChhZnRlciB5b3UgZXhlY3V0ZSB0aGVtKVxuXHRcdFx0aWYgKHR5cGUgPT09IHNldHRpbmdzLmV4aXRfZXZlbnQpIHtcblx0XHRcdFx0b2JqLmNhbGxiYWNrcyA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9iajtcblxuXHRcdH0sXG5cdFx0Ly9FeHBvc2UgdGhlIGdsb2JhbCBjYWxsYmFja3Mgb2JqZWN0IHNvIHRoYXQgdXNlciBjYW4gcmVnaXN0ZXIgc29tZVxuXHRcdGNhbGxiYWNrczogZ2xvYmFsX2NhbGxiYWNrc1xuXHR9O1xufTtcblxuZnVuY3Rpb24gaW5pdF9vYmplY3Qob2JqZWN0KSB7XG5cdG9iamVjdC5jYWxsYmFja3MgPSB7fTtcblx0b2JqZWN0LmFjdGl2ZSA9IGZhbHNlO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuIiwiZnVuY3Rpb24gbm9vcCgpe31cblxuZnVuY3Rpb24gZXhlY19pZihjb25kaXRpb24pIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChhcHAsIGNhbGxiYWNrKSB7XG5cdFx0aWYgKGNvbmRpdGlvbihhcHApKSB7XG5cdFx0XHRjYWxsYmFjay5jYWxsKGFwcCk7XG5cdFx0fVxuXHR9O1xufVxuXG5leHBvcnRzLmFkZF9jYWxsYmFja3MgPSBmdW5jdGlvbiBhZGRfY2FsbGJhY2tzKG9iamVjdCwgZXZlbnRzLCBwcmVmaXgpIHtcblx0ZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYgKHR5cGVvZiBldmVudCA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0ZXZlbnQgPSB7bmFtZTogZXZlbnQsIHRyaWdnZXJfd2hlbjogbm9vcH07XG5cdFx0fVxuXHRcdG9iamVjdFtwcmVmaXggKyBldmVudC5uYW1lXSA9IGV4cG9ydHMuYWRkX2NhbGxiYWNrKGV2ZW50Lm5hbWUsIGV4ZWNfaWYoZXZlbnQudHJpZ2dlcl93aGVuKSk7XG5cdH0pO1xuXHRyZXR1cm4gb2JqZWN0O1xuXG59O1xuXG5leHBvcnRzLmFkZF9jYWxsYmFjayA9IGZ1bmN0aW9uIGFkZF9jYWxsYmFjayhrZXksIG9uX2FkZCl7XG5cdHJldHVybiBmdW5jdGlvbihjYWxsYmFjayl7XG5cdFx0dmFyIG9iaiA9IHRoaXMuY2FsbGJhY2tzO1xuXHRcdGlmKHR5cGVvZiBrZXkgIT09ICd1bmRlZmluZWQnKXtcblx0XHRcdGtleSA9IGtleS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgxKTtcblx0XHR9XG5cdFx0XHRcblx0XHRpZihvYmpba2V5XT09PXVuZGVmaW5lZCl7XG5cdFx0XHRvYmpba2V5XSA9IFtjYWxsYmFja107XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0b2JqW2tleV0ucHVzaChjYWxsYmFjayk7XG5cdFx0fVxuXHRcdGlmKHR5cGVvZiBvbl9hZGQgPT09IFwiZnVuY3Rpb25cIil7XG5cdFx0XHRvbl9hZGQodGhpcywgY2FsbGJhY2spO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcbn07XG5cbmV4cG9ydHMudmFscyA9IGZ1bmN0aW9uIHZhbHMob2JqKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZShmdW5jdGlvbiAoYXJyLCBrZXkpIHtcblx0XHRhcnIucHVzaChvYmpba2V5XSk7XG5cdFx0cmV0dXJuIGFycjtcblx0fSwgW10pO1xufTtcbiIsInZhciBldmVudF9tYW5hZ2VyID0gcmVxdWlyZShcIi4vZXZlbnRfbWFuYWdlclwiKTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcbnZhciBkZXByZWNhdGUgPSByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFnbSwgYXBwcykge1xuXHR2YXIgaW5zdGFuY2VfcHJvdG8gPSBoZWxwZXJzLmFkZF9jYWxsYmFja3Moe1xuXHRcdHN0b3A6IGZ1bmN0aW9uIChwYXJhbXMsIHN1Y2Nlc3MsIGVycm9yKSB7XG5cdFx0XHRhZ20uaW52b2tlKFwiVDQyLkFDUy5TdG9wQXBwbGljYXRpb25cIiwge05hbWU6IHRoaXMuYXBwbGljYXRpb24ubmFtZSwgSWQ6IHRoaXMuaWR9LCBcImJlc3RcIiwge30sIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGUpO1xuXHRcdFx0fSwgZXJyb3IpO1xuXHRcdH0sXG5cdFx0YWN0aXZhdGU6IGZ1bmN0aW9uIChwYXJhbXMsIHN1Y2Nlc3MsIGVycm9yKSB7XG5cdFx0XHRhZ20uaW52b2tlKFwiVDQyLkFDUy5BY3RpdmF0ZUFwcGxpY2F0aW9uXCIsIHtOYW1lOiB0aGlzLmFwcGxpY2F0aW9uLm5hbWUsIElkOiB0aGlzLmlkfSwgXCJiZXN0XCIsIHt9LCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhlKTtcblx0XHRcdH0sIGVycm9yKTtcblx0XHR9XG5cdH0sIFtcblx0XHR7XG5cdFx0XHRuYW1lOiBcIldpbmRvd0FkZGVkXCIsIHRyaWdnZXJfd2hlbjogZnVuY3Rpb24gKGFwcCkgIFx0e1xuXHRcdFx0cmV0dXJuIGFwcC5hY3RpdmUgJiYgYXBwLm1haW5fd2luZG93ICE9PSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0bmFtZTogXCJXaW5kb3dSZW1vdmVkXCIsIHRyaWdnZXJfd2hlbjogZnVuY3Rpb24gKGFwcCkge1xuXHRcdFx0cmV0dXJuIGFwcC5tYWluX3dpbmRvdyA9PT0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR9LFxuXHRcdHtcblx0XHRcdG5hbWU6IFwiU3RhcnRlZFwiLCB0cmlnZ2VyX3doZW46IGZ1bmN0aW9uIChhcHApIHtcblx0XHRcdHJldHVybiBhcHAuaWQgIT09IHVuZGVmaW5lZCAmJiBhcHAuYWN0aXZlO1xuXHRcdH1cblx0XHR9LFxuXHRcdHtcblx0XHRcdG5hbWU6IFwiU3RvcHBlZFwiLCB0cmlnZ2VyX3doZW46IGZ1bmN0aW9uIChhcHApIHtcblx0XHRcdHJldHVybiBhcHAuaWQgIT09IHVuZGVmaW5lZCAmJiAhYXBwLmFjdGl2ZTtcblx0XHR9XG5cdFx0fSxcblx0XHR7XG5cdFx0XHRuYW1lOiBcIkFnbVJlYWR5XCIsIHRyaWdnZXJfd2hlbjogZnVuY3Rpb24gKGFwcCkge1xuXHRcdFx0cmV0dXJuIGFwcC5hY3RpdmUgJiYgYXBwLmFnbSAhPT0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR9LFxuXHRcdHtcblx0XHRuYW1lOiBcIkVycm9yXCIsIHRyaWdnZXJfd2hlbjogZnVuY3Rpb24gKGFwcCkge1xuXHRcdHJldHVybiBhcHAuZXJyb3IgIT09IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0fSxcblx0XSwgXCJvblwiKTtcblxuXHQvL2RlcHJlY2F0ZWRcblx0aW5zdGFuY2VfcHJvdG8ub25fd2luZG93X2FkZGVkID0gZGVwcmVjYXRlKGluc3RhbmNlX3Byb3RvLm9uV2luZG93QWRkZWQsICdpbnN0YW5jZS5vbl93aW5kb3dfYWRkZWQgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgaW5zdGFuY2Uub25XaW5kb3dBZGRlZCgpIGluc3RlYWQnKTtcblx0aW5zdGFuY2VfcHJvdG8ub25fd2luZG93X3JlbW92ZWQgPSBkZXByZWNhdGUoaW5zdGFuY2VfcHJvdG8ub25XaW5kb3dSZW1vdmVkLCAnaW5zdGFuY2Uub25fd2luZG93X3JlbW92ZWQgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgaW5zdGFuY2Uub25XaW5kb3dSZW1vdmVkKCkgaW5zdGVhZCcpO1xuXHRpbnN0YW5jZV9wcm90by5vbl9zdGFydGVkID0gZGVwcmVjYXRlKGluc3RhbmNlX3Byb3RvLm9uU3RhcnRlZCwgJ2luc3RhbmNlLm9uX3N0YXJ0ZWQgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgaW5zdGFuY2Uub25TdGFydGVkKCkgaW5zdGVhZCcpO1xuXHRpbnN0YW5jZV9wcm90by5vbl9zdG9wcGVkID0gZGVwcmVjYXRlKGluc3RhbmNlX3Byb3RvLm9uU3RvcHBlZCwgJ2luc3RhbmNlLm9uX3N0b3BwZWQgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgaW5zdGFuY2Uub25TdG9wcGVkKCkgaW5zdGVhZCcpO1xuXHRpbnN0YW5jZV9wcm90by5vbl9hZ21fcmVhZHkgPSBkZXByZWNhdGUoaW5zdGFuY2VfcHJvdG8ub25BZ21SZWFkeSwgJ2luc3RhbmNlLm9uX2FnbV9yZWFkeSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBpbnN0YW5jZS5vbkFnbVJlYWR5KCkgaW5zdGVhZCcpO1xuXHRpbnN0YW5jZV9wcm90by5vbl9lcnJvciA9IGRlcHJlY2F0ZShpbnN0YW5jZV9wcm90by5vbkVycm9yLCAnaW5zdGFuY2Uub25fZXJyb3IgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgaW5zdGFuY2Uub25FcnJvcigpIGluc3RlYWQnKTtcblxuXHRmdW5jdGlvbiB1cGRhdGVfaW5zdGFuY2UocHJvcHMsIG9iaikge1xuXHRcdG9iai5pZCA9IHByb3BzLklkO1xuXHRcdG9iai5hcHBsaWNhdGlvbiA9IGFwcHMuZ2V0X2J5X2lkKHByb3BzLk5hbWUpO1xuXHRcdG9iai5jb250ZXh0ID0gcHJvcHMuQ29udGV4dDtcblx0XHRvYmoudGl0bGUgPSBwcm9wcy5UaXRsZTtcblx0XHRvYmouYWN0aXZpdHlJZCA9IHByb3BzLkFjdGl2aXR5SWQ7XG5cdFx0cmV0dXJuIG9iajtcblx0fVxuXG5cdHZhciBpbnN0YW5jZVRvRXZlbnRNYW5hZ2VyID17XG5cdFx0Y3JlYXRlOiBmdW5jdGlvbiAocHJvcHMpIHtcblx0XHRcdHJldHVybiB1cGRhdGVfaW5zdGFuY2UocHJvcHMsIE9iamVjdC5jcmVhdGUoaW5zdGFuY2VfcHJvdG8pKTtcblx0XHR9LFxuXHRcdHVwZGF0ZTogdXBkYXRlX2luc3RhbmNlLFxuXHRcdGNyZWF0ZV9ldmVudDogXCJjcmVhdGVcIixcblx0XHRpbml0X2V2ZW50OiBcInN0YXJ0ZWRcIixcblx0XHRleGl0X2V2ZW50OiBcInN0b3BwZWRcIixcbiAgICBcdHVwZGF0ZV9ldmVudDogXCJ1cGRhdGVkXCIsXG5cdFx0aWRfZmllbGQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRyZXR1cm4gZS5Db250ZXh0ICE9PSB1bmRlZmluZWQgJiYgZS5Db250ZXh0Lmd1aWQgIT09IHVuZGVmaW5lZCA/IGUuQ29udGV4dC5ndWlkIDogZS5JZDtcblx0XHR9LFxuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0YWdtUmVhZHk6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdC8vZ2V0IHRoZSBmaXJzdCBBR01cblx0XHRcdFx0dmFyIHNlcnZlcl9uYW1lID0gT2JqZWN0LmtleXMoZS5BZ21TZXJ2ZXJzKVswXTtcblx0XHRcdFx0Ly9BdHRhY2ggaXQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHR0aGlzLmFnbSA9IGNvbnZlcnRfYWdtX2luc3RhbmNlKGUuQWdtU2VydmVyc1tzZXJ2ZXJfbmFtZV0pO1xuXHRcdFx0fSxcblx0XHRcdGVycm9yOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHR0aGlzLmVycm9yID0gZTtcblx0XHRcdH0sXG5cdFx0XHR3aW5kb3dBZGRlZDogZnVuY3Rpb24gKHdpbikge1xuXHRcdFx0XHR0aGlzLm1haW5fd2luZG93ID0gd2luO1xuXHRcdFx0XHR0aGlzLndpbmRvd3MgPSB0aGlzLndpbmRvd3MgfHwgW107XG5cdFx0XHRcdHRoaXMud2luZG93cy5wdXNoKHdpbik7XG5cdFx0XHR9LFxuXHRcdFx0d2luZG93UmVtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLm1haW5fd2luZG93ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR0aGlzLndpbmRvd3MgPSBbXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvL2RlcHJlY2F0ZWRcblx0aW5zdGFuY2VUb0V2ZW50TWFuYWdlci5jYWxsYmFja3MuYWdtX3JlYWR5ID0gZGVwcmVjYXRlKGluc3RhbmNlVG9FdmVudE1hbmFnZXIuY2FsbGJhY2tzLmFnbVJlYWR5LCAnaW5zdGFuY2UuYWdtX3JlYWR5IGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGluc3RhbmNlLmFnbVJlYWR5KCkgaW5zdGVhZCcpO1xuXHRpbnN0YW5jZVRvRXZlbnRNYW5hZ2VyLmNhbGxiYWNrcy53aW5kb3dfYWRkZWQgPSBkZXByZWNhdGUoaW5zdGFuY2VUb0V2ZW50TWFuYWdlci5jYWxsYmFja3Mud2luZG93QWRkZWQsICdpbnN0YW5jZS53aW5kb3dfYWRkZWQgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgaW5zdGFuY2Uud2luZG93QWRkZWQoKSBpbnN0ZWFkJyk7XG5cdGluc3RhbmNlVG9FdmVudE1hbmFnZXIuY2FsbGJhY2tzLndpbmRvd19yZW1vdmVkID0gZGVwcmVjYXRlKGluc3RhbmNlVG9FdmVudE1hbmFnZXIuY2FsbGJhY2tzLndpbmRvd1JlbW92ZWQsICdpbnN0YW5jZS53aW5kb3dfcmVtb3ZlZCBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBpbnN0YW5jZS53aW5kb3dSZW1vdmVkKCkgaW5zdGVhZCcpO1xuXG5cdHJldHVybiBldmVudF9tYW5hZ2VyKGluc3RhbmNlVG9FdmVudE1hbmFnZXIpO1xufTtcblxuZnVuY3Rpb24gY29udmVydF9hZ21faW5zdGFuY2UoYWdtKSB7XG5cdHJldHVybiB7XG5cdFx0bWFjaGluZTogYWdtLm1hY2hpbmVOYW1lLFxuXHRcdHVzZXI6IGFnbS51c2VyTmFtZSxcblx0XHRlbnZpcm9ubWVudDogYWdtLmVudmlyb25tZW50LFxuXHRcdGFwcGxpY2F0aW9uOiBhZ20uYXBwbGljYXRpb25OYW1lXG5cblx0fTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJfYXJnc1wiOiBbXG4gICAgW1xuICAgICAgXCJ0aWNrNDItYXBwLW1hbmFnZXJAMi41LjBcIixcbiAgICAgIFwiQzpcXFxcd29ya1xcXFxzdGFzaFxcXFxHTFVFLWRldlxcXFxqcy1nbHVlXCJcbiAgICBdXG4gIF0sXG4gIFwiX2Zyb21cIjogXCJ0aWNrNDItYXBwLW1hbmFnZXJAMi41LjBcIixcbiAgXCJfaWRcIjogXCJ0aWNrNDItYXBwLW1hbmFnZXJAMi41LjBcIixcbiAgXCJfaW5DYWNoZVwiOiB0cnVlLFxuICBcIl9pbnN0YWxsYWJsZVwiOiB0cnVlLFxuICBcIl9sb2NhdGlvblwiOiBcIi90aWNrNDItYXBwLW1hbmFnZXJcIixcbiAgXCJfbm9kZVZlcnNpb25cIjogXCI2LjMuMFwiLFxuICBcIl9ucG1Vc2VyXCI6IHt9LFxuICBcIl9ucG1WZXJzaW9uXCI6IFwiMy44LjVcIixcbiAgXCJfcGhhbnRvbUNoaWxkcmVuXCI6IHt9LFxuICBcIl9yZXF1ZXN0ZWRcIjoge1xuICAgIFwibmFtZVwiOiBcInRpY2s0Mi1hcHAtbWFuYWdlclwiLFxuICAgIFwicmF3XCI6IFwidGljazQyLWFwcC1tYW5hZ2VyQDIuNS4wXCIsXG4gICAgXCJyYXdTcGVjXCI6IFwiMi41LjBcIixcbiAgICBcInNjb3BlXCI6IG51bGwsXG4gICAgXCJzcGVjXCI6IFwiMi41LjBcIixcbiAgICBcInR5cGVcIjogXCJ2ZXJzaW9uXCJcbiAgfSxcbiAgXCJfcmVxdWlyZWRCeVwiOiBbXG4gICAgXCIvXCJcbiAgXSxcbiAgXCJfc2hhc3VtXCI6IFwiZGIwMjA2ZjFhNjgxYWIyOGZjYTE2NmFjYTI3MjVlMTE4NGZlNjkzNFwiLFxuICBcIl9zaHJpbmt3cmFwXCI6IG51bGwsXG4gIFwiX3NwZWNcIjogXCJ0aWNrNDItYXBwLW1hbmFnZXJAMi41LjBcIixcbiAgXCJfd2hlcmVcIjogXCJDOlxcXFx3b3JrXFxcXHN0YXNoXFxcXEdMVUUtZGV2XFxcXGpzLWdsdWVcIixcbiAgXCJhdXRob3JcIjoge1xuICAgIFwibmFtZVwiOiBcIlRpY2s0MlwiLFxuICAgIFwidXJsXCI6IFwiaHR0cDovL3d3dy50aWNrNDIuY29tXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge30sXG4gIFwiZGVzY3JpcHRpb25cIjogXCJBcHAgTWFuYWdlciBBUEkgZm9yIEphdmFTY3JpcHRcIixcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYmxhbmtldFwiOiBcIl4xLjEuNlwiLFxuICAgIFwiYm9vdHN0cmFwXCI6IFwiXjMuMy40XCIsXG4gICAgXCJicm93c2VyaWZ5LXZlcnNpb25pZnlcIjogXCJeMS4wLjRcIixcbiAgICBcImdydW50XCI6IFwiXjAuNC41XCIsXG4gICAgXCJncnVudC1icm93c2VyaWZ5XCI6IFwiXjMuMy4wXCIsXG4gICAgXCJncnVudC1jbGlcIjogXCJeMC4xLjBcIixcbiAgICBcImdydW50LWNvbnRyaWItY2xlYW5cIjogXCJeMC42LjBcIixcbiAgICBcImdydW50LWNvbnRyaWItY29ubmVjdFwiOiBcIl4wLjkuMFwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi1qc2hpbnRcIjogXCJeMC4xMS4wXCIsXG4gICAgXCJncnVudC1jb250cmliLXF1bml0XCI6IFwiXjAuNS4yXCIsXG4gICAgXCJncnVudC1jb250cmliLXVnbGlmeVwiOiBcIl4wLjYuMFwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi13YXRjaFwiOiBcIl4wLjYuMVwiLFxuICAgIFwiZ3J1bnQtZXhvcmNpc2VcIjogXCJeMS4wLjBcIixcbiAgICBcImh0dHAtc2VydmVyXCI6IFwiXjAuOC4wXCIsXG4gICAgXCJqcXVlcnlcIjogXCJeMi4xLjRcIixcbiAgICBcImxvZGFzaFwiOiBcIl4zLjkuM1wiLFxuICAgIFwicGhhbnRvbWpzXCI6IFwiXjEuOS4xMlwiLFxuICAgIFwicXVuaXRqc1wiOiBcIl4xLjE1LjBcIixcbiAgICBcInRpY2s0Mi1hZ21cIjogXCJeMS4zLjBcIixcbiAgICBcInVnbGlmeWlmeVwiOiBcIl4zLjAuMVwiXG4gIH0sXG4gIFwiZGlyZWN0b3JpZXNcIjoge1xuICAgIFwiZXhhbXBsZVwiOiBcImV4YW1wbGVzXCJcbiAgfSxcbiAgXCJkaXN0XCI6IHtcbiAgICBcInNoYXN1bVwiOiBcImRiMDIwNmYxYTY4MWFiMjhmY2ExNjZhY2EyNzI1ZTExODRmZTY5MzRcIixcbiAgICBcInRhcmJhbGxcIjogXCJodHRwOi8vMTkyLjE2OC4wLjIzNDo0ODczL3RpY2s0Mi1hcHAtbWFuYWdlci8tL3RpY2s0Mi1hcHAtbWFuYWdlci0yLjUuMC50Z3pcIlxuICB9LFxuICBcImdpdEhlYWRcIjogXCJjY2ZjOWQ5YjU4ZmUxNzFkYTM2ZDI2MzM3MjlhZDc1YWQ0NjgxYjMwXCIsXG4gIFwibGljZW5zZVwiOiBcIklTQ1wiLFxuICBcIm1haW5cIjogXCJsaWJyYXJ5L2FwcF9tYW5hZ2VyLmpzXCIsXG4gIFwibmFtZVwiOiBcInRpY2s0Mi1hcHAtbWFuYWdlclwiLFxuICBcIm9wdGlvbmFsRGVwZW5kZW5jaWVzXCI6IHt9LFxuICBcInJlYWRtZVwiOiBcIkVSUk9SOiBObyBSRUFETUUgZGF0YSBmb3VuZCFcIixcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vaWJhbHRhZHpoaWV2YUBzdGFzaC50aWNrNDIuY29tL3NjbS9vZmd3L2pzLWFwcC1tYW5hZ2VyLmdpdFwiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJwcmVwdWJsaXNoXCI6IFwiZ3J1bnRcIixcbiAgICBcInRlc3RcIjogXCJlY2hvIFxcXCJFcnJvcjogbm8gdGVzdCBzcGVjaWZpZWRcXFwiICYmIGV4aXQgMVwiXG4gIH0sXG4gIFwidmVyc2lvblwiOiBcIjIuNS4wXCJcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBhcHBjb25maWdcbiAqL1xudmFyIF8gPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vbW9kZWwnKTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5cbnZhciBldmVudHMgPSB7XG4gICAgY29ubmVjdDogJ2Nvbm5lY3QnLFxuICAgIGRpc2Nvbm5lY3Q6ICdkaXNjb25uZWN0JyxcbiAgICB1cGRhdGU6ICd1cGRhdGUnLFxuICAgIHN0YXR1czogJ3N0YXR1cydcbn07XG5cbnZhciBFdmVudEJ1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIHN1YnNjcmlwdGlvbnNCeVR5cGU7XG4gICAgdmFyIG9uID0gZnVuY3Rpb24gKHR5cGUsIG9uY2UsIGNhbGxiYWNrLCBzY29wZSkge1xuICAgICAgICBpZiAoIV8uaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgb25jZTogb25jZSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgICAgIHNjb3BlOiBzY29wZVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9uc0J5VHlwZVt0eXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdWJzY3JpcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9ucyA9IHN1YnNjcmlwdGlvbnNCeVR5cGVbdHlwZV0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1YnNjcmlwdGlvbi5pZCA9IHN1YnNjcmlwdGlvbnMucHVzaChzdWJzY3JpcHRpb24pIC0gMTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9O1xuXG4gICAgdmFyIGVtaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICB2YXIgdHlwZSA9IGFyZ3Muc3BsaWNlKDAsIDEpWzBdO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHN1YnNjcmlwdGlvbnNCeVR5cGVbdHlwZV07XG4gICAgICAgIGlmICh0eXBlb2Ygc3Vic2NyaXB0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMgPSBzdWJzY3JpcHRpb25zQnlUeXBlW3R5cGVdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBzdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgaWYgKCFzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmNhbGxiYWNrLmFwcGx5KHN1YnNjcmlwdGlvbi5zY29wZSwgYXJncyk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgICAgXy53YXJuKCdFeGNlcHRpb24gZHVyaW5nIGV4ZWN1dGlvbiBvZiBjYWxsYmFjaycsIHN1YnNjcmlwdGlvbiwgYXJncywgeCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24ub25jZSkge1xuICAgICAgICAgICAgICAgIG9mZihzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIG9mZiA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSBzdWJzY3JpcHRpb25zQnlUeXBlW3N1YnNjcmlwdGlvbi50eXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdWJzY3JpcHRpb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZGVsZXRlIHN1YnNjcmlwdGlvbnNbc3Vic2NyaXB0aW9uLmlkXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzdW1lID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIHN1YnNjcmlwdGlvbi5pZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBvbihzdWJzY3JpcHRpb24udHlwZSwgc3Vic2NyaXB0aW9uLm9uY2UsIHN1YnNjcmlwdGlvbi5jYWxsYmFjaywgc3Vic2NyaXB0aW9uLnNjb3BlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9uc0J5VHlwZVtzdWJzY3JpcHRpb24udHlwZV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN1YnNjcmlwdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9ucyA9IHN1YnNjcmlwdGlvbnNCeVR5cGVbc3Vic2NyaXB0aW9uLnR5cGVdID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnNbc3Vic2NyaXB0aW9uLmlkXSA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIHN1YnNjcmlwdGlvbnNCeVR5cGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzdWJzY3JpcHRpb25zQnlUeXBlKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSBzdWJzY3JpcHRpb25zQnlUeXBlW3R5cGVdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3Vic2NyaXB0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzdWJzY3JpcHRpb24uaWQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc3Vic2NyaXB0aW9uc0J5VHlwZSA9IHt9O1xuICAgIH07XG5cbiAgICByZXNldCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG9uOiBvbixcbiAgICAgICAgZW1pdDogZW1pdCxcbiAgICAgICAgb2ZmOiBvZmYsXG4gICAgICAgIHJlc3VtZTogcmVzdW1lLFxuICAgICAgICByZXNldDogcmVzZXRcblxuICAgIH07XG59O1xuXG52YXIgQXBwQ29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgZGVmYXVsdExpc3RlbiAgPSB0cnVlO1xuICAgIHZhciBnYXRld2F5O1xuICAgIHZhciBpbml0R2F0ZXdheTtcbiAgICB2YXIgYnVzID0gbmV3IEV2ZW50QnVzKCk7XG4gICAgdmFyIG1vZGVsID0gbmV3IE1vZGVsKGJ1cyk7XG5cbiAgICB2YXIgcm9vdCA9IHJlcXVpcmUoJy4vcHJvcHMnKShtb2RlbC5yb290KTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgZ2F0ZXdheUNvbm5lY3Rpb247XG4gICAgdmFyIHBvbGxpbmdJbnRlcnZhbElkO1xuICAgIHZhciBjbGVhclBvbGxpbmdJbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwb2xsaW5nSW50ZXJ2YWxJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwocG9sbGluZ0ludGVydmFsSWQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFB1YmxpYyBBUElcbiAgICBzZWxmLmluaXQgPSBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcbiAgICAgICAgdmFyIGlzSWRlbnRpdHlWYWxpZCA9IHR5cGVvZiBzZXR0aW5ncy5pZGVudGl0eSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICBPYmplY3Qua2V5cyhzZXR0aW5ncy5pZGVudGl0eSkubGVuZ3RoID4gMDtcblxuICAgICAgICBpZiAoaXNJZGVudGl0eVZhbGlkKSB7XG4gICAgICAgICAgICBzZWxmLmlkZW50aXR5ID0gc2V0dGluZ3MuaWRlbnRpdHk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0TGlzdGVuID0gc2V0dGluZ3MuZGVmYXVsdExpc3RlbiB8fCBkZWZhdWx0TGlzdGVuO1xuICAgICAgICBpZiAoIXNlbGYuaWRlbnRpdHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lkZW50aXR5IG11c3QgYmUgbm9uIGVtcHR5IG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vZGVsLnNlcGFyYXRvciA9IHNldHRpbmdzLmRlZmF1bHRTZXBhcmF0b3IgfHwgbW9kZWwuc2VwYXJhdG9yO1xuXG4gICAgICAgIHNlbGYuc2NoZW1hID0gc2V0dGluZ3Muc2NoZW1hIHx8IHNlbGYuc2NoZW1hIHx8ICdBcHBsaWNhdGlvbkNvbmZpZ3VyYXRpb24nO1xuXG4gICAgICAgIGluaXRHYXRld2F5ID0gXy5pc0Z1bmN0aW9uKHNldHRpbmdzLmdhdGV3YXkpXG4gICAgICAgID8gc2V0dGluZ3MuZ2F0ZXdheVxuICAgICAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MuZ2F0ZXdheSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5nYXRld2F5ID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MuZ2F0ZXdheS5pbnN0YW5jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5nYXRld2F5Lmluc3RhbmNlID0gXy51dWlkKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXF1aXJlKCcuL2dhdGV3YXknKShzZXR0aW5ncy5nYXRld2F5KTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgc2VsZi5jb25uZWN0ID0gZnVuY3Rpb24gKGxpc3RlbiwgY2FsbGJhY2ssIHNjb3BlKSB7XG4gICAgICAgIGNsZWFyUG9sbGluZ0ludGVydmFsKCk7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb247XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihsaXN0ZW4pKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBsaXN0ZW47XG4gICAgICAgICAgICAgICAgc2NvcGUgPSBjYWxsYmFjaztcbiAgICAgICAgICAgICAgICBsaXN0ZW4gPSBkZWZhdWx0TGlzdGVuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBidXMub24oZXZlbnRzLmNvbm5lY3QsIHRydWUsIGNhbGxiYWNrLCBzY29wZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIGlmICghc2VsZi5pZGVudGl0eSkge1xuICAgICAgICAgICAgZXJyb3IgPSAnaWRlbnRpdHkgaXMgbm90IHNwZWNpZmllZC4gZGlkIHlvdSBmb3JnZXQgdG8gY2FsbCBpbml0KCk/JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghZ2F0ZXdheSkge1xuICAgICAgICAgICAgICAgIGdhdGV3YXkgPSBpbml0R2F0ZXdheSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWxpc3Rlbikge1xuICAgICAgICAgICAgICAgIGdhdGV3YXlDb25uZWN0aW9uID1cbiAgICAgICAgICAgICAgICAgIGdhdGV3YXkuY29ubmVjdChcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaWRlbnRpdHksXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IsIHNuYXBzaG90KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmFwcGx5U25hcHNob3Qoc25hcHNob3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBidXMuZW1pdChldmVudHMuY29ubmVjdCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvciwgc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidXMuZW1pdChldmVudHMuc3RhdHVzLCBlcnJvciwgc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjb25uZWN0RW1pdHRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGdhdGV3YXlDb25uZWN0aW9uID0gZ2F0ZXdheS5jb25uZWN0KFxuICAgICAgICAgICAgICAgICAgc2VsZi5zY2hlbWEsXG4gICAgICAgICAgICAgICAgICBzZWxmLmlkZW50aXR5LFxuICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvciwgc25hcHNob3QsIHVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNuYXBzaG90ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5hcHBseVNuYXBzaG90KHNuYXBzaG90KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHVwZGF0ZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmFwcGx5VXBkYXRlcyh1cGRhdGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbm5lY3RFbWl0dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnVzLmVtaXQoZXZlbnRzLmNvbm5lY3QsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IsIHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBMSVNURU5fTk9UX1NVUFBPUlRFRCA9IDg7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBMSVNURU5fTk9UX1NVUFBPUlRFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwb2xsaW5nSW50ZXJ2YWxJZCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhdGV3YXkuZGlzY29ubmVjdChnYXRld2F5Q29ubmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXRld2F5Q29ubmVjdGlvbiA9IGdhdGV3YXkuY29ubmVjdChzZWxmLnNjaGVtYSwgc2VsZi5pZGVudGl0eSwgZmFsc2UsIGZ1bmN0aW9uIChlcnJvciwgc25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5hcHBseVNuYXBzaG90KHNuYXBzaG90LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMjAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoYnVzLmVtaXQsIDAsIGV2ZW50cy5jb25uZWN0LCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcblxuICAgIH07XG5cbiAgICBzZWxmLnByb3BzID0gZnVuY3Rpb24gKHNlY3Rpb24sIHNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gcm9vdC5wcm9wcyhzZWN0aW9uLCBzZXBhcmF0b3IpO1xuICAgIH07XG5cbiAgICBzZWxmLm1vZGlmeSA9IGZ1bmN0aW9uIChtb2RpZmljYXRpb25zLCBjYWxsYmFjaywgc2NvcGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmljYXRpb25zID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgbW9kaWZpY2F0aW9ucyA9IFttb2RpZmljYXRpb25zXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBidXMub24oZXZlbnRzLnVwZGF0ZSwgdHJ1ZSwgY2FsbGJhY2ssIHNjb3BlKTtcblxuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH07XG5cbiAgICBzZWxmLm9uQ29ubmVjdCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgc2NvcGUpIHtcbiAgICAgICAgcmV0dXJuIGJ1cy5vbihldmVudHMuY29ubmVjdCwgZmFsc2UsIGNhbGxiYWNrLCBzY29wZSk7XG5cbiAgICB9O1xuXG4gICAgc2VsZi5vbkRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHNjb3BlKSB7XG4gICAgICAgIHJldHVybiBidXMub24oZXZlbnRzLmRpc2Nvbm5lY3QsIGZhbHNlLCBjYWxsYmFjaywgc2NvcGUpO1xuICAgIH07XG5cbiAgICBzZWxmLm9mZiA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgYnVzLm9mZihzdWJzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHNlbGYub24gPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGJ1cy5yZXN1bWUoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHNjb3BlKSB7XG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgICBidXMub24oZXZlbnRzLmRpc2Nvbm5lY3QsIHRydWUsIGNhbGxiYWNrLCBzY29wZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclBvbGxpbmdJbnRlcnZhbCgpO1xuICAgICAgICBpZiAodHlwZW9mIGdhdGV3YXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBnYXRld2F5LmRpc2Nvbm5lY3QoZ2F0ZXdheUNvbm5lY3Rpb24sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGJ1cy5lbWl0KGV2ZW50cy5kaXNjb25uZWN0LCBlcnJvcik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZ2F0ZXdheSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1cy5lbWl0KGV2ZW50cy5kaXNjb25uZWN0LCAnbm90IGNvbm5lY3RlZCcpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbkFwcENvbmZpZy5wcm90b3R5cGUuaWRlbnRpdHlFcXVhbCA9IGhlbHBlcnMuaWRlbnRpdHlFcXVhbDtcbkFwcENvbmZpZy5wcm90b3R5cGUuaWRlbnRpdHlUb1N0cmluZyA9IGhlbHBlcnMuaWRlbnRpdHlUb1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHJldHVybiBuZXcgQXBwQ29uZmlnKCk7XG59O1xuIiwidmFyIGdhdGV3YXlDb25uZWN0aW9uID0gcmVxdWlyZSgndGljazQyLWdhdGV3YXktY29ubmVjdGlvbicpO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcbnZhciBpZGVudGl0eVRvU3RyaW5nID0gaGVscGVycy5pZGVudGl0eVRvU3RyaW5nO1xudmFyIFBST0RVQ1QgPSAnYXBwY29uZmlnJztcblxudmFyIEdhdGV3YXlUcmFuc3BvcnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgY29ubmVjdGlvbjtcbiAgICB2YXIgZGF0YUhhbmRsZXJzID0ge307XG4gICAgdmFyIHN0YXR1c0hhbmRsZXJzID0ge307XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdGF0dXNNZXNzYWdlKG1zZykge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHN0YXR1c0hhbmRsZXJzW21zZy5pbnN0YW5jZV07XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICBoYW5kbGVyKG1zZy5lcnJvciwgbXNnLnN0YXR1cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVEYXRhTWVzc2FnZShtc2cpIHtcbiAgICAgICAgdmFyIHNjaGVtYSA9IG1zZy5zY2hlbWE7XG4gICAgICAgIHZhciBzY2hlbWFIYW5kbGVycyA9IGRhdGFIYW5kbGVyc1tzY2hlbWFdO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYUhhbmRsZXJzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlkZW50aXR5S2V5ID0gaWRlbnRpdHlUb1N0cmluZyhtc2cuaWRlbnRpdHksIHRydWUpO1xuICAgICAgICB2YXIgaWRlbnRpdHlIYW5kbGVycyA9IHNjaGVtYUhhbmRsZXJzW2lkZW50aXR5S2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBpZGVudGl0eUhhbmRsZXJzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWRlbnRpdHlIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIobXNnLmVycm9yLCBtc2cuc25hcHNob3QsIG1zZy51cGRhdGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5zdXJlQ29ubmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoY29ubmVjdGlvbikgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29ubmVjdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uID0gb3B0aW9ucy5jb25uZWN0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uID0gZ2F0ZXdheUNvbm5lY3Rpb24ob3B0aW9ucy5zZXR0aW5ncywgb3B0aW9ucy5jdXN0b21fY29ubmVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGF0YVN1YnNjcmlwdGlvbjtcbiAgICB2YXIgc3RhdHVzU3Vic2NyaXB0aW9uO1xuICAgIHZhciBjb25uZWN0ID0gZnVuY3Rpb24gKHNjaGVtYSwgaWRlbnRpdHksIGxpc3RlbiwgaGFuZGxlciwgc3RhdHVzSGFuZGxlcikge1xuICAgICAgICBlbnN1cmVDb25uZWN0aW9uKCk7XG4gICAgICAgIHZhciBzY2hlbWFIYW5kbGVycyA9IGRhdGFIYW5kbGVyc1tzY2hlbWFdO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYUhhbmRsZXJzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc2NoZW1hSGFuZGxlcnMgPSBkYXRhSGFuZGxlcnNbc2NoZW1hXSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlkZW50aXR5S2V5ID0gaWRlbnRpdHlUb1N0cmluZyhpZGVudGl0eSwgdHJ1ZSk7XG4gICAgICAgIHZhciBpZGVudGl0eUhhbmRsZXJzID0gc2NoZW1hSGFuZGxlcnNbaWRlbnRpdHlLZXldO1xuICAgICAgICBpZiAodHlwZW9mIGlkZW50aXR5SGFuZGxlcnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZGVudGl0eUhhbmRsZXJzID0gc2NoZW1hSGFuZGxlcnNbaWRlbnRpdHlLZXldID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFuZGxlclRvUmVnaXN0ZXI7XG4gICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgaWYgKGxpc3Rlbikge1xuICAgICAgICAgICAgaGFuZGxlclRvUmVnaXN0ZXIgPSBoYW5kbGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlclRvUmVnaXN0ZXIgPSBmdW5jdGlvbiAoZXJyb3IsIHNuYXBzaG90LCB1cGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcihlcnJvciwgc25hcHNob3QsIHVwZGF0ZXMpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpZGVudGl0eUhhbmRsZXJzW2luZGV4XTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCA9IGlkZW50aXR5SGFuZGxlcnMucHVzaChoYW5kbGVyVG9SZWdpc3RlcikgLSAxO1xuXG4gICAgICAgIGlmICh0eXBlb2YgKGRhdGFTdWJzY3JpcHRpb24pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZGF0YVN1YnNjcmlwdGlvbiA9IGNvbm5lY3Rpb24ub24oUFJPRFVDVCwgR2F0ZXdheVRyYW5zcG9ydC5NZXNzYWdlVHlwZS5EQVRBLCBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRGF0YU1lc3NhZ2UobXNnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluc3RhbmNlID0gb3B0aW9ucy5pbnN0YW5jZTtcbiAgICAgICAgc3RhdHVzSGFuZGxlcnNbaW5zdGFuY2VdID0gc3RhdHVzSGFuZGxlcjtcbiAgICAgICAgaWYgKHR5cGVvZiAoc3RhdHVzU3Vic2NyaXB0aW9uKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHN0YXR1c1N1YnNjcmlwdGlvbiA9IGNvbm5lY3Rpb24ub24oUFJPRFVDVCwgR2F0ZXdheVRyYW5zcG9ydC5NZXNzYWdlVHlwZS5TVEFUVVMsIGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVTdGF0dXNNZXNzYWdlKG1zZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtc2cgPSB7XG4gICAgICAgICAgICBzY2hlbWE6IHNjaGVtYSxcbiAgICAgICAgICAgIGlkZW50aXR5OiBpZGVudGl0eSxcbiAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgICAgIGxpc3RlbjogbGlzdGVuXG4gICAgICAgIH07XG4gICAgICAgIGNvbm5lY3Rpb24uc2VuZChQUk9EVUNULCBHYXRld2F5VHJhbnNwb3J0Lk1lc3NhZ2VUeXBlLkNPTk5FQ1QsIG1zZyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY2hlbWE6IHNjaGVtYSxcbiAgICAgICAgICAgIGlkZW50aXR5OiBpZGVudGl0eSxcbiAgICAgICAgICAgIGxpc3RlbjogbGlzdGVuLFxuICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgbW9kaWZ5ID0gZnVuY3Rpb24gKHNjaGVtYSwgaWRlbnRpdHksIG1vZGlmaWNhdGlvbnMpIHtcbiAgICAgICAgZW5zdXJlQ29ubmVjdGlvbigpO1xuICAgICAgICBjb25uZWN0aW9uLnNlbmQoUFJPRFVDVCwgR2F0ZXdheVRyYW5zcG9ydC5NZXNzYWdlVHlwZS5NT0RJRlksIG1vZGlmaWNhdGlvbnMpO1xuICAgIH07XG5cbiAgICB2YXIgZGlzY29ubmVjdCA9IGZ1bmN0aW9uIChkZXNjcmlwdG9yKSB7XG4gICAgICAgIHZhciBzY2hlbWFIYW5kbGVycyA9IGRhdGFIYW5kbGVyc1tkZXNjcmlwdG9yLnNjaGVtYV07XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hSGFuZGxlcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB2YXIgaWRlbnRpdHlLZXkgPSBpZGVudGl0eVRvU3RyaW5nKGRlc2NyaXB0b3IuaWRlbnRpdHksIHRydWUpO1xuICAgICAgICAgICAgdmFyIGlkZW50aXR5SGFuZGxlcnMgPSBzY2hlbWFIYW5kbGVyc1tpZGVudGl0eUtleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlkZW50aXR5SGFuZGxlcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBpZGVudGl0eUhhbmRsZXJzW2Rlc2NyaXB0b3IuaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYTogZGVzY3JpcHRvci5zY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZGVudGl0eTogZGVzY3JpcHRvci5pZGVudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBvcHRpb25zLmluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uc2VuZChHYXRld2F5VHJhbnNwb3J0Lk1lc3NhZ2VUeXBlLkRJU0NPTk5FQ1QsIG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpZGVudGl0eUhhbmRsZXJzW2Rlc2NyaXB0b3IuaW5kZXhdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpZGVudGl0eUhhbmRsZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hSGFuZGxlcnNbaWRlbnRpdHlLZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHNjaGVtYUhhbmRsZXJzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZGF0YUhhbmRsZXJzW2Rlc2NyaXB0b3Iuc2NoZW1hXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhkYXRhSGFuZGxlcnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoZGF0YVN1YnNjcmlwdGlvbikgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5vZmYoZGF0YVN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgc3RhdHVzSGFuZGxlcnNbZGVzY3JpcHRvci5pbnN0YW5jZV07XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhzdGF0dXNIYW5kbGVycykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YXR1c1N1YnNjcmlwdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLm9mZihzdGF0dXNTdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGNvbm5lY3Q6IGNvbm5lY3QsXG4gICAgICAgIG1vZGlmeTogbW9kaWZ5LFxuICAgICAgICBkaXNjb25uZWN0OiBkaXNjb25uZWN0XG4gICAgfTtcbn07XG5cbkdhdGV3YXlUcmFuc3BvcnQuTWVzc2FnZVR5cGUgPSB7XG4gICAgLy8geyBzY2hlbWE6ICdBcHBsaWNhdGlvbkNvbmZpZ3VyYXRpb24nLCBpZGVudGl0eToge30sIGxpc3RlbjogdHJ1ZSwgaW5zdGFuY2U6ICcnIH1cbiAgICBDT05ORUNUOiAnY29ubmVjdCcsXG4gICAgLy8geyBzY2hlbWE6ICdBcHBsaWNhdGlvbkNvbmZpZ3VyYXRpb24nLCBpZGVudGl0eToge30sIGluc3RhbmNlOiAnJyB9XG4gICAgRElTQ09OTkVDVDogJ2Rpc2Nvbm5lY3QnLFxuICAgIC8vIHsgc2NoZW1hOiAnQXBwbGljYXRpb25Db25maWd1cmF0aW9uJywgaWRlbnRpdHk6IHt9LCB1cGRhdGVzOiBbXSwgaW5zdGFuY2U6ICcnIH1cbiAgICBNT0RJRlk6ICdtb2RpZnknLFxuICAgIC8vIHsgc2NoZW1hOiAnQXBwbGljYXRpb25Db25maWd1cmF0aW9uJywgaWRlbnRpdHk6IHt9LCBlcnJvcjogJycsIHNuYXBzaG90OiB7ZGVmYXVsdEtleVZhbHVlOiAnJywga2V5czogW10sIHByb3BzOiB7fX0sIHVwZGF0ZXM6IFtdIH1cbiAgICBEQVRBOiAnZGF0YScsXG4gICAgLy8geyBzY2hlbWE6ICdBcHBsaWNhdGlvbkNvbmZpZ3VyYXRpb24nLCBpZGVudGl0eToge30sIGluc3RhbmNlOiAnJywgc3RhdHVzOiAnJywgZXJyb3I6ICcnIH1cbiAgICBTVEFUVVM6ICdzdGF0dXMnXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdhdGV3YXlUcmFuc3BvcnQ7XG4iLCJmdW5jdGlvbiBlc2NhcGVJZGVudGl0eVRleHQodGV4dCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBpZiAodHlwZW9mIHRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1tcXFxcXS9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9bOl0vZywgJ1xcXFw6Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpZGVudGl0eVRvU3RyaW5nKGlkZW50aXR5LCBpbmNsdWRlS2V5cywgc2VwYXJhdG9yLCBvcmRlcikge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBpZiAodHlwZW9mIChpZGVudGl0eSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHNlcGFyYXRvciA9IHNlcGFyYXRvciB8fCAnLyc7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhpZGVudGl0eSk7XG4gICAgaWYgKHR5cGVvZiAob3JkZXIpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGtleXMuc29ydChvcmRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5zb3J0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGluY2x1ZGVLZXlzID8gKGVzY2FwZUlkZW50aXR5VGV4dChrZXkpICsgJzonICsgZXNjYXBlSWRlbnRpdHlUZXh0KGlkZW50aXR5W2tleV0pKSA6IGlkZW50aXR5W2tleV07XG4gICAgfSkuam9pbihzZXBhcmF0b3IpO1xufVxuXG5mdW5jdGlvbiBpZGVudGl0eUVxdWFsKGlkZW50aXR5MSwgaWRlbnRpdHkyKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHJldHVybiBpZGVudGl0eVRvU3RyaW5nKGlkZW50aXR5MSwgdHJ1ZSkgPT09IGlkZW50aXR5VG9TdHJpbmcoaWRlbnRpdHkyLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZmxhdHRlbihwcm9wcywgc2VwYXJhdG9yLCBuYW1lKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHNlcGFyYXRvciA9IHNlcGFyYXRvciB8fCAnLic7XG4gICAgdmFyIHByZWZpeCA9IG5hbWUgPyBuYW1lICsgc2VwYXJhdG9yIDogJyc7XG4gICAgdmFyIHZhbCA9IHt9O1xuICAgIE9iamVjdC5rZXlzKHByb3BzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKHByZWZpeCkgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXRoID0ga2V5LnN1YnN0cmluZyhwcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgdmFyIHRhcmdldCA9IHZhbDtcbiAgICAgICAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0YXJnZXRbcGFydHNbaV1dKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3BhcnRzW2ldXSA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXRbcGFydHNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0W3BhcnRzW2ldXSA9IHByb3BzW2tleV0udmFsdWU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBwcm9wRXF1YWwobGhzLCByaHMpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgaWYgKGxocy52YWx1ZSAhPT0gcmhzLnZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxocy51bmRlcmx5aW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsaHNVbmRlcmx5aW5nID0gbGhzLnVuZGVybHlpbmdbaV07XG4gICAgICAgIHZhciByaHNVbmRlcmx5aW5nID0gcmhzLnVuZGVybHlpbmdbaV0gfHwge307XG4gICAgICAgIGlmIChsaHNVbmRlcmx5aW5nLnZhbHVlICE9PSByaHNVbmRlcmx5aW5nLnZhbHVlIHx8ICFpZGVudGl0eUVxdWFsKGxoc1VuZGVybHlpbmcucGFyZW50LCByaHNVbmRlcmx5aW5nLnBhcmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBmbGF0dGVuOiBmbGF0dGVuLFxuICAgIHByb3BFcXVhbDogcHJvcEVxdWFsLFxuICAgIGlkZW50aXR5VG9TdHJpbmc6IGlkZW50aXR5VG9TdHJpbmcsXG4gICAgaWRlbnRpdHlFcXVhbDogaWRlbnRpdHlFcXVhbFxufTtcbiIsInZhciBwcm9wRXF1YWwgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5wcm9wRXF1YWw7XG5cbnZhciBVcGRhdGVUeXBlID0ge1xuICAgIEFkZGVkOiAnQWRkZWQnLFxuICAgIENoYW5nZWQ6ICdDaGFuZ2VkJyxcbiAgICBSZW1vdmVkOiAnUmVtb3ZlZCdcbn07XG5cbnZhciBNb2RlbCA9IGZ1bmN0aW9uIChidXMsIHNlcGFyYXRvcikge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB0aGlzLmJ1cyA9IGJ1cztcbiAgICB0aGlzLnJvb3QgPSBuZXcgVmlld01vZGVsKHRoaXMsICcnLCBzZXBhcmF0b3IgfHwgJy4nKTtcbiAgICB0aGlzLnZpZXdzID0ge307XG59O1xuXG52YXIgVmlld01vZGVsID0gZnVuY3Rpb24gKG1vZGVsLCBwYXRoLCBzZXBhcmF0b3IpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYubW9kZWwgPSBtb2RlbDtcbiAgICBzZWxmLnByb3BzID0ge307XG4gICAgc2VsZi5zZXBhcmF0b3IgPSBzZXBhcmF0b3IgfHwgbW9kZWwuc2VwYXJhdG9yO1xuICAgIHNlbGYucGF0aCA9IHBhdGg7XG59O1xuXG5WaWV3TW9kZWwucHJvdG90eXBlLmdldFZpZXdNb2RlbCA9IGZ1bmN0aW9uIChuYW1lLCBzZXBhcmF0b3IpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIHBhdGggPSB0aGlzLnBhdGggKyBuYW1lICsgKHNlcGFyYXRvciA/IHNlcGFyYXRvciA6ICcuJyk7XG4gICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICBpZiAocGF0aCA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIG1vZGVsLnJvb3Q7XG4gICAgfVxuXG4gICAgaWYgKCFtb2RlbC52aWV3c1twYXRoXSkge1xuICAgICAgICB2YXIgYmVzdFBhcmVudCA9ICcnO1xuICAgICAgICAvLyBmaWxsIHN1YnZpZXcgcmVmZXJlbmNlcyBhbmQgY2hvb3NlIGJlc3QgcGFyZW50IHByb3BzIHRvIGNvcHkgZnJvbS5cbiAgICAgICAgT2JqZWN0LmtleXMobW9kZWwudmlld3MpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKHBhdGguaW5kZXhPZihrZXkpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJlc3RQYXJlbnQubGVuZ3RoIDwga2V5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0UGFyZW50ID0ga2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBrZWVwIHN1YnZpZXdzIHNvcnRlZC5cbiAgICAgICAgICAgICAgICB2YXIgc3Vidmlld3MgPSBtb2RlbC52aWV3c1trZXldLnN1YnZpZXdzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vidmlld3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnZpZXdzW2ldLmluZGV4T2YocGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnZpZXdzLnNwbGljZShpLCAwLCBwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN1YnZpZXdzLnB1c2gocGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB2aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKG1vZGVsLCBwYXRoLCBzZXBhcmF0b3IpO1xuXG4gICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IGJlc3RQYXJlbnQgPT09ICcnID8gbW9kZWwucm9vdC5wcm9wcyA6IG1vZGVsLnZpZXdzW2Jlc3RQYXJlbnRdLm1vZGVsLnByb3BzO1xuICAgICAgICBPYmplY3Qua2V5cyhwYXJlbnRQcm9wcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgcHJvcCA9IHBhcmVudFByb3BzW2tleV07XG4gICAgICAgICAgICBpZiAocHJvcC5uYW1lLmluZGV4T2YocGF0aCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHByb3AubmFtZS5zdWJzdHJpbmcocGF0aC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHZpZXdNb2RlbC5wcm9wc1tuYW1lXSA9IHByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1vZGVsLnZpZXdzW3BhdGhdID0ge1xuICAgICAgICAgICAgc3Vidmlld3M6IFtdLFxuICAgICAgICAgICAgbW9kZWw6IHZpZXdNb2RlbFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBtb2RlbC52aWV3c1twYXRoXS5tb2RlbDtcbn07XG5cblZpZXdNb2RlbC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHNjb3BlKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHJldHVybiB0aGlzLm1vZGVsLm9uKHRoaXMucGF0aCwgY2FsbGJhY2ssIHNjb3BlKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChwYXRoLCBjYWxsYmFjaywgc2NvcGUpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIHR5cGUgPSB1cGRhdGVUeXBlRm9yUGF0aChwYXRoKTtcbiAgICByZXR1cm4gdGhpcy5idXMub24odHlwZSwgZmFsc2UsIGNhbGxiYWNrLCBzY29wZSk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuYXBwbHlTbmFwc2hvdCA9IGZ1bmN0aW9uIChzbmFwc2hvdCwgaXNTbmFwc2hvdCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBpc1NuYXBzaG90ID0gdHlwZW9mIGlzU25hcHNob3QgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IGlzU25hcHNob3Q7XG5cbiAgICB2YXIgdXBkYXRlcyA9IHRvVXBkYXRlcyhpc1NuYXBzaG90ID8ge30gOiB0aGlzLnJvb3QucHJvcHMsIHNuYXBzaG90LnByb3BzKTtcbiAgICBhcHBseVVwZGF0ZXNBbmRFbWl0RXZlbnRzKHRoaXMsIHVwZGF0ZXMsIGlzU25hcHNob3QpO1xufTtcblxuZnVuY3Rpb24gdXBkYXRlVHlwZUZvclBhdGgocGF0aCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgdHlwZSA9ICd1cGRhdGUnO1xuICAgIGlmIChwYXRoICE9PSAnJykge1xuICAgICAgICB0eXBlID0gdHlwZSArICd8JyArIHBhdGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGU7XG59XG5cbi8vIHNoYWxsb3cgY29weVxuZnVuY3Rpb24gY2xvbmVVcGRhdGVGb3JQYXRoKHVwZGF0ZSwgcGF0aCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgY2xvbmUgPSB7XG4gICAgICAgIHR5cGU6IHVwZGF0ZS50eXBlLFxuICAgICAgICBuYW1lOiB1cGRhdGUubmFtZS5zdWJzdHJpbmcocGF0aC5sZW5ndGgpXG4gICAgfTtcblxuICAgIHN3aXRjaCAodXBkYXRlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBVcGRhdGVUeXBlLkNoYW5nZWQ6XG4gICAgICAgICAgICBjbG9uZS5vbGRWYWx1ZSA9IHVwZGF0ZS5vbGRWYWx1ZTtcbiAgICAgICAgICAgIGNsb25lLnZhbHVlID0gdXBkYXRlLnZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVXBkYXRlVHlwZS5BZGRlZDpcbiAgICAgICAgICAgIGNsb25lLnZhbHVlID0gdXBkYXRlLnZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVXBkYXRlVHlwZS5SZW1vdmVkOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lO1xufVxuXG5mdW5jdGlvbiBhcHBseVVwZGF0ZXNBbmRFbWl0RXZlbnRzKG1vZGVsLCB1cGRhdGVzLCBpc1NuYXBzaG90KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciB2aWV3cyA9IE9iamVjdC5rZXlzKG1vZGVsLnZpZXdzKTtcbiAgICB2YXIgZWZmZWN0aXZlVXBkYXRlcyA9IHsgJyc6IHVwZGF0ZXMgfTtcbiAgICBpZiAodmlld3MubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBzb3J0IHZpZXdzIGZvciBwcmVmaXggc2VhcmNoXG4gICAgICAgIGlmICh2aWV3cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2aWV3cy5zb3J0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVzLmZvckVhY2goZnVuY3Rpb24gKHVwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHZpZXc7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXdzLmxlbmd0aDsgdmlld3MrKykge1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGUubmFtZS5pbmRleE9mKHZpZXdzW2ldKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3ID0gdmlld3NbaV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2aWV3ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWZmZWN0aXZlVXBkYXRlc1t2aWV3XS5wdXNoKGNsb25lVXBkYXRlRm9yUGF0aCh1cGRhdGUsIHZpZXcpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGFmZmVjdGVkUGF0aHMgPSBPYmplY3Qua2V5cyhlZmZlY3RpdmVVcGRhdGVzKTtcbiAgICBpZiAoYWZmZWN0ZWRQYXRocy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGFmZmVjdGVkUGF0aHMuc29ydCgpO1xuICAgIH1cblxuICAgIGFmZmVjdGVkUGF0aHMuZm9yRWFjaChmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgdmlld01vZGVsID0gcGF0aCA9PT0gJycgPyBtb2RlbC5yb290IDogbW9kZWwudmlld3NbcGF0aF0ubW9kZWw7XG4gICAgICAgIGlmIChpc1NuYXBzaG90KSB7XG4gICAgICAgICAgICB2aWV3TW9kZWwucHJvcHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVmZmVjdGl2ZVVwZGF0ZXNbcGF0aF0uZm9yRWFjaChmdW5jdGlvbiAodXBkYXRlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHVwZGF0ZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBVcGRhdGVUeXBlLkFkZGVkOlxuICAgICAgICAgICAgICAgLy8gYnJlYWsgb21pdHRlZFxuICAgICAgICAgICAgICAgIGNhc2UgVXBkYXRlVHlwZS5DaGFuZ2VkOlxuICAgICAgICAgICAgICAgIC8vIGNoYW5nZWQgd29ya3MgZXZlbiBmb3IgbWlzc2luZyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgIHZpZXdNb2RlbC5wcm9wc1t1cGRhdGUubmFtZV0gPSB1cGRhdGUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVXBkYXRlVHlwZS5SZW1vdmVkOlxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmlld01vZGVsLnByb3BzW3VwZGF0ZS5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGFmZmVjdGVkUGF0aHMuZm9yRWFjaChmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgdHlwZSA9IHVwZGF0ZVR5cGVGb3JQYXRoKHBhdGgpO1xuICAgICAgICBtb2RlbC5idXMuZW1pdCh0eXBlLCBpc1NuYXBzaG90LCB1cGRhdGVzKTtcbiAgICB9KTtcbn1cblxuTW9kZWwucHJvdG90eXBlLmFwcGx5VXBkYXRlcyA9IGZ1bmN0aW9uICh1cGRhdGVzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGFwcGx5VXBkYXRlc0FuZEVtaXRFdmVudHModGhpcywgdXBkYXRlcywgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gdG9VcGRhdGVzKGltYWdlLCBzbmFwc2hvdCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBzbmFwc2hvdCA9IHNuYXBzaG90IHx8IHt9O1xuICAgIHZhciB1cGRhdGVzID0gW107XG4gICAgdmFyIHRvRGVsZXRlID0gT2JqZWN0LmtleXMoaW1hZ2UpO1xuICAgIE9iamVjdC5rZXlzKHNuYXBzaG90KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGltYWdlW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB1cGRhdGUudHlwZSA9IFVwZGF0ZVR5cGUuQWRkZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXByb3BFcXVhbChpbWFnZVtrZXldLCBzbmFwc2hvdFtrZXldKSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZS50eXBlID0gVXBkYXRlVHlwZS5DaGFuZ2VkO1xuICAgICAgICAgICAgICAgIHVwZGF0ZS5vbGRWYWx1ZSA9IGltYWdlW2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbmRleFRvRGVsZXRlO1xuICAgICAgICAgICAgZm9yIChpbmRleFRvRGVsZXRlID0gMDsgaW5kZXhUb0RlbGV0ZSA8IHRvRGVsZXRlLmxlbmd0aDsgdG9EZWxldGUrKykge1xuICAgICAgICAgICAgICAgIGlmICh0b0RlbGV0ZVtpbmRleFRvRGVsZXRlXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b0RlbGV0ZVtpbmRleFRvRGVsZXRlXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0b0RlbGV0ZS5zcGxpY2UoaW5kZXhUb0RlbGV0ZSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBkYXRlLnR5cGUpIHtcbiAgICAgICAgICAgIHVwZGF0ZS52YWx1ZSA9IHNuYXBzaG90W2tleV07XG4gICAgICAgICAgICB1cGRhdGUubmFtZSA9IGtleTtcbiAgICAgICAgICAgIHVwZGF0ZXMucHVzaCh1cGRhdGUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB0b0RlbGV0ZS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdXBkYXRlcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFVwZGF0ZVR5cGUuUmVtb3ZlZCxcbiAgICAgICAgICAgIG5hbWU6IGtleVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB1cGRhdGVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsO1xuIiwidmFyIGZsYXR0ZW4gPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5mbGF0dGVuO1xuXG52YXIgUHJvcHMgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIHByb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbW9kZWwucHJvcHNbbmFtZV07XG4gICAgfTtcblxuICAgIHZhciB2YWwgPSBmdW5jdGlvbiB2YWwobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBtb2RlbC5wcm9wc1tuYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuKG1vZGVsLnByb3BzLCBtb2RlbC5zZXBhcmF0b3IsIG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vZGVsLnByb3BzW25hbWVdLnZhbHVlO1xuICAgIH07XG5cbiAgICB2YXIgcHJvcHMgPSBmdW5jdGlvbiAoc2VjdGlvbiwgc2VwYXJhdG9yKSB7XG4gICAgICAgIHNlY3Rpb24gPSBzZWN0aW9uIHx8ICcnO1xuICAgICAgICBpZiAoc2VjdGlvbiA9PT0gJycpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHN1cHBvcnQgc2VwYXJhdG9yIGNoYW5nZSBmb3IgJycgKHNhbWUpIHNlY3Rpb24uXG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlcGFyYXRvciA9IHNlcGFyYXRvciB8fCBtb2RlbC5zZXBhcmF0b3I7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcHMobW9kZWwuZ2V0Vmlld01vZGVsKHNlY3Rpb24sIHNlcGFyYXRvcikpO1xuICAgIH07XG5cbiAgICB2YXIgZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgc2NvcGUpIHtcbiAgICAgICAgT2JqZWN0LmtleXMobW9kZWwucHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChzY29wZSwgbW9kZWwucHJvcHNba2V5XSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgb25VcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHNjb3BlKSB7XG4gICAgICAgIG1vZGVsLm9uKGNhbGxiYWNrLCBzY29wZSk7XG4gICAgfTtcblxuICAgIHZhciBzZWxmID0ge1xuICAgICAgICBwcm9wOiBwcm9wLFxuICAgICAgICB2YWw6IHZhbCxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBmb3JFYWNoOiBmb3JFYWNoLFxuICAgICAgICBvblVwZGF0ZTogb25VcGRhdGVcbiAgICB9O1xuICAgIHJldHVybiBzZWxmO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9wcztcbiIsInZhciB1dWlkID0gZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7XG4gICAgICAgIHZhciB2ID0gYyA9PT0gJ3gnID8gciA6ICgociAmIDB4MykgfCAweDgpO1xuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgfSk7XG59O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn07XG5cbnZhciBsZXZlbHMgPSB7XG4gICAgZGVidWc6ICdkZWJ1ZycsXG4gICAgaW5mbzogJ2luZm8nLFxuICAgIHdhcm46ICd3YXJuJyxcbiAgICBlcnJvcjogJ2Vycm9yJ1xufTtcbnZhciBsb2cgPSBmdW5jdGlvbiAobGV2ZWwsIGFyZ3MpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgaWYgKGNvbnNvbGUpIHtcbiAgICAgICAgdmFyIGxvZ2dlciA9IGNvbnNvbGVbbGV2ZWxdO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihsb2dnZXIpKSB7XG4gICAgICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIFtdLnNwbGljZS5jYWxsKGFyZ3MsIDAsIDAsIG5vdy5nZXRIb3VycygpICsgJzonICsgbm93LmdldE1pbnV0ZXMoKSArICc6JyArIG5vdy5nZXRTZWNvbmRzKCkpO1xuICAgICAgICAgICAgbG9nZ2VyLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGluZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGxvZyhsZXZlbHMuaW5mbywgYXJndW1lbnRzKTtcbn07XG5cbnZhciB3YXJuID0gZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBsb2cobGV2ZWxzLndhcm4sIGFyZ3VtZW50cyk7XG59O1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGxvZyhsZXZlbHMuZGVidWcsIGFyZ3VtZW50cyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICB1dWlkOiB1dWlkLFxuICAgIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gICAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICAgIGxvZzogbG9nLFxuICAgIHdhcm46IHdhcm4sXG4gICAgaW5mbzogaW5mbyxcbiAgICBkZWJ1ZzogZGVidWdcbn07XG4iLCJmdW5jdGlvbiBjcmVhdGVCcmlkZ2UoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgcmV0dXJuIHt9O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJyaWRnZTtcclxuIiwiZnVuY3Rpb24gY3JlYXRlQnJpZGdlKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgdmFyIGZhY2FkZSA9IGh0bWxDb250YWluZXIuc2hhcmVkQ29udGV4dEZhY2FkZTtcclxuXHJcbiAgICBmdW5jdGlvbiBhbGwoKSB7XHJcbiAgICAgICAgdmFyIGFsbE9iaiA9IGZhY2FkZS5hbGwoKTtcclxuICAgICAgICBpZiAoIWFsbE9iaiB8fCAhYWxsT2JqLmtleXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWxsT2JqLmtleXM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlKG5hbWUsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gZmFjYWRlLnVwZGF0ZShuYW1lLCBkYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXQobmFtZSwgZGF0YSkge1xyXG4gICAgICAgIGZhY2FkZS5zZXQobmFtZSwgZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3Vic2NyaWJlKG5hbWUsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhY2FkZS5zdWJzY3JpYmUobmFtZSwgY2FsbGJhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKGtleSkge1xyXG4gICAgICAgIGZhY2FkZS51bnN1YnNjcmliZShrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYWxsOiBhbGwsXHJcbiAgICAgICAgdXBkYXRlOiB1cGRhdGUsXHJcbiAgICAgICAgc2V0OiBzZXQsXHJcbiAgICAgICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXHJcbiAgICAgICAgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlXHJcbiAgICB9O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJyaWRnZTtcclxuXHJcblxyXG4iLCJ2YXIgUGFja2FnZUpzb24gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKTtcclxudmFyIGhjQnJpZGdlID0gcmVxdWlyZSgnLi9icmlkZ2VzL2hjLmpzJyk7XHJcbnZhciBnd0JyaWRnZSA9IHJlcXVpcmUoJy4vYnJpZGdlcy9ndy5qcycpO1xyXG5cclxuZnVuY3Rpb24gY29udGV4dHMoY29uZmlnKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB2YXIgYnJpZGdlID0gZ2V0QnJpZGdlKGNvbmZpZyk7XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0QnJpZGdlKGNvbmZpZykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgaHRtbENvbnRhaW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgaWYgKCFodG1sQ29udGFpbmVyLnNoYXJlZENvbnRleHRGYWNhZGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnWW91ciB2ZXJzaW9uIG9mIEh0bWxDb250YWluZXIgZG9lcyBub3Qgc3VwcG9ydCBjb250ZXh0cy4gR2V0IHZlcnNpb24gMS40Ni4wLjAgb3IgbGF0ZXIgdG8gaGF2ZSB0aGF0IGZlYXR1cmUuJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaGNCcmlkZ2UoY29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGd3QnJpZGdlKGNvbmZpZyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWxsKCkge1xyXG4gICAgICAgIHJldHVybiBicmlkZ2UuYWxsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlKG5hbWUsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gYnJpZGdlLnVwZGF0ZShuYW1lLCBkYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXQobmFtZSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBicmlkZ2Uuc2V0KG5hbWUsIGRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN1YnNjcmliZShuYW1lLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiBicmlkZ2Uuc3Vic2NyaWJlKG5hbWUsIGNhbGxiYWNrKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1bnN1YnNjcmliZShrZXkpIHtcclxuICAgICAgICBicmlkZ2UudW5zdWJzY3JpYmUoa2V5KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBicmlkZ2UgYmVpbmcgYSBzdHJpbmcgbWVhbnMgdGhlIGluaXRpYWxpenRpb24gZmFpbGVkIGFuZCB0aGVyZSBpcyBzb21lIGVycm9yIGluIHRoYXQgc3RyaW5nXHJcbiAgICBpZiAodHlwZW9mIGJyaWRnZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBlcnJvcjogYnJpZGdlLFxyXG4gICAgICAgICAgICB2ZXJzaW9uOiBQYWNrYWdlSnNvbi52ZXJzaW9uXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGFsbDogYWxsLFxyXG4gICAgICAgIHVwZGF0ZTogdXBkYXRlLFxyXG4gICAgICAgIHNldDogc2V0LFxyXG4gICAgICAgIHN1YnNjcmliZTogc3Vic2NyaWJlLFxyXG4gICAgICAgIHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZSxcclxuICAgICAgICB2ZXJzaW9uOiBQYWNrYWdlSnNvbi52ZXJzaW9uXHJcbiAgICB9O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRleHRzO1xyXG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiX2FyZ3NcIjogW1xuICAgIFtcbiAgICAgIFwidGljazQyLWNvbnRleHRzQDAuMC4yXCIsXG4gICAgICBcIkM6XFxcXHdvcmtcXFxcc3Rhc2hcXFxcR0xVRS1kZXZcXFxcanMtZ2x1ZVwiXG4gICAgXVxuICBdLFxuICBcIl9mcm9tXCI6IFwidGljazQyLWNvbnRleHRzQDAuMC4yXCIsXG4gIFwiX2lkXCI6IFwidGljazQyLWNvbnRleHRzQDAuMC4yXCIsXG4gIFwiX2luQ2FjaGVcIjogdHJ1ZSxcbiAgXCJfaW5zdGFsbGFibGVcIjogdHJ1ZSxcbiAgXCJfbG9jYXRpb25cIjogXCIvdGljazQyLWNvbnRleHRzXCIsXG4gIFwiX25vZGVWZXJzaW9uXCI6IFwiNS4zLjBcIixcbiAgXCJfbnBtVXNlclwiOiB7fSxcbiAgXCJfbnBtVmVyc2lvblwiOiBcIjMuMy4xMlwiLFxuICBcIl9waGFudG9tQ2hpbGRyZW5cIjoge30sXG4gIFwiX3JlcXVlc3RlZFwiOiB7XG4gICAgXCJuYW1lXCI6IFwidGljazQyLWNvbnRleHRzXCIsXG4gICAgXCJyYXdcIjogXCJ0aWNrNDItY29udGV4dHNAMC4wLjJcIixcbiAgICBcInJhd1NwZWNcIjogXCIwLjAuMlwiLFxuICAgIFwic2NvcGVcIjogbnVsbCxcbiAgICBcInNwZWNcIjogXCIwLjAuMlwiLFxuICAgIFwidHlwZVwiOiBcInZlcnNpb25cIlxuICB9LFxuICBcIl9yZXF1aXJlZEJ5XCI6IFtcbiAgICBcIi9cIlxuICBdLFxuICBcIl9yZXNvbHZlZFwiOiBcImh0dHA6Ly8xOTIuMTY4LjAuMjM0OjQ4NzMvdGljazQyLWNvbnRleHRzLy0vdGljazQyLWNvbnRleHRzLTAuMC4yLnRnelwiLFxuICBcIl9zaGFzdW1cIjogXCJhZjAzOGJiNTllYzQzMDkxMjlmMzkyZTc2M2I0YjU1Mjc0Y2VlZTVlXCIsXG4gIFwiX3Nocmlua3dyYXBcIjogbnVsbCxcbiAgXCJfc3BlY1wiOiBcInRpY2s0Mi1jb250ZXh0c0AwLjAuMlwiLFxuICBcIl93aGVyZVwiOiBcIkM6XFxcXHdvcmtcXFxcc3Rhc2hcXFxcR0xVRS1kZXZcXFxcanMtZ2x1ZVwiLFxuICBcImF1dGhvclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiVGljazQyXCJcbiAgfSxcbiAgXCJiaW5cIjoge1xuICAgIFwiYnVpbGRcIjogXCIuL2Jpbi9idWlsZC5qc1wiLFxuICAgIFwiY2xlYW5cIjogXCIuL2Jpbi9jbGVhbi5qc1wiLFxuICAgIFwiZmlsZS12ZXJzaW9uaWZ5XCI6IFwiLi9iaW4vZmlsZS12ZXJzaW9uaWZ5LmpzXCIsXG4gICAgXCJtaW5pZnlcIjogXCIuL2Jpbi9taW5pZnkuanNcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJ0aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uXCI6IFwiPj0xLjEuOVwiXG4gIH0sXG4gIFwiZGVzY3JpcHRpb25cIjogXCJBIGxpYnJhcnkgZm9yIHNoYXJlZCBjb250ZXh0c1wiLFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJicm93c2VyaWZ5XCI6IFwiXjEzLjAuMFwiLFxuICAgIFwiYnJvd3NlcmlmeS1yZXBsYWNpZnlcIjogXCJeMC4wLjRcIixcbiAgICBcImJyb3dzZXJpZnktdmVyc2lvbmlmeVwiOiBcIl4xLjAuNFwiLFxuICAgIFwiZXNsaW50XCI6IFwiXjMuMS4xXCIsXG4gICAgXCJlc2xpbnQtY29uZmlnLXN0YW5kYXJkXCI6IFwiXjUuMy41XCIsXG4gICAgXCJlc2xpbnQtY29uZmlnLXRpY2s0MlwiOiBcIl4xLjAuMFwiLFxuICAgIFwiZXNsaW50LXBsdWdpbi1wcm9taXNlXCI6IFwiXjIuMC4wXCIsXG4gICAgXCJlc2xpbnQtcGx1Z2luLXN0YW5kYXJkXCI6IFwiXjIuMC4wXCIsXG4gICAgXCJtaW5pZnlpZnlcIjogXCJeNy4zLjJcIixcbiAgICBcIm9uY2hhbmdlXCI6IFwiXjIuMS4yXCJcbiAgfSxcbiAgXCJkaXN0XCI6IHtcbiAgICBcInNoYXN1bVwiOiBcImFmMDM4YmI1OWVjNDMwOTEyOWYzOTJlNzYzYjRiNTUyNzRjZWVlNWVcIixcbiAgICBcInRhcmJhbGxcIjogXCJodHRwOi8vMTkyLjE2OC4wLjIzNDo0ODczL3RpY2s0Mi1jb250ZXh0cy8tL3RpY2s0Mi1jb250ZXh0cy0wLjAuMi50Z3pcIlxuICB9LFxuICBcImdpdEhlYWRcIjogXCJhZDBmZjQxNTZiMjA5Y2RlYjBiODU1M2ZmMGIzZGFhMzM1ODVmNzZkXCIsXG4gIFwibGljZW5zZVwiOiBcIklTQ1wiLFxuICBcIm1haW5cIjogXCJsaWJyYXJ5L21haW4uanNcIixcbiAgXCJuYW1lXCI6IFwidGljazQyLWNvbnRleHRzXCIsXG4gIFwib3B0aW9uYWxEZXBlbmRlbmNpZXNcIjoge30sXG4gIFwicmVhZG1lXCI6IFwiRVJST1I6IE5vIFJFQURNRSBkYXRhIGZvdW5kIVwiLFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9rcG9wb3ZAc3Rhc2gudGljazQyLmNvbS9zY20vdGcvanMtY29udGV4dHMuZ2l0XCJcbiAgfSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImJ1aWxkXCI6IFwibnBtIHJ1biBlc2xpbnQgJiYgbm9kZSBiaW4vY2xlYW4uanMgJiYgbm9kZSBiaW4vYnVpbGQuanMgJiYgbm9kZSBiaW4vbWluaWZ5ICYmIG5vZGUgYmluL2ZpbGUtdmVyc2lvbmlmeVwiLFxuICAgIFwiZXNsaW50XCI6IFwiZXNsaW50IGxpYnJhcnlcIixcbiAgICBcImVzbGludDpmaXhcIjogXCJlc2xpbnQgbGlicmFyeSAtLWZpeFwiLFxuICAgIFwicHJlcHVibGlzaFwiOiBcIm5wbSB1cGRhdGUgJiBucG0gcnVuIGJ1aWxkXCIsXG4gICAgXCJ3YXRjaFwiOiBcIm9uY2hhbmdlIFxcXCIuL2xpYnJhcnkvKi5qc1xcXCIgLWl2IC1lIFxcXCIuL2JpblxcXCIgLS0gbnBtIHJ1biBidWlsZFwiXG4gIH0sXG4gIFwidmVyc2lvblwiOiBcIjAuMC4yXCJcbn1cbiIsInZhciBjYWxsYmFja1JlZ2lzdHJ5ID0gcmVxdWlyZSgnY2FsbGJhY2stcmVnaXN0cnknKTtcbnZhciBwYWNrYWdlSnNvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpO1xuXG4vKipcbiAqIEEgdGVtcGxhdGUgZm9yIGdhdGV3YXkgY29ubmVjdGlvbnMgLSB0aGlzIGlzIGV4dGVuZGVkIGZyb20gc3BlY2lmaWMgcHJvdG9jb2xzIGFuZCB0cmFuc3BvcnRzLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBUaGUgbWVzc2FnZSBoYW5kbGVycyB0aGF0IGhhdmUgdG8gYmUgZXhlY3V0ZWQgZm9yIGVhY2ggcmVjZWl2ZWQgbWVzc2FnZVxuICAgIHZhciBtZXNzYWdlSGFuZGxlcnMgPSB7fTtcbiAgICB2YXIgaWRzID0gMDtcbiAgICB2YXIgcmVnaXN0cnkgPSBjYWxsYmFja1JlZ2lzdHJ5KCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBfY29ubmVjdGVkIDogZmFsc2UsXG5cbiAgICAgICAgLy8gYXNzZW1ibGVzIGEgbmV3IG1lc3NhZ2UgdG8gYmUgc2VudCB0byBnYXRld2F5LFxuICAgICAgICAvLyB0aGlzIHNob3VsZCBiZSByZXBsYWNlZCBmcm9tIGNvbmNyZXRlIGdhdGV3YXkgY29ubmVjdGlvblxuICAgICAgICBfY3JlYXRlTWVzc2FnZTogZnVuY3Rpb24odHlwZSwgbWVzc2FnZSwgaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkIC0geW91IHNob3VsZCBleHRlbmQgdGhlIGNvbm5lY3Rpb24gd2l0aCBwcm90b2NvbCAnICsgdHlwZSArIG1lc3NhZ2UgKyBpZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gcHJvY2Vzc2VzIGEgbmV3IG1lc3NhZ2UgY2FsbGluZyB0aGUgZGlzdHJpYnV0ZSBtZXRob2QsXG4gICAgICAgIC8vIHRoaXMgc2hvdWxkIGJlIHJlcGxhY2VkIGZyb20gY29uY3JldGUgaWYgdGhleSBoYXZlIGRpZmZlcmVudCBtZXNzYWdlIHN0cnVjdHVyZVxuICAgICAgICBfcHJvY2Vzc01lc3NhZ2U6IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkIC0geW91IHNob3VsZCBleHRlbmQgdGhlIGNvbm5lY3Rpb24gd2l0aCBwcm90b2NvbCAnICsgbWVzc2FnZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRXhlY3V0ZXMgYXBwcm9wcmlhdGUgbWVzc2FnZSBoYW5kbGVycyBmb3IgdGhlIG1lc3NhZ2UgdHlwZS5cbiAgICAgICAgX2Rpc3RyaWJ1dGVNZXNzYWdlOiBmdW5jdGlvbiAobWVzc2FnZSwgdHlwZSkge1xuICAgICAgICAgICAgLy8gUmV0cmlldmUgaGFuZGxlcnMgZm9yIHRoZSBtZXNzYWdlIHR5cGVcbiAgICAgICAgICAgIHZhciBoYW5kbGVycyA9IG1lc3NhZ2VIYW5kbGVyc1t0eXBlLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBFeGVjdXRlIHRoZW1cbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhoYW5kbGVycykuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gaGFuZGxlcnNbaGFuZGxlcklkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHRyaWdnZXJzIGNvbm5lY3Rpb24gY2hhbmdlIG5vdGlmeWluZyBhbGwgdXNlcnNcbiAgICAgICAgX3RyaWdnZXJDb25uZWN0aW9uQ2hhbmdlZDogZnVuY3Rpb24oY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSBjb25uZWN0ZWQ7XG5cbiAgICAgICAgICAgIGlmIChjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZWdpc3RyeS5leGVjdXRlKCdjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVnaXN0cnkuZXhlY3V0ZSgnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQXR0YWNoZXMgYSBoYW5kbGVyXG4gICAgICAgIG9uOiBmdW5jdGlvbiAocHJvZHVjdCwgdHlwZSwgbWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZUhhbmRsZXJzW3R5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlSGFuZGxlcnNbdHlwZV0gPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGlkID0gaWRzKys7XG4gICAgICAgICAgICBtZXNzYWdlSGFuZGxlcnNbdHlwZV1baWRdID0gbWVzc2FnZUhhbmRsZXI7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gUmVtb3ZlIGEgaGFuZGxlclxuICAgICAgICBvZmY6IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgICAgICBkZWxldGUgbWVzc2FnZUhhbmRsZXJzW2luZm8udHlwZS50b0xvd2VyQ2FzZSgpXVtpbmZvLmlkXTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb25uZWN0ZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHNldHRpbmdzLndzIHx8IHNldHRpbmdzLmh0dHApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWdpc3RyeS5hZGQoJ2Nvbm5lY3RlZCcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkaXNjb25uZWN0ZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgcmVnaXN0cnkuYWRkKCdkaXNjb25uZWN0ZWQnLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbG9naW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbG9nb3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEluaXQgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBhZnRlciBzdWNjZXNzZnVsIGxvZ2luXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJvdG9jb2xWZXJzaW9uIDogc2V0dGluZ3MucHJvdG9jb2xWZXJzaW9uIHx8IDEsXG5cbiAgICAgICAgdmVyc2lvbjogcGFja2FnZUpzb24udmVyc2lvblxuICAgIH1cbn07XG5cbiIsInZhciBiYXNlQ29ubmVjdGlvbiA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbicpO1xuXG4vKipcbiAqIENoZWNrIHJlYWRtZS5tZCBmb3IgZGV0YWlsZWQgZGVzY3JpcHRpb25cbiAqL1xudmFyIGNvbm5lY3Rpb24gPSBmdW5jdGlvbiAoc2V0dGluZ3MsIGN1c3RvbUNvbm5lY3Rpb24pIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcbiAgICB2YXIgY29ubmVjdGlvbiA9IGJhc2VDb25uZWN0aW9uKHNldHRpbmdzKTtcblxuICAgIC8vIGlmIHJ1bm5pbmcgaW4gSEMgd2UgdXNlIGd3MSBwcm90b2NvbCBhbmQgaGMgdHJhbnNwb3J0XG4gICAgaWYgKGdsb2JhbC5odG1sQ29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29ubmVjdGlvbiA9IHJlcXVpcmUoJy4vcHJvdG9jb2xzL2d3MScpKGNvbm5lY3Rpb24sIHNldHRpbmdzKTtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoJy4vdHJhbnNwb3J0cy9oYycpKGNvbm5lY3Rpb24sIHNldHRpbmdzKTtcbiAgICB9XG5cbiAgICAvLyBpZiBydW5uaW5nIGluIHRoZSBicm93c2VyIC0gbGV0J3MgY2hlY2sgd2hpY2ggcHJvdG9jb2wgdmVyc2lvbiB1c2VyIHdhbnRzXG4gICAgaWYgKHNldHRpbmdzLnByb3RvY29sVmVyc2lvbiA9PT0gMykge1xuICAgICAgICBjb25uZWN0aW9uID0gcmVxdWlyZSgnLi9wcm90b2NvbHMvZ3czJykoY29ubmVjdGlvbiwgc2V0dGluZ3MpO1xuICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MucHJvdG9jb2xWZXJzaW9uID09PSAyKSB7XG4gICAgICAgIGNvbm5lY3Rpb24gPSByZXF1aXJlKCcuL3Byb3RvY29scy9ndzInKShjb25uZWN0aW9uLCBzZXR0aW5ncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29ubmVjdGlvbiA9IHJlcXVpcmUoJy4vcHJvdG9jb2xzL2d3MScpKGNvbm5lY3Rpb24sIHNldHRpbmdzKTtcbiAgICB9XG5cbiAgICBpZiAoc2V0dGluZ3Mud3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZSgnLi90cmFuc3BvcnRzL3dzJykoY29ubmVjdGlvbiwgc2V0dGluZ3MpO1xuICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuaHR0cCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKCcuL3RyYW5zcG9ydHMvaHR0cCcpKGNvbm5lY3Rpb24sIHNldHRpbmdzKTtcbiAgICB9IGVsc2UgaWYgKGN1c3RvbUNvbm5lY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZSgnLi90cmFuc3BvcnRzL21vY2snKShjb25uZWN0aW9uLCBjdXN0b21Db25uZWN0aW9uLCBzZXR0aW5ncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb25uZWN0aW9uLiBNYWtlIHN1cmUgeW91IGFyZSBydW5uaW5nIHRoZSBhcHBsaWNhdGlvbiBmcm9tIFRpY2s0MiBIdG1sQ29udGFpbmVyIG9yIGZpbGwgdGhlIFxcJ2Nvbm5lY3Rpb24ud2Vic29ja2V0X3VybFxcJyBwcm9wZXJ0eS4nKTtcbiAgICB9XG59O1xuXG5pZiAoZ2xvYmFsLnRpY2s0MiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZ2xvYmFsLnRpY2s0MiA9IHt9O1xufVxuXG5nbG9iYWwudGljazQyLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbm5lY3Rpb247XG4iLCIvLyBDb25uZWN0aW9uIHRvIGdhdGV3YXkgVjEgLSB0aGUgb25lIHRoYXQgcnVucyBvbiB0aGUgZGVza3RvcCB3aXRob3V0IGF1dGhlbnRpY2F0aW9uXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ2VzNi1wcm9taXNlJykuUHJvbWlzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29ubmVjdGlvbi5fcHJvY2Vzc01lc3NhZ2UgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBKU09OLnBhcnNlKG1lc3NhZ2UpO1xuICAgICAgICBjb25uZWN0aW9uLl9kaXN0cmlidXRlTWVzc2FnZShtZXNzYWdlLm1lc3NhZ2UsIG1lc3NhZ2UudHlwZSk7XG4gICAgfTtcblxuICAgIGNvbm5lY3Rpb24uX2NyZWF0ZU1lc3NhZ2UgPSBmdW5jdGlvbih0eXBlLCBtZXNzYWdlLCBpZCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICBpZDogaWRcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbm5lY3Rpb24ubG9naW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gY29ubmVjdGlvbjtcbn07XG4iLCIvLyBDb25uZWN0aW9uIHRvIGdhdGV3YXkgVjIgLSBndzEgKyAgYXV0aGVudGljYXRpb25cbnZhciBQcm9taXNlID0gcmVxdWlyZSgnZXM2LXByb21pc2UnKS5Qcm9taXNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgc2Vzc2lvbkNvb2tpZTtcbiAgICBjb25uZWN0aW9uLl9wcm9jZXNzTWVzc2FnZSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgbWVzc2FnZSA9IEpTT04ucGFyc2UobWVzc2FnZSk7XG4gICAgICAgIHZhciBkYXRhVHlwZSA9IG1lc3NhZ2UudHlwZTtcblxuICAgICAgICBpZiAoZGF0YVR5cGUgPT09ICdTRU5EJykgIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLmRhdGE7XG4gICAgICAgICAgICBjb25uZWN0aW9uLl9kaXN0cmlidXRlTWVzc2FnZShtZXNzYWdlLm1lc3NhZ2UsIG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uLl9kaXN0cmlidXRlTWVzc2FnZShtZXNzYWdlLCBtZXNzYWdlLnR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbm5lY3Rpb24uX2NyZWF0ZU1lc3NhZ2UgPSBmdW5jdGlvbih0eXBlLCBtZXNzYWdlLCBpZCkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ0xPR0lOJykge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdMT0dPVVQnKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeyB0eXBlOiAnTE9HT1VUJyB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICB0eXBlOiAnU0VORCcsXG4gICAgICAgICAgICBzZXNzaW9uQ29va2llOiBzZXNzaW9uQ29va2llLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbm5lY3Rpb24ubG9naW4gPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudG9rZW4pIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbjogbWVzc2FnZS50b2tlbixcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0xPR0lOX1RPS0VOJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UudXNlcm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgICAgICB1c2VyOiBtZXNzYWdlLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICBwYXNzd29yZDogbWVzc2FnZS5wYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0xPR0lOJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhdXRoIG1lc3NhZ2UnICsgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbHJTdWJzID0gY29ubmVjdGlvbi5vbignJywgJ0xPR0lOX1JFU1BPTlNFJywgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5vZmYobHJTdWJzKTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiAhcmVzcG9uc2UuZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25Db29raWUgPSByZXNwb25zZS5zZXNzaW9uQ29va2llO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25uZWN0aW9uLnNlbmQoJycsICdMT0dJTicsIHJlcXVlc3QpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29ubmVjdGlvbi5sb2dvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29ubmVjdGlvbi5zZW5kKCcnLCAnTE9HT1VUJyk7XG4gICAgfTtcblxuICAgIHJldHVybiBjb25uZWN0aW9uO1xufTtcblxuIiwidmFyIGN1aWQgPSByZXF1aXJlKCdjdWlkJyk7XG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ2VzNi1wcm9taXNlJykuUHJvbWlzZTtcbnZhciBVUkxTZWFyY2hQYXJhbXMgPSByZXF1aXJlKCd1cmwtc2VhcmNoLXBhcmFtcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24sIHNldHRpbmdzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBkYXRlUHJlZml4ID0gJyNUNDJfREFURV8nO1xuICAgIHZhciBkYXRlUHJlZml4TGVuID0gZGF0ZVByZWZpeC5sZW5ndGg7XG4gICAgdmFyIGRhdGVNaW5MZW4gPSBkYXRlUHJlZml4TGVuICsgMTsvLyBwcmVmaXggKyBhdCBsZWFzdCBvbmUgY2hhciAoMTk3MC8wMS8wMSA9IDApXG4gICAgdmFyIGRhdGVQcmVmaXhGaXJzdENoYXIgPSBkYXRlUHJlZml4WzBdO1xuXG4gICAgY29ubmVjdGlvbi5pbnN0YW5jZSA9IGN1aWQoKTtcblxuICAgIGNvbm5lY3Rpb24uX3Byb2Nlc3NNZXNzYWdlID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlID0gSlNPTi5wYXJzZShtZXNzYWdlLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5WzBdICE9PSBkYXRlUHJlZml4Rmlyc3RDaGFyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8IGRhdGVNaW5MZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gcGFyc2VJbnQodmFsdWUuc3Vic3RyaW5nKGRhdGVQcmVmaXhMZW4sIHZhbHVlLmxlbmd0aCksIDEwKTtcbiAgICAgICAgICAgIGlmIChpc05hTihtaWxsaXNlY29uZHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG1pbGxpc2Vjb25kcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25uZWN0aW9uLl9kaXN0cmlidXRlTWVzc2FnZShtZXNzYWdlLCBtZXNzYWdlLnR5cGUpO1xuICAgIH07XG5cbiAgICBjb25uZWN0aW9uLl9jcmVhdGVNZXNzYWdlID0gIGZ1bmN0aW9uKHR5cGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBzZXJpYWxpemUgZGF0ZXMgYXMgI1Q0Ml9EQVRFKDxNSUxMSVNFQ09ORFNfRlJPTV8xOTcwXzAxXzAxPilcblxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzb21lIGR1Y2sgdHlwaW5nXG4gICAgICAgICAgICBpZiAoIXZhbHVlLmdldFRpbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkYXRlUHJlZml4ICsgdmFsdWUuZ2V0VGltZSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29ubmVjdGlvbi5sb2dpbiA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIGF1dGhlbnRpY2F0aW9uID0ge307XG4gICAgICAgICAgICB2YXIgZ3dUb2tlbiA9IGdldEdhdGV3YXlUb2tlbigpO1xuICAgICAgICAgICAgaWYgKGd3VG9rZW4pIHtcbiAgICAgICAgICAgICAgICBhdXRoZW50aWNhdGlvbi5tZXRob2QgPSAnZ2F0ZXdheS10b2tlbic7XG4gICAgICAgICAgICAgICAgYXV0aGVudGljYXRpb24udG9rZW4gPSBnd1Rva2VuO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLnRva2VuKSB7XG4gICAgICAgICAgICAgICAgYXV0aGVudGljYXRpb24ubWV0aG9kID0gJ2FjY2Vzcy10b2tlbic7XG4gICAgICAgICAgICAgICAgYXV0aGVudGljYXRpb24udG9rZW4gPSBtZXNzYWdlLnRva2VuO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLnVzZXJuYW1lKSB7XG4gICAgICAgICAgICAgICAgYXV0aGVudGljYXRpb24ubWV0aG9kID0gJ3NlY3JldCc7XG4gICAgICAgICAgICAgICAgYXV0aGVudGljYXRpb24udXNlciA9IG1lc3NhZ2UudXNlcm5hbWU7XG4gICAgICAgICAgICAgICAgYXV0aGVudGljYXRpb24uc2VjcmV0ID0gbWVzc2FnZS5wYXNzd29yZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGF1dGggbWVzc2FnZScgKyBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXF1ZXN0SWQgPSBjdWlkKCk7XG4gICAgICAgICAgICB2YXIgaGVsbG9Nc2cgPSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdF9pZDogcmVxdWVzdElkLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdoZWxsbycsXG4gICAgICAgICAgICAgICAgaWRlbnRpdHk6IHsgYXBwbGljYXRpb246IHNldHRpbmdzLmFwcGxpY2F0aW9uLCBpbnN0YW5jZTogY29ubmVjdGlvbi5pbnN0YW5jZSB9LFxuICAgICAgICAgICAgICAgIGF1dGhlbnRpY2F0aW9uOiBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHdlbGNvbWVTdWIgPSBjb25uZWN0aW9uLm9uKCcnLCAnd2VsY29tZScsIGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgICAgICBpZiAobXNnLnJlcXVlc3RfaWQgIT09IHJlcXVlc3RJZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5vZmYod2VsY29tZVN1Yik7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5vZmYoZXJyb3JTdWIpO1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24ucGVlcklkID0gbXNnLnBlZXJfaWQ7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5nd1Rva2VuID0gZ3dUb2tlbjtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG1zZyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGVycm9yU3ViID0gY29ubmVjdGlvbi5vbignJywgJ2Vycm9yJywgZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgICAgICAgIGlmIChtc2cucmVxdWVzdF9pZCAhPT0gcmVxdWVzdElkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLm9mZihlcnJvclN1Yik7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5vZmYod2VsY29tZVN1Yik7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG1zZyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29ubmVjdGlvbi5zZW5kKCcnLCAnTE9HSU4nLCBoZWxsb01zZyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25uZWN0aW9uLmxvZ291dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25uZWN0aW9uLnNlbmQoJycsICdMT0dPVVQnKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0R2F0ZXdheVRva2VuKCkge1xuICAgICAgICBpZiAoc2V0dGluZ3MuZ3dUb2tlblByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuZ3dUb2tlblByb3ZpZGVyLmdldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvY2F0aW9uICYmIGxvY2F0aW9uLnNlYXJjaCkge1xuICAgICAgICAgICAgdmFyIHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMobG9jYXRpb24uc2VhcmNoLnNsaWNlKDEpKTtcbiAgICAgICAgICAgIHJldHVybiBzZWFyY2hQYXJhbXMuZ2V0KCd0NDJnd3Rva2VuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY29ubmVjdGlvbjtcbn07XG5cbiIsIi8qKlxuICogQ29ubmVjdGlvbiB0byBIdG1sQ29udGFpbmVyXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGNvbm5lY3Rpb25JZCA9IE1hdGguZmxvb3IoMWUxMCAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKCk7XG4gICAgLy8gUm91dGUgbWVzc2FnZXMgdG8gZmFjYWRlKHMpXG4gICAgY29ubmVjdGlvbi5zZW5kID0gZnVuY3Rpb24gKHByb2R1Y3QsIHR5cGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHByb2R1Y3QgPT09ICdtZXRyaWNzJykge1xuICAgICAgICAgICAgZ2xvYmFsLmh0bWxDb250YWluZXIubWV0cmljc0ZhY2FkZS5zZW5kKHR5cGUsIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9kdWN0ID09PSAnbG9nJykge1xuICAgICAgICAgICAgZ2xvYmFsLmh0bWxDb250YWluZXIubG9nZ2luZ0ZhY2FkZS5zZW5kKHR5cGUsIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9kdWN0ID09PSAnYXBwY29uZmlnJykge1xuICAgICAgICAgICAgZ2xvYmFsLmh0bWxDb250YWluZXIuYXBwQ29uZmlnRmFjYWRlLnNlbmQodHlwZSwgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSksIGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKGdsb2JhbC5odG1sQ29udGFpbmVyLmFwcENvbmZpZ0ZhY2FkZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGdsb2JhbC5odG1sQ29udGFpbmVyLmFwcENvbmZpZ0ZhY2FkZS5pbml0Q29ubmVjdGlvbihcbiAgICAgICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChtZXNzYWdlQXNKc29uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uX2hhbmRsZV9tZXNzYWdlKEpTT04ucGFyc2UobWVzc2FnZUFzSnNvbikpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2xvYmFsLmNvbm5lY3Rpb25zID0gZ2xvYmFsLmNvbm5lY3Rpb25zIHx8IHt9O1xuICAgIC8vIEV4cG9zZSBmdW5jdGlvbiBmb3Igc2VuZGluZyBtZXNzYWdlczpcbiAgICBnbG9iYWwuY29ubmVjdGlvbnNbJ2Nvbm5lY3Rpb24nICsgY29ubmVjdGlvbklkXSA9IGNvbm5lY3Rpb24uX2hhbmRsZV9tZXNzYWdlO1xuXG4gICAgcmV0dXJuIGNvbm5lY3Rpb247XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29ubmVjdGlvbiwgc2V0dGluZ3MpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIHVybCA9IHNldHRpbmdzLmh0dHA7XG4gICAgLy8gcG9sbGluZyBpbnRlcnZhbCBpbiBtcywgZGVmYXVsdCBpcyAxIHNlY29uZFxuICAgIHZhciBpbnRlcnZhbCA9IHNldHRpbmdzLmh0dHBfaW50ZXJ2YWxfbXM7XG4gICAgaWYgKCFpbnRlcnZhbCkge1xuICAgICAgICBpbnRlcnZhbCA9IDEwMDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9nRGVidWcobWVzc2FnZSkge1xuICAgICAgICBpZiAoZ2xvYmFsLmNvbnNvbGUgIT09IHVuZGVmaW5lZCAmJiAoc2V0dGluZ3MuZGVidWcgPT09IHRydWUgfHwgc2V0dGluZ3MudHJhY2UgPT09IHRydWUpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvZ1RyYWNlKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgc2V0dGluZ3MudHJhY2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9nRGVidWcoJ0F0dGVtcGluZyB0byBjb25uZWN0IHRvIEdhdGV3YXkgdmlhIEhUVFAgd2l0aCB1cmwgXFwnJyArIHVybCArICdcXCcgYW5kIHBvbGxpbmcgaW50ZXJ2YWwgJyArIGludGVydmFsICsgJyBtcycpO1xuXG4gICAgY29ubmVjdGlvbi5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHBvbGwodXJsLCBpbnRlcnZhbCwgMCwgZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgaXRlbXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5fcHJvY2Vzc01lc3NhZ2UoaXRlbXNbaW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29ubmVjdGlvbi5zZW5kID0gZnVuY3Rpb24gKHByb2R1Y3QsIHR5cGUsIG1lc3NhZ2UsIGlkKSB7XG4gICAgICAgIHZhciBtc2cgPSBjb25uZWN0aW9uLl9jcmVhdGVNZXNzYWdlKHR5cGUsIG1lc3NhZ2UsIGlkKTtcbiAgICAgICAgaHR0cFBvc3QodXJsLCBtc2cpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQb2xscyBkYXRhIGZyb20gYSBnaXZlbiB1cmwgb24gc29tZSBpbnRlcnZhbFxuICAgICAqIEBwYXJhbSB1cmwgICAgICAgQmFzZSBzZXJ2ZXIgdXJsLiBBIHNlcXVlbmNlIHVybCBwYXJhbSBtYXkgYmUgYWRkZWQgYmFzZWQgb24gdGhlIHNlcSBwYXJhbVxuICAgICAqIEBwYXJhbSBpbnRlcnZhbCAgSW50ZXJ2YWwgKGluIG1zKSBiZXR3ZWVuIHBvbGxpbmcgcmVxdWVzdHRzXG4gICAgICogQHBhcmFtIHNlcSAgICAgICBOZXh0IHNlcXVlbmNlIG51bWJlciB3ZSBzaG91bGQgYXNrIGZvciAoaWYgMCB0aGUgc2VydmVyIHdpbGwgcmV0dXJuIHRoZSBsYXN0IGtub3duIG1lc3NhZ2UpXG4gICAgICogQHBhcmFtIG9uZGF0YSAgICBEYXRhIGNhbGxiYWNrXG4gICAgICovXG4gICAgZnVuY3Rpb24gcG9sbCh1cmwsIGludGVydmFsLCBzZXEsIG9uZGF0YSkge1xuICAgICAgICAvLyBjb25zdHJ1Y3QgdGhlIGdldCBVcmwgLSBpZiBzZXEgIT0gMCBhZGQgYXMgdXJsIHBhcmFtIHRvIGdldFxuICAgICAgICAvLyBvbmx5IG1lc3NhZ2VzIGFmdGVyIHRoaXMgc2VxdWVuY2VcbiAgICAgICAgdmFyIGdldFVybCA9IHVybDtcblxuICAgICAgICBpZiAoc2VxICE9PSAwKSB7XG4gICAgICAgICAgICBnZXRVcmwgPSB1cmwgKyAnP3NlcXVlbmNlPScgKyBzZXEgKyAnJm5vLWNhY2hlPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBhIHJlcXVlc3RcbiAgICAgICAgdmFyIHhtbGh0dHAgPSBjcmVhdGVDT1JTUmVxdWVzdCgnR0VUJywgZ2V0VXJsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoc2VxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ0Nvbm5lY3RlZCB0byBHYXRld2F5IG9uICcgKyB1cmwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsb2dUcmFjZSgnUmVzcG9uc2UgZnJvbSBcXCcnICsgZ2V0VXJsICsgJ1xcJyBpcyAnICsgeG1saHR0cC5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBKU09OLnBhcnNlKHhtbGh0dHAucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgIC8vIHRoZSBzZXJ2ZXIgcmV0dXJucyB0aGUgbnVtYmVyIG9mIHRoZSBuZXh0IHNlcXVlbmNlIHRoYXQgd2UgbXVzdCBxdWVyeSBmb3JcbiAgICAgICAgICAgIHZhciBuZXh0U2VxID0gbWVzc2FnZS5uZXh0U2VxdWVuY2U7XG4gICAgICAgICAgICAvLyBjYWxsIHVzZXIgY2FsbGJhY2tlXG4gICAgICAgICAgICBvbmRhdGEobWVzc2FnZS5kYXRhKTtcbiAgICAgICAgICAgIC8vIHJlLXNjaGVkdWxlXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwb2xsKHVybCwgaW50ZXJ2YWwsIG5leHRTZXEsIG9uZGF0YSk7XG4gICAgICAgICAgICB9LCBpbnRlcnZhbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHhtbGh0dHAub25lcnJvciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIHBvbGxpbmcgZGF0YSBmcm9tIGh0dHAgc2VydmVyIFxcJycgKyBnZXRVcmwgKyAnXFwnIC0gJyArIGV2KTtcbiAgICAgICAgICAgIC8vIHJlLXNjaGVkdWxlXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwb2xsKHVybCwgaW50ZXJ2YWwsIHNlcSwgb25kYXRhKTtcbiAgICAgICAgICAgIH0sIGludGVydmFsKTtcbiAgICAgICAgfTtcblxuICAgICAgICBsb2dUcmFjZSgnU2VuZGluZyBHRVQgdG8gXFwnJyArIGdldFVybCArICdcXCcnKTtcbiAgICAgICAgeG1saHR0cC5zZW5kKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUE9TVHMgYSBtZXNzYWdlIHRvIGEgZ2l2ZW4gdXJsXG4gICAgICovXG4gICAgZnVuY3Rpb24gaHR0cFBvc3QodXJsLCBtZXNzYWdlKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIHJlcXVlc3RcbiAgICAgICAgdmFyIHhtbGh0dHAgPSBjcmVhdGVDT1JTUmVxdWVzdCgnUE9TVCcsIHVybCk7XG4gICAgICAgIGxvZ1RyYWNlKCdTZW5kaW5nIFBPU1QgdG8gXFwnJyArIHVybCArICdcXCcgOiAnICsgbWVzc2FnZSk7XG4gICAgICAgIHhtbGh0dHAuc2VuZChtZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIENPUlMgcmVxdWVzdCAoY3Jvc3MgZG9tYWluIHJlcXVlc3RzKSBmb3IgZGlmZmVyZW50IGJyb3dzZXJzIC0gWE1MSHR0cFJlcXVlc3Qgd2l0aENyZWRlbnRpYWxzXG4gICAgICogZm9yIENocm9tZSBhbmQgRkYgYW5kIFhEb21haW5SZXF1ZXN0IGZvciBJRVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNPUlNSZXF1ZXN0KG1ldGhvZCwgdXJsLCByZXN1bHRDYWxsYmFjaykge1xuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgaWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIFhNTEh0dHBSZXF1ZXN0IG9iamVjdCBoYXMgYSBcIndpdGhDcmVkZW50aWFsc1wiIHByb3BlcnR5LlxuICAgICAgICAgICAgLy8gXCJ3aXRoQ3JlZGVudGlhbHNcIiBvbmx5IGV4aXN0cyBvbiBYTUxIVFRQUmVxdWVzdDIgb2JqZWN0cy5cbiAgICAgICAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0Q2FsbGJhY2sgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0ICYmIHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Q2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIFhEb21haW5SZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBjaGVjayBpZiBYRG9tYWluUmVxdWVzdC5cbiAgICAgICAgICAgIC8vIFhEb21haW5SZXF1ZXN0IG9ubHkgZXhpc3RzIGluIElFLCBhbmQgaXMgSUUncyB3YXkgb2YgbWFraW5nIENPUlMgcmVxdWVzdHMuXG4gICAgICAgICAgICB4aHIgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICAgICAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0Q2FsbGJhY2sgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgeGhyLm9ubG9hZCA9IHJlc3VsdENhbGxiYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBDT1JTIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIuXG4gICAgICAgICAgICB4aHIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHhocjtcbiAgICB9XG5cbiAgICByZXR1cm4gY29ubmVjdGlvbjtcbn07XG4iLCIvKipcbiAqIFVzZWQgZm9yIHRlc3RzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgY3VzdG9tQ29ubmVjdGlvbikge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBjb25uZWN0aW9uLnNlbmQgPSBmdW5jdGlvbiAocHJvZHVjdCwgdHlwZSwgbWVzc2FnZSkge1xuICAgICAgICBjdXN0b21Db25uZWN0aW9uLnB1Ymxpc2goe1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGN1c3RvbUNvbm5lY3Rpb24uc3Vic2NyaWJlKGNvbm5lY3Rpb24uX2hhbmRsZV9tZXNzYWdlKTtcbiAgICByZXR1cm4gY29ubmVjdGlvbjtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25uZWN0aW9uLCBzZXR0aW5ncykge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIExvYWQgdGhlICd3cycgbGlicmFyeSwgYnV0IG9ubHkgaWYgd2UgYXJlIHJ1bm5pbmcgdW5kZXIgbm9kZSBqc1xuICAgIHZhciBXZWJTb2NrZXQgPSByZXF1aXJlKCdkZXRlY3Qtbm9kZScpID8gcmVxdWlyZSgnd3MnKSA6IGdsb2JhbC5XZWJTb2NrZXQ7XG5cbiAgICBmdW5jdGlvbiBpbml0aWF0ZVNvY2tldCgpIHtcbiAgICAgICAgdmFyIHdzID0gbmV3IFdlYlNvY2tldChzZXR0aW5ncy53cyk7XG4gICAgICAgIHdzLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uLl90cmlnZ2VyQ29ubmVjdGlvbkNoYW5nZWQoZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBMb2cgb24gY29ubmVjdGlvblxuICAgICAgICB3cy5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uLl90cmlnZ2VyQ29ubmVjdGlvbkNoYW5nZWQodHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEF0dGFjaCBoYW5kbGVyXG4gICAgICAgIHdzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uLl9wcm9jZXNzTWVzc2FnZShtZXNzYWdlLmRhdGEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB3cztcbiAgICB9XG5cbiAgICAvLyBIb2xkcyBjYWxsYmFjayBleGVjdXRpb24gdW50aWwgc29ja2V0IGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQuXG4gICAgZnVuY3Rpb24gd2FpdEZvclNvY2tldENvbm5lY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzb2NrZXQucmVhZHlTdGF0ZSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc29ja2V0LnJlYWR5U3RhdGUgPiAxKSB7XG4gICAgICAgICAgICAvLyA+IDEgbWVhbnMgY2xvc2luZyBvciBjbG9zZWRcbiAgICAgICAgICAgIHNvY2tldCA9IGluaXRpYXRlU29ja2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdhaXRGb3JTb2NrZXRDb25uZWN0aW9uKGNhbGxiYWNrKTtcbiAgICAgICAgfSwgNTApOyAvLyB3YWl0IDUgbWlsbGlzZWNvbmRzIGZvciB0aGUgY29ubmVjdGlvbi4uLlxuICAgIH1cblxuICAgIC8vIEluaXRpYXRlIGEgbmV3IHNvY2tldCAodGhpcyBnZXRzIHJlLWV4ZWN1dGVkIG9uIHJlY29ubmVjdClcbiAgICB2YXIgc29ja2V0ID0gaW5pdGlhdGVTb2NrZXQoKTtcblxuICAgIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGZvciBzZW5kaW5nIGEgbWVzc2FnZVxuICAgIGNvbm5lY3Rpb24uc2VuZCA9IGZ1bmN0aW9uIChwcm9kdWN0LCB0eXBlLCBtZXNzYWdlLCBpZCkge1xuICAgICAgICB3YWl0Rm9yU29ja2V0Q29ubmVjdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSBjb25uZWN0aW9uLl9jcmVhdGVNZXNzYWdlKHR5cGUsIG1lc3NhZ2UsIGlkKTtcbiAgICAgICAgICAgIGlmICghbXNnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc29ja2V0LnNlbmQobXNnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbm5lY3Rpb24ud2Vic29ja2V0X3VybCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHNldHRpbmdzLndlYnNvY2tldF91cmwgPSBhO1xuICAgICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgc29ja2V0ID0gaW5pdGlhdGVTb2NrZXQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGNvbm5lY3Rpb247XG59O1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIl9hcmdzXCI6IFtcbiAgICBbXG4gICAgICBcInRpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25AXjIuMC4zXCIsXG4gICAgICBcIkM6XFxcXHdvcmtcXFxcc3Rhc2hcXFxcR0xVRS1kZXZcXFxcanMtZ2x1ZVwiXG4gICAgXVxuICBdLFxuICBcIl9mcm9tXCI6IFwidGljazQyLWdhdGV3YXktY29ubmVjdGlvbkA+PTIuMC4zIDwzLjAuMFwiLFxuICBcIl9pZFwiOiBcInRpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25AMi4xLjJcIixcbiAgXCJfaW5DYWNoZVwiOiB0cnVlLFxuICBcIl9pbnN0YWxsYWJsZVwiOiB0cnVlLFxuICBcIl9sb2NhdGlvblwiOiBcIi90aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uXCIsXG4gIFwiX25vZGVWZXJzaW9uXCI6IFwiNi4zLjBcIixcbiAgXCJfbnBtVXNlclwiOiB7fSxcbiAgXCJfbnBtVmVyc2lvblwiOiBcIjMuOC41XCIsXG4gIFwiX3BoYW50b21DaGlsZHJlblwiOiB7fSxcbiAgXCJfcmVxdWVzdGVkXCI6IHtcbiAgICBcIm5hbWVcIjogXCJ0aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uXCIsXG4gICAgXCJyYXdcIjogXCJ0aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uQF4yLjAuM1wiLFxuICAgIFwicmF3U3BlY1wiOiBcIl4yLjAuM1wiLFxuICAgIFwic2NvcGVcIjogbnVsbCxcbiAgICBcInNwZWNcIjogXCI+PTIuMC4zIDwzLjAuMFwiLFxuICAgIFwidHlwZVwiOiBcInJhbmdlXCJcbiAgfSxcbiAgXCJfcmVxdWlyZWRCeVwiOiBbXG4gICAgXCIvXCIsXG4gICAgXCIvdGljazQyLWFnbVwiLFxuICAgIFwiL3RpY2s0Mi1hcHBjb25maWdcIixcbiAgICBcIi90aWNrNDItY29udGV4dHNcIixcbiAgICBcIi90aWNrNDItbG9nZ2VyXCIsXG4gICAgXCIvdGljazQyLW1ldHJpY3NcIlxuICBdLFxuICBcIl9zaGFzdW1cIjogXCI0ZGIyODg1M2VkZDVmODhjMTJmZWM0NzFhZDBiNzQxOThjNTEyZDU3XCIsXG4gIFwiX3Nocmlua3dyYXBcIjogbnVsbCxcbiAgXCJfc3BlY1wiOiBcInRpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25AXjIuMC4zXCIsXG4gIFwiX3doZXJlXCI6IFwiQzpcXFxcd29ya1xcXFxzdGFzaFxcXFxHTFVFLWRldlxcXFxqcy1nbHVlXCIsXG4gIFwiYmluXCI6IHtcbiAgICBcImJ1aWxkXCI6IFwiLi9iaW4vYnVpbGQuanNcIixcbiAgICBcImNsZWFuXCI6IFwiLi9iaW4vY2xlYW4uanNcIixcbiAgICBcImZpbGUtdmVyc2lvbmlmeVwiOiBcIi4vYmluL2ZpbGUtdmVyc2lvbmlmeS5qc1wiLFxuICAgIFwibWluaWZ5XCI6IFwiLi9iaW4vbWluaWZ5LmpzXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYnJvd3NlcmlmeS12ZXJzaW9uaWZ5XCI6IFwiXjEuMC40XCIsXG4gICAgXCJjYWxsYmFjay1yZWdpc3RyeVwiOiBcIl4xLjAuMVwiLFxuICAgIFwiY3VpZFwiOiBcIl4xLjMuOFwiLFxuICAgIFwiZGV0ZWN0LW5vZGVcIjogXCJeMi4wLjNcIixcbiAgICBcImVzNi1wcm9taXNlXCI6IFwiXjMuMi4xXCIsXG4gICAgXCJ1cmwtc2VhcmNoLXBhcmFtc1wiOiBcIl4wLjUuMFwiLFxuICAgIFwid3NcIjogXCJeMC43LjJcIlxuICB9LFxuICBcImRlc2NyaXB0aW9uXCI6IFwiVGljazQyIEdhdGV3YXkgQ29ubmVjdGlvbi5cIixcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYmxhbmtldFwiOiBcIl4xLjEuNlwiLFxuICAgIFwiYnJvd3NlcmlmeVwiOiBcIl4xMy4wLjBcIixcbiAgICBcImJyb3dzZXJpZnktcmVwbGFjaWZ5XCI6IFwiXjAuMC40XCIsXG4gICAgXCJicm93c2VyaWZ5LXZlcnNpb25pZnlcIjogXCJeMS4wLjRcIixcbiAgICBcImVzbGludFwiOiBcIl4zLjEuMVwiLFxuICAgIFwiZXNsaW50LWNvbmZpZy1zdGFuZGFyZFwiOiBcIl41LjMuNVwiLFxuICAgIFwiZXNsaW50LWNvbmZpZy10aWNrNDJcIjogXCJeMS4wLjBcIixcbiAgICBcImVzbGludC1wbHVnaW4tcHJvbWlzZVwiOiBcIl4yLjAuMFwiLFxuICAgIFwiZXNsaW50LXBsdWdpbi1zdGFuZGFyZFwiOiBcIl4yLjAuMFwiLFxuICAgIFwiZnNcIjogXCIwLjAuMlwiLFxuICAgIFwianNkb21cIjogXCJeOC4xLjBcIixcbiAgICBcIm1pbmlmeWlmeVwiOiBcIl43LjMuMlwiLFxuICAgIFwib25jaGFuZ2VcIjogXCJeMi4xLjJcIixcbiAgICBcInBoYW50b21qc1wiOiBcIl4xLjkuMTJcIixcbiAgICBcInF1bml0anNcIjogXCJeMS4xNS4wXCIsXG4gICAgXCJzaGVsbGpzXCI6IFwiXjAuNi4wXCJcbiAgfSxcbiAgXCJkaXN0XCI6IHtcbiAgICBcInNoYXN1bVwiOiBcIjRkYjI4ODUzZWRkNWY4OGMxMmZlYzQ3MWFkMGI3NDE5OGM1MTJkNTdcIixcbiAgICBcInRhcmJhbGxcIjogXCJodHRwOi8vMTkyLjE2OC4wLjIzNDo0ODczL3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb24vLS90aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uLTIuMS4yLnRnelwiXG4gIH0sXG4gIFwiZ2l0SGVhZFwiOiBcIjNlYTM1NDZhOGM3OTkwOWY0N2VjMjY2NzdlYThlMTJlODlkY2MyOWZcIixcbiAgXCJtYWluXCI6IFwibGlicmFyeS9tYWluLmpzXCIsXG4gIFwibmFtZVwiOiBcInRpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25cIixcbiAgXCJvcHRpb25hbERlcGVuZGVuY2llc1wiOiB7fSxcbiAgXCJyZWFkbWVcIjogXCJFUlJPUjogTm8gUkVBRE1FIGRhdGEgZm91bmQhXCIsXG4gIFwicmVhZG1lRmlsZW5hbWVcIjogXCJyZWFkbWUubWRcIixcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImJ1aWxkXCI6IFwibnBtIHJ1biBlc2xpbnQgJiYgbm9kZSBiaW4vY2xlYW4uanMgJiYgbm9kZSBiaW4vYnVpbGQuanMgJiYgbm9kZSBiaW4vbWluaWZ5ICYmIG5vZGUgYmluL2ZpbGUtdmVyc2lvbmlmeVwiLFxuICAgIFwiZXNsaW50XCI6IFwiZXNsaW50IGxpYnJhcnlcIixcbiAgICBcImVzbGludDpmaXhcIjogXCJlc2xpbnQgbGlicmFyeSAtLWZpeCBcIixcbiAgICBcInByZXB1Ymxpc2hcIjogXCJucG0gdXBkYXRlICYgbnBtIHJ1biBidWlsZFwiLFxuICAgIFwidGVzdFwiOiBcIm5wbSBydW4gZXNsaW50ICYmIG1vY2hhIC0tcmVxdWlyZSAuL3Rlc3QvdGVzdF9oZWxwZXIgXFxcInRlc3QvKiovKi5qc1xcXCJcIixcbiAgICBcIndhdGNoXCI6IFwib25jaGFuZ2UgXFxcIi4vbGlicmFyeS8qLmpzXFxcIiAtaXYgLWUgXFxcIi4vYmluXFxcIiAtLSBucG0gcnVuIGJ1aWxkXCJcbiAgfSxcbiAgXCJ2ZXJzaW9uXCI6IFwiMi4xLjJcIlxufVxuIiwidmFyIGFzY2lpVGFibGUgPSByZXF1aXJlKCdhc2NpaS10YWJsZScpO1xudmFyIHRpY2s0MkNvbm5lY3Rpb24gPSByZXF1aXJlKCd0aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uJyk7XG52YXIgUGFja2FnZUpzb24gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKTtcblxudmFyIGxldmVscyA9IFsndHJhY2UnLCAnZGVidWcnLCAnaW5mbycsICd3YXJuJywgJ2Vycm9yJywgJ29mZiddO1xuXG5mdW5jdGlvbiBzZXJpYWxpemVQYXRoKHBhdGgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoID09PSAwID8gJycgOiBwYXRoLmpvaW4oJy4nKTtcbn1cblxudmFyIGlzQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChjKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGMuc2VuZCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgYy5vbiA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbmZ1bmN0aW9uIGdldExldmVsKGxvZ2dlciwgbGV2ZWwpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gUmV0cmlldmVzIHRoZSBjb25zb2xlIG9yIHB1Ymxpc2ggbGV2ZWwgb2YgYSBsb2dnZXJcbiAgICAvLyBsb2dnZXIgLSB0aGUgbG9nZ2VyIGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgbGV2ZWxcbiAgICAvLyBsZXZlbCAtIGEgc3RyaW5nIHdoaWNoIGNhbiBlaXRoZXIgYmUgXCJwdWJsaXNoTGV2ZWxcIiBmb3IgcmV0cmlldmluZyB0aGUgcHVibGlzaCBsZXZlbCBvciBcImNfbGV2ZWxcIiBmb3IgcmV0cmlldmluZyB0aGUgY29uc29sZSBsZXZlbC5cbiAgICBpZiAobG9nZ2VyW2xldmVsXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsb2dnZXJbbGV2ZWxdO1xuICAgIH0gZWxzZSBpZiAobG9nZ2VyLnBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBnZXRMZXZlbChsb2dnZXIucGFyZW50LCBsZXZlbCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBtZXNzYWdlVG9UYWJsZSh0aXRsZSwgcm93cykge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBEaXNwbGF5IG1lc3NhZ2UgYXMgdGFibGUgaW4gZmlsZVxuICAgIHZhciBrZXlzID0gZ2V0QWxsS2V5cyhyb3dzKTtcbiAgICAvLyBmaWxsIHJvd3Mgd2l0aCBtZXNzYWdlIHByb3BlcnRpZXNcbiAgICB2YXIgdGFibGVSb3dzID0gcm93cy5tYXAoZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHZhciB0YWJsZU1lc3NhZ2UgPSBhc2NpaVRhYmxlLmZhY3Rvcnkoe1xuICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgIGhlYWRpbmc6IGtleXMsXG4gICAgICAgIHJvd3M6IHRhYmxlUm93c1xuICAgIH0pO1xuICAgIHJldHVybiB0YWJsZU1lc3NhZ2UudG9TdHJpbmcoKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxsS2V5cyhkYXRhKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIEFjY2VwdHMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIGtleXMgZnJvbSBhbGwgb2JqZWN0c1xuICAgIHZhciBhbGxLZXlzID0gW107XG5cbiAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGFsbEtleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGFsbEtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBhbGxLZXlzO1xufVxuXG5mdW5jdGlvbiBsb2dnZXIoY29uZmlndXJhdGlvbikge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBpZiAodHlwZW9mIGNvbmZpZ3VyYXRpb24uY29ubmVjdGlvbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uZmlndXJhdGlvbi5jb25uZWN0aW9uID0ge307XG4gICAgfVxuXG4gICAgLy8gU2V0IGRlYnVnIGZvciB0aGUgY29ubmVjdGlvbiBtb2R1bGUgaWYgZ2xvYmFsIGRlYnVnIGlzIHNldFxuICAgIGNvbmZpZ3VyYXRpb24uY29ubmVjdGlvbi5kZWJ1ZyA9IGNvbmZpZ3VyYXRpb24uZGVidWc7XG5cbiAgICAvLyBJbml0IGNvbm5lY3Rpb25cbiAgICAvLyBEZXRlcm1pbmUgaWYgd2UgYXJlIGdpdmVuIGEgcmVhZHkgJ2Nvbm5lY3Rpb24nIG9iamVjdCBvciBhIGNvbmZpZ3VyYXRpb24uXG4gICAgdmFyIGNvbm5lY3Rpb24gPSBpc0Nvbm5lY3Rpb24oY29uZmlndXJhdGlvbi5jb25uZWN0aW9uKSA/IGNvbmZpZ3VyYXRpb24uY29ubmVjdGlvbiA6IHRpY2s0MkNvbm5lY3Rpb24oY29uZmlndXJhdGlvbi5jb25uZWN0aW9uKTtcblxuICAgIHZhciBpZEtleXMgPSBbJ3N5c3RlbScsICdzZXJ2aWNlJywgJ2luc3RhbmNlJ107XG5cbiAgICAvLyBDb252ZXJ0IGluc3RhbmNlIHRvIHN0cmluZywgdGhyb3cgZXhjZXB0aW9ucyBpZiBpdCBpcyBub3QgZnVsbFxuICAgIHZhciBpbnN0YW5jZVN0ciA9IGlkS2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgcHJvcCA9IGNvbmZpZ3VyYXRpb24uaWRlbnRpdHlba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2Ugc3BlY2lmeSBcIicgKyBrZXkgKyAnXCIgaW4geW91ciBpZGVudGl0eScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgfSkuam9pbignLycpO1xuXG4gICAgdmFyIGxvZ2dlclByb3RvID0ge1xuICAgICAgICBzdWJMb2dnZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgc3VibG9nZ2VyIGlzIGFscmVhZHkgY3JlYXRlZFxuICAgICAgICAgICAgdmFyIGV4aXN0aW5nU3VibG9nZ2VyID0gdGhpcy5zdWJsb2dnZXJzLmZpbHRlcihmdW5jdGlvbiAoc3ViTG9nZ2VyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YkxvZ2dlci5uYW1lID09PSBuYW1lO1xuICAgICAgICAgICAgfSlbMF07XG5cbiAgICAgICAgICAgIGlmIChleGlzdGluZ1N1YmxvZ2dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nU3VibG9nZ2VyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgbmFtZSBpc24ndCB0aGUgc2FtZSBhcyBvbmUgb2YgdGhlIHBhcmVudCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBzdWIgbG9nZ2VyIG5hbWUgaXMgbm90IGFsbG93ZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgbmFtZSBpc24ndCB0aGUgc2FtZSBhcyBvbmUgb2YgdGhlIHBhcmVudCBtZXRob2RzXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhsb2dnZXJQcm90bykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgc3ViIGxvZ2dlciBuYW1lIGlzIG5vdCBhbGxvd2VkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aC5zbGljZSgwKTtcbiAgICAgICAgICAgIHBhdGgucHVzaCh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxvZ2dlcihuYW1lLCBwYXRoLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwdWJsaXNoTGV2ZWw6IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgICAgaWYgKGxldmVsICE9PSBudWxsICYmIGxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wdWJsaXNoTGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGdldExldmVsKHRoaXMsICdfcHVibGlzaExldmVsJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29uc29sZUxldmVsOiBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICAgIGlmIChsZXZlbCAhPT0gbnVsbCAmJiBsZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc29sZUxldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBnZXRMZXZlbCh0aGlzLCAnX2NvbnNvbGVMZXZlbCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1ldHJpY3NMZXZlbDogZnVuY3Rpb24gKGxldmVsLCBtZXRyaWNzU3lzdGVtKSB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgIT09IG51bGwgJiYgbGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21ldHJpY0xldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZXRyaWNzU3lzdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1ldHJpY3NTeXN0ZW0gPT09ICdvYmplY3QnICYmIHR5cGVvZiBtZXRyaWNzU3lzdGVtLm9iamVjdE1ldHJpYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldHJpY1N5c3RlbSA9IG1ldHJpY3NTeXN0ZW07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2Ugc3BlY2lmeSBtZXRyaWMgc3lzdGVtICcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0YWJsZTogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIC8vIG1lc3NhZ2UgbXVzdCBiZSBpbiBhbiBhcnJheSwgdG8gYmUgZGlzcGxheWVkIGFzIHRhYmxlXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBtZXNzYWdlIG11c3QgYmUgaW4gYW4gYXJyYXknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmV0cmlldmUgbG9nZ2VyIG5hbWUgYW5kIGxldmVsc1xuICAgICAgICAgICAgdmFyIGxvZ2dlck5hbWUgPSBnZXRMb2dnZXJOYW1lKHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBQdWJsaXNoIGluIGNvbnNvbGVcbiAgICAgICAgICAgIGlmIChzaG91bGRQdWJsaXNoKGdldExldmVsKHRoaXMsICdfY29uc29sZUxldmVsJyksICdpbmZvJykpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8obG9nZ2VyTmFtZSArICc6Jyk7XG4gICAgICAgICAgICAgICAgY29uc29sZS50YWJsZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFB1Ymxpc2ggaW4gZmlsZVxuICAgICAgICAgICAgaWYgKHNob3VsZFB1Ymxpc2goZ2V0TGV2ZWwodGhpcywgJ19wdWJsaXNoTGV2ZWwnKSwgJ2luZm8nKSkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uc2VuZCgnbG9nJywgJ0xvZ01lc3NhZ2UnLCB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZVN0cixcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IGxldmVscy5pbmRleE9mKCdpbmZvJyksXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcjogbG9nZ2VyTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVRvVGFibGUobG9nZ2VyTmFtZSwgbWVzc2FnZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBsb2c6IGZ1bmN0aW9uIChtZXNzYWdlLCBsZXZlbCkge1xuICAgICAgICAgICAgcHVibGlzaE1lc3NhZ2UodGhpcywgbGV2ZWwgfHwgJ2luZm8nLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2dnZXIobmFtZSwgcGF0aCwgcGFyZW50KSB7XG4gICAgICAgIHZhciBsb2dnZXIgPSBPYmplY3QuY3JlYXRlKGxvZ2dlclByb3RvKTtcbiAgICAgICAgbG9nZ2VyLm5hbWUgPSBuYW1lO1xuICAgICAgICBsb2dnZXIucGF0aCA9IHBhdGg7XG4gICAgICAgIGxvZ2dlci5zdWJsb2dnZXJzID0gW107XG4gICAgICAgIGxvZ2dlci5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gYWRkIHN1YmxvZ2dlciB0byBzdWJsb2dnZXJzIGFycmF5XG4gICAgICAgICAgICBwYXJlbnQuc3VibG9nZ2Vycy5wdXNoKGxvZ2dlcik7XG4gICAgICAgICAgICAvLyBhZGQgZWFzeSBhY2Nlc3MgdG8gc3VibG9nZ2VyXG4gICAgICAgICAgICBwYXJlbnRbbG9nZ2VyLm5hbWVdID0gbG9nZ2VyO1xuICAgICAgICAgICAgLy8gY3JlYXRlIG1ldHJpYyBzeXN0ZW1cbiAgICAgICAgICAgIGlmIChwYXJlbnQubWV0cmljU3lzdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubWV0cmljc0xldmVsKCd3YXJuJywgcGFyZW50Lm1ldHJpY1N5c3RlbS5zdWJTeXN0ZW0obG9nZ2VyLm5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldmVscy5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgICAgbG9nZ2VyW2xldmVsXSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgcHVibGlzaE1lc3NhZ2UobG9nZ2VyLCBsZXZlbCwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICBsb2dnZXIub2ZmID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgbG9nZ2VyLnZlcnNpb24gPSBQYWNrYWdlSnNvbi52ZXJzaW9uO1xuXG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVibGlzaE1lc3NhZ2UobG9nZ2VyLCBsZXZlbCwgbWVzc2FnZSkge1xuICAgICAgICAvLyBSZXRyaWV2ZSBsb2dnZXIgbmFtZSBhbmQgbGV2ZWxzXG4gICAgICAgIHZhciBsb2dnZXJOYW1lID0gZ2V0TG9nZ2VyTmFtZShsb2dnZXIpO1xuXG4gICAgICAgIC8vIEFkZCBzdGFjayB0cmFjZSBpZiB0aGUgbWVzc2FnZSBpcyBhbiBlcnJvclxuICAgICAgICBpZiAobGV2ZWwgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIHZhciBlID0gbmV3IEVycm9yKCk7XG4gICAgICAgICAgICBpZiAoZS5zdGFjaykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlICsgJ1xcbicgKyAoZS5zdGFjay5zcGxpdCgnXFxuJylcbiAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDMpXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQdWJsaXNoIGluIGNvbnNvbGVcbiAgICAgICAgaWYgKHNob3VsZFB1Ymxpc2goZ2V0TGV2ZWwobG9nZ2VyLCAnX2NvbnNvbGVMZXZlbCcpLCBsZXZlbCkpIHtcbiAgICAgICAgICAgIGlmICghY29uc29sZVtsZXZlbF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlW2xldmVsXShsb2dnZXJOYW1lICsgJzogJyArIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFB1Ymxpc2ggaW4gZmlsZVxuICAgICAgICBpZiAoc2hvdWxkUHVibGlzaChnZXRMZXZlbChsb2dnZXIsICdfcHVibGlzaExldmVsJyksIGxldmVsKSkge1xuICAgICAgICAgICAgY29ubmVjdGlvbi5zZW5kKCdsb2cnLCAnTG9nTWVzc2FnZScsIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VTdHIsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IGxldmVscy5pbmRleE9mKGxldmVsKSxcbiAgICAgICAgICAgICAgICBsb2dnZXI6IGxvZ2dlck5hbWUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQdWJsaXNoIGluIG1ldHJpY3NcbiAgICAgICAgaWYgKHNob3VsZFB1Ymxpc2goZ2V0TGV2ZWwobG9nZ2VyLCAnX21ldHJpY0xldmVsJyksIGxldmVsKSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlci5tZXRyaWNTeXN0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5tZXRyaWNTeXN0ZW0ub2JqZWN0TWV0cmljKCdMb2dNZXNzYWdlJywge1xuICAgICAgICAgICAgICAgICAgICBUaW1lOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICBMb2dnZXI6IGxvZ2dlck5hbWUsXG4gICAgICAgICAgICAgICAgICAgIExldmVsOiBsZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZTogbWVzc2FnZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxldmVsID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5tZXRyaWNTeXN0ZW0uc2V0U3RhdGUoMTAwLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkUHVibGlzaCA9IGZ1bmN0aW9uIChwdWJsaXNoTGV2ZWwsIG1lc3NhZ2VMZXZlbCkge1xuICAgICAgICByZXR1cm4gKCFwdWJsaXNoTGV2ZWwgfHwgbGV2ZWxzLmluZGV4T2YocHVibGlzaExldmVsKSA8PSBsZXZlbHMuaW5kZXhPZihtZXNzYWdlTGV2ZWwpKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldExvZ2dlck5hbWUgPSBmdW5jdGlvbiAobG9nZ2VyKSB7XG4gICAgICAgIHZhciBsb2dnZXJQYXRoQW5kTmFtZSA9IGxvZ2dlci5wYXRoLnNsaWNlKCk7XG4gICAgICAgIGxvZ2dlclBhdGhBbmROYW1lLnB1c2gobG9nZ2VyLm5hbWUpO1xuICAgICAgICByZXR1cm4gJ1snICsgc2VyaWFsaXplUGF0aChsb2dnZXJQYXRoQW5kTmFtZSkgKyAnXSc7XG4gICAgfTtcblxuICAgIHZhciBtYWluTG9nZ2VyID0gY3JlYXRlTG9nZ2VyKCdtYWluJywgW10sIHVuZGVmaW5lZCk7XG4gICAgbWFpbkxvZ2dlci5wdWJsaXNoTGV2ZWwoJ3dhcm4nKTtcbiAgICBtYWluTG9nZ2VyLmNvbnNvbGVMZXZlbCgnaW5mbycpO1xuICAgIG1haW5Mb2dnZXIubWV0cmljc0xldmVsKCd3YXJuJyk7XG5cbiAgICByZXR1cm4gbWFpbkxvZ2dlcjtcbn1cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LnRpY2s0MiA9IHdpbmRvdy50aWNrNDIgfHwge307XG4gICAgd2luZG93LnRpY2s0Mi5sb2cgPSBsb2dnZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbG9nZ2VyO1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIl9hcmdzXCI6IFtcbiAgICBbXG4gICAgICBcInRpY2s0Mi1sb2dnZXJAMi4wLjZcIixcbiAgICAgIFwiQzpcXFxcd29ya1xcXFxzdGFzaFxcXFxHTFVFLWRldlxcXFxqcy1nbHVlXCJcbiAgICBdXG4gIF0sXG4gIFwiX2Zyb21cIjogXCJ0aWNrNDItbG9nZ2VyQDIuMC42XCIsXG4gIFwiX2lkXCI6IFwidGljazQyLWxvZ2dlckAyLjAuNlwiLFxuICBcIl9pbkNhY2hlXCI6IHRydWUsXG4gIFwiX2luc3RhbGxhYmxlXCI6IHRydWUsXG4gIFwiX2xvY2F0aW9uXCI6IFwiL3RpY2s0Mi1sb2dnZXJcIixcbiAgXCJfbm9kZVZlcnNpb25cIjogXCI2LjMuMFwiLFxuICBcIl9ucG1Vc2VyXCI6IHt9LFxuICBcIl9ucG1WZXJzaW9uXCI6IFwiMy44LjVcIixcbiAgXCJfcGhhbnRvbUNoaWxkcmVuXCI6IHt9LFxuICBcIl9yZXF1ZXN0ZWRcIjoge1xuICAgIFwibmFtZVwiOiBcInRpY2s0Mi1sb2dnZXJcIixcbiAgICBcInJhd1wiOiBcInRpY2s0Mi1sb2dnZXJAMi4wLjZcIixcbiAgICBcInJhd1NwZWNcIjogXCIyLjAuNlwiLFxuICAgIFwic2NvcGVcIjogbnVsbCxcbiAgICBcInNwZWNcIjogXCIyLjAuNlwiLFxuICAgIFwidHlwZVwiOiBcInZlcnNpb25cIlxuICB9LFxuICBcIl9yZXF1aXJlZEJ5XCI6IFtcbiAgICBcIi9cIlxuICBdLFxuICBcIl9zaGFzdW1cIjogXCIwNDEyNDc2M2IzMGQyYmJlMTk5ZTM4YWFjNzE1ZTMwOGU0MjVjMDIzXCIsXG4gIFwiX3Nocmlua3dyYXBcIjogbnVsbCxcbiAgXCJfc3BlY1wiOiBcInRpY2s0Mi1sb2dnZXJAMi4wLjZcIixcbiAgXCJfd2hlcmVcIjogXCJDOlxcXFx3b3JrXFxcXHN0YXNoXFxcXEdMVUUtZGV2XFxcXGpzLWdsdWVcIixcbiAgXCJhdXRob3JcIjoge1xuICAgIFwibmFtZVwiOiBcIlRpY2s0MlwiXG4gIH0sXG4gIFwiYmluXCI6IHtcbiAgICBcImJ1aWxkXCI6IFwiLi9iaW4vYnVpbGQuanNcIixcbiAgICBcImNsZWFuXCI6IFwiLi9iaW4vY2xlYW4uanNcIixcbiAgICBcImZpbGUtdmVyc2lvbmlmeVwiOiBcIi4vYmluL2ZpbGUtdmVyc2lvbmlmeS5qc1wiLFxuICAgIFwibWluaWZ5XCI6IFwiLi9iaW4vbWluaWZ5LmpzXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYXNjaWktdGFibGVcIjogXCIwLjAuOFwiLFxuICAgIFwidGljazQyLWdhdGV3YXktY29ubmVjdGlvblwiOiBcIj49MS4xLjlcIlxuICB9LFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQSBsaWJyYXJ5IGZvciBsb2dnaW5nXCIsXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImJsYW5rZXRcIjogXCJeMS4xLjZcIixcbiAgICBcImJyb3dzZXJpZnlcIjogXCJeMTMuMC4wXCIsXG4gICAgXCJicm93c2VyaWZ5LXJlcGxhY2lmeVwiOiBcIl4wLjAuNFwiLFxuICAgIFwiYnJvd3NlcmlmeS12ZXJzaW9uaWZ5XCI6IFwiXjEuMC40XCIsXG4gICAgXCJlc2xpbnRcIjogXCJeMy4xLjFcIixcbiAgICBcImVzbGludC1jb25maWctc3RhbmRhcmRcIjogXCJeNS4zLjVcIixcbiAgICBcImVzbGludC1jb25maWctdGljazQyXCI6IFwiXjEuMC4wXCIsXG4gICAgXCJlc2xpbnQtcGx1Z2luLXByb21pc2VcIjogXCJeMi4wLjBcIixcbiAgICBcImVzbGludC1wbHVnaW4tc3RhbmRhcmRcIjogXCJeMi4wLjBcIixcbiAgICBcImZzXCI6IFwiMC4wLjJcIixcbiAgICBcImpzZG9tXCI6IFwiXjguMS4wXCIsXG4gICAgXCJtaW5pZnlpZnlcIjogXCJeNy4zLjJcIixcbiAgICBcIm9uY2hhbmdlXCI6IFwiXjIuMS4yXCIsXG4gICAgXCJwaGFudG9tanNcIjogXCJeMS45LjEyXCIsXG4gICAgXCJxdW5pdGpzXCI6IFwiXjEuMTUuMFwiLFxuICAgIFwic2hlbGxqc1wiOiBcIl4wLjYuMFwiXG4gIH0sXG4gIFwiZGlzdFwiOiB7XG4gICAgXCJzaGFzdW1cIjogXCIwNDEyNDc2M2IzMGQyYmJlMTk5ZTM4YWFjNzE1ZTMwOGU0MjVjMDIzXCIsXG4gICAgXCJ0YXJiYWxsXCI6IFwiaHR0cDovLzE5Mi4xNjguMC4yMzQ6NDg3My90aWNrNDItbG9nZ2VyLy0vdGljazQyLWxvZ2dlci0yLjAuNi50Z3pcIlxuICB9LFxuICBcImdpdEhlYWRcIjogXCIzNGJlMzAxOWIyMzc5MTE5Mzc2MzhhNmY0YWJmMWU4MjBmNmQxODI5XCIsXG4gIFwibGljZW5zZVwiOiBcIklTQ1wiLFxuICBcIm1haW5cIjogXCJsaWJyYXJ5L2xvZ2dlclwiLFxuICBcIm5hbWVcIjogXCJ0aWNrNDItbG9nZ2VyXCIsXG4gIFwib3B0aW9uYWxEZXBlbmRlbmNpZXNcIjoge30sXG4gIFwicmVhZG1lXCI6IFwiRVJST1I6IE5vIFJFQURNRSBkYXRhIGZvdW5kIVwiLFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9zdGFzaC50aWNrNDIuY29tOjg0NDMvc2NtL29mZ3cvanMtbG9nZ2VyLmdpdFwiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJidWlsZFwiOiBcIm5wbSBydW4gZXNsaW50ICYmIG5vZGUgYmluL2NsZWFuLmpzICYmIG5vZGUgYmluL2J1aWxkLmpzICYmIG5vZGUgYmluL21pbmlmeSAmJiBub2RlIGJpbi9maWxlLXZlcnNpb25pZnlcIixcbiAgICBcImVzbGludFwiOiBcImVzbGludCBsaWJyYXJ5XCIsXG4gICAgXCJlc2xpbnQ6Zml4XCI6IFwiZXNsaW50IGxpYnJhcnkgLS1maXhcIixcbiAgICBcInByZXB1Ymxpc2hcIjogXCJucG0gdXBkYXRlICYgbnBtIHJ1biBidWlsZFwiLFxuICAgIFwidGVzdFwiOiBcIm5wbSBydW4gZXNsaW50ICYmIG1vY2hhIC0tcmVxdWlyZSAuL3Rlc3QvdGVzdF9oZWxwZXIgXFxcInRlc3QvKiovKi5qc1xcXCJcIixcbiAgICBcIndhdGNoXCI6IFwib25jaGFuZ2UgXFxcIi4vbGlicmFyeS8qLmpzXFxcIiAtaXYgLWUgXFxcIi4vYmluXFxcIiAtLSBucG0gcnVuIGJ1aWxkXCJcbiAgfSxcbiAgXCJ2ZXJzaW9uXCI6IFwiMi4wLjZcIlxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBvYmplY3RNZXRyaWNfMSA9IHJlcXVpcmUoXCIuLi9tZXRyaWNzL29iamVjdE1ldHJpY1wiKTtcclxudmFyIHN0cmluZ01ldHJpY18xID0gcmVxdWlyZShcIi4uL21ldHJpY3Mvc3RyaW5nTWV0cmljXCIpO1xyXG52YXIgbnVtYmVyTWV0cmljXzEgPSByZXF1aXJlKFwiLi4vbWV0cmljcy9udW1iZXJNZXRyaWNcIik7XHJcbnZhciB0aW1lc3RhbXBNZXRyaWNfMSA9IHJlcXVpcmUoXCIuLi9tZXRyaWNzL3RpbWVzdGFtcE1ldHJpY1wiKTtcclxudmFyIE1ldHJpY1NlcmlhbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWV0cmljU2VyaWFsaXplcigpIHtcclxuICAgIH1cclxuICAgIE1ldHJpY1NlcmlhbGl6ZXIubWV0cmljVG9NZXNzYWdlID0gZnVuY3Rpb24gKG1ldHJpYykge1xyXG4gICAgICAgIHZhciBkZWYgPSBNZXRyaWNTZXJpYWxpemVyLl9nZXRNZXRyaWNEZWZpbml0aW9uKG1ldHJpYy5uYW1lLCBtZXRyaWMudmFsdWUsIG1ldHJpYy5wYXRoLCBtZXRyaWMudHlwZSwgbWV0cmljLmRlc2NyaXB0aW9uLCBtZXRyaWMucGVyaW9kLCBtZXRyaWMucmVzb2x1dGlvbik7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaWQ6IG1ldHJpYy5pZCxcclxuICAgICAgICAgICAgaW5zdGFuY2U6IG1ldHJpYy5yZXBvLmluc3RhbmNlLFxyXG4gICAgICAgICAgICBkZWZpbml0aW9uOiBkZWYsXHJcbiAgICAgICAgICAgIHZhbHVlOiBNZXRyaWNTZXJpYWxpemVyLl9zZXJpYWxpemVWYWx1ZShtZXRyaWMudmFsdWUsIG1ldHJpYyksXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBNZXRyaWNTZXJpYWxpemVyLl9nZXRNZXRyaWNEZWZpbml0aW9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBwYXRoLCB0eXBlLCBkZXNjcmlwdGlvbiwgcmVzb2x1dGlvbiwgcGVyaW9kKSB7XHJcbiAgICAgICAgdmFyIGRlZiA9IHtcclxuICAgICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxyXG4gICAgICAgICAgICB0eXBlOiB0eXBlID8gdHlwZSA6IE1ldHJpY1NlcmlhbGl6ZXIuX2dldFR5cGVGcm9tVmFsdWUodmFsdWUpLFxyXG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxyXG4gICAgICAgICAgICByZXNvbHV0aW9uOiByZXNvbHV0aW9uLFxyXG4gICAgICAgICAgICBwZXJpb2Q6IHBlcmlvZFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGRlZi50eXBlID09PSBvYmplY3RNZXRyaWNfMS5PYmplY3RNZXRyaWMudHlwZSkge1xyXG4gICAgICAgICAgICBkZWYuQ29tcG9zaXRlID0gT2JqZWN0LmtleXModmFsdWUpLnJlZHVjZShmdW5jdGlvbiAoYXJyLCBrZXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWwgPSB2YWx1ZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgYXJyLnB1c2goTWV0cmljU2VyaWFsaXplci5fZ2V0TWV0cmljRGVmaW5pdGlvbihrZXksIHZhbCwgcGF0aCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycjtcclxuICAgICAgICAgICAgfSwgW10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmO1xyXG4gICAgfTtcclxuICAgIE1ldHJpY1NlcmlhbGl6ZXIuX3NlcmlhbGl6ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBtZXRyaWMpIHtcclxuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IERhdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdGhpcy5fdmFsdWVUeXBlcy5pbmRleE9mKFwiZGF0ZVwiKSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUudmFsdWVPZigpLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzQXJyYXk6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgQ29tcG9zaXRlVmFsdWU6IE9iamVjdC5rZXlzKHZhbHVlKS5yZWR1Y2UoZnVuY3Rpb24gKGFyciwga2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IE1ldHJpY1NlcmlhbGl6ZXIuX3NlcmlhbGl6ZVZhbHVlKHZhbHVlW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbC5Jbm5lck1ldHJpY05hbWUgPSBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2godmFsKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgICAgICAgICAgICAgfSwgW10pXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVUeXBlID0gbWV0cmljID8gbWV0cmljLmdldFZhbHVlVHlwZSgpIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB2YWx1ZVR5cGUgPSB2YWx1ZVR5cGUgfCB0aGlzLl92YWx1ZVR5cGVzLmluZGV4T2YodHlwZW9mIHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHsgdHlwZTogdmFsdWVUeXBlLCB2YWx1ZTogdmFsdWUsIGlzQXJyYXk6IGZhbHNlIH0gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTWV0cmljU2VyaWFsaXplci5fZ2V0VHlwZUZyb21WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHZhciB0eXBlQXNTdHJpbmcgPSB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gRGF0ZSA/ICd0aW1lc3RhbXAnIDogdHlwZW9mIHZhbHVlO1xyXG4gICAgICAgIHN3aXRjaCAodHlwZUFzU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nTWV0cmljXzEuU3RyaW5nTWV0cmljLnR5cGU7XHJcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyTWV0cmljXzEuTnVtYmVyTWV0cmljLnR5cGU7XHJcbiAgICAgICAgICAgIGNhc2UgJ3RpbWVzdGFtcCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGltZXN0YW1wTWV0cmljXzEuVGltZXN0YW1wTWV0cmljLnR5cGU7XHJcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0TWV0cmljXzEuT2JqZWN0TWV0cmljLnR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfTtcclxuICAgIE1ldHJpY1NlcmlhbGl6ZXIuX3ZhbHVlVHlwZXMgPSBbXHJcbiAgICAgICAgXCJib29sZWFuXCIsXHJcbiAgICAgICAgXCJpbnRcIixcclxuICAgICAgICBcIm51bWJlclwiLFxyXG4gICAgICAgIFwibG9uZ1wiLFxyXG4gICAgICAgIFwic3RyaW5nXCIsXHJcbiAgICAgICAgXCJkYXRlXCIsXHJcbiAgICAgICAgXCJvYmplY3RcIl07XHJcbiAgICByZXR1cm4gTWV0cmljU2VyaWFsaXplcjtcclxufSgpKTtcclxuZXhwb3J0cy5NZXRyaWNTZXJpYWxpemVyID0gTWV0cmljU2VyaWFsaXplcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0cmljU2VyaWFsaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIG1ldHJpY1NlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL21ldHJpY1NlcmlhbGl6ZXJcIik7XHJcbnZhciBNZXRyaWNzQnJpZGdlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1ldHJpY3NCcmlkZ2UocmVwbywgY29ubmVjdGlvbikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fcmVwbyA9IHJlcG87XHJcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XHJcbiAgICAgICAgY29ubmVjdGlvbi5vbignbWV0cmljcycsIFwiTWV0cmljc1NuYXBzaG90UmVxdWVzdFwiLCBmdW5jdGlvbiAoaW5zdGFuY2VJbmZvKSB7XHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZUluZm8uSW5zdGFuY2UgIT09IHJlcG8uaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5zZW5kRnVsbChfdGhpcy5fcmVwbyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBNZXRyaWNzQnJpZGdlLnByb3RvdHlwZS5zZW5kRnVsbCA9IGZ1bmN0aW9uIChyZXBvKSB7XHJcbiAgICAgICAgdmFyIHJvb3RTeXN0ZW0gPSByZXBvLnJvb3Q7XHJcbiAgICAgICAgaWYgKCFyb290U3lzdGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJvb3RTeXN0ZW0uc3ViU3lzdGVtcy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VuZEZ1bGxTeXN0ZW0ocm9vdFN5c3RlbSk7XHJcbiAgICB9O1xyXG4gICAgTWV0cmljc0JyaWRnZS5wcm90b3R5cGUuc2VuZEZ1bGxTeXN0ZW0gPSBmdW5jdGlvbiAocykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVTeXN0ZW0ocyk7XHJcbiAgICAgICAgcy5zdWJTeXN0ZW1zLmZvckVhY2goZnVuY3Rpb24gKHN1Yikge1xyXG4gICAgICAgICAgICBfdGhpcy5zZW5kRnVsbFN5c3RlbSgoc3ViKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcy5tZXRyaWNzLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICAgICAgX3RoaXMuY3JlYXRlTWV0cmljKG0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE1ldHJpY3NCcmlkZ2UucHJvdG90eXBlLmNyZWF0ZU1ldHJpYyA9IGZ1bmN0aW9uIChtZXRyaWMpIHtcclxuICAgICAgICB0aGlzLl9zZW5kKFwiQ3JlYXRlTWV0cmljXCIsIG1ldHJpY1NlcmlhbGl6ZXJfMS5NZXRyaWNTZXJpYWxpemVyLm1ldHJpY1RvTWVzc2FnZShtZXRyaWMpKTtcclxuICAgIH07XHJcbiAgICBNZXRyaWNzQnJpZGdlLnByb3RvdHlwZS51cGRhdGVNZXRyaWMgPSBmdW5jdGlvbiAobWV0cmljKSB7XHJcbiAgICAgICAgdGhpcy5fc2VuZChcIlVwZGF0ZU1ldHJpY1wiLCBtZXRyaWNTZXJpYWxpemVyXzEuTWV0cmljU2VyaWFsaXplci5tZXRyaWNUb01lc3NhZ2UobWV0cmljKSk7XHJcbiAgICB9O1xyXG4gICAgTWV0cmljc0JyaWRnZS5wcm90b3R5cGUuY3JlYXRlU3lzdGVtID0gZnVuY3Rpb24gKHN5c3RlbSkge1xyXG4gICAgICAgIGlmIChzeXN0ZW0ucGFyZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2VuZChcIkNyZWF0ZU1ldHJpY1N5c3RlbVwiLCB7XHJcbiAgICAgICAgICAgICAgICBpZDogc3lzdGVtLmlkLFxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IHN5c3RlbS5yZXBvLmluc3RhbmNlLFxyXG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbjogeyBuYW1lOiBzeXN0ZW0ubmFtZSwgZGVzY3JpcHRpb246IHN5c3RlbS5kZXNjcmlwdGlvbiwgcGF0aDogc3lzdGVtLnBhdGggfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTWV0cmljc0JyaWRnZS5wcm90b3R5cGUudXBkYXRlU3lzdGVtID0gZnVuY3Rpb24gKHN5c3RlbSwgc3RhdGUpIHtcclxuICAgICAgICB0aGlzLl9zZW5kKFwiVXBkYXRlTWV0cmljU3lzdGVtXCIsIHtcclxuICAgICAgICAgICAgaWQ6IHN5c3RlbS5pZCxcclxuICAgICAgICAgICAgaW5zdGFuY2U6IHN5c3RlbS5yZXBvLmluc3RhbmNlLFxyXG4gICAgICAgICAgICBzdGF0ZTogc3RhdGVcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBNZXRyaWNzQnJpZGdlLnByb3RvdHlwZS5oZWFydGJlYXQgPSBmdW5jdGlvbiAocmVwbywgaW50ZXJ2YWwpIHtcclxuICAgICAgICB0aGlzLl9zZW5kKFwiSGVhcnRiZWF0TWV0cmljc1wiLCB7IHB1Ymxpc2hpbmdJbnRlcnZhbDogaW50ZXJ2YWwsIGluc3RhbmNlOiByZXBvLmluc3RhbmNlIH0pO1xyXG4gICAgfTtcclxuICAgIE1ldHJpY3NCcmlkZ2UucHJvdG90eXBlLl9zZW5kID0gZnVuY3Rpb24gKHR5cGUsIG1lc3NhZ2UpIHtcclxuICAgICAgICB0aGlzLl9jb25uZWN0aW9uLnNlbmQoXCJtZXRyaWNzXCIsIHR5cGUsIG1lc3NhZ2UpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBNZXRyaWNzQnJpZGdlO1xyXG59KCkpO1xyXG5leHBvcnRzLk1ldHJpY3NCcmlkZ2UgPSBNZXRyaWNzQnJpZGdlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc3BvcnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBtZXRyaWNfMSA9IHJlcXVpcmUoXCIuL21ldHJpY1wiKTtcclxudmFyIEFkZHJlc3NNZXRyaWMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFkZHJlc3NNZXRyaWMsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBZGRyZXNzTWV0cmljKGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIHZhbHVlKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVmLCBwYXJlbnQsIHRyYW5zcG9ydCwgQWRkcmVzc01ldHJpYy50eXBlLCB2YWx1ZSB8fCAnJyk7XHJcbiAgICB9XHJcbiAgICBBZGRyZXNzTWV0cmljLnR5cGUgPSA4O1xyXG4gICAgcmV0dXJuIEFkZHJlc3NNZXRyaWM7XHJcbn0obWV0cmljXzEuTWV0cmljKSk7XHJcbmV4cG9ydHMuQWRkcmVzc01ldHJpYyA9IEFkZHJlc3NNZXRyaWM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZHJlc3NNZXRyaWMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBtZXRyaWNfMSA9IHJlcXVpcmUoXCIuL21ldHJpY1wiKTtcclxudmFyIENvdW50TWV0cmljID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDb3VudE1ldHJpYywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIENvdW50TWV0cmljKGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIHZhbHVlKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVmLCBwYXJlbnQsIHRyYW5zcG9ydCwgQ291bnRNZXRyaWMudHlwZSwgdmFsdWUgfHwgMCk7XHJcbiAgICB9XHJcbiAgICBDb3VudE1ldHJpYy5wcm90b3R5cGUuaW5jcmVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaW5jcmVtZW50QnkoMSk7XHJcbiAgICB9O1xyXG4gICAgQ291bnRNZXRyaWMucHJvdG90eXBlLmRlY3JlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmRlY3JlbWVudEJ5KDEpO1xyXG4gICAgfTtcclxuICAgIENvdW50TWV0cmljLnByb3RvdHlwZS5pbmNyZW1lbnRCeSA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKHRoaXMudmFsdWUgfHwgMCkgKyBuKTtcclxuICAgIH07XHJcbiAgICBDb3VudE1ldHJpYy5wcm90b3R5cGUuZGVjcmVtZW50QnkgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCh0aGlzLnZhbHVlIHx8IDApIC0gbik7XHJcbiAgICB9O1xyXG4gICAgQ291bnRNZXRyaWMucHJvdG90eXBlLmdldFZhbHVlVHlwZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gMztcclxuICAgIH07XHJcbiAgICBDb3VudE1ldHJpYy50eXBlID0gMztcclxuICAgIHJldHVybiBDb3VudE1ldHJpYztcclxufShtZXRyaWNfMS5NZXRyaWMpKTtcclxuZXhwb3J0cy5Db3VudE1ldHJpYyA9IENvdW50TWV0cmljO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3VudE1ldHJpYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIE1ldHJpYyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNZXRyaWMoZGVmLCBwYXJlbnQsIHRyYW5zcG9ydCwgdHlwZSwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBkZWYubmFtZTtcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVmLmRlc2NyaXB0aW9uO1xyXG4gICAgICAgIHRoaXMucGVyaW9kID0gZGVmLnBlcmlvZDtcclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSBkZWYucmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLnN5c3RlbSA9IHBhcmVudDtcclxuICAgICAgICB0aGlzLnJlcG8gPSBwYXJlbnQucmVwbztcclxuICAgICAgICB0aGlzLmlkID0gcGFyZW50LnBhdGggKyBcIi9cIiArIHRoaXMubmFtZTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLnBhdGggPSBwYXJlbnQucGF0aC5zbGljZSgwKTtcclxuICAgICAgICB0aGlzLnBhdGgucHVzaChwYXJlbnQubmFtZSk7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xyXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydC5jcmVhdGVNZXRyaWModGhpcyk7XHJcbiAgICB9XHJcbiAgICBNZXRyaWMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLl90cmFuc3BvcnQudXBkYXRlTWV0cmljKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIE1ldHJpYy5wcm90b3R5cGUuZ2V0VmFsdWVUeXBlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgTWV0cmljLnR5cGUgPSAwO1xyXG4gICAgcmV0dXJuIE1ldHJpYztcclxufSgpKTtcclxuZXhwb3J0cy5NZXRyaWMgPSBNZXRyaWM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldHJpYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIG1ldHJpY18xID0gcmVxdWlyZShcIi4vbWV0cmljXCIpO1xyXG52YXIgTnVtYmVyTWV0cmljID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhOdW1iZXJNZXRyaWMsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBOdW1iZXJNZXRyaWMoZGVmLCBwYXJlbnQsIHRyYW5zcG9ydCwgdmFsdWUpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZWYsIHBhcmVudCwgdHJhbnNwb3J0LCBOdW1iZXJNZXRyaWMudHlwZSwgdmFsdWUgfHwgMCk7XHJcbiAgICB9XHJcbiAgICBOdW1iZXJNZXRyaWMucHJvdG90eXBlLmluY3JlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmluY3JlbWVudEJ5KDEpO1xyXG4gICAgfTtcclxuICAgIE51bWJlck1ldHJpYy5wcm90b3R5cGUuZGVjcmVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZGVjcmVtZW50QnkoMSk7XHJcbiAgICB9O1xyXG4gICAgTnVtYmVyTWV0cmljLnByb3RvdHlwZS5pbmNyZW1lbnRCeSA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKHRoaXMudmFsdWUgfHwgMCkgKyBuKTtcclxuICAgIH07XHJcbiAgICBOdW1iZXJNZXRyaWMucHJvdG90eXBlLmRlY3JlbWVudEJ5ID0gZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgodGhpcy52YWx1ZSB8fCAwKSAtIG4pO1xyXG4gICAgfTtcclxuICAgIE51bWJlck1ldHJpYy50eXBlID0gMjtcclxuICAgIHJldHVybiBOdW1iZXJNZXRyaWM7XHJcbn0obWV0cmljXzEuTWV0cmljKSk7XHJcbmV4cG9ydHMuTnVtYmVyTWV0cmljID0gTnVtYmVyTWV0cmljO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXJNZXRyaWMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBtZXRyaWNfMSA9IHJlcXVpcmUoXCIuL21ldHJpY1wiKTtcclxudmFyIE9iamVjdE1ldHJpYyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoT2JqZWN0TWV0cmljLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gT2JqZWN0TWV0cmljKGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIHZhbHVlKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVmLCBwYXJlbnQsIHRyYW5zcG9ydCwgT2JqZWN0TWV0cmljLnR5cGUsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIE9iamVjdE1ldHJpYy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzLCB2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0TWV0cmljLnR5cGUgPSAxMTtcclxuICAgIHJldHVybiBPYmplY3RNZXRyaWM7XHJcbn0obWV0cmljXzEuTWV0cmljKSk7XHJcbmV4cG9ydHMuT2JqZWN0TWV0cmljID0gT2JqZWN0TWV0cmljO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYmplY3RNZXRyaWMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBtZXRyaWNfMSA9IHJlcXVpcmUoXCIuL21ldHJpY1wiKTtcclxudmFyIFJhdGVNZXRyaWMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFJhdGVNZXRyaWMsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBSYXRlTWV0cmljKGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIHZhbHVlKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVmLCBwYXJlbnQsIHRyYW5zcG9ydCwgUmF0ZU1ldHJpYy50eXBlLCB2YWx1ZSB8fCAwKTtcclxuICAgIH1cclxuICAgIFJhdGVNZXRyaWMudHlwZSA9IDQ7XHJcbiAgICByZXR1cm4gUmF0ZU1ldHJpYztcclxufShtZXRyaWNfMS5NZXRyaWMpKTtcclxuZXhwb3J0cy5SYXRlTWV0cmljID0gUmF0ZU1ldHJpYztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmF0ZU1ldHJpYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIG1ldHJpY18xID0gcmVxdWlyZShcIi4vbWV0cmljXCIpO1xyXG52YXIgU3RhdGlzdGljc01ldHJpYyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU3RhdGlzdGljc01ldHJpYywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFN0YXRpc3RpY3NNZXRyaWMoZGVmLCBwYXJlbnQsIHRyYW5zcG9ydCwgdmFsdWUpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZWYsIHBhcmVudCwgdHJhbnNwb3J0LCBTdGF0aXN0aWNzTWV0cmljLnR5cGUsIHZhbHVlIHx8IDApO1xyXG4gICAgfVxyXG4gICAgU3RhdGlzdGljc01ldHJpYy50eXBlID0gNjtcclxuICAgIHJldHVybiBTdGF0aXN0aWNzTWV0cmljO1xyXG59KG1ldHJpY18xLk1ldHJpYykpO1xyXG5leHBvcnRzLlN0YXRpc3RpY3NNZXRyaWMgPSBTdGF0aXN0aWNzTWV0cmljO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0aXN0aWNzTWV0cmljLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgbWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNcIik7XHJcbnZhciBTdHJpbmdNZXRyaWMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFN0cmluZ01ldHJpYywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFN0cmluZ01ldHJpYyhkZWYsIHBhcmVudCwgdHJhbnNwb3J0LCB2YWx1ZSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIFN0cmluZ01ldHJpYy50eXBlLCB2YWx1ZSB8fCAnJyk7XHJcbiAgICB9XHJcbiAgICBTdHJpbmdNZXRyaWMudHlwZSA9IDE7XHJcbiAgICByZXR1cm4gU3RyaW5nTWV0cmljO1xyXG59KG1ldHJpY18xLk1ldHJpYykpO1xyXG5leHBvcnRzLlN0cmluZ01ldHJpYyA9IFN0cmluZ01ldHJpYztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5nTWV0cmljLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgbWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNcIik7XHJcbnZhciBUaW1lc3Bhbk1ldHJpYyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVGltZXNwYW5NZXRyaWMsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUaW1lc3Bhbk1ldHJpYyhkZWYsIHBhcmVudCwgdHJhbnNwb3J0LCB2YWx1ZSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIFRpbWVzcGFuTWV0cmljLnR5cGUsIHZhbHVlIHx8IGZhbHNlKTtcclxuICAgIH1cclxuICAgIFRpbWVzcGFuTWV0cmljLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSh0cnVlKTtcclxuICAgIH07XHJcbiAgICBUaW1lc3Bhbk1ldHJpYy5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZShmYWxzZSk7XHJcbiAgICB9O1xyXG4gICAgVGltZXNwYW5NZXRyaWMudHlwZSA9IDEwO1xyXG4gICAgcmV0dXJuIFRpbWVzcGFuTWV0cmljO1xyXG59KG1ldHJpY18xLk1ldHJpYykpO1xyXG5leHBvcnRzLlRpbWVzcGFuTWV0cmljID0gVGltZXNwYW5NZXRyaWM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVzcGFuTWV0cmljLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgbWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNcIik7XHJcbnZhciBUaW1lc3RhbXBNZXRyaWMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFRpbWVzdGFtcE1ldHJpYywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFRpbWVzdGFtcE1ldHJpYyhkZWYsIHBhcmVudCwgdHJhbnNwb3J0LCB2YWx1ZSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIFRpbWVzdGFtcE1ldHJpYy50eXBlLCB2YWx1ZSB8fCBuZXcgRGF0ZSgpKTtcclxuICAgIH1cclxuICAgIFRpbWVzdGFtcE1ldHJpYy5wcm90b3R5cGUubm93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKG5ldyBEYXRlKCkpO1xyXG4gICAgfTtcclxuICAgIFRpbWVzdGFtcE1ldHJpYy50eXBlID0gNztcclxuICAgIHJldHVybiBUaW1lc3RhbXBNZXRyaWM7XHJcbn0obWV0cmljXzEuTWV0cmljKSk7XHJcbmV4cG9ydHMuVGltZXN0YW1wTWV0cmljID0gVGltZXN0YW1wTWV0cmljO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lc3RhbXBNZXRyaWMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBzeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL3N5c3RlbVwiKTtcclxudmFyIHRyYW5zcG9ydF8xID0gcmVxdWlyZShcIi4vYnJpZGdlL3RyYW5zcG9ydFwiKTtcclxudmFyIFJlcG9zaXRvcnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVwb3NpdG9yeShjb25maWcpIHtcclxuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydF8xLk1ldHJpY3NCcmlkZ2UodGhpcywgY29uZmlnLmNvbm5lY3Rpb24pO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBjb25maWcuaWRlbnRpdHkuc3lzdGVtICsgJy8nICsgY29uZmlnLmlkZW50aXR5LnNlcnZpY2UgKyAnLycgKyBjb25maWcuaWRlbnRpdHkuaW5zdGFuY2U7XHJcbiAgICAgICAgdGhpcy5pZGVudGl0eSA9IGNvbmZpZy5pZGVudGl0eTtcclxuICAgICAgICB0aGlzLl9zdGFydEhlYXJ0YmVhdGluZygpO1xyXG4gICAgICAgIHRoaXMucm9vdCA9IG5ldyBzeXN0ZW1fMS5TeXN0ZW0oJycsIHRoaXMsIHRoaXMuX3RyYW5zcG9ydCk7XHJcbiAgICAgICAgdGhpcy5faW5pdFN5c3RlbU1ldHJpY3ModGhpcy5yb290LCBjb25maWcuY2xpY2tTdHJlYW0gfHwgY29uZmlnLmNsaWNrU3RyZWFtID09PSB1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gICAgUmVwb3NpdG9yeS5wcm90b3R5cGUuX3N0YXJ0SGVhcnRiZWF0aW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0LmhlYXJ0YmVhdCh0aGlzLCB0aGlzLl9jb25maWcuc2V0dGluZ3MuaGVhcnRiZWF0SW50ZXJ2YWwpO1xyXG4gICAgICAgIHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMuX3RyYW5zcG9ydC5oZWFydGJlYXQoX3RoaXMsIF90aGlzLl9jb25maWcuc2V0dGluZ3MuaGVhcnRiZWF0SW50ZXJ2YWwpO1xyXG4gICAgICAgIH0sIHRoaXMuX2NvbmZpZy5zZXR0aW5ncy5oZWFydGJlYXRJbnRlcnZhbCk7XHJcbiAgICB9O1xyXG4gICAgUmVwb3NpdG9yeS5wcm90b3R5cGUuX2luaXRTeXN0ZW1NZXRyaWNzID0gZnVuY3Rpb24gKHJvb3RTeXN0ZW0sIHVzZUNsaWNrU3RyZWFtKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHJvb3RTeXN0ZW0uc3RyaW5nTWV0cmljKCdVc2VyQWdlbnQnLCBuYXZpZ2F0b3IudXNlckFnZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVzZUNsaWNrU3RyZWFtICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdmFyIGNsaWNrU3RyZWFtXzEgPSByb290U3lzdGVtLnN1YlN5c3RlbShcIkNsaWNrU3RyZWFtXCIpO1xyXG4gICAgICAgICAgICB2YXIgZG9jdW1lbnRDbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlLnRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNsaWNrU3RyZWFtXzEub2JqZWN0TWV0cmljKFwiTGFzdEJyb3dzZXJFdmVudFwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjbGlja1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBlLnRhcmdldCA/IGUudGFyZ2V0LmNsYXNzTmFtZSA6ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogZS50YXJnZXQuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICc8JyArIGUudGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSArICc+JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogZS50YXJnZXQuaHJlZiB8fCBcIlwiXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNsaWNrU3RyZWFtXzEub2JqZWN0TWV0cmljKFwiUGFnZVwiLCB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogZG9jdW1lbnQudGl0bGUsXHJcbiAgICAgICAgICAgICAgICBwYWdlOiB3aW5kb3cubG9jYXRpb24uaHJlZlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZG9jdW1lbnRDbGlja0hhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYXR0YWNoRXZlbnQoJ29uY2xpY2snLCBkb2N1bWVudENsaWNrSGFuZGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlcG9zaXRvcnk7XHJcbn0oKSk7XHJcbmV4cG9ydHMuUmVwb3NpdG9yeSA9IFJlcG9zaXRvcnk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcG9zaXRvcnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBudW1iZXJNZXRyaWNfMSA9IHJlcXVpcmUoXCIuL21ldHJpY3MvbnVtYmVyTWV0cmljXCIpO1xyXG52YXIgdGltZXNwYW5NZXRyaWNfMSA9IHJlcXVpcmUoXCIuL21ldHJpY3MvdGltZXNwYW5NZXRyaWNcIik7XHJcbnZhciBzdHJpbmdNZXRyaWNfMSA9IHJlcXVpcmUoXCIuL21ldHJpY3Mvc3RyaW5nTWV0cmljXCIpO1xyXG52YXIgYWRkcmVzc01ldHJpY18xID0gcmVxdWlyZShcIi4vbWV0cmljcy9hZGRyZXNzTWV0cmljXCIpO1xyXG52YXIgb2JqZWN0TWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNzL29iamVjdE1ldHJpY1wiKTtcclxudmFyIHRpbWVzdGFtcE1ldHJpY18xID0gcmVxdWlyZShcIi4vbWV0cmljcy90aW1lc3RhbXBNZXRyaWNcIik7XHJcbnZhciBjb3VudE1ldHJpY18xID0gcmVxdWlyZShcIi4vbWV0cmljcy9jb3VudE1ldHJpY1wiKTtcclxudmFyIHN0YXRpc3RpY3NNZXRyaWNfMSA9IHJlcXVpcmUoXCIuL21ldHJpY3Mvc3RhdGlzdGljc01ldHJpY1wiKTtcclxudmFyIHJhdGVNZXRyaWNfMSA9IHJlcXVpcmUoXCIuL21ldHJpY3MvcmF0ZU1ldHJpY1wiKTtcclxudmFyIFN5c3RlbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTeXN0ZW0obmFtZSwgcmVwbywgdHJhbnNwb3J0LCBwYXJlbnQsIGRlc2NyaXB0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5tZXRyaWNzID0gW107XHJcbiAgICAgICAgdGhpcy5zdWJTeXN0ZW1zID0gW107XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb24gfHwgJyc7XHJcbiAgICAgICAgdGhpcy5yZXBvID0gcmVwbztcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gdGhpcy5fYnVpbGRQYXRoKHRoaXMucGFyZW50KTtcclxuICAgICAgICB0aGlzLmlkID0gKHRoaXMucGF0aC5sZW5ndGggPiAwID8gdGhpcy5wYXRoLmpvaW4oJy8nKSArICcvJyA6ICcnKSArIHRoaXMubmFtZTtcclxuICAgICAgICB0aGlzLmlkZW50aXR5ID0gcmVwby5pZGVudGl0eTtcclxuICAgICAgICB0aGlzLnJvb3QgPSByZXBvLnJvb3Q7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0LmNyZWF0ZVN5c3RlbSh0aGlzKTtcclxuICAgIH1cclxuICAgIFN5c3RlbS5wcm90b3R5cGUuc3ViU3lzdGVtID0gZnVuY3Rpb24gKG5hbWUsIGRlc2NyaXB0aW9uKSB7XHJcbiAgICAgICAgaWYgKCFuYW1lIHx8IG5hbWUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbmFtZSBpcyByZXF1aXJlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWF0Y2hpbmdTeXN0ZW1zID0gdGhpcy5zdWJTeXN0ZW1zLmZpbHRlcihmdW5jdGlvbiAocykgeyByZXR1cm4gcy5uYW1lID09PSBuYW1lOyB9KTtcclxuICAgICAgICBpZiAobWF0Y2hpbmdTeXN0ZW1zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoaW5nU3lzdGVtc1swXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN5c3RlbSA9IG5ldyBTeXN0ZW0obmFtZSwgdGhpcy5yZXBvLCB0aGlzLl90cmFuc3BvcnQsIHRoaXMsIGRlc2NyaXB0aW9uKTtcclxuICAgICAgICB0aGlzLnN1YlN5c3RlbXMucHVzaChzeXN0ZW0pO1xyXG4gICAgICAgIHJldHVybiBzeXN0ZW07XHJcbiAgICB9O1xyXG4gICAgU3lzdGVtLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVzY3JpcHRpb24pIHtcclxuICAgICAgICB0aGlzLl90cmFuc3BvcnQudXBkYXRlU3lzdGVtKHRoaXMsIHsgc3RhdGU6IHN0YXRlLCBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24gfSk7XHJcbiAgICB9O1xyXG4gICAgU3lzdGVtLnByb3RvdHlwZS5zdHJpbmdNZXRyaWMgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbiwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRPckNyZWF0ZU1ldHJpYyhkZWZpbml0aW9uLCBzdHJpbmdNZXRyaWNfMS5TdHJpbmdNZXRyaWMudHlwZSwgdmFsdWUsIGZ1bmN0aW9uIChtZXRyaWNEZWYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBzdHJpbmdNZXRyaWNfMS5TdHJpbmdNZXRyaWMobWV0cmljRGVmLCBfdGhpcywgX3RoaXMuX3RyYW5zcG9ydCwgdmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFN5c3RlbS5wcm90b3R5cGUubnVtYmVyTWV0cmljID0gZnVuY3Rpb24gKGRlZmluaXRpb24sIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0T3JDcmVhdGVNZXRyaWMoZGVmaW5pdGlvbiwgbnVtYmVyTWV0cmljXzEuTnVtYmVyTWV0cmljLnR5cGUsIHZhbHVlLCBmdW5jdGlvbiAobWV0cmljRGVmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgbnVtYmVyTWV0cmljXzEuTnVtYmVyTWV0cmljKG1ldHJpY0RlZiwgX3RoaXMsIF90aGlzLl90cmFuc3BvcnQsIHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTeXN0ZW0ucHJvdG90eXBlLmNvdW50TWV0cmljID0gZnVuY3Rpb24gKGRlZmluaXRpb24sIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0T3JDcmVhdGVNZXRyaWMoZGVmaW5pdGlvbiwgY291bnRNZXRyaWNfMS5Db3VudE1ldHJpYy50eXBlLCB2YWx1ZSwgZnVuY3Rpb24gKG1ldHJpY0RlZikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGNvdW50TWV0cmljXzEuQ291bnRNZXRyaWMobWV0cmljRGVmLCBfdGhpcywgX3RoaXMuX3RyYW5zcG9ydCwgdmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFN5c3RlbS5wcm90b3R5cGUuYWRkcmVzc01ldHJpYyA9IGZ1bmN0aW9uIChkZWZpbml0aW9uLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9yQ3JlYXRlTWV0cmljKGRlZmluaXRpb24sIGFkZHJlc3NNZXRyaWNfMS5BZGRyZXNzTWV0cmljLnR5cGUsIHZhbHVlLCBmdW5jdGlvbiAobWV0cmljRGVmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgYWRkcmVzc01ldHJpY18xLkFkZHJlc3NNZXRyaWMobWV0cmljRGVmLCBfdGhpcywgX3RoaXMuX3RyYW5zcG9ydCwgdmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFN5c3RlbS5wcm90b3R5cGUub2JqZWN0TWV0cmljID0gZnVuY3Rpb24gKGRlZmluaXRpb24sIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0T3JDcmVhdGVNZXRyaWMoZGVmaW5pdGlvbiwgb2JqZWN0TWV0cmljXzEuT2JqZWN0TWV0cmljLnR5cGUsIHZhbHVlLCBmdW5jdGlvbiAobWV0cmljRGVmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgb2JqZWN0TWV0cmljXzEuT2JqZWN0TWV0cmljKG1ldHJpY0RlZiwgX3RoaXMsIF90aGlzLl90cmFuc3BvcnQsIHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTeXN0ZW0ucHJvdG90eXBlLnRpbWVzcGFuTWV0cmljID0gZnVuY3Rpb24gKGRlZmluaXRpb24sIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0T3JDcmVhdGVNZXRyaWMoZGVmaW5pdGlvbiwgdGltZXNwYW5NZXRyaWNfMS5UaW1lc3Bhbk1ldHJpYy50eXBlLCB2YWx1ZSwgZnVuY3Rpb24gKG1ldHJpY0RlZikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRpbWVzcGFuTWV0cmljXzEuVGltZXNwYW5NZXRyaWMobWV0cmljRGVmLCBfdGhpcywgX3RoaXMuX3RyYW5zcG9ydCwgdmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFN5c3RlbS5wcm90b3R5cGUudGltZXN0YW1wTWV0cmljID0gZnVuY3Rpb24gKGRlZmluaXRpb24sIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0T3JDcmVhdGVNZXRyaWMoZGVmaW5pdGlvbiwgdGltZXN0YW1wTWV0cmljXzEuVGltZXN0YW1wTWV0cmljLnR5cGUsIHZhbHVlLCBmdW5jdGlvbiAobWV0cmljRGVmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGltZXN0YW1wTWV0cmljXzEuVGltZXN0YW1wTWV0cmljKG1ldHJpY0RlZiwgX3RoaXMsIF90aGlzLl90cmFuc3BvcnQsIHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTeXN0ZW0ucHJvdG90eXBlLnJhdGVNZXRyaWMgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbiwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRPckNyZWF0ZU1ldHJpYyhkZWZpbml0aW9uLCByYXRlTWV0cmljXzEuUmF0ZU1ldHJpYy50eXBlLCB2YWx1ZSwgZnVuY3Rpb24gKG1ldHJpY0RlZikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJhdGVNZXRyaWNfMS5SYXRlTWV0cmljKG1ldHJpY0RlZiwgX3RoaXMsIF90aGlzLl90cmFuc3BvcnQsIHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTeXN0ZW0ucHJvdG90eXBlLnN0YXRpdGljc01ldHJpYyA9IGZ1bmN0aW9uIChkZWZpbml0aW9uLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9yQ3JlYXRlTWV0cmljKGRlZmluaXRpb24sIHN0YXRpc3RpY3NNZXRyaWNfMS5TdGF0aXN0aWNzTWV0cmljLnR5cGUsIHZhbHVlLCBmdW5jdGlvbiAobWV0cmljRGVmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgc3RhdGlzdGljc01ldHJpY18xLlN0YXRpc3RpY3NNZXRyaWMobWV0cmljRGVmLCBfdGhpcywgX3RoaXMuX3RyYW5zcG9ydCwgdmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFN5c3RlbS5wcm90b3R5cGUuX3VuaW9uVG9NZXRyaWNEZWYgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xyXG4gICAgICAgIHZhciBtZXRyaWNEZWY7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBtZXRyaWNEZWYgPSB7IG5hbWU6IGRlZmluaXRpb24gfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1ldHJpY0RlZiA9IGRlZmluaXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtZXRyaWNEZWYubmFtZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0cmljIG5hbWUgaXMgcmVxdWlyZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtZXRyaWNEZWY7XHJcbiAgICB9O1xyXG4gICAgU3lzdGVtLnByb3RvdHlwZS5fZ2V0T3JDcmVhdGVNZXRyaWMgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbiwgZXhwZWN0ZWRUeXBlLCB2YWx1ZSwgY3JlYXRlRnVuYykge1xyXG4gICAgICAgIHZhciBtZXRyaWNEZWYgPSB0aGlzLl91bmlvblRvTWV0cmljRGVmKGRlZmluaXRpb24pO1xyXG4gICAgICAgIHZhciBtYXRjaGluZ01ldHJpY3MgPSB0aGlzLm1ldHJpY3MuZmlsdGVyKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLm5hbWUgPT09IG1ldHJpY0RlZi5uYW1lOyB9KTtcclxuICAgICAgICBpZiAobWF0Y2hpbmdNZXRyaWNzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIGV4aXN0aW5nTWV0cmljID0gbWF0Y2hpbmdNZXRyaWNzWzBdO1xyXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdNZXRyaWMudHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgbWV0cmljIG5hbWVkICcgKyBtZXRyaWNEZWYubmFtZSArICcgaXMgYWxyZWFkeSBkZWZpbmVkIHdpdGggZGlmZmVyZW50IHR5cGUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgZXhpc3RpbmdNZXRyaWMudXBkYXRlKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdNZXRyaWM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuZXdNZXRyaWMgPSBjcmVhdGVGdW5jKG1ldHJpY0RlZik7XHJcbiAgICAgICAgdGhpcy5tZXRyaWNzLnB1c2gobmV3TWV0cmljKTtcclxuICAgICAgICByZXR1cm4gbmV3TWV0cmljO1xyXG4gICAgfTtcclxuICAgIFN5c3RlbS5wcm90b3R5cGUuX2J1aWxkUGF0aCA9IGZ1bmN0aW9uIChzeXN0ZW0pIHtcclxuICAgICAgICBpZiAoIXN5c3RlbSB8fCAhc3lzdGVtLnBhcmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5fYnVpbGRQYXRoKHN5c3RlbS5wYXJlbnQpO1xyXG4gICAgICAgIHBhdGgucHVzaChzeXN0ZW0ubmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFN5c3RlbTtcclxufSgpKTtcclxuZXhwb3J0cy5TeXN0ZW0gPSBTeXN0ZW07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN5c3RlbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIHJlcG9zaXRvcnlfMSA9IHJlcXVpcmUoXCIuL2NvcmUvcmVwb3NpdG9yeVwiKTtcclxudmFyIHRpY2s0Ml9nYXRld2F5X2Nvbm5lY3Rpb25fMSA9IHJlcXVpcmUoJ3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb24nKTtcclxudmFyIHdpbmRvd0FzQW55ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAobmV3IE9iamVjdCgpKSA6IHdpbmRvdztcclxud2luZG93QXNBbnkudGljazQyID0gd2luZG93QXNBbnkudGljazQyIHx8IHt9O1xyXG53aW5kb3dBc0FueS50aWNrNDIubWV0cmljcyA9IHdpbmRvd0FzQW55LnRpY2s0Mi5tZXRyaWNzIHx8IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgIGlmICghY29uZmlnLmlkZW50aXR5KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJZGVudGl0eSBtaXNzaW5nIGZyb20gbWV0cmljcyBjb25maWd1cmF0aW9uJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWNvbmZpZy5pZGVudGl0eS5zZXJ2aWNlIHx8IHR5cGVvZiBjb25maWcuaWRlbnRpdHkuc2VydmljZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZpY2UgbWlzc2luZyBvciBpbnZhbGlkIGluIG1ldHJpY3MgaWRlbnRpdHkgY29uZmlndXJhdGlvbicpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFjb25maWcuaWRlbnRpdHkuc3lzdGVtIHx8IHR5cGVvZiBjb25maWcuaWRlbnRpdHkuc3lzdGVtICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3lzdGVtIG1pc3Npbmcgb3IgaW52YWxpZCBpbiBtZXRyaWNzIGlkZW50aXR5IGNvbmZpZ3VyYXRpb24nKTtcclxuICAgIH1cclxuICAgIGlmICghY29uZmlnLmlkZW50aXR5Lmluc3RhbmNlIHx8IHR5cGVvZiBjb25maWcuaWRlbnRpdHkuaW5zdGFuY2UgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnN0YW5jZW1pc3Npbmcgb3IgaW52YWxpZCBpbiBtZXRyaWNzIGlkZW50aXR5IGNvbmZpZ3VyYXRpb24nKTtcclxuICAgIH1cclxuICAgIGNvbmZpZy5zZXR0aW5ncyA9IGNvbmZpZy5zZXR0aW5ncyB8fCB7fTtcclxuICAgIGNvbmZpZy5zZXR0aW5ncy5oZWFydGJlYXRJbnRlcnZhbCA9IGNvbmZpZy5zZXR0aW5ncy5oZWFydGJlYXRJbnRlcnZhbCB8fCAxNTAwMDtcclxuICAgIGlmICh0eXBlb2YgY29uZmlnLmNvbm5lY3Rpb24gIT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICBjb25maWcuY29ubmVjdGlvbiA9IHt9O1xyXG4gICAgfVxyXG4gICAgaWYgKCEodHlwZW9mIGNvbmZpZy5jb25uZWN0aW9uID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBjb25maWcuY29ubmVjdGlvbi5zZW5kID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGNvbmZpZy5jb25uZWN0aW9uLm9uID09PSBcImZ1bmN0aW9uXCIpKSB7XHJcbiAgICAgICAgY29uZmlnLmNvbm5lY3Rpb24gPSB0aWNrNDJfZ2F0ZXdheV9jb25uZWN0aW9uXzEuY29ubmVjdGlvbihjb25maWcuY29ubmVjdGlvbik7XHJcbiAgICB9XHJcbiAgICB2YXIgcmVwbyA9IG5ldyByZXBvc2l0b3J5XzEuUmVwb3NpdG9yeShjb25maWcpO1xyXG4gICAgcmVwb1sndmVyc2lvbiddID0gcmVwby5yb290Wyd2ZXJzaW9uJ10gPSAnMi4wLjE1JztcclxuICAgIHJldHVybiByZXBvLnJvb3Q7XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gd2luZG93QXNBbnkudGljazQyLm1ldHJpY3M7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldHJpY3NNb2R1bGUuanMubWFwIiwiICB2YXIgaGVscGVycyA9IG1vZHVsZS5leHBvcnRzID0ge307XHJcblxyXG4gIGhlbHBlcnMuaW52b2tlQWdtU3VjY2Vzc0NhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjYWxsYmFja0Fhcmd1bWVudCkge1xyXG4gICAgICAndXNlIHN0cmljdCc7XHJcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIGNhbGxiYWNrKGNhbGxiYWNrQWFyZ3VtZW50KTtcclxuICAgICAgfVxyXG4gIH1cclxuXHJcbiAgaGVscGVycy5pbnZva2VBZ21FcnJvckNhbGxiYWNrID0gIGZ1bmN0aW9uIChjYWxsYmFjaywgZXJyb3IpIHtcclxuICAgICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICBjYWxsYmFjayhlcnJvci5tZXNzYWdlKTtcclxuICAgICAgfVxyXG4gIH1cclxuXHJcbiAgaGVscGVycy5leGVjQ2FsbGJhY2tzID0gIGZ1bmN0aW9uIChhcnIsIHZhbCkge1xyXG4gICAgICAndXNlIHN0cmljdCc7XHJcbiAgICAgIGlmIChhcnIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgYXJyLmZvckVhY2goZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICBjYWxsYmFjayh2YWwpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICB9XHJcblxyXG4gIGhlbHBlcnMudmFscyA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICAndXNlIHN0cmljdCc7XHJcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZShmdW5jdGlvbihhcnIsIGtleSkge1xyXG4gICAgICAgICAgYXJyLnB1c2gob2JqW2tleV0pO1xyXG4gICAgICAgICAgcmV0dXJuIGFycjtcclxuICAgICAgfSwgW10pO1xyXG4gIH1cbiIsInZhciBkZXByZWNhdGUgPSByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpO1xyXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuaW5pdCA9IGluaXQ7XHJcbm1vZHVsZS5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZVdpbmRvdztcclxuXHJcbnZhciBhZ207XHJcblxyXG5mdW5jdGlvbiBzZXRXaW5kb3dTdHlsZUF0dHJpYnV0ZXMod2luZG93U3R5bGVzKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICAvLyBBZGRpbmcgd2luZG93U3R5bGVBdHRyaWJ1dGVzXHJcbiAgICBpZiAod2luZG93U3R5bGVzICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHdpbmRvd1N0eWxlcyAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh3aW5kb3dTdHlsZXMpO1xyXG4gICAgfSBlbHNlIGlmICh3aW5kb3dTdHlsZXMgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygd2luZG93U3R5bGVzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHJldHVybiB3aW5kb3dTdHlsZXM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaW5pdChhKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICBhZ20gPSBhO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gY3JlYXRlV2luZG93KGlkLCBpbnRlcm5hbElkLCBuYW1lLCBjb250YWluZXJPYmosIHVybCwgdGl0bGUsIHdpbmRvd1N0eWxlcykge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIGlmICghY29udGFpbmVyT2JqKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb250YWluZXJPYmogY2FuIG5vdCBiZSB1bmRlZmluZWQnKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmVzdWx0V2luZG93O1xyXG5cclxuICAgIGZ1bmN0aW9uIGFkZENhbGxiYWNrKGtleSwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgb2JqID0gcmVzdWx0V2luZG93Ll9jYWxsYmFja3M7XHJcbiAgICAgICAgaWYgKG9ialtrZXldID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb2JqW2tleV0gPSBbY2FsbGJhY2tdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG9ialtrZXldLnB1c2goY2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBGdW5jdGlvbnMgZm9yIG9wZW5pbmcsIGNsb3NpbmcsIHJlc2l6aW5nIHdpbmRvd3NcclxuICAgIGZ1bmN0aW9uIG9wZW4oZGltZW5zaW9ucywgc3R5bGUsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcblxyXG4gICAgICAgIC8vIEEgd3JhcHBlciBmb3IgdGhlIHN0YW5kYXJkIEFHTSBcIm9wZW5cIiBmdW5jdGlvblxyXG4gICAgICAgIHZhciB0aGVXaW5kb3cgPSB0aGlzO1xyXG5cclxuICAgICAgICAvLyBJbml0IHN0eWxlIG9iamVjdHMgaWYgdGhleSBhcmUgbnVsbFxyXG4gICAgICAgIGRpbWVuc2lvbnMgPSBkaW1lbnNpb25zIHx8IHt9O1xyXG4gICAgICAgIHN0eWxlID0gc3R5bGUgfHwge307XHJcblxyXG4gICAgICAgIC8vIFRha2Ugb3V0IHRoZSBzdGlja3ktd2luZG93cyByZWxhdGVkIHByb3BlcnRpZXMgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XHJcblxyXG4gICAgICAgIHZhciBpc1N0aWNreSA9IHN0eWxlLmlzU3RpY2t5O1xyXG4gICAgICAgIGRlbGV0ZSBzdHlsZS5pc1N0aWNreTtcclxuXHJcbiAgICAgICAgdmFyIHN0aWNreUdyb3VwID0gc3R5bGUuc3RpY2t5R3JvdXA7XHJcbiAgICAgICAgZGVsZXRlIHN0eWxlLnN0aWNreUdyb3VwO1xyXG4gICAgICAgIGRlbGV0ZSBzdHlsZS5oYXNNb3ZlQXJlYVRoaWNrbmVzcztcclxuICAgICAgICBkZWxldGUgc3R5bGUuaGFzU2l6ZUFyZWFUaGlja25lc3M7XHJcblxyXG4gICAgICAgIHZhciB0YXJnZXQgPSBjb250YWluZXJPYmouZ2V0QWdtVGFyZ2V0KCk7XHJcblxyXG4gICAgICAgIGFnbS5pbnZva2UoJ1Q0Mi5IdG1sLkNyZWF0ZVdpbmRvdycsIHtcclxuICAgICAgICAgICAgLy8gV2luZG93IG5hbWUgYW5kIHVybFxyXG4gICAgICAgICAgICB3aW5kb3dOYW1lOiB0aGVXaW5kb3cubmFtZSxcclxuICAgICAgICAgICAgdXJsOiB0aGVXaW5kb3cudXJsLFxyXG4gICAgICAgICAgICAvLyBkaW1lbnNpb25zXHJcbiAgICAgICAgICAgIHRvcDogZGltZW5zaW9ucy50b3AsXHJcbiAgICAgICAgICAgIGxlZnQ6IGRpbWVuc2lvbnMubGVmdCxcclxuICAgICAgICAgICAgd2lkdGg6IGRpbWVuc2lvbnMud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogZGltZW5zaW9ucy5oZWlnaHQsXHJcbiAgICAgICAgICAgIC8vIFN0aWNreXdpbmRvd3MgLSByZWxhdGVkIHByb3BzXHJcbiAgICAgICAgICAgIGlzU3RpY2t5OiBpc1N0aWNreSxcclxuICAgICAgICAgICAgc3RpY2t5R3JvdXA6IHN0aWNreUdyb3VwLFxyXG4gICAgICAgICAgICAvLyBTdHlsZSBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgIHdpbmRvd1N0eWxlQXR0cmlidXRlczogSlNPTi5zdHJpbmdpZnkoc3R5bGUpXHJcblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRhcmdldCxcclxuICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgIG9wZW5lZCxcclxuICAgICAgICAgICAgY2Fubm90T3Blbik7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG9wZW5lZChtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIC8vIEFkZCBpZCB0byB0aGUgY3VycmVudCB3aW5kb3dzIGJlY2F1c2UgdGhlIGN1cnJlbnQgSFRNTCBDb250YWluZXJcclxuICAgICAgICAgICAgLy8gZG9lc24ndCBzdXBwb3J0IHRyYWNraW5nIHRoZSB1cGRhdGVzIG9mIHRoZSB3aW5kb3dcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucmV0dXJuZWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhlV2luZG93LmlkID0gbWVzc2FnZS5yZXR1cm5lZC5pZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBoZWxwZXJzLmludm9rZUFnbVN1Y2Nlc3NDYWxsYmFjayhzdWNjZXNzLCB0aGVXaW5kb3cpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY2Fubm90T3BlbihlKSB7XHJcbiAgICAgICAgICAgIC8vIENhbGwgdGhlIGVycm9yIGNhbGxiYWNrXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFRyeSB0byBiaW5kIHRoZSByZXR1cm5lZCBvYmplY3QgaW4gY2FzZS4uLlxyXG4gICAgICAgICAgICAvLyBiaW5kV2luZG93KHRoZVdpbmRvdyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhlV2luZG93O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBhZ21BY3Rpb24oJ1Q0Mi5XbmQuU2V0V2luZG93U3R5bGUnLCBzdWNjZXNzLCBlcnJvciwgeyB3aW5kb3dTdHlsZUF0dHJpYnV0ZXM6IEpTT04uc3RyaW5naWZ5KHN0eWxlKSB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvcGVuZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdFdpbmRvdy5pZCAhPT0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZVdpbmRvd0Nsb3NlKCkge1xyXG4gICAgICAgIGlmIChyZXN1bHRXaW5kb3cuaWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBoZWxwZXJzLmV4ZWNDYWxsYmFja3MocmVzdWx0V2luZG93Ll9jYWxsYmFja3Mub25DbG9zZSk7XHJcbiAgICAgICAgICAgIHJlc3VsdFdpbmRvdy5pZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgcmVzdWx0V2luZG93Ll9jYWxsYmFja3MgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2xvc2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIGFnbUFjdGlvbignVDQyLlduZC5DbG9zZScsIGZ1bmN0aW9uKHdpbikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnXCInICsgd2luLm5hbWUgKyAgJ1wiIHdpbmRvdyB3YXMgY2xvc2VkLicpO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1wiJyArIHJlc3VsdFdpbmRvdy5uYW1lICsgICdcIiB3aW5kb3cgd2FzIE5PVCBjbG9zZWQgZHVlIGZvbGxvd2luZyBlcnJvcjogJywgZXJyKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG5hdmlnYXRlKHVybCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gYWdtQWN0aW9uKCdUNDIuSHRtbC5PcGVuVXJsJywgc3VjY2VzcywgZXJyb3IsIHsgdXJsOiB1cmwgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0VGl0bGUodGl0bGUsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGFnbUFjdGlvbignVDQyLlduZC5TZXRXaW5kb3dUaXRsZScsIHN1Y2Nlc3MsIGVycm9yLCB7IHRpdGxlOiB0aXRsZSB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXREZXRhaWxzKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIHdpbmRvd0lkID0gcmVzdWx0V2luZG93LmlkO1xyXG4gICAgICAgIGFnbS5pbnZva2UoJ1Q0Mi5XbmQuRmluZEJ5SWQnLCB7IHdpbmRvd0lkOiByZXN1bHRXaW5kb3cuaWQgfSwgY29udGFpbmVyT2JqLmdldEFnbVRhcmdldCgpLCB7fSwgcmV0dXJuZWREaW1lbnNpb25zLCBjYW5ub3RSZXR1cm5EaW1lbnNpb25zKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmV0dXJuZWREaW1lbnNpb25zKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGhlbHBlcnMuaW52b2tlQWdtU3VjY2Vzc0NhbGxiYWNrKHN1Y2Nlc3MsIHZhbHVlLnJldHVybmVkW3dpbmRvd0lkXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBjYW5ub3RSZXR1cm5EaW1lbnNpb25zKGUpIHtcclxuICAgICAgICAgICAgaGVscGVycy5pbnZva2VBZ21FcnJvckNhbGxiYWNrKGVycm9yLCBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbW92ZVJlc2l6ZShkaW1lbnNpb25zLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBhZ21BY3Rpb24oJ1Q0Mi5XbmQuUmVzaXplQW5kTW92ZScsIHN1Y2Nlc3MsIGVycm9yLCBkaW1lbnNpb25zKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZFRhYkJ1dHRvbihidXR0b25JbmZvLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYnV0dG9uSW5mbyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXJyb3IoJ05vIGJ1dHRvbiBpbmZvJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChidXR0b25JbmZvLmJ1dHRvbklkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXJyb3IoJ05vIGJ1dHRvbklkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChidXR0b25JbmZvLmltYWdlQmFzZTY0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXJyb3IoJ05vIGltYWdlQmFzZTY0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEludm9rZSB0aGUgQUdNIG1ldGhvZFxyXG4gICAgICAgIGFnbS5pbnZva2UoJ1Q0Mi5XbmQuQWRkQnV0dG9uJywge1xyXG4gICAgICAgICAgICB3aW5kb3dJZDogcmVzdWx0V2luZG93LmlkLFxyXG4gICAgICAgICAgICBidXR0b25JbmZvOiBidXR0b25JbmZvXHJcbiAgICAgICAgfSwgY29udGFpbmVyT2JqLmdldEFnbVRhcmdldCgpLCB7fSwgYnV0dG9uSXNBZGRlZC5iaW5kKHRoaXMpLCBidXR0b25DYW5ub3RCZUFkZGVkLmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBidXR0b25Jc0FkZGVkKCkge1xyXG4gICAgICAgICAgICB2YXIgX2J1dHRvbklkID0gYnV0dG9uSW5mby5idXR0b25JZDtcclxuICAgICAgICAgICAgcmVzdWx0V2luZG93LmJ1dHRvbnNbX2J1dHRvbklkXSA9IHtcclxuICAgICAgICAgICAgICAgIGlkOiBfYnV0dG9uSWQsXHJcbiAgICAgICAgICAgICAgICBpbmZvOiBidXR0b25JbmZvXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGhlbHBlcnMuaW52b2tlQWdtU3VjY2Vzc0NhbGxiYWNrKHN1Y2Nlc3MsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYnV0dG9uQ2Fubm90QmVBZGRlZChlKSB7XHJcbiAgICAgICAgICAgIGhlbHBlcnMuaW52b2tlQWdtRXJyb3JDYWxsYmFjayhlcnJvciwgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG9uVGl0bGVDaGFuZ2VkKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY2FsbGJhY2socmVzdWx0V2luZG93LnRpdGxlKTtcclxuICAgICAgICBhZGRDYWxsYmFjaygnb25UaXRsZUNoYW5nZWQnLCBjYWxsYmFjayk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gb25BdmFpbGFibGUoY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAocmVzdWx0V2luZG93Lm9wZW5lZCgpKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWRkQ2FsbGJhY2soJ29uQXZhaWxhYmxlJywgY2FsbGJhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG9uQ2xvc2UoY2FsbGJhY2spIHtcclxuICAgICAgICBhZGRDYWxsYmFjaygnb25DbG9zZScsIGNhbGxiYWNrKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvblVybENoYW5nZWQoY2FsbGJhY2spIHtcclxuICAgICAgICBhZGRDYWxsYmFjaygnb25VcmxDaGFuZ2VkJywgY2FsbGJhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG9uVGFiQnV0dG9uKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgYWRkQ2FsbGJhY2soJ29uVGFiQnV0dG9uJywgY2FsbGJhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFjdGl2YXRlKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGFnbUFjdGlvbignVDQyLlduZC5BY3RpdmF0ZScsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtYXhpbWl6ZVJlc3RvcmUoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gYWdtQWN0aW9uKCdUNDIuV25kLk1heGltaXplT3JSZXN0b3JlRG93bicsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtYXhpbWl6ZShzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBhZ21BY3Rpb24oJ1Q0Mi5XbmQuTWF4aW1pemUnLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVzdG9yZShzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBhZ21BY3Rpb24oJ1Q0Mi5XbmQuUmVzdG9yZScsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtaW5pbWl6ZShzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBhZ21BY3Rpb24oJ1Q0Mi5XbmQuTWluaW1pemUnLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29sbGFwc2Uoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gYWdtQWN0aW9uKCdUNDIuV25kLkNvbGxhcHNlJywgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRpdGxlQ2hhbmdlZCh0aXRsZSkge1xyXG4gICAgICAgIHJlc3VsdFdpbmRvdy50aXRsZSA9IHRpdGxlO1xyXG4gICAgICAgIGhlbHBlcnMuZXhlY0NhbGxiYWNrcyhyZXN1bHRXaW5kb3cuX2NhbGxiYWNrcy5vblRpdGxlQ2hhbmdlZCwgdGl0bGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVybENoYW5nZWQodXJsKSB7XHJcbiAgICAgICAgcmVzdWx0V2luZG93LnVybCA9IHVybDtcclxuICAgICAgICBoZWxwZXJzLmV4ZWNDYWxsYmFja3MocmVzdWx0V2luZG93Ll9jYWxsYmFja3Mub25VcmxDaGFuZ2VkLCB1cmwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZHMgYW4gYWxpYXMgb2YgYW4gQUdNIG1ldGhvZCBpbiB0aGUgV2luZG93IHByb3RvdHlwZVxyXG4gICAgZnVuY3Rpb24gYWdtQWN0aW9uKGFjdGlvbiwgc3VjY2VzcywgZXJyb3IsIGFyZ3MpIHtcclxuICAgICAgICAvLyBTdG9wIGlmIHRoZSB3aW5kb3cgaXMgY2xvc2VkXHJcbiAgICAgICAgaWYgKHJlc3VsdFdpbmRvdy51cmwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcignQ2Fubm90IGV4ZWN1dGUgYSBjb21tYW5kIG9uIGEgY2xvc2VkIHdpbmRvdy4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBZGQgdGhlIHdpbmRvdyBJRCB0byB0aGUgYXJndW1lbnRzXHJcbiAgICAgICAgYXJncyA9IGFyZ3MgfHwge307XHJcbiAgICAgICAgYXJncy53aW5kb3dJZCA9IHJlc3VsdFdpbmRvdy5pZDtcclxuXHJcbiAgICAgICAgLy8gSW52b2tlIHRoZSBBR00gbWV0aG9kXHJcbiAgICAgICAgYWdtLmludm9rZShhY3Rpb24sIGFyZ3MsIGNvbnRhaW5lck9iai5nZXRBZ21UYXJnZXQoKSwge30sIGZ1bGZpbGxlZCwgZXJyb3IpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQoKSB7XHJcbiAgICAgICAgICAgIGhlbHBlcnMuaW52b2tlQWdtU3VjY2Vzc0NhbGxiYWNrKHN1Y2Nlc3MsIHJlc3VsdFdpbmRvdyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlc3VsdFdpbmRvdyA9IHtcclxuICAgICAgICBfaW50ZXJuYWxJZDogaW50ZXJuYWxJZCxcclxuICAgICAgICBfY2FsbGJhY2tzOiB7fSxcclxuXHJcbiAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lck9iai5uYW1lLFxyXG4gICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgIGlkOiBpZCxcclxuICAgICAgICBhcHBsaWNhdGlvbjogY29udGFpbmVyT2JqLm5hbWUgKyAnLicgKyBuYW1lLFxyXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcclxuICAgICAgICBidXR0b25zOiB7fSxcclxuICAgICAgICB3aW5kb3dTdHlsZUF0dHJpYnV0ZXM6IHNldFdpbmRvd1N0eWxlQXR0cmlidXRlcyh3aW5kb3dTdHlsZXMpLFxyXG5cclxuICAgICAgICBvbkF2YWlsYWJsZTogb25BdmFpbGFibGUsXHJcbiAgICAgICAgb25DbG9zZTogb25DbG9zZSxcclxuICAgICAgICBvblVybENoYW5nZWQ6IG9uVXJsQ2hhbmdlZCxcclxuICAgICAgICBvblRpdGxlQ2hhbmdlZDogb25UaXRsZUNoYW5nZWQsXHJcbiAgICAgICAgb25UYWJCdXR0b246IG9uVGFiQnV0dG9uLFxyXG5cclxuICAgICAgICBtYXhpbWl6ZTogbWF4aW1pemUsXHJcbiAgICAgICAgcmVzdG9yZTogcmVzdG9yZSxcclxuICAgICAgICBtaW5pbWl6ZTogbWluaW1pemUsXHJcbiAgICAgICAgbWF4aW1pemVSZXN0b3JlOiBtYXhpbWl6ZVJlc3RvcmUsXHJcbiAgICAgICAgY29sbGFwc2U6IGNvbGxhcHNlLFxyXG4gICAgICAgIGZvY3VzOiBhY3RpdmF0ZSxcclxuICAgICAgICBvcGVuOiBvcGVuLFxyXG4gICAgICAgIG9wZW5lZDogb3BlbmVkLFxyXG4gICAgICAgIGdldERldGFpbHM6IGdldERldGFpbHMsXHJcbiAgICAgICAgbW92ZVJlc2l6ZTogbW92ZVJlc2l6ZSxcclxuICAgICAgICBzZXRUaXRsZTogc2V0VGl0bGUsXHJcbiAgICAgICAgc2V0U3R5bGU6IHNldFN0eWxlLFxyXG4gICAgICAgIG5hdmlnYXRlOiBuYXZpZ2F0ZSxcclxuICAgICAgICBhZGRUYWJCdXR0b246IGFkZFRhYkJ1dHRvbixcclxuICAgICAgICBjbG9zZTogY2xvc2UsXHJcbiAgICAgICAgaGFuZGxlV2luZG93Q2xvc2U6IGhhbmRsZVdpbmRvd0Nsb3NlLFxyXG4gICAgICAgIHRpdGxlQ2hhbmdlZDogdGl0bGVDaGFuZ2VkLFxyXG4gICAgICAgIHVybENoYW5nZWQ6IHVybENoYW5nZWQsXHJcblxyXG4gICAgICAgIC8vIGRlcHJlY2F0ZXNcclxuICAgICAgICBzZXRfc3R5bGU6IGRlcHJlY2F0ZShzZXRTdHlsZSwgJ3dpbmRvdy5zZXRfc3R5bGUoKSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSB3aW5kb3cuc2V0U3R5bGUoKSBpbnN0ZWFkJyksXHJcbiAgICAgICAgb25fYXZhaWxhYmxlOiBkZXByZWNhdGUob25BdmFpbGFibGUsICd3aW5kb3cub25fYXZhaWxhYmxlKCkgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2Ugd2luZG93Lm9uQXZhaWxhYmxlKCkgaW5zdGVhZCcpLFxyXG4gICAgICAgIG9uX2Nsb3NlOiBkZXByZWNhdGUob25DbG9zZSwgJ3dpbmRvdy5vbl9jbG9zZSgpIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIHdpbmRvdy5vbkNsb3NlKCkgaW5zdGVhZCcpLFxyXG4gICAgICAgIG9uX3VybF9jaGFuZ2VkOiBkZXByZWNhdGUob25VcmxDaGFuZ2VkLCAnd2luZG93Lm9uX3VybF9jaGFuZ2VkKCkgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2Ugd2luZG93Lm9uVXJsQ2hhbmdlZCgpIGluc3RlYWQnKSxcclxuICAgICAgICBzZXRfdGl0bGU6IGRlcHJlY2F0ZShzZXRUaXRsZSwgJ3dpbmRvdy5zZXRfdGl0bGUoKSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSB3aW5kb3cuc2V0VGl0bGUoKSBpbnN0ZWFkJyksXHJcbiAgICAgICAgZ2V0X2RldGFpbHM6IGRlcHJlY2F0ZShnZXREZXRhaWxzLCAnd2luZG93LmdldF9kZXRhaWxzKCkgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2Ugd2luZG93LmdldERldGFpbHMoKSBpbnN0ZWFkJyksXHJcbiAgICAgICAgbW92ZV9yZXNpemU6IGRlcHJlY2F0ZShtb3ZlUmVzaXplLCAnd2luZG93Lm1vdmVfcmVzaXplKCkgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2Ugd2luZG93Lm1vdmVSZXNpemUoKSBpbnN0ZWFkJyksXHJcbiAgICAgICAgbWF4aW1pemVfcmVzdG9yZTogZGVwcmVjYXRlKG1heGltaXplUmVzdG9yZSwgJ3dpbmRvdy5tYXhpbWl6ZV9yZXN0b3JlKCkgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2Ugd2luZG93Lm1heGltaXplUmVzdG9yZSgpIGluc3RlYWQnKVxyXG5cclxuICAgIH07XHJcbiAgICByZXR1cm4gcmVzdWx0V2luZG93O1xyXG59XHJcbiIsInZhciBQYWNrYWdlSnNvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpO1xyXG52YXIgZGVwcmVjYXRlID0gcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKTtcclxudmFyIHdpbmRvd0ZhY3RvcnkgPSByZXF1aXJlKCcuL3dpbmRvdycpO1xyXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xyXG5cclxudmFyIHdpbmRvd3MgPSBmdW5jdGlvbiAoYWdtKSB7XHJcbiAgICAndXNlIHN0cmljdCdcclxuXHJcbiAgICB3aW5kb3dGYWN0b3J5LmluaXQoYWdtKTtcclxuXHJcbiAgICBpZiAoZ2xvYmFsLmh0bWxDb250YWluZXIgJiYgYWdtLnN1YnNjcmliZSkge1xyXG4gICAgICAgIC8vIE9ubHkgY29udGFpbmVyLlxyXG4gICAgICAgIGFnbS5zZXJ2ZXJNZXRob2RBZGRlZChmdW5jdGlvbiAocmVzcCkge1xyXG4gICAgICAgICAgICBpZiAoKHJlc3Auc2VydmVyLmFwcGxpY2F0aW9uLmluZGV4T2YoJ0h0bWxDb250YWluZXIuJykgIT09IC0xICYmIHJlc3Auc2VydmVyLmFwcGxpY2F0aW9uLmluZGV4T2YoJy5JbnRlcm5hbCcpICE9PSAtMSkgJiYgcmVzcC5tZXRob2QubmFtZS5pbmRleE9mKCdUNDIuV25kLldpbmRvd1N0YXRlQ2hhbmdlZCcpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgYWdtLnN1YnNjcmliZSgnVDQyLlduZC5XaW5kb3dTdGF0ZUNoYW5nZWQnLCB7IHRhcmdldDogJ2FsbCcgfSkudGhlbihmdW5jdGlvbiAoc3RyZWFtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLm9uRGF0YShmdW5jdGlvbiAoc3RyZWFtRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVXaW5kb3coc3RyZWFtRGF0YS5kYXRhLCBtYXRjaENvbnRhaW5lcihzdHJlYW1EYXRhLnNlcnZlci5hcHBsaWNhdGlvbikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGF0dGFjaCBjYWxsYmFja3NcclxuICAgICAgICAgICAgICAgICAgICAvLyBzdHJlYW0ub24oXCJlbmRcIiwgaGFuZGxlU3RyZWFtQ2xvc2VkKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzdHJlYW0ub24oXCJjbG9zZVwiLCBoYW5kbGVTdHJlYW1DbG9zZWQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgYWdtLnNlcnZlckFkZGVkKGZ1bmN0aW9uIChzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgaWYgKHNlcnZlci5hcHBsaWNhdGlvbi5pbmRleE9mKCdIdG1sQ29udGFpbmVyLicpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGNvbnN0cnVjdENvbnRhaW5lck9iamVjdChzZXJ2ZXIuYXBwbGljYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgYWRkQ29udGFpbmVyKGNvbnRhaW5lcnMsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICBnZXRBbGxXaW5kb3dzT25BZGRlZENvbnRhaW5lcihjb250YWluZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3RvcmUgd2luZG93cyB0aGF0IGFyZSB0cmFja2VkIGJ5IElEIGFuZCByZWNlaXZlIHVwZGF0ZXNcclxuICAgIHZhciB3aW5kb3dzID0ge307XHJcbiAgICB2YXIgY29udGFpbmVycyA9IFtdO1xyXG5cclxuICAgIGlmIChnbG9iYWwuaHRtbENvbnRhaW5lcikge1xyXG4gICAgICAgIHZhciBteUNvbnRhaW5lciA9IGNvbnN0cnVjdENvbnRhaW5lck9iamVjdChodG1sQ29udGFpbmVyLmNvbnRhaW5lck5hbWUpO1xyXG4gICAgICAgIGFkZENvbnRhaW5lcihjb250YWluZXJzLCBteUNvbnRhaW5lcik7XHJcbiAgICAgICAgY3JlYXRlV2luZG93KGh0bWxDb250YWluZXIuYnJvd3NlcldpbmRvd05hbWUsIG15Q29udGFpbmVyLCB3aW5kb3cubG9jYXRpb24uaHJlZiwgaHRtbENvbnRhaW5lci53aW5kb3dJZCwgaHRtbENvbnRhaW5lci53aW5kb3dTdHlsZUF0dHJpYnV0ZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGVuc3VyZUNvbnRhaW5lckF2YWlsaWFibGUoY29udGFpbmVyLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgY29udGFpbmVyRm91bmQgPSBtYXRjaENvbnRhaW5lcihjb250YWluZXIpXHJcbiAgICAgICAgaWYgKGNvbnRhaW5lckZvdW5kKSB7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayhjb250YWluZXJGb3VuZCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyRm91bmQgPSBtYXRjaENvbnRhaW5lcihjb250YWluZXIpXHJcbiAgICAgICAgICAgIGlmIChjb250YWluZXJGb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKGNvbnRhaW5lckZvdW5kKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIDIwMDApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1hdGNoQ29udGFpbmVyKGNvbnRhaW5lcklkZW50aWZpZXIpIHtcclxuICAgICAgICBpZiAoIWNvbnRhaW5lcklkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcnNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb250YWluZXJzLmZpbHRlcihmdW5jdGlvbiAoY29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb250YWluZXIuc2hvcnROYW1lID09PSBjb250YWluZXJJZGVudGlmaWVyIHx8XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIubmFtZSA9PT0gY29udGFpbmVySWRlbnRpZmllciB8fFxyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFnbUFwcGxpY2F0aW9uID09PSBjb250YWluZXJJZGVudGlmaWVyO1xyXG4gICAgICAgIH0pWzBdO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbnN0cnVjdENvbnRhaW5lck9iamVjdChjb250YWluZXJJZGVudGl0eSkge1xyXG4gICAgICAgIHZhciBwYXJ0cyA9IGNvbnRhaW5lcklkZW50aXR5LnNwbGl0KCcuJyk7XHJcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICBwYXJ0cy5zcGxpY2UoMCwgMCwgJ0h0bWxDb250YWluZXInKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBhZ21BcHBsaWNhdGlvbiA9IHBhcnRzWzBdICsgJy4nICsgcGFydHNbMV0gKyAnLicgKyBwYXJ0c1syXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2hvcnROYW1lOiBwYXJ0c1syXSxcclxuICAgICAgICAgICAgbmFtZTogcGFydHNbMV0gKyAnLicgKyBwYXJ0c1syXSxcclxuICAgICAgICAgICAgYWdtQXBwbGljYXRpb246IGFnbUFwcGxpY2F0aW9uLFxyXG4gICAgICAgICAgICBnZXRBZ21UYXJnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IGFwcGxpY2F0aW9uOiBhZ21BcHBsaWNhdGlvbiB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZENvbnRhaW5lcihjb250YWluZXJzLCBjb250YWluZXIpIHtcclxuICAgICAgICBpZiAoY29udGFpbmVycy5maWx0ZXIoZnVuY3Rpb24oY29udCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29udC5zaG9ydE5hbWUgPT09IGNvbnRhaW5lci5zaG9ydE5hbWUgJiZcclxuICAgICAgICAgICAgY29udC5uYW1lID09PSBjb250YWluZXIubmFtZSAmJlxyXG4gICAgICAgICAgICBjb250LmFnbUFwcGxpY2F0aW9uID09PSBjb250YWluZXIuYWdtQXBwbGljYXRpb25cclxuICAgICAgICB9KS5sZW5ndGggID09PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lcnMucHVzaChjb250YWluZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRDYWxsYmFja3MoY2FsbGJhY2tzLCBjb250YWluZXJOYW1lKSB7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrcy5jb250YWluZXJzQ2FsbGJhY2tzW2NvbnRhaW5lck5hbWVdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrcy5hbGxDb250YWluZXJzQ2FsbGJhY2tzLmNvbmNhdChjYWxsYmFja3MuY29udGFpbmVyc0NhbGxiYWNrc1tjb250YWluZXJOYW1lXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrcy5hbGxDb250YWluZXJzQ2FsbGJhY2tzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwdXRDYWxsYmFja3MoZ2xvYmFsQ2FsbGJhY2tzLCBjYWxsYmFjaywgY29udGFpbmVyKSB7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5lciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGdsb2JhbENhbGxiYWNrcy5hbGxDb250YWluZXJzQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChnbG9iYWxDYWxsYmFja3MuY29udGFpbmVyc0NhbGxiYWNrc1tjb250YWluZXJdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGdsb2JhbENhbGxiYWNrcy5jb250YWluZXJzQ2FsbGJhY2tzW2NvbnRhaW5lcl0gPSBbY2FsbGJhY2tdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZ2xvYmFsQ2FsbGJhY2tzLmNvbnRhaW5lcnNDYWxsYmFja3NbY29udGFpbmVyXS5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVXaW5kb3cod2luZG93SW5mbywgY29udGFpbmVyTmFtZSkge1xyXG4gICAgICAgIHZhciB0aGVXaW5kb3cgPSBnZXRXaW5kb3cod2luZG93SW5mby53aW5kb3dOYW1lLCBjb250YWluZXJOYW1lLCB3aW5kb3dJbmZvLnVybCwgd2luZG93SW5mby53aW5kb3dJZCwgd2luZG93SW5mby53aW5kb3dTdHlsZUF0dHJpYnV0ZXMsIHdpbmRvd0luZm8ud2luZG93VGl0bGUpO1xyXG5cclxuICAgICAgICBpZiAodGhlV2luZG93LmlkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhlV2luZG93LmlkID0gd2luZG93SW5mby53aW5kb3dJZDtcclxuICAgICAgICAgICAgaGVscGVycy5leGVjQ2FsbGJhY2tzKHRoZVdpbmRvdy5fY2FsbGJhY2tzLm9uQXZhaWxhYmxlLCB0aGVXaW5kb3cpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHdpbmRvd0luZm8uc3RhdGUgPT09ICdUaXRsZUNoYW5nZWQnKSB7XHJcbiAgICAgICAgICAgIHRoZVdpbmRvdy50aXRsZUNoYW5nZWQod2luZG93SW5mby53aW5kb3dUaXRsZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAod2luZG93SW5mby5zdGF0ZSA9PT0gJ1VybENoYW5nZWQnKSB7XHJcbiAgICAgICAgICAgIHRoZVdpbmRvdy51cmxDaGFuZ2VkKHdpbmRvd0luZm8udXJsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh3aW5kb3dJbmZvLnN0YXRlID09PSAnQ3JlYXRlZCcpIHtcclxuICAgICAgICAgICAgLy8gRXhlY3V0ZSBnbG9iYWwgXCJ3aW5kb3dfYWRkZWRcIiBjYWxsYmFja3NcclxuICAgICAgICAgICAgaGVscGVycy5leGVjQ2FsbGJhY2tzKGdldENhbGxiYWNrcyh3aW5kb3dBZGRlZENhbGxiYWNrcywgY29udGFpbmVyTmFtZSksIHRoZVdpbmRvdyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDbGVhciB0aGUgd2luZG93IG9uIGNsb3NlIGV2ZW50XHJcbiAgICAgICAgaWYgKHdpbmRvd0luZm8uc3RhdGUgPT09ICdDbG9zZWQnKSB7XHJcbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgZ2xvYmFsIFwid2luZG93X3JlbW92ZWRcIiBjYWxsYmFja3NcclxuICAgICAgICAgICAgaGVscGVycy5leGVjQ2FsbGJhY2tzKGdldENhbGxiYWNrcyh3aW5kb3dSZW1vdmVkQ2FsbGJhY2tzLCBjb250YWluZXJOYW1lKSwgdGhlV2luZG93KTtcclxuXHJcbiAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3dzW3RoZVdpbmRvdy5faW50ZXJuYWxJZF07XHJcblxyXG4gICAgICAgICAgICB0aGVXaW5kb3cuaGFuZGxlV2luZG93Q2xvc2UoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEJ1dHRvbkNsaWNrZWRcclxuICAgICAgICBpZiAod2luZG93SW5mby5zdGF0ZSA9PT0gJ0J1dHRvbkNsaWNrZWQnKSB7XHJcbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgZ2xvYmFsIFwid2luZG93X2FkZGVkXCIgY2FsbGJhY2tzXHJcbiAgICAgICAgICAgIGlmICh0aGVXaW5kb3cuYnV0dG9ucyAhPT0gdW5kZWZpbmVkICYmIE9iamVjdC5rZXlzKHRoZVdpbmRvdy5idXR0b25zKS5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGVXaW5kb3cuX2NhbGxiYWNrcy5vblRhYkJ1dHRvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaGVscGVycy5leGVjQ2FsbGJhY2tzKHRoZVdpbmRvdy5fY2FsbGJhY2tzLm9uVGFiQnV0dG9uLCB3aW5kb3dJbmZvLmJ1dHRvbklkLCB0aGVXaW5kb3cuYnV0dG9uc1t3aW5kb3dJbmZvLmJ1dHRvbklkXS5pbmZvKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGVXaW5kb3cuX2NhbGxiYWNrcy5vblRhYkJ1dHRvbi5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHdpbmRvd0luZm8uYnV0dG9uSWQsIHRoZVdpbmRvdy5idXR0b25zW3dpbmRvd0luZm8uYnV0dG9uSWRdLmluZm8pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3JlYXRlIGEgZGljdGlvbmFyeSB0byBzdG9yZSB0aGUgY2FsbGJhY2tzIGZvciB0aGUgbWV0aG9kIFwid2luZG93X2FkZGVkXCIuXHJcbiAgICB2YXIgd2luZG93QWRkZWRDYWxsYmFja3MgPSB7XHJcbiAgICAgICAgY29udGFpbmVyc0NhbGxiYWNrczoge30sXHJcbiAgICAgICAgYWxsQ29udGFpbmVyc0NhbGxiYWNrczogW11cclxuICAgIH07XHJcblxyXG4gICAgLy8gQ3JlYXRlIGEgZGljdGlvbmFyeSB0byBzdG9yZSB0aGUgY2FsbGJhY2tzIGZvciB0aGUgbWV0aG9kIFwid2luZG93X3JlbW92ZWRcIi5cclxuICAgIHZhciB3aW5kb3dSZW1vdmVkQ2FsbGJhY2tzID0ge1xyXG4gICAgICAgIGNvbnRhaW5lcnNDYWxsYmFja3M6IHt9LFxyXG4gICAgICAgIGFsbENvbnRhaW5lcnNDYWxsYmFja3M6IFtdXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVdpbmRvd0lkKG5hbWUsIGNvbnRhaW5lcikge1xyXG4gICAgICAgIHJldHVybiBjb250YWluZXIuYWdtQXBwbGljYXRpb24gKyAnLicgKyBuYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVdpbmRvdyhuYW1lLCBjb250YWluZXIsIHVybCwgaWQsIHdpbmRvd1N0eWxlcywgdGl0bGUpIHtcclxuICAgICAgICB2YXIgd2luZG93SWQgPSBjcmVhdGVXaW5kb3dJZChuYW1lLCBjb250YWluZXIpO1xyXG5cclxuICAgICAgICB2YXIgd2luZG93T2JqID0gd2luZG93RmFjdG9yeS5jcmVhdGUoaWQsIHdpbmRvd0lkLCBuYW1lLCBjb250YWluZXIsIHVybCwgdGl0bGUsIHdpbmRvd1N0eWxlcyk7XHJcblxyXG4gICAgICAgIHdpbmRvd3Nbd2luZG93SWRdID0gd2luZG93T2JqO1xyXG5cclxuICAgICAgICByZXR1cm4gd2luZG93T2JqO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEl0IGlzIG5vdCBndWFyYW50ZWVkIHRvIHJldHVybiB0aGUgd2luZG93IHdpdGggdGhlIHNhbWUgVVJMIGFuZCBJRFxyXG4gICAgZnVuY3Rpb24gZ2V0V2luZG93KG5hbWUsIGNvbnRhaW5lciwgdXJsLCBpZCwgd2luZG93U3R5bGVzLCB0aXRsZSkge1xyXG5cclxuICAgICAgICB2YXIgd2luZG93SWQgPSBjcmVhdGVXaW5kb3dJZChuYW1lLCBjb250YWluZXIpO1xyXG5cclxuICAgICAgICB2YXIgZXhpc3RpbmdXaW5kb3cgPSB3aW5kb3dzW3dpbmRvd0lkXTtcclxuXHJcbiAgICAgICAgaWYgKGV4aXN0aW5nV2luZG93ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nV2luZG93O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEluaXQgb2JqZWN0XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVXaW5kb3cobmFtZSwgY29udGFpbmVyLCB1cmwsIGlkLCB3aW5kb3dTdHlsZXMsIHRpdGxlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbXkoKSB7XHJcbiAgICAgICAgdmFyIGg7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGggPSB3aW5kb3cuaHRtbENvbnRhaW5lcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmV0cmlldmUgdGhlIGN1cnJlbnQgd2luZG93ICh0aGUgb253IGluIHdoaWNoIHlvdXIgYXBwbGljYXRpb24gY3VycmVudGx5IHJlc2lkZXMpLlxyXG4gICAgICAgIGlmIChoID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0V2luZG93KGguYnJvd3NlcldpbmRvd05hbWUsIG1hdGNoQ29udGFpbmVyKGguY29udGFpbmVyTmFtZSksIHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBoLndpbmRvd0lkLCBoLndpbmRvd1N0eWxlQXR0cmlidXRlcywgZG9jdW1lbnQudGl0bGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvcGVuKG5hbWUsIHVybCwgY29udGFpbmVyLCBkaW1lbnNpb25zLCBzdHlsZSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIgfHwgJ0ludGVybmFsJztcclxuICAgICAgICBlbnN1cmVDb250YWluZXJBdmFpbGlhYmxlKGNvbnRhaW5lciwgZnVuY3Rpb24gKGNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0V2luZG93KG5hbWUsIGNvbnRhaW5lciwgdXJsLCB1bmRlZmluZWQsIHN0eWxlKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vcGVuKGRpbWVuc2lvbnMsIHN0eWxlLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBlcnJvcignY2FuIG5vdCBmaW5kIGNvbnRhaW5lcicpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZmluZCAobmFtZSwgY29udGFpbmVyLCBzdWNjZXNzKSB7XHJcblxyXG4gICAgICAgIGNvbnRhaW5lciA9IG1hdGNoQ29udGFpbmVyKGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgIHZhciB3aW5kb3dzRm9yTGlzdGluZyA9IE9iamVjdC5rZXlzKHdpbmRvd3MpLnJlZHVjZShmdW5jdGlvbiAobWVtbywgd2luSWQpIHtcclxuICAgICAgICAgICAgdmFyIHdpbmRvdyA9IHdpbmRvd3Nbd2luSWRdO1xyXG4gICAgICAgICAgICBpZiAod2luZG93LmNvbnRhaW5lciA9PT0gY29udGFpbmVyLm5hbWUgJiYgd2luZG93Lm5hbWUgPT09IG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIG1lbW8ucHVzaCh3aW5kb3cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtZW1vO1xyXG4gICAgICAgIH0sIFtdKTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdWNjZXNzICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3dzRm9yTGlzdGluZ1swXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN1Y2Nlc3Mod2luZG93c0Zvckxpc3RpbmdbMF0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxpc3QgKGNvbnRhaW5lciwgc3VjY2Vzcykge1xyXG5cclxuICAgICAgICBjb250YWluZXIgPSBtYXRjaENvbnRhaW5lcihjb250YWluZXIpO1xyXG5cclxuICAgICAgICB2YXIgd2luZG93c0Zvckxpc3RpbmcgPSBPYmplY3Qua2V5cyh3aW5kb3dzKS5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIHdpbklkKSB7XHJcbiAgICAgICAgICAgIHZhciB3aW5kb3cgPSB3aW5kb3dzW3dpbklkXTtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5jb250YWluZXIgPT09IGNvbnRhaW5lci5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBtZW1vLnB1c2god2luZG93KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWVtbztcclxuICAgICAgICB9LCBbXSk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygc3VjY2VzcyAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHdpbmRvd3NGb3JMaXN0aW5nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3VjY2Vzcyh3aW5kb3dzRm9yTGlzdGluZyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gd2luZG93QWRkZWQoY2FsbGJhY2ssIGNvbnRhaW5lcikge1xyXG4gICAgICAgIC8vIEFkZCB0aGUgY3VycmVudCBjYWxsYmFjayB0byB0aGUgY2FsbGJhY2sgZGljdGlvbmFyeS5cclxuICAgICAgICBwdXRDYWxsYmFja3Mod2luZG93QWRkZWRDYWxsYmFja3MsIGNhbGxiYWNrLCBjb250YWluZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHdpbmRvd1JlbW92ZWQoY2FsbGJhY2ssIGNvbnRhaW5lcikge1xyXG4gICAgICAgIC8vIEFkZCB0aGUgY3VycmVudCBjYWxsYmFjayB0byB0aGUgY2FsbGJhY2sgZGljdGlvbmFyeS5cclxuICAgICAgICBwdXRDYWxsYmFja3Mod2luZG93UmVtb3ZlZENhbGxiYWNrcywgY2FsbGJhY2ssIGNvbnRhaW5lcik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29udGFpbmVyQWRkZWQoY2FsbGJhY2spIHtcclxuICAgICAgICBhZ20uc2VydmVyQWRkZWQoZnVuY3Rpb24gKHNlcnZlcikge1xyXG4gICAgICAgICAgICBpZiAoc2VydmVyLmFwcGxpY2F0aW9uLmluZGV4T2YoJ0h0bWxDb250YWluZXIuJykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBoZWxwZXJzLmludm9rZUFnbVN1Y2Nlc3NDYWxsYmFjayhjYWxsYmFjaywgc2VydmVyLmFwcGxpY2F0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbnRhaW5lclJlbW92ZWQoY2FsbGJhY2spIHtcclxuICAgICAgICBhZ20uc2VydmVyUmVtb3ZlZChmdW5jdGlvbiAoc2VydmVyKSB7XHJcbiAgICAgICAgICAgIGlmIChzZXJ2ZXIuYXBwbGljYXRpb24uaW5kZXhPZignSHRtbENvbnRhaW5lci4nKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGhlbHBlcnMuaW52b2tlQWdtU3VjY2Vzc0NhbGxiYWNrKGNhbGxiYWNrLCBzZXJ2ZXIuYXBwbGljYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0QWxsV2luZG93c09uQWRkZWRDb250YWluZXIoY29udGFpbmVyKSB7XHJcbiAgICAgICAgYWdtLmludm9rZSgnVDQyLlduZC5MaXN0V2luZG93cycsIHt9LCAnYmVzdCcsIHt9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAobGlzdE9mV2luZG93cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMobGlzdE9mV2luZG93cy5yZXR1cm5lZCkuZm9yRWFjaChmdW5jdGlvbiAoZXhpc3RpbmdXaW5kb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2luZG93SW5mbyA9IGxpc3RPZldpbmRvd3MucmV0dXJuZWRbZXhpc3RpbmdXaW5kb3ddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3JpbmcgYWxsIHdpbmRvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGVXaW5kb3cgPSBnZXRXaW5kb3cod2luZG93SW5mby53aW5kb3dOYW1lLCBjb250YWluZXIsIHdpbmRvd0luZm8udXJsLCB3aW5kb3dJbmZvLndpbmRvd0lkLCB3aW5kb3dJbmZvLndpbmRvd1N0eWxlQXR0cmlidXRlcywgd2luZG93SW5mby53aW5kb3dUaXRsZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXJzLmV4ZWNDYWxsYmFja3MoZ2V0Q2FsbGJhY2tzKHdpbmRvd0FkZGVkQ2FsbGJhY2tzLCBjb250YWluZXIubmFtZSksIHRoZVdpbmRvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXJyb3IgY2FsbGJhY2sgaWYgdGhlIHdpbmRvd3MgY2Fubm90IGJlIGxpc3RlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVbmFibGUgdG8gbG9hZCBleGlzdGluZyB3aW5kb3dzLiAnICsgZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZSBBUEkgaXRzZWxmXHJcbiAgICB2YXIgYXBpID0ge1xyXG4gICAgICAgIG15OiBteSxcclxuICAgICAgICBvcGVuOiBvcGVuLFxyXG4gICAgICAgIGZpbmQ6IGZpbmQsXHJcbiAgICAgICAgbGlzdDogbGlzdCxcclxuICAgICAgICB3aW5kb3dBZGRlZDogd2luZG93QWRkZWQsXHJcbiAgICAgICAgd2luZG93UmVtb3ZlZDogd2luZG93UmVtb3ZlZCxcclxuICAgICAgICBjb250YWluZXJBZGRlZDogY29udGFpbmVyQWRkZWQsXHJcbiAgICAgICAgY29udGFpbmVyUmVtb3ZlZDogY29udGFpbmVyUmVtb3ZlZCxcclxuXHJcbiAgICAgICAgX2Zyb21fZXZlbnQ6IGZ1bmN0aW9uKG5hbWUsIGNvbnRhaW5lciwgdXJsLCBpZCwgd2luZG93U3R5bGVzLCB0aXRsZSkge1xyXG4gICAgICAgICAgICBjb250YWluZXIgPSBtYXRjaENvbnRhaW5lcihjb250YWluZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0V2luZG93KG5hbWUsIGNvbnRhaW5lciwgdXJsLCBpZCwgd2luZG93U3R5bGVzLCB0aXRsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBkZXByZWNhdGVzXHJcbiAgICBhcGkud2luZG93X2FkZGVkID0gZGVwcmVjYXRlKGFwaS53aW5kb3dBZGRlZCwgJ3dpbmRvdy53aW5kb3dfYWRkZWQoKSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSB3aW5kb3cud2luZG93QWRkZWQoKSBpbnN0ZWFkJyk7XHJcbiAgICBhcGkud2luZG93X3JlbW92ZWQgPSBkZXByZWNhdGUoYXBpLndpbmRvd1JlbW92ZWQsICd3aW5kb3cud2luZG93X3JlbW92ZWQoKSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSB3aW5kb3cud2luZG93UmVtb3ZlZCgpIGluc3RlYWQnKTtcclxuICAgIGFwaS5jb250YWluZXJfYWRkZWQgPSBkZXByZWNhdGUoYXBpLmNvbnRhaW5lckFkZGVkLCAnd2luZG93LmNvbnRhaW5lcl9hZGRlZCgpIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIHdpbmRvdy5jb250YWluZXJBZGRlZCgpIGluc3RlYWQnKTtcclxuICAgIGFwaS5jb250YWluZXJfcmVtb3ZlZCA9IGRlcHJlY2F0ZShhcGkuY29udGFpbmVyUmVtb3ZlZCwgJ3dpbmRvdy5jb250YWluZXJfcmVtb3ZlZCgpIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIHdpbmRvdy5jb250YWluZXJSZW1vdmVkKCkgaW5zdGVhZCcpO1xyXG5cclxuICAgIGFwaS52ZXJzaW9uID0gUGFja2FnZUpzb24udmVyc2lvbjtcclxuXHJcbiAgICByZXR1cm4gYXBpO1xyXG59O1xyXG5cclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICB3aW5kb3cudGljazQyID0gd2luZG93LnRpY2s0MiB8fCB7fTtcclxuICAgIHdpbmRvdy50aWNrNDIud2luZG93cyA9IHdpbmRvd3M7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gd2luZG93cztcclxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIl9hcmdzXCI6IFtcbiAgICBbXG4gICAgICBcInRpY2s0Mi13aW5kb3dzQDIuMi42XCIsXG4gICAgICBcIkM6XFxcXHdvcmtcXFxcc3Rhc2hcXFxcR0xVRS1kZXZcXFxcanMtZ2x1ZVwiXG4gICAgXVxuICBdLFxuICBcIl9mcm9tXCI6IFwidGljazQyLXdpbmRvd3NAMi4yLjZcIixcbiAgXCJfaWRcIjogXCJ0aWNrNDItd2luZG93c0AyLjIuNlwiLFxuICBcIl9pbkNhY2hlXCI6IHRydWUsXG4gIFwiX2luc3RhbGxhYmxlXCI6IHRydWUsXG4gIFwiX2xvY2F0aW9uXCI6IFwiL3RpY2s0Mi13aW5kb3dzXCIsXG4gIFwiX25vZGVWZXJzaW9uXCI6IFwiNS4zLjBcIixcbiAgXCJfbnBtVXNlclwiOiB7fSxcbiAgXCJfbnBtVmVyc2lvblwiOiBcIjMuMy4xMlwiLFxuICBcIl9waGFudG9tQ2hpbGRyZW5cIjoge30sXG4gIFwiX3JlcXVlc3RlZFwiOiB7XG4gICAgXCJuYW1lXCI6IFwidGljazQyLXdpbmRvd3NcIixcbiAgICBcInJhd1wiOiBcInRpY2s0Mi13aW5kb3dzQDIuMi42XCIsXG4gICAgXCJyYXdTcGVjXCI6IFwiMi4yLjZcIixcbiAgICBcInNjb3BlXCI6IG51bGwsXG4gICAgXCJzcGVjXCI6IFwiMi4yLjZcIixcbiAgICBcInR5cGVcIjogXCJ2ZXJzaW9uXCJcbiAgfSxcbiAgXCJfcmVxdWlyZWRCeVwiOiBbXG4gICAgXCIvXCJcbiAgXSxcbiAgXCJfcmVzb2x2ZWRcIjogXCJodHRwOi8vMTkyLjE2OC4wLjIzNDo0ODczL3RpY2s0Mi13aW5kb3dzLy0vdGljazQyLXdpbmRvd3MtMi4yLjYudGd6XCIsXG4gIFwiX3NoYXN1bVwiOiBcIjUxMTY5MjJhMDgyNWU4N2VjMWE3MjhmOTkzN2U1OTQ0NDlhYmI0N2VcIixcbiAgXCJfc2hyaW5rd3JhcFwiOiBudWxsLFxuICBcIl9zcGVjXCI6IFwidGljazQyLXdpbmRvd3NAMi4yLjZcIixcbiAgXCJfd2hlcmVcIjogXCJDOlxcXFx3b3JrXFxcXHN0YXNoXFxcXEdMVUUtZGV2XFxcXGpzLWdsdWVcIixcbiAgXCJhdXRob3JcIjoge1xuICAgIFwibmFtZVwiOiBcIlRpY2s0MlwiXG4gIH0sXG4gIFwiYmluXCI6IHtcbiAgICBcImJ1aWxkXCI6IFwiLi9iaW4vYnVpbGQuanNcIixcbiAgICBcImNsZWFuXCI6IFwiLi9iaW4vY2xlYW4uanNcIixcbiAgICBcImZpbGUtdmVyc2lvbmlmeVwiOiBcIi4vYmluL2ZpbGUtdmVyc2lvbmlmeS5qc1wiLFxuICAgIFwibWluaWZ5XCI6IFwiLi9iaW4vbWluaWZ5LmpzXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiZXM2LXByb21pc2VcIjogXCJeMy4wLjJcIixcbiAgICBcInV0aWwtZGVwcmVjYXRlXCI6IFwiXjEuMC4yXCJcbiAgfSxcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkEgd2luZG93aW5nIEFQSSBmb3IgdGhlIFRpY2s0MiBIVE1MIENvbnRhaW5lclwiLFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJibGFua2V0XCI6IFwiXjEuMS42XCIsXG4gICAgXCJicm93c2VyaWZ5XCI6IFwiXjEzLjAuMFwiLFxuICAgIFwiYnJvd3NlcmlmeS1yZXBsYWNpZnlcIjogXCJeMC4wLjRcIixcbiAgICBcImJyb3dzZXJpZnktdmVyc2lvbmlmeVwiOiBcIl4xLjAuNFwiLFxuICAgIFwiZXNsaW50XCI6IFwiXjMuMS4xXCIsXG4gICAgXCJlc2xpbnQtY29uZmlnLXN0YW5kYXJkXCI6IFwiXjUuMy41XCIsXG4gICAgXCJlc2xpbnQtY29uZmlnLXRpY2s0MlwiOiBcIl4xLjAuMFwiLFxuICAgIFwiZXNsaW50LXBsdWdpbi1wcm9taXNlXCI6IFwiXjIuMC4wXCIsXG4gICAgXCJlc2xpbnQtcGx1Z2luLXN0YW5kYXJkXCI6IFwiXjIuMC4wXCIsXG4gICAgXCJmc1wiOiBcIjAuMC4yXCIsXG4gICAgXCJqc2NzXCI6IFwiXjMuMC43XCIsXG4gICAgXCJqc2RvbVwiOiBcIl44LjEuMFwiLFxuICAgIFwianNoaW50XCI6IFwiXjIuOS4xXCIsXG4gICAgXCJtaW5pZnlpZnlcIjogXCJeNy4zLjJcIixcbiAgICBcIm9uY2hhbmdlXCI6IFwiXjIuMS4yXCIsXG4gICAgXCJwaGFudG9tanNcIjogXCJeMS45LjEyXCIsXG4gICAgXCJxdW5pdGpzXCI6IFwiXjEuMTUuMFwiLFxuICAgIFwic2hlbGxqc1wiOiBcIl4wLjYuMFwiXG4gIH0sXG4gIFwiZGlyZWN0b3JpZXNcIjoge1xuICAgIFwidGVzdFwiOiBcInRlc3RzXCJcbiAgfSxcbiAgXCJkaXN0XCI6IHtcbiAgICBcInNoYXN1bVwiOiBcIjUxMTY5MjJhMDgyNWU4N2VjMWE3MjhmOTkzN2U1OTQ0NDlhYmI0N2VcIixcbiAgICBcInRhcmJhbGxcIjogXCJodHRwOi8vMTkyLjE2OC4wLjIzNDo0ODczL3RpY2s0Mi13aW5kb3dzLy0vdGljazQyLXdpbmRvd3MtMi4yLjYudGd6XCJcbiAgfSxcbiAgXCJnaXRIZWFkXCI6IFwiNTZkYjhlYmQzOWUxMzVkNjAyMzQ4NWVmMTg3NDQ1ZDQwODJkZThkMlwiLFxuICBcImxpY2Vuc2VcIjogXCJJU0NcIixcbiAgXCJtYWluXCI6IFwibGlicmFyeS93aW5kb3dzLmpzXCIsXG4gIFwibmFtZVwiOiBcInRpY2s0Mi13aW5kb3dzXCIsXG4gIFwib3B0aW9uYWxEZXBlbmRlbmNpZXNcIjoge30sXG4gIFwicmVhZG1lXCI6IFwiRVJST1I6IE5vIFJFQURNRSBkYXRhIGZvdW5kIVwiLFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9zdGFzaC50aWNrNDIuY29tOjg0NDMvc2NtL29mZ3cvanMtd2luZG93cy5naXRcIlxuICB9LFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwiYnVpbGRcIjogXCJucG0gcnVuIGVzbGludCAmJiBub2RlIGJpbi9jbGVhbi5qcyAmJiBub2RlIGJpbi9idWlsZC5qcyAmJiBub2RlIGJpbi9taW5pZnkgJiYgbm9kZSBiaW4vZmlsZS12ZXJzaW9uaWZ5XCIsXG4gICAgXCJlc2xpbnRcIjogXCJlc2xpbnQgbGlicmFyeVwiLFxuICAgIFwiZXNsaW50OmZpeFwiOiBcImVzbGludCBsaWJyYXJ5IC0tZml4XCIsXG4gICAgXCJwcmVwdWJsaXNoXCI6IFwibnBtIHVwZGF0ZSAmIG5wbSBydW4gYnVpbGRcIixcbiAgICBcInRlc3RcIjogXCJucG0gcnVuIGVzbGludCAmJiBtb2NoYSAtLXJlcXVpcmUgLi90ZXN0L3Rlc3RfaGVscGVyIFxcXCJ0ZXN0LyoqLyouanNcXFwiXCIsXG4gICAgXCJ3YXRjaFwiOiBcIm9uY2hhbmdlIFxcXCIuL2xpYnJhcnkvKi5qc1xcXCIgLWl2IC1lIFxcXCIuL2JpblxcXCIgLS0gbnBtIHJ1biBidWlsZFwiXG4gIH0sXG4gIFwidmVyc2lvblwiOiBcIjIuMi42XCJcbn1cbiIsIi8qIVxuQ29weXJpZ2h0IChDKSAyMDE1IGJ5IFdlYlJlZmxlY3Rpb25cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuXG4qL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBlbmNvZGUoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKGZpbmQsIHJlcGxhY2VyKTtcbn1cblxuZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0ci5yZXBsYWNlKHBsdXMsICcgJykpO1xufVxuXG5mdW5jdGlvbiBVUkxTZWFyY2hQYXJhbXMocXVlcnkpIHtcbiAgdGhpc1tzZWNyZXRdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFxdWVyeSkgcmV0dXJuO1xuICBmb3IgKHZhclxuICAgIGluZGV4LCB2YWx1ZSxcbiAgICBwYWlycyA9IChxdWVyeSB8fCAnJykuc3BsaXQoJyYnKSxcbiAgICBpID0gMCxcbiAgICBsZW5ndGggPSBwYWlycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrK1xuICApIHtcbiAgICB2YWx1ZSA9IHBhaXJzW2ldO1xuICAgIGluZGV4ID0gdmFsdWUuaW5kZXhPZignPScpO1xuICAgIGlmICgtMSA8IGluZGV4KSB7XG4gICAgICB0aGlzLmFwcGVuZChcbiAgICAgICAgZGVjb2RlKHZhbHVlLnNsaWNlKDAsIGluZGV4KSksXG4gICAgICAgIGRlY29kZSh2YWx1ZS5zbGljZShpbmRleCArIDEpKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxudmFyXG4gIFVSTFNlYXJjaFBhcmFtc1Byb3RvID0gVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZSxcbiAgZmluZCA9IC9bISdcXChcXCl+XXwlMjB8JTAwL2csXG4gIHBsdXMgPSAvXFwrL2csXG4gIHJlcGxhY2UgPSB7XG4gICAgJyEnOiAnJTIxJyxcbiAgICBcIidcIjogJyUyNycsXG4gICAgJygnOiAnJTI4JyxcbiAgICAnKSc6ICclMjknLFxuICAgICd+JzogJyU3RScsXG4gICAgJyUyMCc6ICcrJyxcbiAgICAnJTAwJzogJ1xceDAwJ1xuICB9LFxuICByZXBsYWNlciA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiByZXBsYWNlW21hdGNoXTtcbiAgfSxcbiAgaXRlcmFibGUgPSBpc0l0ZXJhYmxlKCksXG4gIHNlY3JldCA9ICdfX1VSTFNlYXJjaFBhcmFtc19fOicgKyBNYXRoLnJhbmRvbSgpXG47XG5cbmZ1bmN0aW9uIGlzSXRlcmFibGUoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhU3ltYm9sLml0ZXJhdG9yO1xuICB9IGNhdGNoKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cblVSTFNlYXJjaFBhcmFtc1Byb3RvLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChuYW1lLCB2YWx1ZSkge1xuICB2YXIgZGljdCA9IHRoaXNbc2VjcmV0XTtcbiAgaWYgKG5hbWUgaW4gZGljdCkge1xuICAgIGRpY3RbbmFtZV0ucHVzaCgnJyArIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBkaWN0W25hbWVdID0gWycnICsgdmFsdWVdO1xuICB9XG59O1xuXG5VUkxTZWFyY2hQYXJhbXNQcm90by5kZWxldGUgPSBmdW5jdGlvbiBkZWwobmFtZSkge1xuICBkZWxldGUgdGhpc1tzZWNyZXRdW25hbWVdO1xufTtcblxuVVJMU2VhcmNoUGFyYW1zUHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgdmFyIGRpY3QgPSB0aGlzW3NlY3JldF07XG4gIHJldHVybiBuYW1lIGluIGRpY3QgPyBkaWN0W25hbWVdWzBdIDogbnVsbDtcbn07XG5cblVSTFNlYXJjaFBhcmFtc1Byb3RvLmdldEFsbCA9IGZ1bmN0aW9uIGdldEFsbChuYW1lKSB7XG4gIHZhciBkaWN0ID0gdGhpc1tzZWNyZXRdO1xuICByZXR1cm4gbmFtZSBpbiBkaWN0ID8gZGljdFtuYW1lXS5zbGljZSgwKSA6IFtdO1xufTtcblxuVVJMU2VhcmNoUGFyYW1zUHJvdG8uaGFzID0gZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUgaW4gdGhpc1tzZWNyZXRdO1xufTtcblxuVVJMU2VhcmNoUGFyYW1zUHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KG5hbWUsIHZhbHVlKSB7XG4gIHRoaXNbc2VjcmV0XVtuYW1lXSA9IFsnJyArIHZhbHVlXTtcbn07XG5cblVSTFNlYXJjaFBhcmFtc1Byb3RvLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gIHZhciBkaWN0ID0gdGhpc1tzZWNyZXRdO1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkaWN0KS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkaWN0W25hbWVdLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdmFsdWUsIG5hbWUsIHRoaXMpO1xuICAgIH0sIHRoaXMpO1xuICB9LCB0aGlzKTtcbn07XG5cblVSTFNlYXJjaFBhcmFtc1Byb3RvLmtleXMgPSBmdW5jdGlvbiBrZXlzKCkge1xuICB2YXIgaXRlbXMgPSBbXTtcbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7IGl0ZW1zLnB1c2gobmFtZSk7IH0pO1xuICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpdGVtcy5zaGlmdCgpO1xuICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9O1xuICAgIH1cbiAgfTtcblxuICBpZiAoaXRlcmFibGUpIHtcbiAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBpdGVyYXRvcjtcbn07XG5cblVSTFNlYXJjaFBhcmFtc1Byb3RvLnZhbHVlcyA9IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgdmFyIGl0ZW1zID0gW107XG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkgeyBpdGVtcy5wdXNoKHZhbHVlKTsgfSk7XG4gIHZhciBpdGVyYXRvciA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KCk7XG4gICAgICByZXR1cm4ge2RvbmU6IHZhbHVlID09PSB1bmRlZmluZWQsIHZhbHVlOiB2YWx1ZX07XG4gICAgfVxuICB9O1xuXG4gIGlmIChpdGVyYWJsZSkge1xuICAgIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGl0ZXJhdG9yO1xufTtcblxuVVJMU2VhcmNoUGFyYW1zUHJvdG8uZW50cmllcyA9IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gIHZhciBpdGVtcyA9IFtdO1xuICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHsgaXRlbXMucHVzaChbbmFtZSwgdmFsdWVdKTsgfSk7XG4gIHZhciBpdGVyYXRvciA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KCk7XG4gICAgICByZXR1cm4ge2RvbmU6IHZhbHVlID09PSB1bmRlZmluZWQsIHZhbHVlOiB2YWx1ZX07XG4gICAgfVxuICB9O1xuXG4gIGlmIChpdGVyYWJsZSkge1xuICAgIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGl0ZXJhdG9yO1xufTtcblxuaWYgKGl0ZXJhYmxlKSB7XG4gIFVSTFNlYXJjaFBhcmFtc1Byb3RvW1N5bWJvbC5pdGVyYXRvcl0gPSBVUkxTZWFyY2hQYXJhbXNQcm90by5lbnRyaWVzO1xufVxuXG4vKlxuVVJMU2VhcmNoUGFyYW1zUHJvdG8udG9Cb2R5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgQmxvYihcbiAgICBbdGhpcy50b1N0cmluZygpXSxcbiAgICB7dHlwZTogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCd9XG4gICk7XG59O1xuKi9cblxuVVJMU2VhcmNoUGFyYW1zUHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICByZXR1cm4ge307XG59O1xuXG5VUkxTZWFyY2hQYXJhbXNQcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICB2YXIgZGljdCA9IHRoaXNbc2VjcmV0XSwgcXVlcnkgPSBbXSwgaSwga2V5LCBuYW1lLCB2YWx1ZTtcbiAgZm9yIChrZXkgaW4gZGljdCkge1xuICAgIG5hbWUgPSBlbmNvZGUoa2V5KTtcbiAgICBmb3IgKFxuICAgICAgaSA9IDAsXG4gICAgICB2YWx1ZSA9IGRpY3Rba2V5XTtcbiAgICAgIGkgPCB2YWx1ZS5sZW5ndGg7IGkrK1xuICAgICkge1xuICAgICAgcXVlcnkucHVzaChuYW1lICsgJz0nICsgZW5jb2RlKHZhbHVlW2ldKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBxdWVyeS5qb2luKCcmJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5VUkxTZWFyY2hQYXJhbXMgfHwgVVJMU2VhcmNoUGFyYW1zOyIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBnbG9iYWwgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSgpO1xuXG4vKipcbiAqIFdlYlNvY2tldCBjb25zdHJ1Y3Rvci5cbiAqL1xuXG52YXIgV2ViU29ja2V0ID0gZ2xvYmFsLldlYlNvY2tldCB8fCBnbG9iYWwuTW96V2ViU29ja2V0O1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0ID8gd3MgOiBudWxsO1xuXG4vKipcbiAqIFdlYlNvY2tldCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBUaGUgdGhpcmQgYG9wdHNgIG9wdGlvbnMgb2JqZWN0IGdldHMgaWdub3JlZCBpbiB3ZWIgYnJvd3NlcnMsIHNpbmNlIGl0J3NcbiAqIG5vbi1zdGFuZGFyZCwgYW5kIHRocm93cyBhIFR5cGVFcnJvciBpZiBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZWluYXJvcy93cy9pc3N1ZXMvMjI3XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaVxuICogQHBhcmFtIHtBcnJheX0gcHJvdG9jb2xzIChvcHRpb25hbClcbiAqIEBwYXJhbSB7T2JqZWN0KSBvcHRzIChvcHRpb25hbClcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gd3ModXJpLCBwcm90b2NvbHMsIG9wdHMpIHtcbiAgdmFyIGluc3RhbmNlO1xuICBpZiAocHJvdG9jb2xzKSB7XG4gICAgaW5zdGFuY2UgPSBuZXcgV2ViU29ja2V0KHVyaSwgcHJvdG9jb2xzKTtcbiAgfSBlbHNlIHtcbiAgICBpbnN0YW5jZSA9IG5ldyBXZWJTb2NrZXQodXJpKTtcbiAgfVxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbmlmIChXZWJTb2NrZXQpIHdzLnByb3RvdHlwZSA9IFdlYlNvY2tldC5wcm90b3R5cGU7XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcInRpY2s0Mi1nbHVlXCIsXG4gIFwidmVyc2lvblwiOiBcIjMuMC4wLWJldGEuM1wiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQSBKYXZhU2NyaXB0IGxpYnJhcnkgd2hpY2ggcHJvdmlkZXMgc3VwcG9ydCBmb3IgVGljazQyIEdMVUUuXCIsXG4gIFwibWFpblwiOiBcIi4vbGlicmFyeS9tYWluLmpzXCIsXG4gIFwiYmluXCI6IHtcbiAgICBcImluaXQtZGV2LW1vZGVcIjogXCJiaW4vaW5pdC1kZXYtbW9kZS5qc1wiLFxuICAgIFwicmVtb3ZlLWluc3RhbGxlZC1kZXBlbmRlbmNpZXNcIjogXCJiaW4vcmVtb3ZlLWluc3RhbGxlZC1kZXBlbmRlbmNpZXMuanNcIixcbiAgICBcInJlbW92ZS1kZXZlbG9wbWVudC1kZXBlbmRlbmNpZXNcIjogXCJiaW4vcmVtb3ZlLWRldmVsb3BtZW50LWRlcGVuZGVuY2llcy5qc1wiLFxuICAgIFwiYnVpbGRcIjogXCIuL2Jpbi9idWlsZC5qc1wiLFxuICAgIFwiY2xlYW5cIjogXCIuL2Jpbi9jbGVhbi5qc1wiLFxuICAgIFwiZmlsZS12ZXJzaW9uaWZ5XCI6IFwiYmluL2ZpbGUtdmVyc2lvbmlmeS5qc1wiLFxuICAgIFwibWluaWZ5XCI6IFwiLi9iaW4vbWluaWZ5LmpzXCJcbiAgfSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImVzbGludFwiOiBcImVzbGludCBsaWJyYXJ5XCIsXG4gICAgXCJlc2xpbnQ6Zml4XCI6IFwiZXNsaW50IGxpYnJhcnkgLS1maXhcIixcbiAgICBcInRlc3RcIjogXCJucG0gcnVuIGVzbGludCAmJiBtb2NoYSAtLXJlcXVpcmUgLi90ZXN0L3Rlc3RfaGVscGVyIFxcXCJ0ZXN0LyoqLyouanNcXFwiXCIsXG4gICAgXCJidWlsZFwiOiBcIm5wbSBydW4gZXNsaW50ICYmIG5vZGUgYmluL2NsZWFuLmpzICYmIG5vZGUgYmluL2J1aWxkLmpzICYmIG5vZGUgYmluL21pbmlmeSAmJiBub2RlIGJpbi9maWxlLXZlcnNpb25pZnlcIixcbiAgICBcImJ1aWxkOmRldlwiOiBcIm5wbSBydW4gZXNsaW50OmZpeCAmJiBub2RlIGJpbi9jbGVhbiAmJiBub2RlIGJpbi9idWlsZFwiLFxuICAgIFwicHJlcHVibGlzaFwiOiBcIm5wbSB1cGRhdGUgJiYgbnBtIHJ1biBidWlsZFwiLFxuICAgIFwiaW5pdDpkZXZlbG9wXCI6IFwibm9kZSBiaW4vaW5pdC1kZXYtbW9kZVwiLFxuICAgIFwiY2xlYXI6ZGV2ZWxvcFwiOiBcIm5vZGUgYmluL3JlbW92ZS1kZXZlbG9wbWVudC1kZXBlbmRlbmNpZXNcIixcbiAgICBcIndhdGNoXCI6IFwib25jaGFuZ2UgXFxcIi4vbGlicmFyeS8qLmpzXFxcIiBcXFwiLi9ub2RlX21vZHVsZXMvdGljazQyLSovbGlicmFyeS8qLmpzXFxcIiAgXFxcIi4vbm9kZV9tb2R1bGVzL3RpY2s0Mi0qL2xpYnJhcnlfanMvKi5qc1xcXCIgXFxcIi4uL25vZGVfbW9kdWxlcy90aWNrNDItKi9saWJyYXJ5LyoqLmpzXFxcIiAgXFxcIi4uL25vZGVfbW9kdWxlcy90aWNrNDItKi9saWJyYXJ5X2pzLyouanNcXFwiIC1pdiAtZSBcXFwiLi9iaW5cXFwiIC0tIG5wbSBydW4gYnVpbGQ6ZGV2XCIsXG4gICAgXCJ3YXRjaDpkZXZlbG9wXCI6IFwibm9kZSBiaW4vcmVtb3ZlLWluc3RhbGxlZC1kZXBlbmRlbmNpZXMgJiYgbnBtIHJ1biB3YXRjaFwiLFxuICAgIFwid2F0Y2g6cHJvZFwiOiBcIm5wbSBpbnN0YWxsICYmIG5wbSBydW4gd2F0Y2hcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9ibWFyaW5vdkBzdGFzaC50aWNrNDIuY29tOjg0NDMvc2NtL29mZ3cvanMtZ2x1ZS5naXRcIlxuICB9LFxuICBcImF1dGhvclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiVGljazQyXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwOi8vd3d3LnRpY2s0Mi5jb21cIlxuICB9LFxuICBcImxpY2Vuc2VcIjogXCJJU0NcIixcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiY3VpZFwiOiBcIl4xLjMuOFwiLFxuICAgIFwiZGV0ZWN0LW5vZGVcIjogXCJeMi4wLjNcIixcbiAgICBcImVzNS1zaGltXCI6IFwiXjQuMS4xNFwiLFxuICAgIFwib2JqZWN0LWFzc2lnblwiOiBcIl40LjEuMFwiLFxuICAgIFwidGljazQyLWFjdGl2aXR5XCI6IFwiXjIuMi4xXCIsXG4gICAgXCJ0aWNrNDItYWdtXCI6IFwiXjMuMi4wXCIsXG4gICAgXCJ0aWNrNDItYXBwLW1hbmFnZXJcIjogXCJeMi4zLjZcIixcbiAgICBcInRpY2s0Mi1hcHBjb25maWdcIjogXCJeMC4xLjJcIixcbiAgICBcInRpY2s0Mi1jb250ZXh0c1wiOiBcIl4wLjAuMlwiLFxuICAgIFwidGljazQyLWdhdGV3YXktY29ubmVjdGlvblwiOiBcIl4yLjAuM1wiLFxuICAgIFwidGljazQyLWxvZ2dlclwiOiBcIl4yLjAuNVwiLFxuICAgIFwidGljazQyLW1ldHJpY3NcIjogXCJeMi4wLjE1XCIsXG4gICAgXCJ0aWNrNDItd2luZG93c1wiOiBcIl4yLjIuM1wiXG4gIH0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICAgIFwiZXNsaW50XCI6IFwiXjMuMS4xXCIsXG4gICAgICBcImVzbGludC1jb25maWctc3RhbmRhcmRcIjogXCJeNS4zLjVcIixcbiAgICAgIFwiZXNsaW50LWNvbmZpZy10aWNrNDJcIjogXCJeMS4wLjBcIixcbiAgICAgIFwiZXNsaW50LXBsdWdpbi1wcm9taXNlXCI6IFwiXjIuMC4wXCIsXG4gICAgICBcImVzbGludC1wbHVnaW4tc3RhbmRhcmRcIjogXCJeMi4wLjBcIixcbiAgICAgIFwiYnJvd3NlcmlmeVwiOiBcIl4xMy4wLjBcIixcbiAgICAgIFwiYnJvd3NlcmlmeS1yZXBsYWNpZnlcIjogXCJeMC4wLjRcIixcbiAgICAgIFwiYnJvd3NlcmlmeS12ZXJzaW9uaWZ5XCI6IFwiXjEuMC40XCIsXG4gICAgICBcImNoYWlcIjogXCJeMy41LjBcIixcbiAgICAgIFwiZnNcIjogXCIwLjAuMlwiLFxuICAgICAgXCJqc2RvbVwiOiBcIl44LjEuMFwiLFxuICAgICAgXCJqc2hpbnRcIjogXCJeMi45LjFcIixcbiAgICAgIFwibWluaWZ5aWZ5XCI6IFwiXjcuMy4yXCIsXG4gICAgICBcIm1vY2hhXCI6IFwiXjIuNC41XCIsXG4gICAgICBcIm9uY2hhbmdlXCI6IFwiXjIuMS4yXCIsXG4gICAgICBcInNoZWxsanNcIjogXCJeMC42LjBcIlxuICB9XG59XG4iXX0=
